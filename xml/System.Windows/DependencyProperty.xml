<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fc117fffb2ec2f4ee7c294166d054208a4b13ede" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39942029" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta una proprietà che può essere impostata tramite metodi, ad esempio stile, data binding, animazione ed ereditarietà.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.DependencyProperty> supporta le funzionalità seguenti in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   La proprietà può essere impostata in uno stile. Per altre informazioni, vedere [Applicazione di stili e modelli](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   La proprietà può essere impostata tramite l'associazione dati. Per altre informazioni sulle proprietà di dipendenza di data binding, vedere [procedura: associare la proprietà di due controlli](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   La proprietà può essere impostata con un riferimento di risorsa dinamica. Per altre informazioni, vedere [Risorse XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   La proprietà può ereditare automaticamente il valore da un elemento padre nell'albero degli elementi. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   È possibile animare la proprietà. Per altre informazioni, vedere [Panoramica dell'animazione](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   La proprietà può segnalare se il valore precedente della proprietà è stato modificato e può essere assegnato il valore della proprietà. Per altre informazioni, vedere [Callback e convalida delle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   La proprietà segnala informazioni da [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], ad esempio se la modifica di un valore della proprietà richiede il sistema di layout ricomponga gli elementi visivi per un elemento.  
  
-   La proprietà riceve supporto nel [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Ad esempio, la proprietà può essere modificata nel **proprietà** finestra.  
  
 Per altre informazioni sulle proprietà di dipendenza, vedere [Cenni preliminari sulle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Se si desidera che le proprietà sui tipi personalizzati per supportare le funzionalità nell'elenco precedente, è necessario creare una proprietà di dipendenza.  Per informazioni su come creare proprietà di dipendenza personalizzate, vedere [proprietà di dipendenza personalizzate](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Una proprietà associata è una proprietà che consente a qualsiasi oggetto di informazioni sul report per il tipo che definisce la proprietà associata. Nelle [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], qualsiasi tipo che eredita da <xref:System.Windows.DependencyObject> può usare una proprietà associata indipendentemente dal fatto che il tipo eredita dal tipo che definisce la proprietà. Una proprietà associata è una funzionalità del [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] language.  Per impostare una proprietà associata [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], usare il *TipoProprietario*.* propertyName* sintassi. Un esempio di una proprietà associata è di <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> proprietà. Se si desidera creare una proprietà che può essere utilizzata in tutti i <xref:System.Windows.DependencyObject> tipi, è necessario creare una proprietà associata. Per altre informazioni sulle proprietà associate, tra cui come crearli, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Valori XAML  
 `dependencyPropertyName`  
 Stringa che specifica il <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> della proprietà di dipendenza desiderato. Questo può essere preceduto dal prefisso dello spazio dei nomi XML, se la proprietà non è incluso nello spazio dei nomi XML predefinito (per informazioni dettagliate, vedere [spazi dei nomi XAML e Mapping di Namespace per XAML WPF](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Stringa che specifica un tipo di proprietario di una proprietà di dipendenza, un punto (.), quindi il <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` possono anche essere preceduti dal prefisso dello spazio dei nomi XML. Questo utilizzo è specifico di associazione tardiva stili e modelli, in cui il proprietario della proprietà di dipendenza deve essere specificato per l'analisi del contesto perché il `TargetType` non è ancora noto. Per altre informazioni, vedere [Applicazione di stili e modelli](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Stringa che specifica il proprietario di una proprietà associata, un punto (.), quindi il nome della proprietà associata. `attachedPropertyOwnerType` possono anche essere preceduti dal prefisso dello spazio dei nomi XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge un altro tipo come proprietario di una proprietà di dipendenza che è già stata registrata in un tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Tipo da aggiungere come proprietario della proprietà di dipendenza.</param>
        <summary>Aggiunge un altro tipo come proprietario di una proprietà di dipendenza che è già stata registrata.</summary>
        <returns>Riferimento all'identificatore <see cref="T:System.Windows.DependencyProperty" /> originale che identifica la proprietà di dipendenza. Questo identificatore deve essere esposto dalla classe che aggiunge come un campo <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente al sistema di proprietà di riconoscere una proprietà di dipendenza in un tipo che non ha registrato la proprietà di dipendenza specifica inizialmente.  
  
 In genere, <xref:System.Windows.DependencyProperty.AddOwner%2A> consente di aggiungere le proprietà di dipendenza per le classi che non espongono già quella proprietà di dipendenza tramite l'ereditarietà di classe gestita (ereditarietà della classe causerebbe la proprietà wrapper da ereditare dalla classe derivata e di conseguenza fornisce l'accesso generale alla tabella dei membri alla proprietà di dipendenza già). <xref:System.Windows.DependencyProperty.AddOwner%2A> consente al sistema di proprietà di riconoscere una proprietà di dipendenza in un tipo che non ha registrato la proprietà di dipendenza iniziale.  
  
 Questa firma non consente di specificare i metadati.  Quando si usa questo metodo, i metadati viene generato automaticamente per il nuovo <xref:System.Windows.DependencyProperty> e il relativo tipo di proprietario. I metadati generati automaticamente sono il risultato dei metadati di merge da tutti i tipi di base che dispongono di questa proprietà definite. Se i metadati non unito sono disponibili, i metadati predefiniti per la proprietà viene utilizzata. Se la proprietà è registrata con il <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metodo, il metadato predefinito è quello utilizzato per i metadati che viene creato quando <xref:System.Windows.DependencyProperty.RegisterAttached%2A> è stato chiamato. In caso contrario, il <xref:System.Windows.PropertyMetadata> oggetto viene creato con il <xref:System.Windows.PropertyMetadata.DefaultValue%2A> proprietà è impostata per impostazione predefinita del tipo di proprietà e tutte le altre proprietà delle <xref:System.Windows.PropertyMetadata> è impostata su `null`. Usare il <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> firma se si desidera fornire i metadati per la versione della proprietà di dipendenza con l'aggiunta al tipo fornito.  
  
 Il valore restituito di questo metodo viene in genere usato per dichiarare ed esporre le proprietà di dipendenza tramite l'archiviazione di un identificatore di proprietà di dipendenza. L'identificatore fornisce l'accesso alla proprietà di dipendenza se si desidera chiamare il sistema di proprietà [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] rispetto alla proprietà di dipendenza, in particolare perché esiste nella classe proprietario aggiunta. Lo stesso nome di proprietà per il proprietario originale sia stato aggiunto un proprietario deve essere utilizzato per indicare la funzionalità simile. È consigliabile usare la <xref:System.Windows.DependencyProperty> valore restituito del <xref:System.Windows.DependencyProperty.AddOwner%2A> metodo per definire l'identificatore di proprietà di dipendenza, nonché per dichiarare [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper della proprietà, per le proprietà di dipendenza che vengono aggiunti ai tipi usando <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Il <xref:System.Windows.DependencyProperty.AddOwner%2A> metodologia consigliata in precedenza viene usato durante la creazione di proprietà di dipendenza che vengono dichiarate all'interno di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Ad esempio, entrambe <xref:System.Windows.Controls.Border> e <xref:System.Windows.Controls.Control> definiscono un `BorderBrush` proprietà di dipendenza, che hanno una funzionalità simile. <xref:System.Windows.Controls.Control> definisce relativi `BorderBrush` proprietà per il sistema di proprietà chiamando <xref:System.Windows.DependencyProperty.AddOwner%2A> base il proprietario originale <xref:System.Windows.Controls.Border> e relativi registrati <xref:System.Windows.Controls.Border.BorderBrushProperty> identificatore della proprietà di dipendenza. Il <xref:System.Windows.DependencyProperty.AddOwner%2A> valore restituito viene quindi utilizzato per stabilire un nuovo valore statico <xref:System.Windows.DependencyProperty> campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) per la proprietà del proprietario aggiunto e un `BorderBrush` wrapper della proprietà viene dichiarato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Tipo da aggiungere come proprietario della proprietà di dipendenza.</param>
        <param name="typeMetadata">Metadati che qualificano la proprietà di dipendenza nello stato attuale per il tipo specificato.</param>
        <summary>Aggiunge un altro tipo come proprietario di una proprietà di dipendenza già registrata, fornendo i metadati della proprietà di dipendenza nello stato attuale per il tipo di proprietario specificato.</summary>
        <returns>Riferimento all'identificatore <see cref="T:System.Windows.DependencyProperty" /> originale che identifica la proprietà di dipendenza. Questo identificatore deve essere esposto dalla classe che aggiunge come un campo <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente al sistema di proprietà di riconoscere una proprietà di dipendenza in un tipo che non ha registrato la proprietà di dipendenza specifica inizialmente.  
  
 Il valore restituito di questo metodo viene usato per dichiarare ed esporre proprietà di dipendenza, in particolar modo esiste nella classe proprietario aggiunta. In genere, lo stesso nome di proprietà per il proprietario originale sia stato aggiunto un proprietario da utilizzare per indicare la funzionalità simile. È buona norma per esporre gli identificatori, nonché i nuovi [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper della proprietà, per le proprietà di dipendenza che vengono aggiunti ai tipi usando <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 Il <xref:System.Windows.DependencyProperty.AddOwner%2A> metodologia consigliata in precedenza viene usato durante la creazione [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] dichiarati all'interno di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Ad esempio, entrambe <xref:System.Windows.Controls.Border> e <xref:System.Windows.Controls.Control> definiscono un `BorderBrush` proprietà di dipendenza, che hanno una funzionalità simile. <xref:System.Windows.Controls.Control> definisce le `BorderBrush` proprietà per il sistema di proprietà chiamando <xref:System.Windows.DependencyProperty.AddOwner%2A> sul proprietario originale <xref:System.Windows.Controls.Border> e relativi registrati <xref:System.Windows.Controls.Border.BorderBrushProperty> identificatore della proprietà di dipendenza. Il <xref:System.Windows.DependencyProperty.AddOwner%2A> valore restituito viene quindi utilizzato per stabilire un valore statico <xref:System.Windows.DependencyProperty> campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) per la proprietà del proprietario aggiunto e un `BorderBrush` wrapper della proprietà viene dichiarato.  
  
 Identificatore della proprietà di dipendenza del proprietario aggiunto deve essere utilizzato per le operazioni, ad esempio <xref:System.Windows.DependencyObject.GetValue%2A>. Tuttavia, operazioni specifiche del tipo che coinvolgono tipi o le istanze della classe che è stato aggiunto come proprietario con metadati diversi verrà comunque restituiranno i risultati previsti, anche se originale (non l'aggiunta del proprietario) identificatore della proprietà di dipendenza viene specificato le chiamate a metodi quali <xref:System.Windows.DependencyObject.GetValue%2A> o <xref:System.Windows.DependencyProperty.GetMetadata%2A>. I metadati per il proprietario aggiunto vengono trasmessi dal <xref:System.Windows.DependencyProperty.AddOwner%2A> chiamare se stesso, non necessariamente fa riferimento il campo dell'identificatore di classe proprietario aggiunta. Tuttavia, è buona norma per esporre l'identificatore, nonché i nuovi [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper della proprietà, per le proprietà di dipendenza che vengono aggiunti ai tipi di uso <xref:System.Windows.DependencyProperty.AddOwner%2A>, poiché in caso contrario crea disparità tra il [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] e[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] rappresentazioni delle proprietà.  
  
 Metadati forniti vengono uniti i metadati della proprietà per la proprietà di dipendenza esistente sul proprietario di base. Tutte le caratteristiche specificate nei metadati di base originali verranno mantenuti. Solo le caratteristiche che sono state modificate in modo specifico i nuovi metadati sostituiranno le caratteristiche dei metadati di base. Alcune caratteristiche, ad esempio <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, vengono sostituite se vengono specificate nei metadati di nuovo. Altri, ad esempio <xref:System.Windows.PropertyChangedCallback>, vengono combinate. In definitiva, il comportamento di tipo merge dipende dal tipo metadati proprietà utilizzato per la sostituzione, pertanto il comportamento qui descritto è per le classi di metadati di proprietà esistente usate da [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] le proprietà di dipendenza. Per informazioni dettagliate, vedere [metadati delle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-metadata.md) e [i metadati della proprietà Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i metadati predefiniti della proprietà di dipendenza.</summary>
        <value>Metadati predefiniti della proprietà di dipendenza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I metadati predefiniti sono i metadati della proprietà che sono disponibili per quel particolare oggetto o un oggetto di un tipo derivato in cui i metadati alternativi non sono stati forniti da esplicita <xref:System.Windows.DependencyProperty.Register%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> chiamare.  
  
 Se il proprietario originale applicati i metadati per il primo <xref:System.Windows.DependencyProperty.Register%2A> chiamata che ha stabilito la proprietà di dipendenza, quindi che i metadati viene restituito come <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Se i metadati non è stato applicato nell'originale <xref:System.Windows.DependencyProperty.Register%2A> chiamare, metadati predefiniti viene generato dall'interno di <xref:System.Windows.DependencyProperty.Register%2A> chiamata e questo valore viene restituito come il <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Lo scopo principale di avere metadati predefiniti associati a un <xref:System.Windows.DependencyProperty> consiste nel fornire un valore predefinito per questa proprietà su qualsiasi <xref:System.Windows.DependencyObject> o un tipo derivato.  
  
 Per le proprietà non associate, il tipo di metadati restituito da questa proprietà non è possibile eseguire il cast ai tipi derivati di <xref:System.Windows.PropertyMetadata> digita, anche se la proprietà è stata originariamente registrata con un tipo di metadati derivate. Se si desidera che i metadati registrati in origine, inclusi il tipo di metadati derivate possibilmente originale, chiamare <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> invece il passaggio di registrazione originale digitare come parametro.  
  
 Per le proprietà associate, il tipo di metadati restituiti da questa proprietà verrà corrisponde al tipo specificato nell'oggetto originale <xref:System.Windows.DependencyProperty.RegisterAttached%2A> metodo di registrazione.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un codice hash per <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>Codice hash per <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il sistema di proprietà Usa il proprio identificatore univoco <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, e il valore di tale proprietà viene restituito da <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce i metadati associati a questa proprietà di dipendenza nello stato attuale per un particolare tipo. Può trattarsi del tipo in cui la proprietà di dipendenza è stata registrata per la prima volta, uno a cui è stata aggiunta successivamente o un tipo in cui la proprietà di dipendenza è stata ottenuta tramite ereditarietà, ma è stato specificamente eseguito l'override dei metadati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">Tipo specifico da cui recuperare i metadati della proprietà di dipendenza.</param>
        <summary>Restituisce i metadati per questa proprietà di dipendenza nello stato attuale per un tipo esistente specificato.</summary>
        <returns>Oggetto metadati della proprietà.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica il tipo o un riferimento all'oggetto da utilizzare come tipo è necessario perché i metadati possono variare dalla registrazione originale a causa delle <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> chiamate che modificano i metadati della proprietà di dipendenza esistente in un tipo.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene i metadati per una proprietà di dipendenza in base al tipo. Il tipo viene ottenuto tramite un `typeof` operatore.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Oggetto dipendenza di cui viene verificato il tipo, per determinare da quale versione specifica del tipo della proprietà di dipendenza devono provenire i metadati.</param>
        <summary>Restituisce i metadati per questa proprietà di dipendenza nello stato attuale per l'istanza dell'oggetto specificato.</summary>
        <returns>Oggetto metadati della proprietà.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica il tipo o un riferimento all'oggetto è necessaria perché i metadati di qualsiasi proprietà di dipendenza possono variare dalla registrazione originale a causa delle <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> chiamate che possono definire i metadati della proprietà esistente in un tipo.  
  
 Quando si richiedono i metadati della proprietà basato su un'istanza, si sta semplicemente passando l'istanza in modo che il relativo tipo può essere valutato internamente. Metadati della proprietà di dipendenza non variano per ogni istanza. è sempre coerenza per qualsiasi combinazione di proprietà del tipo specificato.  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati per una proprietà di dipendenza basata su una specifica <xref:System.Windows.DependencyObject> istanza.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">n oggetto specifico che registra il tipo di oggetto dipendenza dal quale sono desiderati i metadati della proprietà di dipendenza.</param>
        <summary>Restituisce i metadati per questa proprietà di dipendenza nello stato attuale per un tipo specificato.</summary>
        <returns>Oggetto metadati della proprietà.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Specifica il tipo o un riferimento all'oggetto è necessaria perché i metadati di qualsiasi proprietà di dipendenza possono variare dalla registrazione originale a causa delle <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> chiamate che possono definire i metadati della proprietà esistente in un tipo.  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati per una proprietà di dipendenza di base relativi <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore generato internamente che identifica in modo univoco la proprietà di dipendenza.</summary>
        <value>Identificatore numerico univoco.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo valore è un numero intero, non un identificatore univoco globale (GUID). In generale, Usa questo valore di indice non è obbligatorio e non è possibile accedere indice nelle tabelle di tutte le proprietà di dipendenza. Le proprietà di dipendenza devono essere invece fatto riferimento dai campi dell'identificatore.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> viene usato internamente per un accesso più rapido alle strutture di dati che usano il <xref:System.Windows.DependencyProperty.GlobalIndex%2A> come un indice di matrice in base zero. Un utilizzo simile potrebbe avere applicazioni per gli strumenti o finestre di progettazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valore da controllare.</param>
        <summary>Determina se un valore specificato è accettabile per questo tipo di proprietà di dipendenza, come controllato per il tipo di proprietà fornito nella registrazione originale della proprietà di dipendenza.</summary>
        <returns>
          <see langword="true" /> se il valore specificato è il tipo di proprietà registrato o un tipo derivato accettabile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valore pari `null` è un tipo valido per le proprietà di dipendenza di tipo riferimento o per un <xref:System.Nullable%601> proprietà di dipendenza e restituirebbe `true` in questi casi. Nei casi in cui la proprietà di dipendenza né un riferimento né <xref:System.Nullable%601> , digitare <xref:System.Windows.DependencyProperty.IsValidType%2A> restituirà `false` per un valore null anziché generare un'eccezione.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Windows.DependencyProperty.IsValidType%2A> come un controllo prima di chiamare <xref:System.Windows.DependencyObject.SetValue%2A> nella proprietà di dipendenza.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valore da controllare.</param>
        <summary>Determina se il valore fornito è accettato per il tipo di proprietà tramite il controllo del tipo di base e anche, potenzialmente, se è all'interno dell'intervallo consentito dei valori per quel tipo.</summary>
        <returns>
          <see langword="true" /> se il valore è accettabile ed è del tipo corretto o di un tipo derivato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per una proprietà di dipendenza, è possibile specificare un intervallo di valori per il tipo consentito attraverso un <xref:System.Windows.ValidateValueCallback> fornito nella registrazione della proprietà di dipendenza.  
  
 Questo metodo chiama <xref:System.Windows.DependencyProperty.IsValidType%2A> internamente. Se la proprietà di dipendenza in questione non ha alcun <xref:System.Windows.ValidateValueCallback>, quindi si chiama questo metodo equivale alla chiamata al metodo <xref:System.Windows.DependencyProperty.IsValidType%2A>. Se la proprietà di dipendenza sono un <xref:System.Windows.ValidateValueCallback>e se <xref:System.Windows.DependencyProperty.IsValidType%2A> avrebbe restituito `true`, il valore restituito è come implementato nel callback.  
  
 Un valore null è un valore valido per le proprietà di dipendenza di tipo riferimento o per un <xref:System.Nullable%601> proprietà di dipendenza e restituirebbe `true` in questi casi. Nei casi in cui la proprietà di dipendenza né un riferimento né <xref:System.Nullable%601> , digitare <xref:System.Windows.DependencyProperty.IsValidType%2A> restituirà `false` per un valore null anziché generare un'eccezione.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Windows.DependencyProperty.IsValidValue%2A> come un controllo prima di chiamare <xref:System.Windows.DependencyObject.SetValue%2A> nella proprietà di dipendenza.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome della proprietà di dipendenza.</summary>
        <value>Nome della proprietà.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà ottiene il nome fornito come il `name` parametro durante la registrazione di proprietà di dipendenza. Questo nome non è modificabile e non può essere `null` o una stringa vuota. Le registrazioni dei nomi duplicati nello stesso tipo del proprietario non sono consentiti e verrà generata un'eccezione quando si prova a registrare il duplicato.  
  
> [!IMPORTANT]
>  Il <xref:System.Windows.DependencyProperty.Name%2A> una dipendenza della proprietà deve seguire la convenzione di corrispondere al nome dell'identificatore meno il suffisso "Proprietà" proprietà di dipendenza. Per informazioni dettagliate, vedere [Proprietà di dipendenza personalizzate](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 Nell'esempio seguente esegue una query varie caratteristiche di un identificatore di proprietà di dipendenza, tra cui la <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Specifica i metadati alternativi per questa proprietà di dipendenza quando è presente nelle istanze di un tipo specificato, rispetto ai metadati specificati nella registrazione della proprietà di dipendenza originale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Tipo in cui questa proprietà di dipendenza viene ereditata e in cui verranno applicati i metadati alternativi.</param>
        <param name="typeMetadata">Metadati da applicare alla proprietà di dipendenza nel tipo che esegue l'override.</param>
        <summary>Specifica i metadati alternativi per questa proprietà di dipendenza quando è presente nelle istanze di un tipo specificato, eseguendo l'override dei metadati esistenti per la proprietà di dipendenza quando è stata ereditata dai tipi di base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima che il sistema di proprietà viene utilizzata la proprietà di dipendenza, è necessario eseguire l'override dei metadati di proprietà di dipendenza. Ciò equivale all'ora in cui vengono create istanze specifiche usando la classe che registra la proprietà di dipendenza. Le chiamate a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> deve essere eseguita solo all'interno dei costruttori statici del tipo che fornisce se stesso come il `forType` parametro di questo metodo, o tramite la creazione di istanze analoghe. Tentativo di modificare i metadati dopo esistono istanze del tipo di proprietario non genererà eccezioni, ma comporterà comportamenti incoerenti nel sistema di proprietà.  
  
 Dopo aver stabilito i metadati per una determinata classe derivata di sostituzione con questo metodo, i tentativi successivi di eseguire l'override dei metadati di questa classe derivata stessa genererà un'eccezione.  
  
 Metadati forniti vengono uniti i metadati della proprietà per la proprietà di dipendenza esistente sul proprietario di base. Tutte le caratteristiche specificate nei metadati di base originali verranno mantenuti; solo le caratteristiche che sono state modificate in modo specifico i nuovi metadati sostituiranno le caratteristiche dei metadati di base. Alcune caratteristiche, ad esempio <xref:System.Windows.PropertyMetadata.DefaultValue%2A> vengono sostituiti se specificato nei metadati di nuovo. Altri, ad esempio <xref:System.Windows.PropertyChangedCallback>, vengono combinate. In definitiva, il comportamento di tipo merge dipende dal tipo metadati proprietà utilizzato per la sostituzione, pertanto il comportamento qui descritto è per le classi di metadati di proprietà esistente usate da [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] le proprietà di dipendenza. Per informazioni dettagliate, vedere [metadati delle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-metadata.md) e [i metadati della proprietà Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si è tentato di eseguire l'override dei metadati in una proprietà di dipendenza di sola lettura. Tale operazione non può essere eseguita usando questa firma.</exception>
        <exception cref="T:System.ArgumentException">I metadati sono già stati stabiliti per la proprietà di dipendenza nello stato attuale per il tipo specificato.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Tipo in cui questa proprietà di dipendenza viene ereditata e in cui verranno applicati i metadati alternativi.</param>
        <param name="typeMetadata">Metadati da applicare alla proprietà di dipendenza nel tipo che esegue l'override.</param>
        <param name="key">Chiave di accesso per una proprietà di dipendenza di sola lettura.</param>
        <summary>Specifica i metadati alternativi per una proprietà di dipendenza di sola lettura quando è presente nelle istanze di un tipo specificato, in sostituzione dei metadati specificati nella registrazione della proprietà di dipendenza iniziale. È necessario passare <see cref="T:System.Windows.DependencyPropertyKey" /> affinché la proprietà di dipendenza di sola lettura eviti di generare un'eccezione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa firma fornisce l'implementazione sottostante per un identificatore di proprietà di dipendenza di sola lettura (<xref:System.Windows.DependencyPropertyKey>) (metodo). Se si esegue l'override dei metadati per una proprietà di dipendenza di lettura / scrittura, usare <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Prima che il sistema di proprietà viene utilizzata la proprietà di dipendenza, è necessario eseguire l'override dei metadati di proprietà di dipendenza. Ciò equivale al tempo che vengono creati oggetti specifici per la classe che registra la proprietà di dipendenza. Le chiamate a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> deve essere eseguita solo all'interno dei costruttori statici del tipo che fornisce se stesso come il `forType` parametro di questo metodo, o tramite la creazione di istanze analoghe. Tentativo di modificare i metadati dopo esistono istanze del tipo di proprietario non genererà eccezioni, ma comporterà comportamenti incoerenti nel sistema di proprietà.  
  
 Dopo aver stabilito i metadati per una determinata classe derivata di sostituzione con questo metodo, i tentativi successivi di eseguire l'override dei metadati di questa classe derivata stessa genererà un'eccezione.  
  
 Metadati forniti vengono uniti i metadati della proprietà per la proprietà di dipendenza esistente sul proprietario di base. Tutte le caratteristiche specificate nei metadati di base originali verranno mantenuti; solo le caratteristiche che sono state modificate in modo specifico i nuovi metadati sostituiranno le caratteristiche dei metadati di base. Alcune caratteristiche, ad esempio <xref:System.Windows.PropertyMetadata.DefaultValue%2A> vengono sostituiti se specificato nei metadati di nuovo. Altri, ad esempio <xref:System.Windows.PropertyChangedCallback>, vengono combinate. Il comportamento di tipo merge dipende dal tipo proprietà dei metadati utilizzato per l'override. Per informazioni dettagliate, vedere [metadati delle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-metadata.md) e [i metadati della proprietà Framework](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo dell'oggetto che ha registrato la proprietà di dipendenza nel sistema di proprietà o che si è aggiunto come proprietario della proprietà.</summary>
        <value>Tipo dell'oggetto che ha registrato la proprietà o che si è aggiunto come proprietario della proprietà.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo valore è stato fornito durante la registrazione della proprietà. Il proprietario sarà il tipo della registrazione originale nel caso di un <xref:System.Windows.DependencyProperty> identificatore generato da un <xref:System.Windows.DependencyProperty.Register%2A> chiamata o il tipo che è stato aggiunto come proprietario nel caso di un <xref:System.Windows.DependencyProperty> identificatore generato da un <xref:System.Windows.DependencyProperty.AddOwner%2A> chiamare.  
  
 Il <xref:System.Windows.DependencyProperty.OwnerType%2A> su qualsiasi dato <xref:System.Windows.DependencyProperty> non è modificabile e non può essere `null` in un valore valido <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 L'esempio seguente ottiene il tipo di proprietario basato su un identificatore di proprietà di dipendenza `dp`e quindi Ottiene i metadati sul tipo di proprietario per tale identificatore stesso. Questa operazione equivale effettivamente a ottenere <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> su `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo che la proprietà di dipendenza utilizza per il valore.</summary>
        <value>
          <see cref="T:System.Type" /> del valore della proprietà.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà indica il tipo del valore della proprietà come dichiarato dalla registrazione della proprietà originale, tramite il `propertyType` parametro. Simile al <xref:System.Windows.DependencyProperty.Name%2A>, il tipo di proprietà di una proprietà di dipendenza non è modificabile dopo la registrazione.  
  
   
  
## Examples  
 Nell'esempio seguente esegue una query varie caratteristiche di un identificatore di proprietà di dipendenza, tra cui la <xref:System.Windows.DependencyProperty.PropertyType%2A>. La stringa del nome del tipo di <xref:System.Windows.DependencyProperty.PropertyType%2A> viene ottenuto dall'oggetto restituito <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la proprietà di dipendenza identificata da questa istanza <see cref="T:System.Windows.DependencyProperty" /> è una proprietà di dipendenza di sola lettura.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza è di sola lettura, in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le proprietà di dipendenza di sola lettura vengono registrate all'interno del sistema di proprietà chiamando i <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> metodo anziché il <xref:System.Windows.DependencyProperty.Register%2A> (metodo). Le proprietà associate possono essere registrate come di sola lettura. vedere <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Le proprietà di dipendenza di sola lettura richiedono un <xref:System.Windows.DependencyPropertyKey> identificatore anziché un <xref:System.Windows.DependencyProperty> identificatore per eseguire operazioni sui metadati, ad esempio l'override dei metadati o l'impostazione del valore. Se si ottiene una raccolta di <xref:System.Windows.DependencyProperty> identificatori tramite una chiamata a <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> o da un'altra [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] che espone gli identificatori, controllare il <xref:System.Windows.DependencyProperty.ReadOnly%2A> valore prima di chiamare <xref:System.Windows.DependencyObject.SetValue%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> utilizzando quel Identificatore della proprietà di dipendenza come parametro di input, per verificare che la proprietà di dipendenza che rappresenta l'identificatore non è in sola lettura. Se il valore di <xref:System.Windows.DependencyProperty.ReadOnly%2A> viene `true` su una proprietà di dipendenza, non vi è alcuna modalità programmatica per ottenere un riferimento al <xref:System.Windows.DependencyPropertyKey> identificatore di tale proprietà di dipendenza, dai metadati o dal <xref:System.Windows.DependencyProperty> identificatore; l'identificatore deve essere disponibile come un campo statico affinché la chiamata <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> in base a una proprietà di dipendenza di sola lettura.  
  
 Quando si crea una proprietà di dipendenza personalizzate e registrarlo in sola lettura, è consigliabile definire solo una funzione di accesso get per il [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] proprietà wrapper. In caso contrario, la classe avrà un modello a oggetti poco chiaro per il wrapper della proprietà a confronto l'accesso alla proprietà di dipendenza sottostante. Per informazioni dettagliate, vedere [proprietà di dipendenza personalizzate](~/docs/framework/wpf/advanced/custom-dependency-properties.md) oppure [delle proprietà di dipendenza di sola lettura](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 Nell'esempio seguente ottiene i metadati predefiniti e le proprietà identificatore di proprietà di dipendenza da vari campi di proprietà di dipendenza e utilizza le informazioni per popolare una tabella per implementare un visualizzatore"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra una proprietà di dipendenza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà di dipendenza da registrare. Il nome deve essere univoco all'interno dello spazio dei nomi di registrazione del tipo di proprietario.</param>
        <param name="propertyType">Tipo della proprietà.</param>
        <param name="ownerType">Tipo di proprietario che registra la proprietà di dipendenza.</param>
        <summary>Registra una proprietà di dipendenza con il nome di proprietà, il tipo di proprietà e il tipo di proprietario specificati.</summary>
        <returns>Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <see langword="public static readonly" /> nella classe. Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà di dipendenza da registrare.</param>
        <param name="propertyType">Tipo della proprietà.</param>
        <param name="ownerType">Tipo di proprietario che registra la proprietà di dipendenza.</param>
        <param name="typeMetadata">Metadati della proprietà per la proprietà di dipendenza.</param>
        <summary>Registra una proprietà di dipendenza con il nome, il tipo e i metadati della proprietà e il tipo di proprietario specificati.</summary>
        <returns>Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <see langword="public static readonly" /> nella classe. Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà di dipendenza da registrare.</param>
        <param name="propertyType">Tipo della proprietà.</param>
        <param name="ownerType">Tipo di proprietario che registra la proprietà di dipendenza.</param>
        <param name="typeMetadata">Metadati della proprietà per la proprietà di dipendenza.</param>
        <param name="validateValueCallback">Riferimento a un callback che deve eseguire qualsiasi convalida personalizzata del valore della proprietà di dipendenza oltre la normale convalida del tipo.</param>
        <summary>Registra una proprietà di dipendenza con il nome di proprietà, il tipo di proprietà, il tipo di proprietario, i metadati della proprietà e un callback di convalida del valore della proprietà specificati.</summary>
        <returns>Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <see langword="public static readonly" /> nella classe. Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Nell'esempio seguente registra una proprietà di dipendenza, tra cui un callback di convalida (la definizione di callback non viene visualizzato; per informazioni dettagliate sulla definizione di callback, vedere <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra una proprietà associata al sistema di proprietà.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà di dipendenza da registrare.</param>
        <param name="propertyType">Tipo della proprietà.</param>
        <param name="ownerType">Tipo di proprietario che registra la proprietà di dipendenza.</param>
        <summary>Registra una proprietà associata con il nome di proprietà, il tipo di proprietà e il tipo di proprietario specificati.</summary>
        <returns>Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <see langword="public static readonly" /> nella classe. Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà associata è un concetto di proprietà definito da [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] le proprietà associati vengono implementati come proprietà di dipendenza. Poiché il [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] le proprietà associate sono proprietà di dipendenza, possono avere metadati applicati e che possono essere utilizzato dal sistema di proprietà generale per operazioni quali la segnalazione delle caratteristiche di layout. Per altre informazioni, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Per altre informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Nell'esempio seguente registra una proprietà associata in una classe astratta usando questo <xref:System.Windows.DependencyProperty.RegisterAttached%2A> firma.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà di dipendenza da registrare.</param>
        <param name="propertyType">Tipo della proprietà.</param>
        <param name="ownerType">Tipo di proprietario che registra la proprietà di dipendenza.</param>
        <param name="defaultMetadata">Metadati della proprietà per la proprietà di dipendenza. Può essere incluso il valore predefinito così come altre caratteristiche.</param>
        <summary>Registra una proprietà associata al nome, al tipo e ai metadati della proprietà e al tipo di proprietario specificati.</summary>
        <returns>Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <see langword="public static readonly" /> nella classe. Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà associata è un concetto di proprietà definito da [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] le proprietà associati vengono implementati come proprietà di dipendenza. Poiché il [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] le proprietà associate sono proprietà di dipendenza, possono avere metadati applicati e che possono essere utilizzato dal sistema di proprietà generale per operazioni quali la segnalazione delle caratteristiche di layout. Per altre informazioni, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Per altre informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilizzare RegisterAttached eredità valore delle proprietà di dipendenza  
 Uno scenario specifico per la registrazione di una proprietà di dipendenza con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> invece di <xref:System.Windows.DependencyProperty.Register%2A> per supportare l'ereditarietà del valore della proprietà. È consigliabile registrare il valore che eredita le proprietà di dipendenza con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si prevede di esporre Get * e * Set di metodi statici per fornire true collegati funzioni di supporto di proprietà.   Anche se può sembrare ereditarietà del valore della proprietà per le proprietà di dipendenza non associata, il comportamento di ereditarietà per una proprietà non associata tramite certi limiti di elementi nell'albero della fase di esecuzione è definito. Registrazione della proprietà collegata in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che l'ereditarietà del valore della proprietà funziona tra tutti i limiti in un albero degli elementi. Usare sempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> per registrare le proprietà in cui si specificano <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nei metadati. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà di dipendenza da registrare.</param>
        <param name="propertyType">Tipo della proprietà.</param>
        <param name="ownerType">Tipo di proprietario che registra la proprietà di dipendenza.</param>
        <param name="defaultMetadata">Metadati della proprietà per la proprietà di dipendenza. Può essere incluso il valore predefinito così come altre caratteristiche.</param>
        <param name="validateValueCallback">Riferimento a un callback che deve eseguire qualsiasi convalida personalizzata del valore della proprietà di dipendenza oltre la normale convalida del tipo.</param>
        <summary>Registra una proprietà associata con il tipo della proprietà, il tipo del proprietario, i metadati della proprietà e un callback di convalida del valore per la proprietà specificati.</summary>
        <returns>Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <see langword="public static readonly" /> nella classe. Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà associata è un concetto di proprietà definito da [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] le proprietà associati vengono implementati come proprietà di dipendenza. Poiché il [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] le proprietà associate sono proprietà di dipendenza, possono avere metadati applicati e che possono essere utilizzato dal sistema di proprietà generale per operazioni quali la segnalazione delle caratteristiche di layout. Per altre informazioni, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Per altre informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilizzare RegisterAttached eredità valore delle proprietà di dipendenza  
 Uno scenario specifico per la registrazione di una proprietà di dipendenza con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> invece di <xref:System.Windows.DependencyProperty.Register%2A> per supportare l'ereditarietà del valore della proprietà. È consigliabile registrare il valore che eredita le proprietà di dipendenza con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si prevede di esporre Get * e * Set di metodi statici per fornire true collegati funzioni di supporto di proprietà.   Anche se può sembrare ereditarietà del valore della proprietà per le proprietà di dipendenza non associata, il comportamento di ereditarietà per una proprietà non associata tramite certi limiti di elementi nell'albero della fase di esecuzione è definito. Registrazione della proprietà collegata in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che l'ereditarietà del valore della proprietà funziona tra tutti i limiti in un albero degli elementi. Usare sempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> per registrare le proprietà in cui si specificano <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nei metadati. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 Nell'esempio seguente registra una proprietà associata in una classe astratta usando questo <xref:System.Windows.DependencyProperty.RegisterAttached%2A> firma. Questa proprietà associata è una proprietà del tipo di enumerazione e la registrazione consente di aggiungere un callback di convalida per verificare che il valore specificato è un valore dell'enumerazione.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra un proprietà associata di sola lettura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà di dipendenza da registrare.</param>
        <param name="propertyType">Tipo della proprietà.</param>
        <param name="ownerType">Tipo di proprietario che registra la proprietà di dipendenza.</param>
        <param name="defaultMetadata">Metadati della proprietà per la proprietà di dipendenza.</param>
        <summary>Registra una proprietà associata di sola lettura con il tipo e i metadati della proprietà e il tipo di proprietario specificati.</summary>
        <returns>Chiave della proprietà di dipendenza che deve essere usata per impostare il valore di un campo statico di sola lettura nella classe, che viene quindi usata per fare riferimento alla proprietà di dipendenza in un secondo momento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce il tipo <xref:System.Windows.DependencyPropertyKey>, mentre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> restituisce il tipo <xref:System.Windows.DependencyProperty>. In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore di proprietà di dipendenza chiamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <xref:System.Windows.DependencyPropertyKey> solo alle parti del codice che è necessario impostare questa proprietà di dipendenza come parte della logica di classe o l'applicazione. Si consiglia inoltre di esporre un identificatore di proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> come un `public static readonly` campo nella classe.  
  
 Le proprietà associate di sola lettura sono uno scenario raro, perché lo scenario principale per una proprietà associata è l'utilizzo in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Senza un setter pubblico, non può essere impostata una proprietà associata [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintassi.  
  
 Per altre informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilizzare RegisterAttached eredità valore delle proprietà di dipendenza  
 Per supportare l'ereditarietà del valore della proprietà associata è uno scenario specifico per la registrazione di una proprietà di dipendenza come. È consigliabile registrare il valore che eredita le proprietà di dipendenza con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si prevede di esporre Get * e * Set di metodi statici per fornire true collegati funzioni di supporto di proprietà.   Anche se può sembrare ereditarietà del valore della proprietà per le proprietà di dipendenza non associata, il comportamento di ereditarietà per una proprietà non associata tramite certi limiti di elementi nell'albero della fase di esecuzione è definito. Registrazione della proprietà collegata in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che l'ereditarietà del valore della proprietà funziona tra tutti i limiti in un albero degli elementi. Usare sempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> per registrare le proprietà in cui si specificano <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nei metadati. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà di dipendenza da registrare.</param>
        <param name="propertyType">Tipo della proprietà.</param>
        <param name="ownerType">Tipo di proprietario che registra la proprietà di dipendenza.</param>
        <param name="defaultMetadata">Metadati della proprietà per la proprietà di dipendenza.</param>
        <param name="validateValueCallback">Riferimento a un callback creato dall'utente che deve eseguire qualsiasi convalida personalizzata del valore della proprietà di dipendenza oltre la normale convalida del tipo.</param>
        <summary>Registra una proprietà associata di sola lettura, con il tipo della proprietà, il tipo del proprietario, i metadati della proprietà e un callback di convalida specificati.</summary>
        <returns>Chiave della proprietà di dipendenza che deve essere usata per impostare il valore di un campo statico di sola lettura nella classe, che viene quindi usata per fare riferimento alla proprietà di dipendenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce il tipo <xref:System.Windows.DependencyPropertyKey>, mentre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> restituisce il tipo <xref:System.Windows.DependencyProperty>. In genere, le chiavi che rappresentano il tipo <xref:System.Windows.DependencyProperty>. In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore di proprietà di dipendenza chiamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <xref:System.Windows.DependencyPropertyKey> solo alle parti del codice che è necessario impostare questa proprietà di dipendenza come parte della logica di classe o l'applicazione. Si consiglia inoltre di esporre un identificatore di proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> come un `public static readonly` campo nella classe.  
  
 Le proprietà associate di sola lettura sono uno scenario raro, perché lo scenario principale per una proprietà associata è l'utilizzo in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Senza un setter pubblico, non può essere impostata una proprietà associata [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintassi.  
  
 Per altre informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Utilizzare RegisterAttached eredità valore delle proprietà di dipendenza  
 Uno scenario specifico per la registrazione di una proprietà di dipendenza collegata anziché <xref:System.Windows.DependencyProperty.Register%2A> per supportare l'ereditarietà del valore della proprietà. È consigliabile registrare il valore che eredita le proprietà di dipendenza con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si prevede di esporre Get * e * Set di metodi statici per fornire true collegati funzioni di supporto di proprietà.   Anche se può sembrare ereditarietà del valore della proprietà per le proprietà di dipendenza non associata, il comportamento di ereditarietà per una proprietà non associata tramite certi limiti di elementi nell'albero della fase di esecuzione è definito. Registrazione della proprietà collegata in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che l'ereditarietà del valore della proprietà funziona tra tutti i limiti in un albero degli elementi. Usare sempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> per registrare le proprietà in cui si specificano <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nei metadati. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra una proprietà di dipendenza come proprietà di dipendenza di sola lettura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà di dipendenza da registrare.</param>
        <param name="propertyType">Tipo della proprietà.</param>
        <param name="ownerType">Tipo di proprietario che registra la proprietà di dipendenza.</param>
        <param name="typeMetadata">Metadati della proprietà per la proprietà di dipendenza.</param>
        <summary>Registra una proprietà di dipendenza di sola lettura con il tipo e i metadati della proprietà e il tipo di proprietario specificati.</summary>
        <returns>Chiave della proprietà di dipendenza che deve essere usata per impostare il valore di un campo statico di sola lettura nella classe, che viene quindi usata per fare riferimento alla proprietà di dipendenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce il tipo <xref:System.Windows.DependencyPropertyKey>, mentre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> restituisce il tipo <xref:System.Windows.DependencyProperty>. In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore di proprietà di dipendenza chiamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <xref:System.Windows.DependencyPropertyKey> solo alle parti del codice che è necessario impostare questa proprietà di dipendenza come parte della logica di classe o l'applicazione. Si consiglia inoltre di esporre un identificatore di proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> come un `public static readonly` campo nella classe.  
  
 Le proprietà di dipendenza di sola lettura sono piuttosto uno scenario tipico entrambi esistente [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] e per gli scenari di personalizzazione, perché altri [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funzionalità potrebbero richiedere una proprietà di dipendenza, anche se tale proprietà non deve essere impostata da chiamanti. È possibile usare il valore di una proprietà di dipendenza di sola lettura come base per altre operazioni di sistema di proprietà che accettano una proprietà di dipendenza, ad esempio basare un <xref:System.Windows.Trigger> nella proprietà di dipendenza in uno stile.  
  
 Per altre informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Nell'esempio seguente viene registrato un `AquariumSize` proprietà di dipendenza di sola lettura. Nell'esempio viene definita `AquariumSizeKey` come una chiave interna (in modo che le altre classi nell'assembly è stato possibile eseguire l'override dei metadati) ed espone l'identificatore di proprietà di dipendenza in base a tale chiave come `AquariumSizeProperty`. Inoltre, viene creato un wrapper per `AquariumSize`, con solo una funzione di accesso get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà di dipendenza da registrare.</param>
        <param name="propertyType">Tipo della proprietà.</param>
        <param name="ownerType">Tipo di proprietario che registra la proprietà di dipendenza.</param>
        <param name="typeMetadata">Metadati della proprietà per la proprietà di dipendenza.</param>
        <param name="validateValueCallback">Riferimento a un callback creato dall'utente che deve eseguire qualsiasi convalida personalizzata del valore della proprietà di dipendenza oltre la normale convalida del tipo.</param>
        <summary>Registra una proprietà di dipendenza di sola lettura, con il tipo di proprietà, il tipo di proprietario, i metadati della proprietà e un callback di convalida specificati.</summary>
        <returns>Chiave della proprietà di dipendenza che deve essere usata per impostare il valore di un campo statico di sola lettura nella classe, che viene quindi usata per fare riferimento alla proprietà di dipendenza in un secondo momento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce il tipo <xref:System.Windows.DependencyPropertyKey>, mentre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> restituisce il tipo <xref:System.Windows.DependencyProperty>. In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore di proprietà di dipendenza chiamando <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <xref:System.Windows.DependencyPropertyKey> solo alle parti del codice che è necessario impostare questa proprietà di dipendenza come parte della logica di classe o l'applicazione. Si consiglia inoltre di esporre un identificatore di proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> come un `public static readonly` campo nella classe.  
  
 Le proprietà di dipendenza di sola lettura sono uno scenario tipico. È possibile usare il valore di una proprietà di dipendenza di sola lettura come base per altre operazioni di sistema di proprietà che accettano una proprietà di dipendenza, ad esempio basare un <xref:System.Windows.Trigger> nella proprietà di dipendenza in uno stile.  
  
 Per altre informazioni sulla registrazione di proprietà di dipendenza, vedere <xref:System.Windows.DependencyProperty>.  
  
 La convalida su una proprietà di dipendenza di sola lettura potrebbe essere meno importante. Il livello di accesso non pubblico specificato per la chiave riduce la probabilità per l'input non valido non autorizzato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce la rappresentazione di stringa della proprietà di dipendenza.</summary>
        <returns>Rappresentazione di stringa della proprietà di dipendenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione restituisce il <xref:System.Windows.DependencyProperty.Name%2A> valore della proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica un valore statico utilizzato dal sistema della proprietà [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] piuttosto che <see langword="null" /> per indicare che la proprietà esiste, ma non ha il valore impostato dal sistema della proprietà.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> è un valore di sentinel che viene usato per gli scenari in cui il [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema di proprietà non è in grado di determinare una richiesta <xref:System.Windows.DependencyProperty> valore. <xref:System.Windows.DependencyProperty.UnsetValue> viene usato invece `null`, in quanto `null` potrebbe essere un valore di proprietà valido, nonché un valore valido (e più frequente) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> non viene mai restituita fuori <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. Quando si chiama <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> su una proprietà di dipendenza su un <xref:System.Windows.DependencyObject> istanza, si applica una delle opzioni seguenti condizioni:  
  
-   Una proprietà di dipendenza è un valore predefinito stabilito nei metadati e viene restituito tale valore. Questo valore potrebbe derivare da <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Un altro valore definito dal sistema di proprietà e il valore predefinito è più pertinente. Per altri dettagli, vedere [Precedenza del valore della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Impostazione di un <xref:System.Windows.PropertyMetadata.DefaultValue%2A> di <xref:System.Windows.DependencyProperty.UnsetValue> specificamente è consentita.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Restituisce <xref:System.Windows.DependencyProperty.UnsetValue> quando la proprietà richiesta è non stato impostata localmente.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale quando usato come valore restituito di un <xref:System.Windows.CoerceValueCallback>. Per informazioni dettagliate, vedere [callback delle proprietà di dipendenza e la convalida](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 Se esegue il binding a un database, si noti che <xref:System.Windows.DependencyProperty.UnsetValue> non equivale al <xref:System.DBNull.Value>, in modo analogo al modo in cui <xref:System.DBNull.Value> non equivale a un vero null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il callback di convalida del valore per la proprietà di dipendenza.</summary>
        <value>Callback di convalida del valore per questa proprietà di dipendenza, come fornito per il parametro <paramref name="validateValueCallback" /> nella registrazione della proprietà di dipendenza originale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà conterrà `null` per qualsiasi proprietà di dipendenza con alcun callback di convalida registrato.  
  
 Valore di convalida richiamate devono agire in senso statico: convalida applicata tramite il <xref:System.Windows.ValidateValueCallback> non è possibile determinare se il valore specificato è valido per una particolare istanza. Il callback può determinare solo se tutti gli oggetti che possiedono la proprietà di dipendenza devono o non devono accettare il valore specificato come valido. Se è necessario eseguire la convalida che si basa sulla conoscenza dei valori di altre proprietà di dipendenza in una determinata istanza, utilizzare un <xref:System.Windows.CoerceValueCallback> invece. Il <xref:System.Windows.CoerceValueCallback> viene registrata come parte dei metadati di proprietà di dipendenza, anziché direttamente nell'identificatore delle proprietà di dipendenza. Per informazioni dettagliate, vedere [callback delle proprietà di dipendenza e la convalida](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>