<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DependencyProperty.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b891ec5d-4b60-42d7-ac21-95eab9e3ef823e36dd257b906b7c94742536f4e333ac2cac8cd0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3e36dd257b906b7c94742536f4e333ac2cac8cd0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">058bfa0b75b777d3171411d35da8f11617fc06b0</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/04/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</source>
          <target state="translated">Rappresenta una proprietà che può essere impostata tramite metodi, ad esempio stile, data binding, animazione ed ereditarietà.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> supports the following capabilities in <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>:</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> supporta le funzionalità seguenti in <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>:</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set in a style.</source>
          <target state="translated">La proprietà può essere impostata in uno stile.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Applicazione di stili e modelli<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set through data binding.</source>
          <target state="translated">La proprietà può essere impostata tramite l'associazione dati.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information about data binding dependency properties, see <bpt id="p1">[</bpt>How to: Bind the Properties of Two Controls<ept id="p1">](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulle proprietà di dipendenza di associazione dati, vedere <bpt id="p1">[</bpt>procedura: associare le proprietà dei due controlli<ept id="p1">](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)</ept>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set with a dynamic resource reference.</source>
          <target state="translated">La proprietà può essere impostata con un riferimento alla risorsa dinamica.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Risorse XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can inherit its value automatically from a parent element in the element tree.</source>
          <target state="translated">La proprietà può ereditare automaticamente il valore da un elemento padre nell'albero degli elementi.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Ereditarietà del valore della proprietà<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be animated.</source>
          <target state="translated">La proprietà può essere animata.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Animation Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Panoramica dell'animazione<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can report when the previous value of the property has been changed and the property value can be coerced.</source>
          <target state="translated">La proprietà può segnalare quando il valore precedente della proprietà è stato modificato e può essere assegnato il valore della proprietà.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Callback e convalida delle proprietà di dipendenza<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property reports information to <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, such as whether changing a property value should require the layout system to recompose the visuals for an element.</source>
          <target state="translated">La proprietà vengono fornite informazioni per <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, ad esempio se la modifica di un valore della proprietà richiede il sistema di layout per ricomporre gli elementi visivi di un elemento.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property receives support in the <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]</ph>.</source>
          <target state="translated">La proprietà riceve supporto nel <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For example, the property can be edited in the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> window.</source>
          <target state="translated">Ad esempio, la proprietà può essere modificata nella <bpt id="p1">**</bpt>proprietà<ept id="p1">**</ept> finestra.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn more about dependency properties, see <bpt id="p1">[</bpt>Dependency Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulle proprietà di dipendenza, vedere <bpt id="p1">[</bpt>Cenni preliminari sulle proprietà di dipendenza<ept id="p1">](~/docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>If you want properties on your custom types to support the capabilities in the preceding list, you should create a dependency property.</source>
          <target state="translated">Se si desidera che le proprietà nei tipi personalizzati per supportare le funzionalità nell'elenco precedente, è necessario creare una proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn how to create custom dependency properties, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
          <target state="translated">Per informazioni su come creare proprietà di dipendenza personalizzata, vedere <bpt id="p1">[</bpt>delle proprietà di dipendenza personalizzata<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An attached property is a property that enables any object to report information to the type that defines the attached property.</source>
          <target state="translated">Una proprietà associata è una proprietà che consente a qualsiasi oggetto per fornire le informazioni per il tipo che definisce la proprietà associata.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, any type that inherits from <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> can use an attached property regardless of whether the type inherits from the type that defines the property.</source>
          <target state="translated">In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, qualsiasi tipo che eredita da <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> possibile utilizzare una proprietà associata indipendentemente dal fatto che il tipo eredita dal tipo che definisce la proprietà.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An attached property is a feature of the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> language.</source>
          <target state="translated">Una proprietà associata è una funzionalità di <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> language.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To set an attached property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, use the <bpt id="p1">*</bpt>ownerType<ept id="p1">*</ept>.<bpt id="p2">*</bpt>propertyName<ept id="p2">*</ept> syntax.</source>
          <target state="translated">Per impostare una proprietà associata <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, utilizzare il <bpt id="p1">*</bpt>ownerType<ept id="p1">*</ept>.<bpt id="p2">*</bpt> propertyName<ept id="p2">*</ept> sintassi.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An example of an attached property is the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Un esempio di una proprietà associata è di <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>If you want to create a property that can be used on all <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> types, then you should create an attached property.</source>
          <target state="translated">Se si desidera creare una proprietà che può essere usata in tutti <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> tipi, sarà necessario creare una proprietà associata.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn more about attached properties, including how to create them, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulle proprietà associate e su come crearle, vedere <bpt id="p1">[</bpt>collegato Cenni preliminari sulle proprietà<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>XAML Attribute Usage</source>
          <target state="translated">Uso della sintassi XAML per gli attributi</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>XAML Values</source>
          <target state="translated">Valori XAML</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph> of the desired dependency property.</source>
          <target state="translated">Stringa che specifica il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph> della proprietà di dipendenza desiderata.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>This can be preceded by an XML namespace prefix if the property is not in the default XML namespace (for details, see <bpt id="p1">[</bpt>XAML Namespaces and Namespace Mapping for WPF XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.)</source>
          <target state="translated">Questo può essere preceduto dal prefisso dello spazio dei nomi XML, se la proprietà non è presente nello spazio dei nomi XML predefinito (per informazioni dettagliate, vedere <bpt id="p1">[</bpt>spazi dei nomi XAML e Namespace Mapping per XAML di WPF<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></source>
          <target state="translated"><ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies an owner type of a dependency property, a dot (.), then the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Stringa che specifica un tipo di proprietario di una proprietà di dipendenza, un punto (.), quindi il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`ownerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`ownerType`</ph> possono anche essere preceduti dal prefisso dello spazio dei nomi XML.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>This usage is particular to late-bound styles and templates, where the owner of the dependency property must be specified for parsing context because the <ph id="ph1">`TargetType`</ph> is not yet known.</source>
          <target state="translated">Questo utilizzo è specifico per l'associazione tardiva stili e modelli, in cui il proprietario della proprietà di dipendenza deve essere specificato per l'analisi di contesto, perché il <ph id="ph1">`TargetType`</ph> non è ancora noto.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Applicazione di stili e modelli<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies  the owner of an attached property, a dot (.), then the attached property name.</source>
          <target state="translated">Stringa che specifica il proprietario di una proprietà associata, un punto (.), il nome della proprietà associata.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph> possono anche essere preceduti dal prefisso dello spazio dei nomi XML.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Adds another type as an owner of a dependency property that has already been registered to a type.</source>
          <target state="translated">Aggiunge un altro tipo come proprietario di una proprietà di dipendenza che è già stata registrata in un tipo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The type to add as an owner of this dependency property.</source>
          <target state="translated">Tipo da aggiungere come proprietario della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Adds another type as an owner of a dependency property that has already been registered.</source>
          <target state="translated">Aggiunge un altro tipo come proprietario di una proprietà di dipendenza che è già stata registrata.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>A reference to the original <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier that identifies the dependency property.</source>
          <target state="translated">Riferimento all'identificatore <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> originale che identifica la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This identifier should be exposed by the adding class as a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field.</source>
          <target state="translated">Questo identificatore deve essere esposto dalla classe che aggiunge come un campo <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">Questo metodo consente al sistema di proprietà di riconoscere una proprietà di dipendenza su un tipo che non ha registrato la proprietà di dipendenza specifica inizialmente.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Typically, <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> is used to add dependency properties to classes that do not already expose that dependency property through managed class inheritance (class inheritance would cause the wrapper properties to be inherited by the derived class, and thus would provide general members-table access to the dependency property already).</source>
          <target state="translated">In genere, <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> viene utilizzato per aggiungere le proprietà di dipendenza a classi che non è già espongono la proprietà di dipendenza tramite l'ereditarietà di classe gestita (ereditarietà della classe determina le proprietà del wrapper a essere ereditato dalla classe derivata di conseguenza fornisce accesso alla tabella dei membri generale per la proprietà di dipendenza già).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> enables the property system to recognize a dependency property on a type that did not register that dependency property initially.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> consente al sistema di proprietà di riconoscere una proprietà di dipendenza su un tipo che non ha registrato la proprietà di dipendenza inizialmente.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This signature does not allow for specifying metadata.</source>
          <target state="translated">Questa firma non consente di specificare metadati.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>When you use this method, the metadata is automatically generated for the new <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> and its owner type.</source>
          <target state="translated">Quando si utilizza questo metodo, i metadati vengono generati automaticamente per il nuovo <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> e il relativo tipo di proprietario.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The auto-generated metadata is the result of the merged metadata from all of the base types that have this property defined.</source>
          <target state="translated">I metadati generati automaticamente sono il risultato di metadati uniti di tutti i tipi di base che questa proprietà definita.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>If no merged metadata is available, then the default metadata for the property is used.</source>
          <target state="translated">Se non sono metadati di merge sono disponibili, i metadati predefiniti per la proprietà viene utilizzata.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>If the property is registered by using the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> method, then the default metadata is the same as the metadata that is created when <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> was called.</source>
          <target state="translated">Se la proprietà viene registrata con il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> (metodo), i metadati predefiniti è identico per i metadati che viene creato quando <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> è stato chiamato.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Otherwise, the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object is created with the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> property set to the property type's default and all other properties of the <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> is set to <ph id="ph4">`null`</ph>.</source>
          <target state="translated">In caso contrario, il <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> oggetto viene creato con il <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> impostata per impostazione predefinita del tipo di proprietà e tutte le altre proprietà del <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> è impostato su <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> signature if you want to provide metadata for the version of the dependency property as added to the provided type.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> firma se si desidera fornire i metadati per la versione della proprietà di dipendenza con l'aggiunta al tipo specificato.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The return value of this method is typically used to declare and expose the dependency property by storing a dependency property identifier.</source>
          <target state="translated">Il valore restituito di questo metodo viene in genere utilizzato per dichiarare ed esporre la proprietà di dipendenza archiviando l'identificatore della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The identifier provides access to the dependency property if you want to call property system <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> against the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">L'identificatore fornisce l'accesso alla proprietà di dipendenza se si desidera chiamare proprietà sistema <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> rispetto alla proprietà di dipendenza, in particolare perché esiste nella classe di aggiunta del proprietario.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">Lo stesso nome di proprietà per il proprietario originale sia proprietario aggiunto deve essere utilizzato per indicare la funzionalità simile.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>You should use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> return value of the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> method to define the dependency property identifier, and also to declare <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</source>
          <target state="translated">È consigliabile utilizzare il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> restituire valore il <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> metodo per definire l'identificatore della proprietà di dipendenza, nonché per dichiarare <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> wrapper della proprietà, per le proprietà di dipendenza che vengono aggiunti ai tipi tramite <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> methodology recommended above is used when creating the dependency properties that are declared within <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> metodologia consigliata sopra viene utilizzata per creare le proprietà di dipendenza che vengono dichiarate all'interno di <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>For instance, both <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> define a <ph id="ph3">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">Ad esempio, entrambi <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> definire un <ph id="ph3">`BorderBrush`</ph> proprietà di dipendenza, con funzionalità simili.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> defines its <ph id="ph2">`BorderBrush`</ph> property to the property system by calling <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> based on the original owner <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> and its registered <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> dependency property identifer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> definisce il <ph id="ph2">`BorderBrush`</ph> proprietà al sistema di proprietà chiamando <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> basato sul proprietario originale <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> e relativi registrati <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> identificatore della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> return value is then used to establish a new static <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> field (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) for that property on the added owner, and a <ph id="ph4">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> valore restituito viene quindi utilizzato per stabilire un nuovo valore statico <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> campo (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) per la proprietà sul proprietario aggiunto e un <ph id="ph4">`BorderBrush`</ph> wrapper della proprietà viene dichiarato.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The type to add as owner of this dependency property.</source>
          <target state="translated">Tipo da aggiungere come proprietario della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata that qualifies the dependency property as it exists on the provided type.</source>
          <target state="translated">Metadati che qualificano la proprietà di dipendenza nello stato attuale per il tipo specificato.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</source>
          <target state="translated">Aggiunge un altro tipo come proprietario di una proprietà di dipendenza già registrata, fornendo i metadati della proprietà di dipendenza nello stato attuale per il tipo di proprietario specificato.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>A reference to the original <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier that identifies the dependency property.</source>
          <target state="translated">Riferimento all'identificatore <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> originale che identifica la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>This identifier should be exposed by the adding class as a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field.</source>
          <target state="translated">Questo identificatore deve essere esposto dalla classe che aggiunge come un campo <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">Questo metodo consente al sistema di proprietà di riconoscere una proprietà di dipendenza su un tipo che non ha registrato la proprietà di dipendenza specifica inizialmente.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The return value of this method is used to declare and expose the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">Il valore restituito di questo metodo viene utilizzato per dichiarare ed esporre la proprietà di dipendenza, in particolare nello stato attuale per la classe proprietario aggiunta.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Generally, the same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">Generalmente, lo stesso nome di proprietà per il proprietario originale sia proprietario aggiunto deve essere usato per indicare la funzionalità simile.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>It is good practice to expose the identifiers, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</source>
          <target state="translated">È consigliabile esporre gli identificatori, nonché i nuovi <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> wrapper della proprietà, per le proprietà di dipendenza che vengono aggiunti ai tipi tramite <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> methodology recommended above is used when creating <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> declared within <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> metodologia consigliata sopra viene utilizzato durante la creazione di <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> dichiarati all'interno di <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>For instance, both <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> define a <ph id="ph3">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">Ad esempio, entrambi <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> definire un <ph id="ph3">`BorderBrush`</ph> proprietà di dipendenza, con funzionalità simili.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> defines its <ph id="ph2">`BorderBrush`</ph> property to the property system by calling <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> on original owner <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> and its registered <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> dependency property identifer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> definisce il <ph id="ph2">`BorderBrush`</ph> proprietà al sistema di proprietà chiamando <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> sul proprietario originale <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> e relativi registrati <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> identificatore della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> return value is then used to establish a static <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> field (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>)for that property on the added owner, and a <ph id="ph4">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> valore restituito viene quindi utilizzato per stabilire un valore statico <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> campo (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) per la proprietà sul proprietario aggiunto e un <ph id="ph4">`BorderBrush`</ph> wrapper della proprietà viene dichiarato.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The added owner's dependency property identifier should be used for operations such as <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>.</source>
          <target state="translated">Identificatore della proprietà di dipendenza del proprietario aggiunto deve essere utilizzato per le operazioni, ad esempio <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>However, type-specific operations involving either types or instances of the class that was added as owner with different metadata will still return the expected results even if the original (not the added owner's) dependency property identifier is specified in calls to methods such as <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph>.</source>
          <target state="translated">Tuttavia, operazioni specifiche del tipo che coinvolgono tipi o le istanze della classe che è stato aggiunto come proprietario con metadati diversi verrà comunque restituiranno i risultati previsti anche se originale (non il proprietario aggiunto) è incluso l'identificatore della proprietà di dipendenza le chiamate a metodi quali <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata for the added owner is perpetuated by the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call itself, not necessarily referenced exclusively by the adding owner class identifier field.</source>
          <target state="translated">I metadati per il proprietario aggiunto vengono trasmessi dal <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> chiamare se stesso, non necessariamente a cui fa riferimento il campo dell'identificatore di classe proprietario aggiunta.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Nevertheless, it is good practice to expose the  identifier, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, because failing to do so creates disparity between the <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> and <ph id="ph4">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> representations of your properties.</source>
          <target state="translated">Tuttavia, è opportuno esporre l'identificatore, nonché i nuovi <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> wrapper della proprietà, per le proprietà di dipendenza che vengono aggiunti ai tipi tramite <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, poiché in caso contrario, crea una disparità tra le <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> e <ph id="ph4">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> rappresentazioni delle proprietà.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">I metadati forniti viene unito con i metadati della proprietà per la proprietà di dipendenza nello stato attuale per il proprietario di base.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Any characteristics that were specified in the original base metadata will persist.</source>
          <target state="translated">Verranno mantenute tutte le caratteristiche che sono state specificate nei metadati di base originali.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Solo le caratteristiche che sono state modificate in particolare nei nuovi metadati sostituiranno le caratteristiche dei metadati di base.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Some characteristics, such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, are replaced if they are specified in the new metadata.</source>
          <target state="translated">Alcune caratteristiche, ad esempio <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, vengono sostituiti se sono specificati nei nuovi metadati.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Altri, ad esempio <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, vengono combinate.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">Infine, il comportamento di tipo merge dipende il tipo di metadati di proprietà utilizzato per la sostituzione, pertanto il comportamento descritto di seguito è per le classi di metadati di proprietà esistenti utilizzate da <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> le proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Per informazioni dettagliate, vedere <bpt id="p1">[</bpt>metadati della proprietà di dipendenza<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> e <bpt id="p2">[</bpt>i metadati della proprietà Framework<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>Gets the default metadata of the dependency property.</source>
          <target state="translated">Ottiene i metadati predefiniti della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The default metadata of the dependency property.</source>
          <target state="translated">Metadati predefiniti della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The default metadata is the property metadata that is available to that particular object or an object of a derived type where no alternative metadata was supplied by an explicit <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> call.</source>
          <target state="translated">I metadati predefiniti sono i metadati della proprietà che sono disponibili per quel particolare oggetto o un oggetto di un tipo derivato in cui i metadati alternativi non sono stati forniti da esplicita <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> chiamare.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If the original owner applied metadata to the first <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call that established the dependency property, then that metadata is returned as <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Se il proprietario originale applicato i metadati per il primo <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> chiamata che ha stabilito la proprietà di dipendenza, che i metadati viene restituito come <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If no metadata was applied in the original <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call, then default metadata is generated from within the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call and this value is returned as the <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Se i metadati non sono stati applicati nella originale <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> chiamare, quindi metadati predefiniti vengono generati all'interno di <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> chiamata e questo valore viene restituito come il <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The main purpose of having default metadata associated with a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> is to supply a default value for this property on any <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> or a derived type.</source>
          <target state="translated">Lo scopo principale di avere metadati predefiniti associati un <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> consiste nel fornire un valore predefinito per questa proprietà su qualsiasi <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> o un tipo derivato.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>For nonattached properties, the metadata type returned by this property cannot be cast to derived types of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> type, even if the property was originally registered with a derived metadata type.</source>
          <target state="translated">Per le proprietà non associate, il tipo di metadati restituito da questa proprietà non può essere convertito tipi derivati di <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> tipo, anche se la proprietà è stato originariamente registrata con un tipo di metadati derivato.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If you want the originally registered metadata including its original possibly derived metadata type, call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;</ph> instead, passing the original registering type as a parameter.</source>
          <target state="translated">Se si desidera che i metadati registrati in origine, incluso il tipo di metadati derivati eventualmente originale, chiamare <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;</ph> invece il passaggio di registrazione originale del tipo come parametro.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>For attached properties, the type of the metadata returned by this property will match the type given in the original <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> registration method.</source>
          <target state="translated">Per le proprietà associate, il tipo di metadati restituiti da questa proprietà corrisponderà al tipo specificato nell'originale <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> metodo di registrazione.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>Returns a hash code for this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</source>
          <target state="translated">Restituisce un codice hash per <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>The hash code for this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</source>
          <target state="translated">Codice hash per <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>The property system uses its own unique identifier <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph>, and the value of that property is returned by <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Il sistema di proprietà utilizza un identificatore univoco <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph>, e viene restituito il valore della proprietà da <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Returns the metadata associated with this dependency property as it exists for a particular type.</source>
          <target state="translated">Restituisce i metadati associati a questa proprietà di dipendenza nello stato attuale per un particolare tipo.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</source>
          <target state="translated">Può trattarsi del tipo in cui la proprietà di dipendenza è stata registrata per la prima volta, uno a cui è stata aggiunta successivamente o un tipo in cui la proprietà di dipendenza è stata ottenuta tramite ereditarietà, ma è stato specificamente eseguito l'override dei metadati.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The specific type from which to retrieve the dependency property metadata.</source>
          <target state="translated">Tipo specifico da cui recuperare i metadati della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>Returns the metadata for this dependency property as it exists on a specified existing type.</source>
          <target state="translated">Restituisce i metadati per questa proprietà di dipendenza nello stato attuale per un tipo esistente specificato.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>A property metadata object.</source>
          <target state="translated">Oggetto metadati della proprietà.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>Specifying either the type or an object reference to use as type is necessary because the metadata can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that alter the metadata of the dependency property as it exists on a type.</source>
          <target state="translated">Specifica il tipo o un riferimento all'oggetto da utilizzare come tipo è necessaria perché i metadati possono variare dalla registrazione originale a causa delle <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> chiamate che modificano i metadati della proprietà di dipendenza nello stato attuale per un tipo.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The following example gets metadata for a dependency property based on its type.</source>
          <target state="translated">Nell'esempio seguente ottiene i metadati per una proprietà di dipendenza in base al tipo.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The type is obtained by using a <ph id="ph1">`typeof`</ph> operator.</source>
          <target state="translated">Il tipo è ottenuto mediante un <ph id="ph1">`typeof`</ph> operatore.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</source>
          <target state="translated">Oggetto dipendenza di cui viene verificato il tipo, per determinare da quale versione specifica del tipo della proprietà di dipendenza devono provenire i metadati.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Returns the metadata for this dependency property as it exists on the specified object instance.</source>
          <target state="translated">Restituisce i metadati per questa proprietà di dipendenza nello stato attuale per l'istanza dell'oggetto specificato.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>A property metadata object.</source>
          <target state="translated">Oggetto metadati della proprietà.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">Specifica il tipo o un riferimento all'oggetto è necessaria perché i metadati di qualsiasi proprietà di dipendenza possono variare dalla registrazione originale a causa delle <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> chiamate che possono definire i metadati della proprietà su un tipo.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>When you request property metadata based on an instance, you are really just passing the instance so that its type can be evaluated internally.</source>
          <target state="translated">Quando si richiedono i metadati della proprietà in base a un'istanza, si sta semplicemente passando l'istanza in modo che il tipo può essere valutato internamente.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Dependency property metadata does not vary per instance; it is always consistent for any given type-property combination.</source>
          <target state="translated">Metadati della proprietà di dipendenza non variano per ogni istanza. è sempre coerenza per qualsiasi combinazione di proprietà del tipo specificato.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>The following example gets metadata for a dependency property based on a specific <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance.</source>
          <target state="translated">Nell'esempio seguente ottiene i metadati per una proprietà di dipendenza in base a uno specifico <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> istanza.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>A specific object that records the dependency object type from which the dependency property metadata is desired.</source>
          <target state="translated">n oggetto specifico che registra il tipo di oggetto dipendenza dal quale sono desiderati i metadati della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>Returns the metadata for this dependency property as it exists on a specified type.</source>
          <target state="translated">Restituisce i metadati per questa proprietà di dipendenza nello stato attuale per un tipo specificato.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>A property metadata object.</source>
          <target state="translated">Oggetto metadati della proprietà.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">Specifica il tipo o un riferimento all'oggetto è necessaria perché i metadati di qualsiasi proprietà di dipendenza possono variare dalla registrazione originale a causa delle <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> chiamate che possono definire i metadati della proprietà su un tipo.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>The following example gets metadata for a dependency property based on its <ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>.</source>
          <target state="translated">Nell'esempio seguente ottiene i metadati per una proprietà di dipendenza in base alle relative <ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Gets an internally generated value that uniquely identifies the dependency property.</source>
          <target state="translated">Ottiene un valore generato internamente che identifica in modo univoco la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>A unique numeric identifier.</source>
          <target state="translated">Identificatore numerico univoco.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>This value is an integer, not a globally unique identifier (GUID).</source>
          <target state="translated">Questo valore è un numero intero, non un identificatore univoco globale (GUID).</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Generally, using this index value is not required, and there is no index access to tables of all dependency properties.</source>
          <target state="translated">In genere, non è necessario usare questo valore di indice e non è possibile accedere a indice alle tabelle di tutte le proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Dependency properties should instead be referenced by their identifier fields.</source>
          <target state="translated">Le proprietà di dipendenza devono invece fare riferimento a campi dell'identificatore.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> is used internally for faster access to data structures that use the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> as a zero-based array index.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> viene utilizzata internamente per un accesso più rapido alle strutture di dati che utilizzano il <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> come un indice di matrice in base zero.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>A similar usage might have applications for designers or tools.</source>
          <target state="translated">Un utilizzo simile potrebbe avere applicazioni per gli strumenti o finestre di progettazione.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>The value to check.</source>
          <target state="translated">Valore da controllare.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</source>
          <target state="translated">Determina se un valore specificato è accettabile per questo tipo di proprietà di dipendenza, come controllato per il tipo di proprietà fornito nella registrazione originale della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified value is the registered property type or an acceptable derived type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il valore specificato è il tipo di proprietà registrato o un tipo derivato accettabile; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>A value of <ph id="ph1">`null`</ph> is a valid type for reference type dependency properties, or for a <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> dependency property, and would return <ph id="ph3">`true`</ph> for these cases.</source>
          <target state="translated">Il valore <ph id="ph1">`null`</ph> è un tipo valido per le proprietà di dipendenza di tipo riferimento o per un <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> proprietà di dipendenza, restituisce <ph id="ph3">`true`</ph> in questi casi.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>In cases where the dependency property is neither a reference nor a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> will return <ph id="ph3">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">Nei casi in cui la proprietà di dipendenza è né un riferimento né un <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> tipo <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> restituirà <ph id="ph3">`false`</ph> per un valore null anziché generare un'eccezione.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> as a check before calling <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> on the dependency property.</source>
          <target state="translated">L'esempio seguente usa <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> come controllo prima di chiamare <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> nella proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>The value to check.</source>
          <target state="translated">Valore da controllare.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</source>
          <target state="translated">Determina se il valore fornito è accettato per il tipo di proprietà tramite il controllo del tipo di base e anche, potenzialmente, se è all'interno dell'intervallo consentito dei valori per quel tipo.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value is acceptable and is of the correct type or a derived type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il valore è accettabile ed è del tipo corretto o di un tipo derivato; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>For a dependency property, an allowed range of values for that type can be specified through a <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> that is provided in the dependency property registration.</source>
          <target state="translated">Per una proprietà di dipendenza, un intervallo consentito di valori per tale tipo può essere specificato tramite un <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> fornito nella registrazione della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>This method calls <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> internally.</source>
          <target state="translated">Questo metodo chiama <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> internamente.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>If the dependency property in question has no <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>,then calling this method is effectively equivalent to calling <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph>.</source>
          <target state="translated">Se la proprietà di dipendenza in questione non ha alcun <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, quindi chiamare questo metodo è equivale alla chiamata al metodo <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>If the dependency property does have a <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, and if <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> would have returned <ph id="ph3">`true`</ph>, then the value returned will be as implemented in the callback.</source>
          <target state="translated">Se la proprietà di dipendenza sono un <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>e se <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> avrebbe restituito <ph id="ph3">`true`</ph>, il valore restituito sarà come implementato nel callback.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>A null value is a valid value for reference type dependency properties, or for a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> dependency property, and would return <ph id="ph2">`true`</ph> for these cases.</source>
          <target state="translated">Un valore null è un valore valido per le proprietà di dipendenza di tipo riferimento o per un <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> proprietà di dipendenza, restituisce <ph id="ph2">`true`</ph> in questi casi.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>In cases where the dependency property is neither a reference nor a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> will return <ph id="ph3">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">Nei casi in cui la proprietà di dipendenza è né un riferimento né un <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> tipo <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> restituirà <ph id="ph3">`false`</ph> per un valore null anziché generare un'eccezione.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidValue%2A&gt;</ph> as a check before calling <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> on the dependency property.</source>
          <target state="translated">L'esempio seguente usa <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidValue%2A&gt;</ph> come controllo prima di chiamare <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> nella proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.Name">
          <source>Gets the name of the dependency property.</source>
          <target state="translated">Ottiene il nome della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The name of the property.</source>
          <target state="translated">Nome della proprietà.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>This property gets the name provided as the <ph id="ph1">`name`</ph> parameter during dependency property registration.</source>
          <target state="translated">Questa proprietà ottiene il nome fornito come il <ph id="ph1">`name`</ph> parametro durante la registrazione di proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>This name is immutable, and cannot be <ph id="ph1">`null`</ph> or an empty string.</source>
          <target state="translated">Questo nome è modificabile e non può essere <ph id="ph1">`null`</ph> o una stringa vuota.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>Duplicate name registrations on the same owner type are not permitted, and will throw an exception when you attempt to register the duplicate.</source>
          <target state="translated">Nome duplicato registrazioni sullo stesso tipo di proprietario non sono consentite e verranno generata un'eccezione quando si tenta di registrare il duplicato.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> of a dependency property must follow the convention of matching the name of its dependency property identifier minus the suffix "Property".</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> una dipendenza della proprietà deve seguire la convenzione di corrispondere al nome dell'identificatore meno il suffisso "Proprietà" proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
          <target state="translated">Per informazioni dettagliate, vedere <bpt id="p1">[</bpt>Proprietà di dipendenza personalizzate<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The following example queries various characteristics of a dependency property identifier, including the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>.</source>
          <target state="translated">Nell'esempio seguente viene eseguita una query varie caratteristiche di un identificatore della proprietà di dipendenza, incluso il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</source>
          <target state="translated">Specifica i metadati alternativi per questa proprietà di dipendenza quando è presente nelle istanze di un tipo specificato, rispetto ai metadati specificati nella registrazione della proprietà di dipendenza originale.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">Tipo in cui questa proprietà di dipendenza viene ereditata e in cui verranno applicati i metadati alternativi.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">Metadati da applicare alla proprietà di dipendenza nel tipo che esegue l'override.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</source>
          <target state="translated">Specifica i metadati alternativi per questa proprietà di dipendenza quando è presente nelle istanze di un tipo specificato, eseguendo l'override dei metadati esistenti per la proprietà di dipendenza quando è stata ereditata dai tipi di base.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">Prima che il sistema di proprietà viene utilizzata la proprietà di dipendenza, è necessario eseguire l'override dei metadati di proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>This equates to the time that specific instances are created using the class that registers the dependency property.</source>
          <target state="translated">Ciò corrisponde a quella che vengono create istanze specifiche utilizzando la classe che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">Le chiamate a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> deve essere eseguita solo all'interno dei costruttori statici del tipo che fornisce se stesso come il <ph id="ph2">`forType`</ph> parametro di questo metodo, o tramite la creazione di istanze simili.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">Il tentativo di modificare i metadati dopo esistono istanze del tipo di proprietario non genererà eccezioni, ma comporterà comportamenti incoerenti nel sistema di proprietà.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">Dopo aver stabilito i metadati per una determinata classe derivata di sostituzione con questo metodo, i successivi tentativi di eseguire l'override dei metadati su questa stessa classe derivata verranno generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">I metadati forniti viene unito con i metadati della proprietà per la proprietà di dipendenza nello stato attuale per il proprietario di base.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Tutte le caratteristiche che sono state specificate nei metadati di base originali verranno mantenuti; solo le caratteristiche che sono state modificate in particolare nei nuovi metadati sostituiranno le caratteristiche dei metadati di base.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Some characteristics such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> are replaced if specified in the new metadata.</source>
          <target state="translated">Alcune caratteristiche, ad esempio <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> vengono sostituite se è specificato nei nuovi metadati.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Altri, ad esempio <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, vengono combinate.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">Infine, il comportamento di tipo merge dipende il tipo di metadati di proprietà utilizzato per la sostituzione, pertanto il comportamento descritto di seguito è per le classi di metadati di proprietà esistenti utilizzate da <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> le proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Per informazioni dettagliate, vedere <bpt id="p1">[</bpt>metadati della proprietà di dipendenza<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> e <bpt id="p2">[</bpt>i metadati della proprietà Framework<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</source>
          <target state="translated">Si è tentato di eseguire l'override dei metadati in una proprietà di dipendenza di sola lettura. Tale operazione non può essere eseguita usando questa firma.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata was already established for the dependency property as it exists on the provided type.</source>
          <target state="translated">I metadati sono già stati stabiliti per la proprietà di dipendenza nello stato attuale per il tipo specificato.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">Tipo in cui questa proprietà di dipendenza viene ereditata e in cui verranno applicati i metadati alternativi.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">Metadati da applicare alla proprietà di dipendenza nel tipo che esegue l'override.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The access key for a read-only dependency property.</source>
          <target state="translated">Chiave di accesso per una proprietà di dipendenza di sola lettura.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration.</source>
          <target state="translated">Specifica i metadati alternativi per una proprietà di dipendenza di sola lettura quando è presente nelle istanze di un tipo specificato, in sostituzione dei metadati specificati nella registrazione della proprietà di dipendenza iniziale.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>You must pass the <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> for the read-only dependency property to avoid raising an exception.</source>
          <target state="translated">È necessario passare <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> affinché la proprietà di dipendenza di sola lettura eviti di generare un'eccezione.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>This signature provides underlying implementation for a read-only dependency property identifier (<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>) method.</source>
          <target state="translated">Questa firma fornisce l'implementazione sottostante per un identificatore della proprietà di dipendenza di sola lettura (<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>) metodo.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>If overriding metadata for a read-write dependency property, use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</source>
          <target state="translated">Se si esegue l'override dei metadati per una proprietà di dipendenza di lettura / scrittura, utilizzare <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">Prima che il sistema di proprietà viene utilizzata la proprietà di dipendenza, è necessario eseguire l'override dei metadati di proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>This equates to the time that specific objects are created for the class that registers the dependency property.</source>
          <target state="translated">Ciò corrisponde a quella che vengono creati oggetti specifici per la classe che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">Le chiamate a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> deve essere eseguita solo all'interno dei costruttori statici del tipo che fornisce se stesso come il <ph id="ph2">`forType`</ph> parametro di questo metodo, o tramite la creazione di istanze simili.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">Il tentativo di modificare i metadati dopo esistono istanze del tipo di proprietario non genererà eccezioni, ma comporterà comportamenti incoerenti nel sistema di proprietà.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">Dopo aver stabilito i metadati per una determinata classe derivata di sostituzione con questo metodo, i successivi tentativi di eseguire l'override dei metadati su questa stessa classe derivata verranno generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">I metadati forniti viene unito con i metadati della proprietà per la proprietà di dipendenza nello stato attuale per il proprietario di base.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Tutte le caratteristiche che sono state specificate nei metadati di base originali verranno mantenuti; solo le caratteristiche che sono state modificate in particolare nei nuovi metadati sostituiranno le caratteristiche dei metadati di base.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Some characteristics such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> are replaced if specified in the new metadata.</source>
          <target state="translated">Alcune caratteristiche, ad esempio <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> vengono sostituite se è specificato nei nuovi metadati.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Altri, ad esempio <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, vengono combinate.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The merge behavior depends on the property metadata type being used for the override.</source>
          <target state="translated">Il comportamento di tipo merge dipende dal tipo di metadati di proprietà utilizzato per l'override.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Per informazioni dettagliate, vedere <bpt id="p1">[</bpt>metadati della proprietà di dipendenza<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> e <bpt id="p2">[</bpt>i metadati della proprietà Framework<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</source>
          <target state="translated">Ottiene il tipo dell'oggetto che ha registrato la proprietà di dipendenza nel sistema di proprietà o che si è aggiunto come proprietario della proprietà.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The type of the object that registered the property or added itself as owner of the property.</source>
          <target state="translated">Tipo dell'oggetto che ha registrato la proprietà o che si è aggiunto come proprietario della proprietà.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>This value was provided during property registration.</source>
          <target state="translated">Questo valore è stato fornito durante la registrazione di proprietà.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The owner will be either the original registering type in the case of a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier generated from a <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call, or the type that added itself as owner in the case of a <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier generated from an <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call.</source>
          <target state="translated">Il proprietario sarà il tipo della registrazione originale in caso di un <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificatore generato da un <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> chiamata o il tipo che è stato aggiunto come proprietario nel caso di un <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificatore generato da un <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> chiamare.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OwnerType%2A&gt;</ph> on any given <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> is immutable, and cannot be <ph id="ph3">`null`</ph> in a valid <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OwnerType%2A&gt;</ph> in un dato <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> non è modificabile e non può essere <ph id="ph3">`null`</ph> in un oggetto valido <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The following example gets the owner type based on a dependency property identifier <ph id="ph1">`dp`</ph>, and then gets metadata on the owner type for that same identifier.</source>
          <target state="translated">Nell'esempio seguente ottiene il tipo di proprietario in base a un identificatore della proprietà di dipendenza <ph id="ph1">`dp`</ph>e quindi ottiene metadati sul tipo di proprietario per l'identificatore stesso.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>This operation is actually equivalent to getting <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph> on <ph id="ph2">`dp`</ph>.</source>
          <target state="translated">Questa operazione è davvero equivalente a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph> su <ph id="ph2">`dp`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>Gets the type that the dependency property uses for its value.</source>
          <target state="translated">Ottiene il tipo che la proprietà di dipendenza utilizza per il valore.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the property value.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> del valore della proprietà.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>This property reports the type of the property's value as declared by the original property registration, through the <ph id="ph1">`propertyType`</ph> parameter.</source>
          <target state="translated">Questa proprietà indica il tipo del valore della proprietà come dichiarato dalla registrazione originale della proprietà, tramite il <ph id="ph1">`propertyType`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>Similar to the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>, the property type of a dependency property is immutable after registration.</source>
          <target state="translated">Simile al <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>, il tipo di proprietà di una proprietà di dipendenza non è modificabile dopo la registrazione.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The following example queries various characteristics of a dependency property identifier, including the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph>.</source>
          <target state="translated">Nell'esempio seguente viene eseguita una query varie caratteristiche di un identificatore della proprietà di dipendenza, incluso il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The type name string of the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph> is obtained from the returned <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">La stringa del nome del tipo di <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph> viene ottenuto da restituito <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Gets a value that indicates whether the dependency property identified by this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> instance is a read-only dependency property.</source>
          <target state="translated">Ottiene un valore che indica se la proprietà di dipendenza identificata da questa istanza <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> è una proprietà di dipendenza di sola lettura.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property is read-only; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se la proprietà di dipendenza è di sola lettura, in caso contrario <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Read-only dependency properties are registered within the property system by calling the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> method as opposed to the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method.</source>
          <target state="translated">Le proprietà di dipendenza di sola lettura vengono registrate all'interno del sistema di proprietà chiamando il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> metodo anziché il <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Attached properties can also be registered as read-only; see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</source>
          <target state="translated">Le proprietà associate possono essere registrate come di sola lettura. vedere <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Read-only dependency properties require a <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identifier rather than a <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier to perform metadata operations such as overriding the metadata or setting the value.</source>
          <target state="translated">Le proprietà di dipendenza di sola lettura richiedono un <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identificatore anziché un <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificatore per eseguire operazioni sui metadati, ad esempio si esegue l'override dei metadati o l'impostazione del valore.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>If you obtained a collection of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifiers through a call to <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> or another <ph id="ph3">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> that exposes identifiers, check the <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> value before attempting to call <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> or <ph id="ph6">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> using that dependency property identifier as an input parameter, to verify that the dependency property that the identifier represents is not read-only.</source>
          <target state="translated">Se si ottiene un insieme di <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificatori tramite una chiamata a <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> o un altro <ph id="ph3">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> che espone gli identificatori, controllare il <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> valore prima di chiamare <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> o <ph id="ph6">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> specificando lo stesso Identificatore della proprietà di dipendenza come parametro di input, per verificare che la proprietà di dipendenza che rappresenta l'identificatore non è di sola lettura.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>If the value of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> is <ph id="ph2">`true`</ph> on a dependency property, there is no programmatic way to obtain a reference to the <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identifier of that dependency property, from the metadata or from the <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier; the identifier must be available as a static field in order to call <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph> against a read-only dependency property.</source>
          <target state="translated">Se il valore di <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> è <ph id="ph2">`true`</ph> su una proprietà di dipendenza, non è a livello di codice per ottenere un riferimento al <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identificatore della proprietà di dipendenza, dai metadati o dal <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identificatore; l'identificatore deve essere disponibile come un campo statico per poter chiamare <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph> su una proprietà di dipendenza di sola lettura.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>When you create a custom dependency property, and register it as read-only, you should define only a get accessor for the <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> wrapper property.</source>
          <target state="translated">Quando si crea una proprietà di dipendenza personalizzata e registrarlo come di sola lettura, è consigliabile definire solo una funzione di accesso get per il <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> proprietà wrapper.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Otherwise, your class will have a confusing object model for the property wrapper as compared to the access to the backing dependency property.</source>
          <target state="translated">In caso contrario, la classe avrà un modello a oggetti poco chiaro per il wrapper della proprietà se confrontato all'accesso alla proprietà di dipendenza di backup.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> or <bpt id="p2">[</bpt>Read-Only Dependency Properties<ept id="p2">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.</source>
          <target state="translated">Per informazioni dettagliate, vedere <bpt id="p1">[</bpt>delle proprietà di dipendenza personalizzata<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> o <bpt id="p2">[</bpt>le proprietà di dipendenza di sola lettura<ept id="p2">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">Nell'esempio seguente ottiene i metadati predefiniti e le proprietà identificatore di proprietà di dipendenza da vari campi di proprietà di dipendenza e utilizza le informazioni per popolare una tabella per implementare un browser"metadati".</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a dependency property.</source>
          <target state="translated">Registra una proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nome della proprietà di dipendenza da registrare.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The name must be unique within the registration namespace of the owner type.</source>
          <target state="translated">Il nome deve essere univoco all'interno dello spazio dei nomi di registrazione del tipo di proprietario.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The type of the property.</source>
          <target state="translated">Tipo della proprietà.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Tipo di proprietario che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>Registers a dependency property with the specified property name, property type, and owner type.</source>
          <target state="translated">Registra una proprietà di dipendenza con il nome di proprietà, il tipo di proprietà e il tipo di proprietario specificati.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> nella classe.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nome della proprietà di dipendenza da registrare.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Tipo della proprietà.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Tipo di proprietario che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadati della proprietà per la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a dependency property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">Registra una proprietà di dipendenza con il nome, il tipo e i metadati della proprietà e il tipo di proprietario specificati.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> nella classe.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nome della proprietà di dipendenza da registrare.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Tipo della proprietà.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Tipo di proprietario che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadati della proprietà per la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Riferimento a un callback che deve eseguire qualsiasi convalida personalizzata del valore della proprietà di dipendenza oltre la normale convalida del tipo.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</source>
          <target state="translated">Registra una proprietà di dipendenza con il nome di proprietà, il tipo di proprietà, il tipo di proprietario, i metadati della proprietà e un callback di convalida del valore della proprietà specificati.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> nella classe.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>).</source>
          <target state="translated">Nell'esempio seguente viene registrata una proprietà di dipendenza, incluso un callback di convalida (la definizione di callback non viene mostrata; per ulteriori informazioni sulla definizione del callback, vedere <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers an attached property with the property system.</source>
          <target state="translated">Registra una proprietà associata al sistema di proprietà.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nome della proprietà di dipendenza da registrare.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The type of the property.</source>
          <target state="translated">Tipo della proprietà.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Tipo di proprietario che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>Registers an attached property with the specified property name, property type, and owner type.</source>
          <target state="translated">Registra una proprietà associata con il nome di proprietà, il tipo di proprietà e il tipo di proprietario specificati.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> nella classe.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Una proprietà associata è un concetto di proprietà definito da <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implementa le proprietà associate come proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Poiché il <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> le proprietà associate sono le proprietà di dipendenza, possono avere metadati applicati che possono essere utilizzato dal sistema di proprietà generale per operazioni quali la segnalazione delle caratteristiche di layout.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Cenni preliminari sulle proprietà associate<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The following example registers an attached property on an abstract class using this <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</source>
          <target state="translated">Nell'esempio seguente registra una proprietà associata in una classe astratta utilizzando questa <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> firma.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nome della proprietà di dipendenza da registrare.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Tipo della proprietà.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Tipo di proprietario che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadati della proprietà per la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">Può essere incluso il valore predefinito così come altre caratteristiche.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers an attached property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">Registra una proprietà associata al nome, al tipo e ai metadati della proprietà e al tipo di proprietario specificati.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> nella classe.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Una proprietà associata è un concetto di proprietà definito da <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implementa le proprietà associate come proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Poiché il <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> le proprietà associate sono le proprietà di dipendenza, possono avere metadati applicati che possono essere utilizzato dal sistema di proprietà generale per operazioni quali la segnalazione delle caratteristiche di layout.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Cenni preliminari sulle proprietà associate<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Utilizzare RegisterAttached per eredità valore delle proprietà di dipendenza</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>One particular scenario for registering a dependency property with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Uno scenario specifico per la registrazione di una proprietà di dipendenza con <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> anziché <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> per supportare l'ereditarietà del valore di proprietà.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">È consigliabile registrare il valore che eredita le proprietà di dipendenza con <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si intende esporre Get * e * Set di metodi statici per fornire true collegato funzioni di supporto di proprietà.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Anche se potrebbe sembrare che ereditarietà del valore di proprietà funziona per le proprietà di dipendenza non associata, non è definito il comportamento di ereditarietà per una proprietà non associata tramite certi limiti di elementi nell'albero della fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Registra la proprietà come collegato in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che l'ereditarietà del valore di proprietà funziona attraverso tutti i limiti di una struttura ad albero.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Utilizzare sempre <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> per registrare le proprietà in cui si specifica <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> nei metadati.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Ereditarietà del valore della proprietà<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nome della proprietà di dipendenza da registrare.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Tipo della proprietà.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Tipo di proprietario che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadati della proprietà per la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">Può essere incluso il valore predefinito così come altre caratteristiche.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Riferimento a un callback che deve eseguire qualsiasi convalida personalizzata del valore della proprietà di dipendenza oltre la normale convalida del tipo.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</source>
          <target state="translated">Registra una proprietà associata con il tipo della proprietà, il tipo del proprietario, i metadati della proprietà e un callback di convalida del valore per la proprietà specificati.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Identificatore della proprietà di dipendenza che deve essere utilizzato per impostare il valore di un campo <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> nella classe.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Tale identificatore viene quindi usato per fare riferimento in un secondo momento alla proprietà di dipendenza, per operazioni come l'impostazione del valore a livello di codice o per ottenere i metadati.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Una proprietà associata è un concetto di proprietà definito da <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implementa le proprietà associate come proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Poiché il <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> le proprietà associate sono le proprietà di dipendenza, possono avere metadati applicati che possono essere utilizzato dal sistema di proprietà generale per operazioni quali la segnalazione delle caratteristiche di layout.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Cenni preliminari sulle proprietà associate<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Utilizzare RegisterAttached per eredità valore delle proprietà di dipendenza</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>One particular scenario for registering a dependency property with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Uno scenario specifico per la registrazione di una proprietà di dipendenza con <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> anziché <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> per supportare l'ereditarietà del valore di proprietà.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">È consigliabile registrare il valore che eredita le proprietà di dipendenza con <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si intende esporre Get * e * Set di metodi statici per fornire true collegato funzioni di supporto di proprietà.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Anche se potrebbe sembrare che ereditarietà del valore di proprietà funziona per le proprietà di dipendenza non associata, non è definito il comportamento di ereditarietà per una proprietà non associata tramite certi limiti di elementi nell'albero della fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Registra la proprietà come collegato in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che l'ereditarietà del valore di proprietà funziona attraverso tutti i limiti di una struttura ad albero.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Utilizzare sempre <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> per registrare le proprietà in cui si specifica <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> nei metadati.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Ereditarietà del valore della proprietà<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The following example registers an attached property on an abstract class using this <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</source>
          <target state="translated">Nell'esempio seguente registra una proprietà associata in una classe astratta utilizzando questa <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> firma.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.</source>
          <target state="translated">Questa proprietà associata è una proprietà del tipo di enumerazione e la registrazione viene aggiunto un callback di convalida per verificare che il valore specificato è un valore dell'enumerazione.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a read-only attached property.</source>
          <target state="translated">Registra un proprietà associata di sola lettura.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nome della proprietà di dipendenza da registrare.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Tipo della proprietà.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Tipo di proprietario che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadati della proprietà per la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a read-only attached property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">Registra una proprietà associata di sola lettura con il tipo e i metadati della proprietà e il tipo di proprietario specificati.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">Chiave della proprietà di dipendenza che deve essere usata per impostare il valore di un campo statico di sola lettura nella classe, che viene quindi usata per fare riferimento alla proprietà di dipendenza in un secondo momento.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Questo metodo restituisce il tipo <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, mentre <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> restituisce il tipo <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore della proprietà di dipendenza chiamando <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> solo alle parti del codice necessarie impostare la proprietà di dipendenza come parte della logica di classe o un'applicazione.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">È inoltre consigliabile esporre un identificatore della proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> come un <ph id="ph2">`public static readonly`</ph> campo nella classe.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Le proprietà associate di sola lettura sono rare, poiché lo scenario principale per una proprietà associata è l'utilizzo in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Without a public setter, an attached property cannot be set in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">Senza un setter pubblico, è possibile impostare una proprietà associata <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> sintassi.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Utilizzare RegisterAttached per eredità valore delle proprietà di dipendenza</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>One particular scenario for registering a dependency property as attached is to support property value inheritance.</source>
          <target state="translated">Uno scenario specifico per la registrazione di una proprietà di dipendenza associata è per supportare l'ereditarietà del valore di proprietà.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">È consigliabile registrare il valore che eredita le proprietà di dipendenza con <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si intende esporre Get * e * Set di metodi statici per fornire true collegato funzioni di supporto di proprietà.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Anche se potrebbe sembrare che ereditarietà del valore di proprietà funziona per le proprietà di dipendenza non associata, non è definito il comportamento di ereditarietà per una proprietà non associata tramite certi limiti di elementi nell'albero della fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Registra la proprietà come collegato in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che l'ereditarietà del valore di proprietà funziona attraverso tutti i limiti di una struttura ad albero.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Utilizzare sempre <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> per registrare le proprietà in cui si specifica <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> nei metadati.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Ereditarietà del valore della proprietà<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nome della proprietà di dipendenza da registrare.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Tipo della proprietà.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Tipo di proprietario che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadati della proprietà per la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Riferimento a un callback creato dall'utente che deve eseguire qualsiasi convalida personalizzata del valore della proprietà di dipendenza oltre la normale convalida del tipo.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">Registra una proprietà associata di sola lettura, con il tipo della proprietà, il tipo del proprietario, i metadati della proprietà e un callback di convalida specificati.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">Chiave della proprietà di dipendenza che deve essere usata per impostare il valore di un campo statico di sola lettura nella classe, che viene quindi usata per fare riferimento alla proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Questo metodo restituisce il tipo <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, mentre <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> restituisce il tipo <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent the type <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">In genere, le chiavi che rappresentano il tipo <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore della proprietà di dipendenza chiamando <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> solo alle parti del codice necessarie impostare la proprietà di dipendenza come parte della logica di classe o un'applicazione.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">È inoltre consigliabile esporre un identificatore della proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> come un <ph id="ph2">`public static readonly`</ph> campo nella classe.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Le proprietà associate di sola lettura sono rare, poiché lo scenario principale per una proprietà associata è l'utilizzo in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Without a public setter, an attached property cannot be set in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">Senza un setter pubblico, è possibile impostare una proprietà associata <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> sintassi.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Utilizzare RegisterAttached per eredità valore delle proprietà di dipendenza</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>One particular scenario for registering a dependency property as attached instead of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Uno scenario specifico per la registrazione di una proprietà di dipendenza come collegato anziché <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> per supportare l'ereditarietà del valore di proprietà.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">È consigliabile registrare il valore che eredita le proprietà di dipendenza con <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> anche se la classe definisce funzioni wrapper di proprietà che espongono la proprietà di dipendenza e anche se non si intende esporre Get * e * Set di metodi statici per fornire true collegato funzioni di supporto di proprietà.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Anche se potrebbe sembrare che ereditarietà del valore di proprietà funziona per le proprietà di dipendenza non associata, non è definito il comportamento di ereditarietà per una proprietà non associata tramite certi limiti di elementi nell'albero della fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Registra la proprietà come collegato in modo efficace rende la proprietà associata una proprietà globale per il sistema di proprietà e assicura che l'ereditarietà del valore di proprietà funziona attraverso tutti i limiti di una struttura ad albero.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Utilizzare sempre <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> per registrare le proprietà in cui si specifica <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> nei metadati.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Ereditarietà del valore della proprietà<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a dependency property as a read-only dependency property.</source>
          <target state="translated">Registra una proprietà di dipendenza come proprietà di dipendenza di sola lettura.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nome della proprietà di dipendenza da registrare.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Tipo della proprietà.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Tipo di proprietario che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadati della proprietà per la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">Registra una proprietà di dipendenza di sola lettura con il tipo e i metadati della proprietà e il tipo di proprietario specificati.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">Chiave della proprietà di dipendenza che deve essere usata per impostare il valore di un campo statico di sola lettura nella classe, che viene quindi usata per fare riferimento alla proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Questo metodo restituisce il tipo <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, mentre <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> restituisce il tipo <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore della proprietà di dipendenza chiamando <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> solo alle parti del codice necessarie impostare la proprietà di dipendenza come parte della logica di classe o un'applicazione.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">È inoltre consigliabile esporre un identificatore della proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> come un <ph id="ph2">`public static readonly`</ph> campo nella classe.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Read-only dependency properties are a fairly typical scenario both in the existing <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> and for customization scenarios, because other <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> features might require a dependency property even if that property is not intended to be settable by callers.</source>
          <target state="translated">Le proprietà di dipendenza di sola lettura sono un tipico scenario entrambi esistente <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> e per gli scenari di personalizzazione, perché altri <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> funzionalità potrebbero richiedere una proprietà di dipendenza, anche se tale proprietà non deve essere impostata da chiamanti.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> on the dependency property in a style.</source>
          <target state="translated">È possibile utilizzare il valore di una proprietà di dipendenza di sola lettura come base per altre operazioni di sistema di proprietà che accettano una proprietà di dipendenza, ad esempio basando una <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> nella proprietà di dipendenza in uno stile.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The following example registers an <ph id="ph1">`AquariumSize`</ph> dependency property as read-only.</source>
          <target state="translated">Nell'esempio seguente viene registrato un <ph id="ph1">`AquariumSize`</ph> proprietà di dipendenza di sola lettura.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The example defines <ph id="ph1">`AquariumSizeKey`</ph> as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as <ph id="ph2">`AquariumSizeProperty`</ph>.</source>
          <target state="translated">L'esempio definisce <ph id="ph1">`AquariumSizeKey`</ph> come chiave interna (in modo che le altre classi nell'assembly può eseguire l'override dei metadati) ed espone l'identificatore della proprietà di dipendenza in base a tale chiave come <ph id="ph2">`AquariumSizeProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Also, a wrapper is created for <ph id="ph1">`AquariumSize`</ph>, with only a get accessor.</source>
          <target state="translated">Inoltre, in cui viene creato un wrapper per <ph id="ph1">`AquariumSize`</ph>, con sola funzione di accesso get.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Nome della proprietà di dipendenza da registrare.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Tipo della proprietà.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Tipo di proprietario che registra la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Metadati della proprietà per la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Riferimento a un callback creato dall'utente che deve eseguire qualsiasi convalida personalizzata del valore della proprietà di dipendenza oltre la normale convalida del tipo.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">Registra una proprietà di dipendenza di sola lettura, con il tipo di proprietà, il tipo di proprietario, i metadati della proprietà e un callback di convalida specificati.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">Chiave della proprietà di dipendenza che deve essere usata per impostare il valore di un campo statico di sola lettura nella classe, che viene quindi usata per fare riferimento alla proprietà di dipendenza in un secondo momento.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Questo metodo restituisce il tipo <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, mentre <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> restituisce il tipo <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">In genere, le chiavi che rappresentano le proprietà di sola lettura non sono rese pubbliche, perché le chiavi possono essere utilizzate per impostare il valore della proprietà di dipendenza chiamando <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">La progettazione della classe influirà sui requisiti, ma è in genere consigliabile limitare l'accesso e la visibilità di qualsiasi <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> solo alle parti del codice necessarie impostare la proprietà di dipendenza come parte della logica di classe o un'applicazione.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">È inoltre consigliabile esporre un identificatore della proprietà di dipendenza per la proprietà di dipendenza di sola lettura, esponendo il valore di <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> come un <ph id="ph2">`public static readonly`</ph> campo nella classe.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Read-only dependency properties are a fairly typical scenario.</source>
          <target state="translated">Proprietà di dipendenza di sola lettura sono uno scenario tipico.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> on the dependency property in a style.</source>
          <target state="translated">È possibile utilizzare il valore di una proprietà di dipendenza di sola lettura come base per altre operazioni di sistema di proprietà che accettano una proprietà di dipendenza, ad esempio basando una <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> nella proprietà di dipendenza in uno stile.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulla registrazione di proprietà di dipendenza, vedere <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Validation on a read-only dependency property might be less important.</source>
          <target state="translated">La convalida su una proprietà di dipendenza di sola lettura potrebbe essere meno importante.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The nonpublic access level you specify for the key reduces the likelihood for arbitrary invalid input.</source>
          <target state="translated">Il livello di accesso non pubblico specificato per la chiave riduce la probabilità di input non valido non autorizzato.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.ToString">
          <source>Returns the string representation of the dependency property.</source>
          <target state="translated">Restituisce la rappresentazione di stringa della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.ToString">
          <source>The string representation of the dependency property.</source>
          <target state="translated">Rappresentazione di stringa della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.ToString">
          <source>This implementation returns the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> property value.</source>
          <target state="translated">Questa implementazione restituisce il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> valore della proprietà.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Specifies a static value that is used by the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system rather than <ph id="ph2">&lt;see langword="null" /&gt;</ph> to indicate that the property exists, but does not have its value set by the property system.</source>
          <target state="translated">Specifica un valore statico utilizzato dal sistema della proprietà <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> piuttosto che <ph id="ph2">&lt;see langword="null" /&gt;</ph> per indicare che la proprietà esiste, ma non ha il valore impostato dal sistema della proprietà.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is a sentinel value that is used for scenarios where the <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system is unable to determine a requested <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> è un valore di sentinel che viene utilizzato per gli scenari in cui il <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> sistema di proprietà non è in grado di determinare una richiesta <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> valore.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is used rather than <ph id="ph2">`null`</ph>, because <ph id="ph3">`null`</ph> could be a valid property value, as well as a valid (and frequently used) <ph id="ph4">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> viene utilizzato anziché <ph id="ph2">`null`</ph>perché <ph id="ph3">`null`</ph> potrebbe essere un valore di proprietà valido, nonché un valore valido (e utilizzati di frequente) <ph id="ph4">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is never returned out of <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> non viene mai restituito da <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>When you call <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph> on a dependency property on a <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, one of the following applies:</source>
          <target state="translated">Quando si chiama <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph> su una proprietà di dipendenza su un <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> istanza, si applica una delle operazioni seguenti condizioni:</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>A dependency property has a default value established in metadata and that value is returned.</source>
          <target state="translated">Una proprietà di dipendenza è un valore predefinito stabilito nei metadati e viene restituito tale valore.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>This value might come from <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Questo valore potrebbe provenire da <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Some other value was established by the property system, and the default value is no longer relevant.</source>
          <target state="translated">Un altro valore definito dal sistema di proprietà e il valore predefinito è più pertinente.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">Per altri dettagli, vedere <bpt id="p1">[</bpt>Precedenza del valore della proprietà di dipendenza<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Setting a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is specifically disallowed.</source>
          <target state="translated">Impostazione di un <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> di <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> specificamente è consentita.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> when the requested property has not been locally set.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType&gt;</ph> Restituisce <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> quando la proprietà richiesta è non stata impostata localmente.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has a special meaning when used as the return value of a <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> ha un significato speciale quando viene utilizzato come valore restituito di un <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Per informazioni dettagliate, vedere <bpt id="p1">[</bpt>convalida e i callback di proprietà di dipendenza<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>If you are binding to a database, note that <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is not equivalent to <ph id="ph2">&lt;xref:System.DBNull.Value&gt;</ph>, in a similar way to how <ph id="ph3">&lt;xref:System.DBNull.Value&gt;</ph> is not equivalent to a true null.</source>
          <target state="translated">Se si desidera associare a un database, si noti che <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> non equivale a <ph id="ph2">&lt;xref:System.DBNull.Value&gt;</ph>, in modo analogo a come <ph id="ph3">&lt;xref:System.DBNull.Value&gt;</ph> non equivale a un vero null.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>Gets the value validation callback for the dependency property.</source>
          <target state="translated">Ottiene il callback di convalida del valore per la proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The value validation callback for this dependency property, as provided for the <ph id="ph1">&lt;paramref name="validateValueCallback" /&gt;</ph> parameter in the original dependency property registration.</source>
          <target state="translated">Callback di convalida del valore per questa proprietà di dipendenza, come fornito per il parametro <ph id="ph1">&lt;paramref name="validateValueCallback" /&gt;</ph> nella registrazione della proprietà di dipendenza originale.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>This property will contain <ph id="ph1">`null`</ph> for any dependency property with no registered validation callback.</source>
          <target state="translated">Questa proprietà conterrà <ph id="ph1">`null`</ph> per qualsiasi proprietà di dipendenza senza callback di convalida registrato.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>Validate value callbacks must act in a static sense: validation applied through the <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> cannot determine whether the provided value is valid for any particular instance.</source>
          <target state="translated">Convalidare il valore di callback devono agire in senso statico: la convalida applicata tramite la <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> non è possibile determinare se il valore specificato è valido per una particolare istanza.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The callback can only determine whether all objects that possess the dependency property should or should not accept the provided value as valid.</source>
          <target state="translated">Il callback può determinare solo se tutti gli oggetti che dispongono di proprietà di dipendenza devono o non devono accettare il valore fornito come valido.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>If you need to perform validation that relies on knowing the values of other dependency properties on a particular instance, use a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> instead.</source>
          <target state="translated">Se è necessario eseguire la convalida che si basa sulla conoscenza dei valori di altre proprietà di dipendenza in un'istanza specifica, utilizzare un <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> invece.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> is registered as part of dependency property metadata, rather than directly within the dependency property identifier.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> viene registrata come parte dei metadati di proprietà di dipendenza, anziché direttamente all'interno di identificatore della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Per informazioni dettagliate, vedere <bpt id="p1">[</bpt>convalida e i callback di proprietà di dipendenza<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>