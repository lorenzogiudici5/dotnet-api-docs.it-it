<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8241e2ff47b51e906cfa1cf3ca25aac03e6ca974" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37489330" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce una classe base per la gestione degli eventi usata nel *modello di eventi deboli*. Il gestore aggiunge e rimuove listener per eventi (o callback) che utilizzano il modello.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È in genere possibile usare il modello di eventi deboli quando l'origine evento abbia una durata degli oggetti che è indipendente dal listener di eventi. Tramite l'evento centrale dell'invio di funzionalità di un <xref:System.Windows.WeakEventManager> consente ai gestori del listener venga sottoposto a garbage collection anche se l'oggetto di origine viene mantenuto. Al contrario, un'associazione dell'evento normale utilizzando il `+=` operatore fa sì che l'origine eventualmente disconnessa che contiene un riferimento di listener di traccia. Ciò impedisce che il destinatario di garbage collection in modo tempestivo.  
  
 Una situazione comune in cui è necessario utilizzare le relazioni di durata tra le origini e i listener dello schema di eventi debole è la gestione degli eventi di aggiornamento provenienti dal data binding.  
  
 Il modello di eventi deboli è anche utilizzabile per eventi regolari e i callback.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Per un esempio di una classe personalizzata <see cref="T:System.Windows.WeakEventManager" />, vedere [modelli di eventi deboli](~/docs/framework/wpf/advanced/weak-event-patterns.md).</para>
    </block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza i valori della classe di base quando viene utilizzato come inizializzatore dal costruttore di una classe derivata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Oggetto nel quale è gestito l'evento.</param>
        <param name="args">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento da recapitare.</param>
        <summary>Recapita l'evento gestito a ogni listener.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.WeakEventManager.DeliverEvent%2A> metodo all'interno di gestori eventi che vengono aggiunti o rimossi dal <xref:System.Windows.WeakEventManager.StartListening%2A> e <xref:System.Windows.WeakEventManager.StopListening%2A> implementazioni delle sottoclassi.  
  
 Se si chiama il <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> metodo di `AddListener` implementazione della classe, l'elenco di listener che riceve l'evento viene mantenuta in una raccolta sottostante. (`AddListener` non fa parte di un contratto di interfaccia o classe. `AddListener` è il nome suggerito per il metodo della classe del gestore che chiama <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> e aggiunge i listener di eventi deboli modello per l'evento.)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Aggiunge i listener a un unico elenco. Se l'implementazione del gestore gestisce più di un elenco di listener per ogni evento, non utilizzare <xref:System.Windows.WeakEventManager.DeliverEvent%2A> o <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Al contrario, l'implementazione deve creare la propria <xref:System.Windows.WeakEventManager.ListenerList> istanze `AddListener` deve aggiungere i listener all'elenco appropriato, e gli eventi devono essere recapitati all'elenco di listener appropriato chiamando <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">Oggetto nel quale è gestito l'evento.</param>
        <param name="args">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <param name="list">Oggetto <see cref="T:System.Windows.WeakEventManager.ListenerList" /> fornito.</param>
        <summary>Recapita l'evento gestito a ogni listener contenuto nell'elenco fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è necessario se l'implementazione del gestore gestisce gli elenchi di listener separati in base alle informazioni acquisite nei dati dell'evento. Se si usa questa tecnica avanzata, è necessario creare e gestire elenchi separati come parte dell'implementazione della gestione ed è necessario fornire un modo per aggiungere i listener per un elenco specifico. L'implementazione del gestore che ascolta l'evento non elaborato deve agire la condizione che si utilizzano per differenziare gli elenchi e recapitare l'evento solo l'elenco appropriato o agli elenchi.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">Tipo per il quale ottenere <see cref="T:System.Windows.WeakEventManager" />.</param>
        <summary>Restituisce l'implementazione di <see cref="T:System.Windows.WeakEventManager" /> utilizzata per il tipo fornito.</summary>
        <returns>Implementazione di <see cref="T:System.Windows.WeakEventManager" /> corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> le implementazioni di chiamano questo metodo con loro passato `managerType`. L'oggetto restituito <xref:System.Windows.WeakEventManager> viene quindi utilizzato come l'elemento di differenziazione che determina quali eventi è stato ricevuto e il gestore di classe privata da richiamare.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Indice in base zero dell'origine richiesta.</param>
        <summary>Ottiene o imposta i dati archiviati per l'origine specificata.</summary>
        <value>Dati archiviati dal gestore per questa origine.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le classi derivate possono scegliere quali dati e il tipo da archiviare in questo indicizzatore. In genere viene implementato come un <xref:System.Windows.WeakEventManager.ListenerList>, ovvero un elenco di riferimenti deboli al listener. Si sarebbe sufficiente modificare il tipo se il <xref:System.Windows.WeakEventManager.ListenerList> tipo non può contenere le informazioni necessarie. Se, pertanto, sarà necessario eseguire l'override di <xref:System.Windows.WeakEventManager.Purge%2A> metodo in modo che tutte le operazioni di pulitura del tipo sottostante viene eseguita correttamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un nuovo oggetto per contenere i listener per un evento.</summary>
        <returns>Nuovo oggetto per contenere i listener a un evento.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Oggetto di origine cui il delegato del gestore esegue la sottoscrizione.</param>
        <param name="handler">Il delegato che gestisce l'evento generato da <c>source</c>.</param>
        <summary>Aggiunge il delegato specificato come gestore eventi dell'origine specificata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Origine alla quale associare il listener.</param>
        <param name="listener">Classe in ascolto (che deve implementare <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Aggiunge il listener fornito all'origine fornita per l'evento gestito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo all'interno della classe di gestione `AddListener` metodi su <xref:System.Windows.WeakEventManager> implementazioni. `AddListener` è il nome suggerito per il metodo statico è definire nella classe del gestore per consentire alle altre classi aggiungere un listener per il modello di eventi deboli. `AddListener` deve accettare due parametri: la `source` in cui è associato il listener e il `listener` istanza. Per i `AddListener` implementazione, chiamare il <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> metodo nel gestore corrente e passare gli stessi due parametri.  
  
 Se è stata precedentemente vuoto, l'elenco di listener <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> chiamate il <xref:System.Windows.WeakEventManager.StartListening%2A> metodo internamente, specifico che verrà chiamato <xref:System.Windows.WeakEventManager.StartListening%2A> eseguire l'override tramite il polimorfismo.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Aggiunge i listener a un singolo interno <xref:System.Windows.WeakEventManager.ListenerList> per ogni `source`. Se l'implementazione del gestore gestisce più di un elenco di listener per ogni combinazione di origini eventi, non utilizzare <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Invece, l'implementazione deve creare la propria <xref:System.Windows.WeakEventManager.ListenerList> istanze `AddListener` deve aggiungere i listener all'elenco appropriato, e gli eventi devono essere recapitati all'elenco di listener appropriato chiamando il <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> evento invece di <xref:System.Windows.WeakEventManager.DeliverEvent%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Origine da cui rimuovere il gestore.</param>
        <param name="handler">Delegato da rimuovere da <c>source</c>.</param>
        <summary>Rimuove il gestore aggiunto in precedenza dall'origine specificata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Origine da cui rimuovere i listener.</param>
        <param name="listener">Classe in ascolto (che deve implementare <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Rimuove un listener precedentemente aggiunto dall'origine fornita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo all'interno della classe di gestione `RemoveListener` metodi su <xref:System.Windows.WeakEventManager> implementazioni. `RemoveListener` è il nome suggerito per il metodo statico è definire nella classe del gestore per consentire alle altre classi rimuovere un listener per il modello di eventi deboli. `RemoveListener` deve accettare due parametri: la `source` in cui il listener viene rimosso e il `listener` classe. Per i `RemoveListener` implementazione, chiamare il <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> metodo nel gestore corrente e passare gli stessi due parametri.  
  
 Se una chiamata a <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> rimuove l'ultimo listener nell'elenco <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> chiamate il <xref:System.Windows.WeakEventManager.StopListening%2A> metodo internamente, specifico che verrà chiamato <xref:System.Windows.WeakEventManager.StopListening%2A> eseguire l'override tramite il polimorfismo.  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Rimuove i listener da un singolo interno <xref:System.Windows.WeakEventManager.ListenerList> per ogni `source`. Se l'implementazione del gestore gestisce più di un elenco di listener per ogni combinazione di origini eventi, non utilizzare <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>. Al contrario, l'implementazione deve creare la propria <xref:System.Windows.WeakEventManager.ListenerList> istanze, `RemoveListener` deve rimuovere i listener dall'elenco appropriato e gli eventi devono essere recapitati all'elenco di listener appropriato chiamando il <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> invece del metodo di <xref:System.Windows.WeakEventManager.DeliverEvent%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Origine per gli eventi attesi.</param>
        <param name="data">Dati da controllare. Si presume che questo oggetto sia un'implementazione di <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</param>
        <param name="purgeAll">
          <see langword="true" /> per interrompere l'ascolto di <c>source</c> e rimuovere completamente tutte le voci da <c>data</c>.</param>
        <summary>Rimuove voci di listener inattivi dall'elenco di dati per l'origine fornita. Restituisce <see langword="true" /> se alcune voci sono state effettivamente rimosse dall'elenco.</summary>
        <returns>
          <see langword="true" /> se alcune voci sono state effettivamente rimosse, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.WeakEventManager.Purge%2A> metodo ha un'implementazione predefinita che rimuoverà tutte le voci quando i dati sono un <xref:System.Windows.WeakEventManager.ListenerList>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se il tipo sottostante per il <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> è diverso da <see cref="T:System.Windows.WeakEventManager.ListenerList" />, o contiene dati oltre a un <see cref="T:System.Windows.WeakEventManager.ListenerList" />, è necessario eseguire l'override di <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> (metodo). La sostituzione deve fornire un comportamento di eliminazione per l'elenco di elementi di tipo alternativo. In generale, la sostituzione deve fornire un comportamento senza chiamare l'implementazione di base. Se uno specifico <see cref="T:System.Windows.WeakEventManager.ListenerList" /> deve comunque la cancellazione, chiamare <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta un blocco di lettura nella tabella di dati sottostanti e restituisce <see cref="T:System.IDisposable" />.</summary>
        <value>Oggetto che può essere utilizzato per impostare un blocco sui membri della tabella di dati ed essere rimosso all'occorrenza, mediante un costrutto <see langword="using" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle classi derivate, esegue una query alla tabella dei contenuti in <xref:System.Windows.WeakEventManager.Item%2A> devono essere sempre eseguiti all'interno di un `using (ReadLock) { ... }` clausola, fatta eccezione per le query che sono già all'interno di un blocco di scrittura. Queste query possono essere necessarie se la classe supporta più sofisticati `AddListener` implementazione che richiede più dati oltre i `source` e il `listener`e utilizza il <xref:System.Windows.WeakEventManager.Item%2A> raccolta per archiviare le informazioni aggiuntive.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Origine per la quale rimuovere le informazioni del listener.</param>
        <summary>Rimuove tutti i listener per l'origine specificata.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Richiede l'esecuzione, in un thread con priorità inferiore, della cancellazione di voci inutilizzate contenute nell'elenco di listener sottostante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiama il <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> è simile alla chiamata al metodo il <xref:System.Windows.WeakEventManager.Purge%2A> metodo nell'elenco del gestore corrente al thread con priorità inferiore, con il `purgeAll` parametro impostato su `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">Tipo su cui impostare la gestione degli eventi.</param>
        <param name="manager">Nuovo gestore degli eventi.</param>
        <summary>Imposta la gestione corrente per il tipo di gestione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> metodo per inizializzare un manager, se è richiesto da una chiamata ai `CurrentManager` proprietà su un <xref:System.Windows.WeakEventManager> implementazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Origine in cui avviare l'attesa.</param>
        <summary>Quando è sottoposto a override in una classe derivata, avvia l'attesa dell'evento gestito. Dopo la prima chiamata al metodo <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />, la gestione deve restare nello stato di chiamata a <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> o a <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> ogni volta che viene gestito l'evento pertinente proveniente dall'origine fornita.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> gli override devono aggiungere un gestore per l'oggetto fornito <paramref name="source" />. Il gestore di è dichiarato dal gestore di se stesso. Il gestore della classe non deve essere pubblico e deve essere chiamato solo in risposta all'evento che si sta gestendo. Deve chiamare il gestore della classe di <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> metodo o il <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> metodo in modo appropriato.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Origine in cui arrestare l'attesa.</param>
        <summary>Quando è sottoposto a override in una classe derivata, interrompe l'attesa dell'evento gestito nell'origine fornita.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> le implementazioni devono rimuovere il gestore della classe di aggiunta dal <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> (metodo). Rimozione di un listener non cancellare l'elenco di listener. Al contrario, ma solo disconnettere il gestore della classe (ad esempio temporaneamente). Sono disponibili altri metodi per cancellare l'elenco completo, ad esempio la <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> metodo con il <paramref name="purgeAll" /> parametro impostato su <see langword="true" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Imposta un blocco di scrittura nella tabella di dati sottostanti e restituisce <see cref="T:System.IDisposable" />.</summary>
        <value>Oggetto che può essere utilizzato per impostare un blocco sui membri della tabella di dati ed essere rimosso all'occorrenza, mediante un costrutto <see langword="using" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle classi derivate, tutte le modifiche apportate alla tabella dati sottostante devono verificarsi all'interno di un `using (WriteLock) { ... }` clausola. Queste modifiche potrebbero essere necessarie se la classe supporta più sofisticati `AddListener` implementazione che richiede più dati oltre i `source` e il `listener`e utilizza il <xref:System.Windows.WeakEventManager.Item%2A> raccolta per archiviare le informazioni aggiuntive.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>