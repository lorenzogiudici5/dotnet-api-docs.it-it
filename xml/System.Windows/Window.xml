<Type Name="Window" FullName="System.Windows.Window">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f805a8dedd189924a31c53379179c725286ba810" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695010" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce la possibilità di creare, configurare, visualizzare e gestire la durata di finestre e finestre di dialogo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il punto di interazione tra un utente e un'applicazione autonoma è una finestra. Oggetto [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] finestra è costituita da due aree distinte:  
  
-   Un'area non client, che ospita le aree di controllo di windows, tra cui un'icona, titolo, il menu di sistema, pulsante Riduci a icona, Ingrandisci pulsante, il pulsante di ripristino, pulsante Chiudi e un bordo.  
  
-   Un'area client, che ospita il contenuto specifico dell'applicazione.  
  
 Una finestra standard è illustrata nella figura riportata di seguito:  
  
 ![Gli elementi della finestra](~/add/media/windowoverviewfigure1.PNG "gli elementi della finestra")  
  
 <xref:System.Windows.Window> incapsula la possibilità di creare, configurare, visualizzare e gestire la durata di finestre e finestre di dialogo e fornisce i seguenti servizi principali:  
  
 **Gestione della durata**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **Gestione delle finestre**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Aspetto e il comportamento**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **Finestre di dialogo**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Inoltre, <xref:System.Windows.Application> espone il supporto speciale per la gestione di tutte le finestre in un'applicazione:  
  
-   Applicazione gestisce un elenco di tutte le finestre che attualmente viene creata un'istanza dell'applicazione. Questo elenco è esposto dal <xref:System.Windows.Application.Windows%2A> proprietà.  
  
-   Per impostazione predefinita, <xref:System.Windows.Application.MainWindow%2A> viene impostato automaticamente con un riferimento al primo <xref:System.Windows.Window> che viene creata un'istanza in un'applicazione. Questa finestra principale dell'applicazione, rendendo la finestra.  
  
 Oggetto <xref:System.Windows.Window> può essere implementata tramite markup, markup e code-behind o codice.  
  
 <xref:System.Windows.Window> viene utilizzato principalmente per visualizzare finestre e finestre di dialogo per le applicazioni autonome. Tuttavia, per le applicazioni che richiedono lo spostamento a livello di finestra, ad esempio le procedure guidate, è possibile utilizzare <xref:System.Windows.Navigation.NavigationWindow> ; <xref:System.Windows.Navigation.NavigationWindow> deriva da <xref:System.Windows.Window> e la estende con supporto di navigazione di tipo browser.  
  
> [!NOTE]
>  Contenuto esplorabile può essere incorporate in altri contenitori, contenuti e il contenuto utilizzando <xref:System.Windows.Controls.Frame>.  
  
 <xref:System.Windows.Window> è necessario `UnmanagedCode` autorizzazione di sicurezza deve essere creata un'istanza. Questo comporta le conseguenze seguenti:  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-le applicazioni autonome distribuite richiedono l'elevazione delle autorizzazioni quando avviata da aree Internet o Intranet locale.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] che non richiedono le autorizzazioni complete non sarà in grado di creare un'istanza di windows o le finestre di dialogo.  
  
 Per informazioni sulla distribuzione delle applicazioni autonome e considerazioni sulla sicurezza, vedere [strategia di sicurezza di WPF - sicurezza della piattaforma](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 Oggetto <xref:System.Windows.Window> è un <xref:System.Windows.Controls.ContentControl>, il che significa che può contenere un singolo oggetto di qualsiasi tipo (ad esempio una stringa, un'immagine o un pannello). Per altre informazioni, vedere la classe <xref:System.Windows.Controls.ContentControl>. Inoltre, <xref:System.Windows.Window> è un elemento radice e, pertanto, non possono far parte del contenuto di un altro elemento.  
  
> [!NOTE]
>  Il <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, e <xref:System.Windows.Window.Left%2A> sono impostate su un <xref:System.Windows.Window> tramite uno stile non verrà applicato in fase di esecuzione.  
  
## <a name="customizing-the-window-control"></a>Personalizzazione del controllo di finestra  
 Per applicare le stesse impostazioni di proprietà a più <xref:System.Windows.Window> controlli, utilizzare il <xref:System.Windows.FrameworkElement.Style%2A> proprietà. È possibile modificare il valore predefinito <xref:System.Windows.Controls.ControlTemplate> per fornire al controllo un aspetto univoco. Per ulteriori informazioni sulla creazione di un <xref:System.Windows.Controls.ControlTemplate>, vedere [personalizzazione dell'aspetto di un controllo esistente tramite la creazione di ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Per visualizzare le parti e stati specifici di <xref:System.Windows.Window>, vedere [finestra Stili e modelli](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Proprietà di dipendenza per questo controllo potrebbe essere impostata dallo stile predefinito del controllo.  Se una proprietà viene impostata da uno stile predefinito, la proprietà può variare rispetto al valore predefinito quando il controllo viene visualizzato nell'applicazione. Lo stile predefinito è determinato dal tema del desktop viene utilizzato quando l'applicazione è in esecuzione.  Per ulteriori informazioni, vedere [temi WPF predefiniti](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  L'impostazione di una proprietà visiva può avere effetto solo se tale proprietà è sia presente nel <xref:System.Windows.Window> controllo del modello predefinito e viene impostata tramite una. È possibile trovare un elenco di proprietà visive nella sezione "Modifica la struttura Visual di un controllo" [personalizzazione dell'aspetto di un controllo esistente tramite la creazione di ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come una finestra standard viene definito utilizzando solo il markup:  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 Nell'esempio seguente viene illustrato come viene definita una finestra standard utilizzando solo codice:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 Nell'esempio seguente viene illustrato come una finestra standard viene definito mediante una combinazione di markup e code-behind.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore inizializza la <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, e <xref:System.Windows.Window.Left%2A> proprietà sui valori predefiniti <xref:System.Windows.Window> valori.  
  
 Se viene creata una finestra all'interno di un <xref:System.AppDomain> che ha un <xref:System.Windows.Application> dell'oggetto, il costruttore aggiunge il <xref:System.Windows.Window> oggetto al set di <xref:System.Windows.Application>-gestiti di windows tramite il <xref:System.Windows.Application.Windows%2A> proprietà del <xref:System.Windows.Application> oggetto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per l'autorizzazione per questo oggetto per chiamare metodi nativi unsafe. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tenta di portare la finestra in primo piano e la attiva.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.Windows.Window" /> è stato attivato correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le regole che determinano se è attivata la finestra sono uguali a quelli utilizzati dal [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` funzione (User32. dll).  
  
 Se la finestra viene attivata in un'applicazione Windows Presentation Foundation che non è l'applicazione dell'utente in primo piano, <xref:System.Windows.Application.Activated> evento viene generato.  
  
> [!NOTE]
>  Questo metodo non può essere chiamato quando una finestra è ospitata in un browser.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per l'autorizzazione attivare una finestra. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando una finestra diventa la finestra in primo piano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene attivata una finestra (diventa la finestra di primo piano) quando:  
  
-   Si apre la finestra.  
  
-   Un utente passa a una finestra, selezionarlo con il mouse, premere ALT + TAB o da Gestione attività.  
  
-   Un utente fa clic sul pulsante della barra delle applicazioni della finestra.  
  
 Windows necessarie per rilevare quando diventano attive in grado di gestire il <xref:System.Windows.Window.Activated> evento.  
  
 Dopo l'attivazione di una finestra, può disattivato e riattivato più volte durante la relativa durata. Se il comportamento o stato di un'applicazione dipende dal relativo stato di attivazione, è possibile esaminare <xref:System.Windows.Window.IsActive%2A> per determinare quale stato di attivazione è in.  
  
 Un'applicazione può anche essere <xref:System.Windows.Application.Activated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'area client di una finestra supporta la trasparenza.</summary>
        <value>
          <see langword="true" /> se la finestra supporta la trasparenza; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Windows.Controls.Control.Background%2A> di una finestra è impostata su un oggetto trasparente, il colore con il <xref:System.Windows.Media.Brushes.Transparent%2A> , ad esempio, la finestra rimane opaca. Ciò significa che non possono essere visualizzate sul desktop e le applicazioni in esecuzione "la finestra beneath". Per abilitare questo tipo di trasparenza, <xref:System.Windows.Window.AllowsTransparency%2A> deve essere impostato su `true`.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> è disponibile per facilitare la creazione di finestre non rettangolari e, di conseguenza, quando <xref:System.Windows.Window.AllowsTransparency%2A> è impostato su `true`, una finestra <xref:System.Windows.Window.WindowStyle%2A> proprietà deve essere impostata su <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Finestra con un valore di <see cref="P:System.Windows.Window.WindowStyle" /> diverso da <see cref="F:System.Windows.WindowStyle.None" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.AllowsTransparency" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Oggetto <see cref="T:System.Windows.Size" /> che riflette le dimensioni finali che la finestra deve utilizzare per disporre se stessa e i relativi elementi figlio.</param>
        <summary>Eseguire l'override di questo metodo per disporre e ridimensionare una finestra e i relativi elementi figlio.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Size" /> che riflette le dimensioni effettive utilizzate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> non viene chiamato quando il <xref:System.Windows.UIElement.Visibility%2A> proprietà ha un valore <xref:System.Windows.Visibility.Collapsed>. Se il valore di <xref:System.Windows.UIElement.Visibility%2A> la proprietà <xref:System.Windows.Visibility.Hidden> o <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> viene chiamato.  
  
> [!NOTE]
>  Quando sia <xref:System.Windows.Window.Show%2A> o <xref:System.Windows.Window.ShowDialog%2A> vengono chiamati i <xref:System.Windows.UIElement.Visibility%2A> proprietà di un <xref:System.Windows.Window> è impostato su <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude manualmente un oggetto <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Window> possono essere chiusi utilizzando uno di diversi meccanismi noti, fornito dal sistema, si trovano nella barra del titolo, tra cui:  
  
-   ALT + F4.  
  
-   Menu di sistema &#124; **Chiudi**.  
  
-   **Chiudi** pulsante.  
  
 Oggetto <xref:System.Windows.Window> può anche essere chiuso utilizzando uno dei diversi meccanismi noti all'interno dell'area client forniti dagli sviluppatori, tra cui:  
  
-   **File** &#124; **Exit** in una finestra principale.  
  
-   **File** &#124; **Close** o un **Chiudi** pulsante in una finestra figlio.  
  
> [!NOTE]
>  **OK** e **Annulla** anche i pulsanti nella finestra di dialogo sono fornito dallo sviluppatore, anche se sarà probabilmente set <xref:System.Windows.Window.DialogResult%2A>, che chiude automaticamente una finestra che è stato aperto chiamando <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Questi meccanismi richiedono una chiamata esplicita a <xref:System.Windows.Window.Close%2A> per chiudere una finestra.  
  
> [!NOTE]
>  Se una finestra aperta chiamando <xref:System.Windows.Window.ShowDialog%2A>e con un <xref:System.Windows.Controls.Button> con il relativo <xref:System.Windows.Controls.Button.IsCancel%2A> proprietà è impostata su true, verrà chiusa automaticamente quando il pulsante viene fatto o si preme ESC. Se è stata aperta la finestra utilizzando <xref:System.Windows.Window.Show%2A>, tuttavia, <xref:System.Windows.Window.Close%2A> deve essere chiamato in modo esplicito, ad esempio da <xref:System.Windows.Controls.Primitives.ButtonBase.Click> gestore eventi per il <xref:System.Windows.Controls.Button>.  
  
 Chiusura di una finestra determina il <xref:System.Windows.Window.Closing> dell'evento. Se il <xref:System.Windows.Window.Closing> evento non viene annullato, si verifica quanto segue:  
  
-   Il <xref:System.Windows.Window> viene rimosso dal <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (se un <xref:System.Windows.Application> oggetto esistente).  
  
-   Il <xref:System.Windows.Window> viene rimosso dal proprietario <xref:System.Windows.Window> se è stata stabilita la relazione proprietario e prima la proprietà <xref:System.Windows.Window> è stata visualizzata e dopo il proprietario <xref:System.Windows.Window> è stato aperto.  
  
-   Viene generato l'evento <xref:System.Windows.Window.Closed>.  
  
-   Creato da risorse non gestite di <xref:System.Windows.Window> vengono eliminati.  
  
-   Se <xref:System.Windows.Window.ShowDialog%2A> è stato chiamato per mostrare il <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> restituisce.  
  
 Chiusura di un <xref:System.Windows.Window> fa sì che tutte le finestre di sua proprietà per essere chiuso. Inoltre, la chiusura un <xref:System.Windows.Window> può provocare un'applicazione arrestare l'esecuzione a seconda della modalità di <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> proprietà è impostata.  
  
> [!NOTE]
>  Questo metodo non può essere chiamato quando una finestra è ospitata in un browser.  
  
   
  
## Examples  
 L'esempio seguente illustra una **File** &#124; **Exit** menu gestito per chiamare in modo esplicito <xref:System.Windows.Window.Close%2A>.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">l'autorizzazione per utilizzare tutte le finestre e gli eventi di input utente senza restrizioni. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la finestra è in fase di chiusura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo questo evento viene generato, una finestra non è possibile impedire la chiusura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> è impostata oppure viene chiamato <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> o <see cref="M:System.Windows.Window.Hide" /> durante la chiusura di una finestra.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica direttamente dopo la chiamata a <see cref="M:System.Windows.Window.Close" /> e può essere gestito per annullare la chiusura della finestra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> può essere gestito per rilevare quando una finestra viene chiusa (ad esempio, quando <xref:System.Windows.Window.Close%2A> viene chiamato). Inoltre, <xref:System.Windows.Window.Closing> può essere utilizzato per impedire la chiusura di una finestra. Per impedire la chiusura di una finestra, è possibile impostare il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del <xref:System.ComponentModel.CancelEventArgs> argomento `true`.  
  
 Il <xref:System.Windows.Window.Closing> evento viene generato quando <xref:System.Windows.Window.Close%2A> viene chiamato se si fa clic sul pulsante Chiudi di una finestra o se l'utente preme ALT + F4.  
  
 Se è stato aperto una finestra di proprietà dalla finestra proprietaria tramite <xref:System.Windows.Window.Show%2A>e il proprietario della finestra è chiusa, la finestra di proprietà <xref:System.Windows.Window.Closing> non viene generato l'evento. Se il proprietario di una finestra viene chiusa (vedere <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> non viene generato nella finestra Proprietà.  
  
 Se <xref:System.Windows.Application.Shutdown%2A> viene chiamato, il <xref:System.Windows.Window.Closing> viene generato l'evento per ogni finestra. Tuttavia, se <xref:System.Windows.Window.Closing> è annullato, l'annullamento viene ignorato.  
  
 Se una sessione viene interrotta perché un utente si disconnette o arrestato <xref:System.Windows.Window.Closing> non viene generato; gestire <xref:System.Windows.Application.SessionEnding> per implementare il codice che consente di annullare la chiusura dell'applicazione.  
  
 Se si desidera visualizzare e nascondere una finestra più volte nel corso della durata di un'applicazione e non si desidera creare una nuova finestra ogni volta che è la visualizzazione, è possibile gestire il <xref:System.Windows.Window.Closing> evento, annullarlo e chiamare il <xref:System.Windows.Window.Hide%2A> metodo. Quindi, è possibile chiamare <xref:System.Windows.Window.Show%2A> nella stessa istanza per riaprirla.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un <xref:System.Windows.Window> che determina se è necessario l'intervento dell'utente per chiudere.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> è impostata oppure viene chiamato <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> o <see cref="M:System.Windows.Window.Close" /> durante la chiusura di una finestra.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica dopo il rendering del contenuto di una finestra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la finestra non dispone di alcun contenuto, questo evento non viene generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando una finestra diventa una finestra di sfondo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una finestra viene disattivata (diventa una finestra di sfondo) quando:  
  
-   Un utente passa a un'altra finestra dell'applicazione corrente.  
  
-   Un utente passa alla finestra in un'altra applicazione utilizzando ALT + TAB oppure tramite Gestione attività.  
  
-   Un utente fa clic sul pulsante della barra delle applicazioni per una finestra in un'altra applicazione.  
  
 Windows necessarie per rilevare quando diventano disattivate gestendo il <xref:System.Windows.Window.Deactivated> evento.  
  
 Dopo la disattivazione prima di una finestra, può riattivato e disattivato più volte durante la relativa durata. Se il comportamento o stato di un'applicazione dipende dal relativo stato di attivazione, è possibile esaminare <xref:System.Windows.Window.IsActive%2A> per determinare quale stato di attivazione è in.  
  
 Un'applicazione può anche essere <xref:System.Windows.Application.Deactivated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore del risultato della finestra di dialogo, ovvero il valore restituito dal metodo <see cref="M:System.Windows.Window.ShowDialog" />.</summary>
        <value>Valore <see cref="T:System.Nullable`1" /> di tipo <see cref="T:System.Boolean" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> può essere utilizzato dal codice che mostrano una finestra di dialogo per determinare se un utente è stato accettato (`true`) o annullata (`false`) nella finestra di dialogo. Se una finestra di dialogo è stata accettata, ciò significa che per il codice che ha aperto la finestra di dialogo per recuperare i dati raccolti dall'utente ed elaborarlo. Se una finestra di dialogo è stata annullata, tuttavia, ciò significa che il codice chiamante deve essere arrestata un'ulteriore elaborazione.  
  
 Per impostazione predefinita, una finestra di dialogo viene annullata quando un utente esegue uno dei valori seguenti:  
  
-   PressesALT + F4.  
  
-   Seleziona il **Chiudi** pulsante.  
  
-   Seleziona **Chiudi** dal menu di sistema.  
  
 In tutti questi casi, <xref:System.Windows.Window.DialogResult%2A> è `false` per impostazione predefinita.  
  
 Una finestra di dialogo in genere fornisce un pulsante speciale per annullare una finestra di dialogo, che corrisponde al pulsante la cui <xref:System.Windows.Controls.Button.IsCancel%2A> è impostata su `true`. Un pulsante configurato in questo modo verrà chiusa automaticamente una finestra quando è premuto o quando viene premuto il tasto ESC. In entrambi i casi, <xref:System.Windows.Window.DialogResult%2A> rimane `false`.  
  
 Una finestra di dialogo in genere disponibile anche un pulsante di conferma, che corrisponde al pulsante la cui <xref:System.Windows.Controls.Button.IsDefault%2A> è impostata su `true`. Un pulsante configurato in questo modo verrà generato il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento quando viene premuto, o il tasto INVIO. Tuttavia, non verrà chiusa automaticamente la finestra di dialogo, non verrà impostata <xref:System.Windows.Window.DialogResult%2A> a `true`. È necessario scrivere manualmente questo codice, in genere dal <xref:System.Windows.Controls.Primitives.ButtonBase.Click> gestore eventi per il pulsante predefinito.  
  
 <xref:System.Windows.Window.DialogResult%2A> è `null` quando viene visualizzata nella finestra di dialogo non viene accettata né annullata.  
  
 Al termine di una finestra di dialogo, è possibile ottenere il risultato della finestra di dialogo dal valore restituito da <xref:System.Windows.Window.ShowDialog%2A> , metodo o controllando il <xref:System.Windows.Window.DialogResult%2A> proprietà.  
  
 <xref:System.Windows.Window.DialogResult%2A> può essere impostata solo quando un <xref:System.Windows.Window> è aperto, chiamando il relativo <xref:System.Windows.Window.ShowDialog%2A> metodo.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come configurare un pulsante OK e un pulsante Annulla per tornare appropriata <xref:System.Windows.Window.DialogResult%2A>.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.DialogResult" /> viene impostato prima che la finestra venga aperta chiamando <see cref="M:System.Windows.Window.ShowDialog" />.  
  
 oppure  
  
 <see cref="P:System.Windows.Window.DialogResult" /> viene impostato in una finestra aperta chiamando <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica dopo la modifica del valore DPI dello schermo su cui è visualizzata la finestra.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oggetto <see cref="T:System.Windows.RoutedEvent" /> per la modifica del valore DPI dello schermo su cui si trova la finestra.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente il trascinamento di una finestra con il pulsante sinistro del mouse su un'area esposta dell'area client della finestra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il pulsante sinistro del mouse deve essere premuto quando <xref:System.Windows.Window.DragMove%2A> viene chiamato. Per rilevare quando viene premuto il pulsante sinistro del mouse, è possibile gestire il <xref:System.Windows.UIElement.MouseLeftButtonDown> evento.  
  
 Quando <xref:System.Windows.Window.DragMove%2A> viene chiamato, sinistra deve essere premuto il pulsante del mouse su un'area esposta dell'area client della finestra.  
  
> [!NOTE]
>  Questo metodo non può essere chiamato quando una finestra è ospitata in un browser.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come eseguire l'override <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> chiamare <xref:System.Windows.Window.DragMove%2A>.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il pulsante sinistro del mouse non è premuto.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">l'autorizzazione per trascinare una finestra. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Oggetto di dipendenza.</param>
        <summary>Restituisce un riferimento all'oggetto <see cref="T:System.Windows.Window" /> che ospita la struttura ad albero del contenuto in cui è situato l'oggetto di dipendenza.</summary>
        <returns>Riferimento <see cref="T:System.Windows.Window" /> alla finestra host.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> è null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rende invisibile una finestra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una finestra non viene chiusa quando è nascosta e non il <xref:System.Windows.Window.Closing> né <xref:System.Windows.Window.Closed> viene generato l'evento. Al contrario, la finestra <xref:System.Windows.UIElement.Visibility%2A> è impostata su <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>.  
  
 Se l'applicazione è una finestra <xref:System.Windows.Application.MainWindow%2A> e l'applicazione <xref:System.Windows.Application.ShutdownMode%2A> è <xref:System.Windows.ShutdownMode.OnMainWindowClose>, l'applicazione non viene arrestato. Analogamente, l'applicazione viene arrestata se una finestra è l'unica finestra e la modalità di arresto dell'applicazione è <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Se si desidera visualizzare e nascondere una finestra più volte nel corso della durata di un'applicazione e non si desidera creare nuovamente la finestra ogni volta che è la visualizzazione, è possibile gestire il <xref:System.Windows.Window.Closing> evento, annullarlo e chiamare il <xref:System.Windows.Window.Hide%2A> metodo. Quindi, è possibile chiamare <xref:System.Windows.Window.Show%2A> nella stessa istanza per riaprirla.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Hide" /> viene chiamato su una finestra in fase di chiusura (<see cref="E:System.Windows.Window.Closing" />) o che è stata chiusa (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o imposta l'icona di una finestra.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.ImageSource" /> che rappresenta l'icona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Applicazioni autonome di Windows Presentation Foundation (WPF) sono due tipi di icone:  
  
-   Icona di un assembly, viene specificata utilizzando il `<ApplicationIcon>` file di compilazione di proprietà del progetto dell'applicazione. Questa icona viene utilizzata come icona del desktop di un assembly.  
  
    > [!NOTE]
    >  Durante il debug in Visual Studio, non verrà visualizzata l'icona a causa del processo di hosting. Se si esegue il file eseguibile, verrà visualizzata l'icona. Per altre informazioni, vedere [Processo di hosting (vshost.exe)](http://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Un'icona per ogni finestra che viene specificato impostando <xref:System.Windows.Window.Icon%2A>. Per ogni finestra, questa icona viene utilizzata nella barra del titolo, il relativo pulsante della barra e nella relativa voce di elenco Selezione applicazione ALT + TAB.  
  
 Una finestra WPF viene sempre visualizzata un'icona. Quando non viene specificato impostando <xref:System.Windows.Window.Icon%2A>, WPF viene scelta un'icona da visualizzare in base alle regole seguenti:  
  
1.  Utilizzare l'icona di assembly, se specificato.  
  
2.  Se l'icona di assembly non viene specificato, utilizzare l'icona predefinita di Microsoft Windows.  
  
 Se si utilizza <xref:System.Windows.Window.Icon%2A> per specificare un'icona di finestra personalizzati, è possibile ripristinare l'icona predefinita dell'applicazione impostando <xref:System.Windows.Window.Icon%2A> a `null`.  
  
 Una singola icona può essere utilizzata in diversi modi in Windows, tra cui viene visualizzato nella barra del titolo di una finestra, sulla barra delle applicazioni per una finestra, l'elenco di selezione file ALT + TAB. Ognuno di questi Mostra l'icona con dimensioni diverse. viene visualizzata un'icona di 16x16 pixel nella barra del titolo di una finestra e nella barra delle applicazioni, mentre viene visualizzata un'icona di 32 x 32 pixel nell'elenco di selezione file ALT + TAB. Alcune applicazioni, ad esempio [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], fornire un **vista** menu che consente di scegliere le dimensioni dell'icona di cui si desidera visualizzare.  
  
 Per soddisfare le varie dimensioni di visualizzazione, un file di icona è costituito da uno o più icone effettive in cui ognuno rappresenta una versione dell'icona destinato a una profondità di colore e dimensione specifica. Ad esempio, un'icona può avere una singola icona di 16x16 pixel con 16 colori, mentre un altro può contenere 16 x 16 pixel e icone di 32 x 32 pixel con 16 colori e 256 colori.  
  
 Se le icone per tutte le dimensioni e possibili intensità di colore esistono all'interno di un file di icona, <xref:System.Windows.Window> utilizzerà sull'icona appropriata. Se un file icona contiene solo un subset di tutte le icone possibili <xref:System.Windows.Window> utilizza l'icona più appropriata in ordine decrescente di dimensioni e profondità di colore.  
  
 Il risultato è che verrà sempre utilizzata un'icona da <xref:System.Windows.Window>, anche se l'icona utilizzata non potrebbero avere come destinazione la profondità di colore e dimensione obbligatoria. Ad esempio, un'icona di 16x16 pixel con 16 colori utilizzabili per visualizzare come icona 32 x 32 pixel con 256 colori. Questo può causare effetti visivi indesiderati, ad esempio dei mezzitoni, ma è possibile evitare la creazione di icone per tutte le dimensioni e intensità di colore.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.IconProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare un'icona di finestra.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per l'autorizzazione impostare l'icona. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.Icon" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la finestra è attiva.</summary>
        <value>
          <see langword="true" /> se la finestra è attiva; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una finestra attiva è visualizzata in primo piano corrente dell'utente e ha lo stato attivo, viene indicato dall'aspetto attivo della barra del titolo. Una finestra attiva sarà anche il superiore di tutte le finestre di primo livello che non vengono impostate in modo esplicito il <xref:System.Windows.Window.Topmost%2A> proprietà.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.IsActiveProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.IsActive" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la posizione del bordo sinistro della finestra, in relazione al desktop.</summary>
        <value>Posizione del bordo sinistro della finestra, in unità logiche (1/96 di pollice).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Windows.Window> viene ingrandita o ridotta, questo valore rappresenta il bordo sinistro dell'operazione di ripristino punto per il <xref:System.Windows.Window>.  
  
 Questa proprietà non può essere impostata tramite uno stile.  
  
 Se non si specifica un valore, <xref:System.Windows.Window.Left%2A> è impostata sul valore predefinito di sistema. È inoltre possibile specificare il valore predefinito di sistema impostando <xref:System.Windows.Window.Left%2A> a <xref:System.Double.NaN>. Né <xref:System.Double.NegativeInfinity> né <xref:System.Double.PositiveInfinity> è un valore valido per <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.LeftProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.Left" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica in seguito alla modifica della posizione della finestra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Percorso di una finestra di modifica quando:  
  
-   Un utente si sposta una finestra trascinandola con barra del titolo della finestra.  
  
-   Una finestra viene spostata dopo <xref:System.Windows.Window.DragMove%2A> viene chiamato.  
  
-   Sia il <xref:System.Windows.Window.Left%2A> o <xref:System.Windows.Window.Top%2A> proprietà è impostata a livello di codice.  
  
-   Il **spostare** del menu di sistema di una finestra viene scelto.  
  
-   Il <xref:System.Windows.Window.WindowState%2A> proprietà viene modificata.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un enumeratore per gli elementi figlio logici di una finestra.</summary>
        <value>Oggetto <see cref="T:System.Collections.IEnumerator" /> per gli elementi figlio logici di una finestra.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Oggetto <see cref="T:System.Windows.Size" /> che riflette le dimensioni disponibili che la finestra può assegnare all'elemento figlio. È possibile specificare Infinity per indicare che la finestra verrà ridimensionata in base al contenuto disponibile.</param>
        <summary>Eseguire l'override di questo metodo per misurare le dimensioni di una finestra.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Size" /> che riflette le dimensioni che questa finestra determina come necessarie durante il layout, in base ai calcoli delle dimensioni degli elementi figlio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> non viene chiamato quando il <xref:System.Windows.UIElement.Visibility%2A> proprietà ha un valore <xref:System.Windows.Visibility.Collapsed>. Se il valore di <xref:System.Windows.UIElement.Visibility%2A> la proprietà <xref:System.Windows.Visibility.Hidden> o <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> viene chiamato.  
  
> [!NOTE]
>  Quando sia <xref:System.Windows.Window.Show%2A> o <xref:System.Windows.Window.ShowDialog%2A> vengono chiamati i <xref:System.Windows.UIElement.Visibility%2A> proprietà di un <xref:System.Windows.Window> è impostato su <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Window.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A> genera l'evento <xref:System.Windows.Window.Activated>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnActivated%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnActivated%2A> sulla classe di base se <xref:System.Windows.Window.Activated> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Window.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A> genera l'evento <xref:System.Windows.Window.Closed>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnClosed%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnClosed%2A> sulla classe di base se <xref:System.Windows.Window.Closed> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.ComponentModel.CancelEventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Window.Closing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A> genera l'evento <xref:System.Windows.Window.Closing>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnClosing%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnClosing%2A> sulla classe di base se <xref:System.Windows.Window.Closing> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">Riferimento alla radice della struttura ad albero di contenuto obsoleta.</param>
        <param name="newContent">Riferimento alla radice della nuova struttura ad albero di contenuto.</param>
        <summary>Viene chiamato quando viene modificata la proprietà <see cref="P:System.Windows.Controls.ContentControl.Content" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Window.ContentRendered" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A> genera l'evento <xref:System.Windows.Window.ContentRendered>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnContentRendered%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnContentRendered%2A> sulla classe di base se <xref:System.Windows.Window.ContentRendered> deve essere generato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea e restituisce un oggetto <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> per questo <see cref="T:System.Windows.Window" />.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> per questa classe <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override del metodo <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Window.Deactivated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A> genera l'evento <xref:System.Windows.Window.Deactivated>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnDeactivated%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnDeactivated%2A> sulla classe di base se <xref:System.Windows.Window.Deactivated> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Impostazione precedente della scala DPI.</param>
        <param name="newDpi">Nuova impostazione della scala DPI.</param>
        <summary>Chiamato in caso di variazione del valore DPI usato per il rendering della finestra.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Window.LocationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A> genera l'evento <xref:System.Windows.Window.LocationChanged>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnLocationChanged%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnLocationChanged%2A> sulla classe di base se <xref:System.Windows.Window.LocationChanged> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati per l'evento.</param>
        <summary>Viene chiamato quando si verifica l'evento <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione non modifica lo stato gestito (il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà) del <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> dati dell'evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se esegue l'override <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, chiamare sempre l'implementazione di base <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> implementazione. Errore durante la chiamata l'implementazione di base impedisce che classi base la gestione dell'evento, il che potrebbe modificare il comportamento in fase di esecuzione della classe finale. È possibile chiamare l'implementazione di base prima o dopo la gestione speciale, a seconda dei requisiti.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Window.SourceInitialized" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A> genera l'evento <xref:System.Windows.Window.SourceInitialized>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnSourceInitialized%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnSourceInitialized%2A> sulla classe di base se <xref:System.Windows.Window.SourceInitialized> deve essere generato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.Window.StateChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A> genera l'evento <xref:System.Windows.Window.StateChanged>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnStateChanged%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnStateChanged%2A> sulla classe di base se <xref:System.Windows.Window.StateChanged> deve essere generato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Elemento padre precedente. È impostato su null se <see cref="T:System.Windows.DependencyObject" /> non aveva un elemento padre precedente.</param>
        <summary>Viene chiamato quando l'elemento padre della finestra viene modificato.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un insieme di finestre di proprietà della finestra corrente.</summary>
        <value>Oggetto <see cref="T:System.Windows.WindowCollection" /> che contiene riferimenti alle finestre di proprietà della finestra corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È una finestra di proprietà il cui <xref:System.Windows.Window.Owner%2A> proprietà è impostata con un riferimento a un'altra finestra, nota come finestra proprietaria. Per trovare tutte le finestre che una finestra proprietaria, è possibile enumerare <xref:System.Windows.WindowCollection> restituito dal <xref:System.Windows.Window.OwnedWindows%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come enumerare <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Window" /> proprietario di questo oggetto <see cref="T:System.Windows.Window" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Window" /> che rappresenta il proprietario di questo oggetto <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando una finestra figlio viene aperto da una finestra padre chiamando <xref:System.Windows.Window.ShowDialog%2A>, viene stabilita una relazione implicita tra la finestra padre e figlio. Questa relazione applica determinati comportamenti, tra cui rispetto alla riduzione, ottimizzare e il ripristino.  
  
 Quando una finestra figlio viene creata da una finestra padre chiamando <xref:System.Windows.Window.Show%2A>, tuttavia, la finestra figlio non ha una relazione con la finestra padre. Vale a dire che:  
  
-   La finestra figlio non dispone di un riferimento alla finestra padre.  
  
-   Il comportamento della finestra figlio non è dipendente dal comportamento della finestra padre. entrambe le finestre possono coprire l'altra o essere ridotta a icona, ingrandito e ripristinato indipendente.  
  
 Consente di creare una relazione tra una finestra figlio e una finestra padre, <xref:System.Windows.Window> supporta la nozione di proprietà. La proprietà viene stabilita quando il <xref:System.Windows.Window.Owner%2A> di una finestra (finestra proprietà) sia impostata con un riferimento a un'altra finestra (finestra proprietaria).  
  
 Una volta stabilita la relazione, si verificano i comportamenti seguenti:  
  
-   Se una finestra ridotta a icona, sono ridotto anche tutte le finestre di proprietà.  
  
-   Se è ridotta a icona una finestra di proprietà, il proprietario non viene ridotto.  
  
-   Se una finestra è ingrandita, sia la finestra proprietaria e le finestre di proprietà vengono ripristinate.  
  
-   Una finestra proprietaria non è in grado di coprire una finestra di proprietà.  
  
-   Proprietà che non sono state aperte tramite <xref:System.Windows.Window.ShowDialog%2A> non sono modale. L'utente può interagire con la finestra proprietaria.  
  
-   Se si chiude una finestra proprietaria, le finestre di proprietà vengono chiusi.  
  
-   Se è stato aperto una finestra di proprietà dalla finestra proprietaria tramite <xref:System.Windows.Window.Show%2A>e il proprietario della finestra è chiusa, la finestra di proprietà <xref:System.Windows.Window.Closing> non viene generato l'evento.  
  
 Quando si apre una finestra figlio chiamando <xref:System.Windows.Window.ShowDialog%2A>, è necessario impostare anche la <xref:System.Windows.Window.Owner%2A> proprietà della finestra figlio. In caso contrario, gli utenti sarà in grado di ripristinare sia finestre figlio e padre premendo il pulsante della barra. In alternativa, premere il pulsante della barra verrà generato un elenco di windows, tra cui finestra padre e figlio, per poter selezionare; viene ripristinata solo sulla finestra selezionata.  
  
> [!IMPORTANT]
>  È necessario impostare anche la <xref:System.Windows.Window.Owner%2A> proprietà in una finestra che aperto chiamando <xref:System.Windows.Window.ShowDialog%2A> per assicurare il corretto funzionamento con.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come stabilire la relazione proprietario/proprietà.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Una finestra tenta di essere proprietaria di se stessa  
  
 oppure  
  
 Due finestre tentano di essere proprietarie una dell'altra.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Windows.Window.Owner" /> è impostata su una finestra visibile visualizzata tramite <see cref="M:System.Windows.Window.ShowDialog" />  
  
 oppure  
  
 La proprietà <see cref="P:System.Windows.Window.Owner" /> è impostata con una finestra che non è stata visualizzata in precedenza.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">l'autorizzazione per utilizzare tutte le finestre e gli eventi di input utente senza restrizioni. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la modalità di ridimensionamento.</summary>
        <value>Valore di <see cref="T:System.Windows.ResizeMode" /> che specifica la modalità di ridimensionamento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sono disponibili quattro opzioni:  
  
-   **NoResize**. L'utente non è possibile ridimensionare la finestra. Non vengono visualizzate le caselle di ingrandimento e riduzione a icona.  
  
-   **CanMinimize**. L'utente può solo ridurre a icona la finestra e ripristinarlo nella barra delle applicazioni. Le caselle di riduzione a icona e Ingrandisci sono entrambi disponibili, ma solo la casella di riduzione a icona è abilitata.  
  
-   **CanResize**. L'utente ha la possibilità di effettuare ridimensionare la finestra, utilizzando le caselle di riduzione a icona e Ingrandisci e una struttura draggable intorno alla finestra. Le caselle di riduzione a icona e Ingrandisci sono visualizzate e abilitate. (Impostazione predefinita).  
  
-   **CanResizeWithGrip**. Questa opzione ha la stessa funzionalità <xref:System.Windows.ResizeMode.CanResize>, ma aggiunge un "ridimensionamento" nell'angolo inferiore destro della finestra.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.ResizeModeProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.ResizeMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le dimensioni e la posizione di una finestra prima della riduzione a icona o l'ingrandimento.</summary>
        <value>Oggetto <see cref="T:System.Windows.Rect" /> che specifica le dimensioni e la posizione di una finestra prima della riduzione a icona o l'ingrandimento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il rettangolo di ripristino è l'area occupata dalla finestra prima che è stata ridotta a icona o ingrandita. È possibile utilizzare <xref:System.Windows.Window.RestoreBounds%2A> per salvare le ultime dimensioni e posizione di una finestra prima della chiusura di un'applicazione e al successivo avvio di un'applicazione per ripristinare una finestra al modo in cui un utente ha lasciato per recuperare i valori.  
  
 Se si eseguono query <xref:System.Windows.Window.RestoreBounds%2A> prima la finestra o dopo che è stato chiuso, <xref:System.Windows.Rect.Empty%2A> viene restituito.  
  
> [!NOTE]
>  Quando una finestra è ospitata in un browser, è possibile ottenere questa proprietà.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Windows.Window.RestoreBounds%2A> e isolata di archiviazione per verificare le dimensioni e la posizione di una finestra siano uguali a quelli all'esecuzione precedente della finestra.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">l'autorizzazione per eseguire una query per le dimensioni e la posizione di una finestra rettangolo di delimitazione. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Apre una finestra e restituisce un valore senza attendere la chiusura della finestra appena aperta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Windows.Window> viene creata un'istanza di classe, non è visibile per impostazione predefinita. <xref:System.Windows.Window.Show%2A> viene visualizzata una finestra e restituisce immediatamente, senza attendere la chiusura della finestra. Di conseguenza, la finestra aperta non impedisce l'interazione con altre finestre dell'applicazione. Questo tipo di finestra viene chiamato un *non modale* finestra. Esempi comuni di windows non modali sono tavolozze caselle e finestre delle proprietà. Per impedire un utente di interagire con una finestra specifica, è necessario aprire la finestra chiamando <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Una finestra che viene aperto chiamando <xref:System.Windows.Window.Show%2A> does automaticamente hanno una relazione con la finestra in cui è stato aperto, in particolare, la finestra aperta non conosce quale finestra stato aperto. Questa relazione può essere stabilita utilizzando il <xref:System.Windows.Window.Owner%2A> proprietà e gestiti mediante il <xref:System.Windows.Window.OwnedWindows%2A> proprietà.  
  
 La chiamata <xref:System.Windows.Window.Show%2A> ottenga lo stesso risultato finale come impostazione <xref:System.Windows.UIElement.Visibility%2A> proprietà del <xref:System.Windows.Window> oggetto <xref:System.Windows.Visibility.Visible>. Tuttavia, sussiste una differenza tra i due termini di intervallo.  
  
 La chiamata <xref:System.Windows.Window.Show%2A> è un'operazione sincrona che restituisce solo dopo che il <xref:System.Windows.FrameworkElement.Loaded> è stato generato l'evento della finestra figlio:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Impostazione <xref:System.Windows.UIElement.Visibility%2A>, tuttavia, è un'operazione asincrona che restituisce immediatamente:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 Quando si imposta <xref:System.Windows.UIElement.Visibility%2A>, gli eventi di finestra è registrare prima di impostare <xref:System.Windows.UIElement.Visibility%2A> non può essere generato solo dopo il metodo in cui è stato impostato <xref:System.Windows.UIElement.Visibility%2A> ha completato l'esecuzione.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come aprire una finestra non modale.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Show" /> viene chiamato su una finestra in fase di chiusura (<see cref="E:System.Windows.Window.Closing" />) o che è stata chiusa (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una finestra è attivata la prima volta che viene visualizzata.</summary>
        <value>
          <see langword="true" /> se una finestra è attivata la prima volta che viene visualizzata. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando una finestra con il relativo <xref:System.Windows.Window.ShowActivated%2A> proprietà impostata su `false` è aperto, la finestra non è attivata e il relativo <xref:System.Windows.Window.Activated> non viene generato fino a quando un utente attiva manualmente la finestra, selezionarlo. Dopo aver selezionata la finestra, attiva e disattiva normalmente.  
  
 Per impedire che una finestra viene attivata quando si apre, il <xref:System.Windows.Window.ShowActivated%2A> proprietà deve essere impostata su `false` prima di visualizzare la finestra (chiamando <xref:System.Windows.Window.Show%2A>); impostazione <xref:System.Windows.Window.ShowActivated%2A> a `false` dopo avere visualizzata una finestra non ha alcun effetto.  
  
 Impostazione <xref:System.Windows.Window.ShowActivated%2A> a `false` in una finestra che viene aperta come modale, chiamando <xref:System.Windows.Window.ShowDialog%2A>, ha un impatto reale. Anche se non verrà attivata la finestra modale, finestra modale impedirà all'utente di attivare altre finestre dell'applicazione aperte.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.ShowActivatedProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il markup per configurare una finestra per essere aperto senza essere attivato.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 Nell'esempio seguente viene illustrato come usare il codice per configurare una finestra per essere aperto senza attivarla.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.ShowActivated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Apre una finestra e restituisce un valore solo quando la finestra appena aperta viene chiusa.</summary>
        <returns>Valore <see cref="T:System.Nullable`1" /> del tipo <see cref="T:System.Boolean" /> che specifica se l'attività è stata accettata (<see langword="true" />) o annullata (<see langword="false" />). Il valore restituito è il valore della proprietà <see cref="P:System.Windows.Window.DialogResult" /> prima della chiusura di una finestra.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un <xref:System.Windows.Window> viene creata un'istanza di classe, non è visibile per impostazione predefinita. <xref:System.Windows.Window.ShowDialog%2A> Mostra la finestra, disabilita tutte le altre finestre dell'applicazione e viene restituita solo quando la finestra è chiusa. Questo tipo di finestra è noto come un *modale* finestra.  
  
 Finestre modali vengono utilizzate principalmente come finestre di dialogo. Una finestra di dialogo è un tipo speciale di finestra utilizzato dalle applicazioni per interagire con gli utenti per completare le attività, ad esempio l'apertura di file o la stampa di documenti. Finestre di dialogo in genere consentono agli utenti di accettare o annullare l'attività per cui vengono visualizzate prima la finestra di dialogo viene chiusa. <xref:System.Windows.Window.ShowDialog%2A> Restituisce un <xref:System.Nullable%601> <xref:System.Boolean> valore che specifica se l'attività è stata accettata o annullata. Il valore restituito è il valore della proprietà <xref:System.Windows.Window.DialogResult%2A> prima della chiusura di una finestra. Per ulteriori informazioni, vedere <xref:System.Windows.Window.DialogResult%2A>.  
  
 Una finestra che viene aperto chiamando il <xref:System.Windows.Window.ShowDialog%2A> (metodo) non dispone automaticamente di una relazione con la finestra in cui è stato aperto, in particolare, la finestra aperta non conosce quale finestra stato aperto. Questa relazione può essere stabilita utilizzando il <xref:System.Windows.Window.Owner%2A> proprietà e gestiti mediante il <xref:System.Windows.Window.OwnedWindows%2A> proprietà. Per supportare [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] automazione (vedere [Panoramica di automazione dell'interfaccia utente](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> deve essere impostata per una finestra aperta chiamando <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Quando un oggetto modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] finestra (aperta una finestra chiamando <xref:System.Windows.Window.ShowDialog%2A>) è chiuso, attivata in precedenza viene riattivata finestra. Se un oggetto modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] finestra dispone di una finestra proprietaria (vedere <xref:System.Windows.Window.Owner%2A>), la finestra proprietaria non è riattivata quando modal [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] finestra è chiusa, a meno che non si tratti della finestra attivata in precedenza.  
  
> [!NOTE]
>  Questo metodo non può essere chiamato quando una finestra è ospitata in un browser.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come aprire una finestra modale.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.ShowDialog" /> viene chiamato su una finestra in fase di chiusura (<see cref="E:System.Windows.Window.Closing" />) o che è stata chiusa (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">per l'autorizzazione attivare una finestra. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la finestra è associata a un pulsante della barra delle applicazioni.</summary>
        <value>
          <see langword="true" /> se la finestra è associata a un pulsante della barra delle applicazioni; in caso contrario, <see langword="false" />. Non si applica quando la finestra è ospitata in un browser.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Windows.Window.ShowInTaskbar%2A> è impostato su `true`, la finestra verrà anche visualizzata nell'elenco di selezione applicazione ALT + TAB.  
  
 L'icona utilizzata per il pulsante della barra sia l'elenco di selezione applicazione ALT + TAB è il valore di <xref:System.Windows.Window.Icon%2A> proprietà.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.ShowInTaskbar" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una finestra verrà ridimensionata automaticamente in base alle dimensioni del contenuto.</summary>
        <value>Valore <see cref="T:System.Windows.SizeToContent" />. Il valore predefinito è <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Windows.Window.SizeToContent%2A> è impostato su <xref:System.Windows.SizeToContent.WidthAndHeight>, impostazione di <xref:System.Windows.FrameworkElement.Height%2A> o <xref:System.Windows.FrameworkElement.Width%2A> non ha alcun effetto; è possibile impostare entrambe le proprietà, ma i valori che sono stati impostati con non vengono applicati alla finestra.  
  
 Quando <xref:System.Windows.Window.SizeToContent%2A> è impostato su <xref:System.Windows.SizeToContent.Height>, l'impostazione <xref:System.Windows.FrameworkElement.Height%2A> non modifica l'altezza della finestra.  
  
 Quando <xref:System.Windows.Window.SizeToContent%2A> è impostato su <xref:System.Windows.SizeToContent.Width>, l'impostazione <xref:System.Windows.FrameworkElement.Width%2A> non modifica la larghezza della finestra.  
  
 Se <xref:System.Windows.Window.SizeToContent%2A> presenta un valore diverso da <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> viene impostato automaticamente su <xref:System.Windows.SizeToContent.Manual> se un utente ridimensiona la finestra utilizzando il ridimensionamento o trascinando il bordo.  
  
-   Se le dimensioni del contenuto viene modificato in modo che la finestra di ridimensionamento, <xref:System.Windows.FrameworkElement.SizeChanged> viene generato.  
  
 Se una finestra è trasparente (vedere <xref:System.Windows.Window.AllowsTransparency%2A>), è consigliabile impostare <xref:System.Windows.Window.SizeToContent%2A> a <xref:System.Windows.SizeToContent.WidthAndHeight> per garantire la finestra non siano maggiore del relativo contenuto visibile.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.SizeToContentProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il <xref:System.Windows.Window.SizeToContent%2A> proprietà nel codice per specificare come una finestra viene ridimensionata per adattarsi al contenuto.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.SizeToContent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Questo evento viene generato per supportare l'interazione con [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]. Vedere <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la proprietà <see cref="P:System.Windows.Window.WindowState" /> della finestra viene modificata.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'anteprima della barra delle applicazioni di [!INCLUDE[win7](~/includes/win7-md.md)] per <see cref="T:System.Windows.Window" />.</summary>
        <value>Anteprima della barra delle applicazioni di [!INCLUDE[win7](~/includes/win7-md.md)] per <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sull'utilizzo di [!INCLUDE[win7](~/includes/win7-md.md)] barra delle applicazioni in anteprima, vedere la <xref:System.Windows.Shell.TaskbarItemInfo> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.TaskbarItemInfo" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o imposta il titolo di una finestra.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene il titolo della finestra.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il titolo di un <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, o [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], può essere impostato anche tramite <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.TitleProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.Title" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la posizione del bordo superiore della finestra, in relazione al desktop.</summary>
        <value>Posizione della parte superiore della finestra, in unità logiche (1/96 di pollice).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Windows.Window> viene ingrandita o ridotta, questo valore rappresenta il bordo superiore del ripristino punto per il <xref:System.Windows.Window>.  
  
 Questa proprietà non può essere impostata tramite uno stile.  
  
 Se non si specifica un valore, <xref:System.Windows.Window.Top%2A> è impostata sul valore predefinito di sistema. È inoltre possibile specificare il valore predefinito di sistema impostando <xref:System.Windows.Window.Top%2A> a <xref:System.Double.NaN>. Né <xref:System.Double.NegativeInfinity> né <xref:System.Double.PositiveInfinity> è un valore valido per <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.TopProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una finestra viene visualizzata in primo piano nell'ordine Z.</summary>
        <value>
          <see langword="true" /> se la finestra è in primo piano; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una finestra cui <xref:System.Windows.Window.Topmost%2A> è impostata su `true` viene visualizzato sopra tutte le finestre di cui <xref:System.Windows.Window.Topmost%2A> sono impostate su `false`.  
  
 Nel gruppo di windows che hanno <xref:System.Windows.Window.Topmost%2A> è impostata su `true`, la finestra che viene attualmente attivata è la finestra in primo piano. Allo stesso modo per il gruppo di windows che hanno <xref:System.Windows.Window.Topmost%2A> è impostata su `false`.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.TopmostProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.Topmost" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.Top" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o imposta la posizione della finestra alla prima visualizzazione.</summary>
        <value>Valore <see cref="T:System.Windows.WindowStartupLocation" /> che specifica la posizione superiore/sinistra di una finestra la prima volta che viene visualizzata. Il valore predefinito è <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostazione <xref:System.Windows.WindowStartupLocation> a <xref:System.Windows.WindowStartupLocation.Manual> , una finestra deve essere posizionato in base al relativo <xref:System.Windows.Window.Left%2A> e <xref:System.Windows.Window.Top%2A> i valori delle proprietà. Se il <xref:System.Windows.Window.Left%2A> o <xref:System.Windows.Window.Top%2A> non sono specificate proprietà, i relativi valori vengono determinati da Windows.  
  
 Impostazione <xref:System.Windows.WindowStartupLocation.CenterScreen> , una finestra deve essere posizionato al centro dello schermo che contiene il cursore del mouse.  
  
 Impostazione <xref:System.Windows.WindowStartupLocation> a <xref:System.Windows.WindowStartupLocation.CenterOwner> , una finestra deve essere posizionato al centro della relativa finestra proprietaria (vedere <xref:System.Windows.Window.Owner%2A>), se specificato. La finestra proprietaria può essere un'altra finestra WPF o una finestra non WPF.  
  
> [!NOTE]
>  Per ulteriori informazioni sulle finestre WPF con finestre non WPF, vedere [interoperatività di WPF e Win32](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) e <xref:System.Windows.Interop.WindowInteropHelper>.  
  
 Se una finestra proprietaria non è specificata, la posizione della finestra è determinata esattamente come se <xref:System.Windows.WindowStartupLocation> è impostato su <xref:System.Windows.WindowStartupLocation.Manual>.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere il valore di questa proprietà quando una finestra è ospitata in un browser.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una finestra è ripristinata, ridotta a icona o ingrandita.</summary>
        <value>Oggetto <see cref="T:System.Windows.WindowState" /> che determina se una finestra è ripristinata, ridotta a icona o ingrandita. Il valore predefinito è <see cref="F:System.Windows.WindowState.Normal" /> (finestra ripristinata).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima che una finestra ridotta a icona o ingrandita, le dimensioni e posizione vengono archiviate <xref:System.Windows.Window.RestoreBounds%2A>. Quando una finestra viene successivamente ripristinata, i valori di dimensioni e posizione vengono ripristinati con i valori da <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 Quando il <xref:System.Windows.Window.WindowState%2A> proprietà viene modificata, <xref:System.Windows.Window.StateChanged> viene generato.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.WindowStateProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.WindowState" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o imposta lo stile del bordo di una finestra.</summary>
        <value>Oggetto <see cref="T:System.Windows.WindowStyle" /> che specifica lo stile del bordo di una finestra. Il valore predefinito è <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> può essere uno del <xref:System.Windows.WindowStyle> valori di enumerazione, tra cui <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (impostazione predefinita), e <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 La figura seguente mostra gli stili di finestra in [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (tema Windows Vista Aero, con effetto cristallo trasparente abilitata):  
  
 ![Stili finestra](~/add/media/windowoverviewfigure6.PNG "stili finestra")  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.WindowStyleProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.Window.WindowStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>