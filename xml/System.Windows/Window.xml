<Type Name="Window" FullName="System.Windows.Window">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="30e9c154175370c143890004c37ed150b5ecabbb" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36456201" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides the ability to create, configure, show, and manage the lifetime of windows and dialog boxes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il punto di interazione tra un utente e un'applicazione autonoma è una finestra. Oggetto [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] finestra è costituita da due aree distinte:  
  
-   Un'area non client, che ospita le aree di controllo di windows, tra cui un'icona, titolo, menu di sistema, pulsante Riduci a icona, Ottimizza pulsante, pulsante Ripristina, pulsante Chiudi e un bordo.  
  
-   Un'area client, che ospita il contenuto specifico dell'applicazione.  
  
 Una finestra standard è illustrata nella figura riportata di seguito:  
  
 ![Gli elementi della finestra](~/add/media/windowoverviewfigure1.PNG "gli elementi della finestra")  
  
 <xref:System.Windows.Window> incapsula la possibilità di creare, configurare, visualizzare e gestire la durata delle finestre e finestre di dialogo e fornisce i servizi chiavi seguenti:  
  
 **Gestione della durata**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **Gestione delle finestre**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Aspetto e il comportamento**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **Finestre di dialogo**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Inoltre, <xref:System.Windows.Application> espone il supporto speciale per la gestione di tutte le finestre in un'applicazione:  
  
-   Applicazione gestisce un elenco di tutte le finestre che attualmente viene creata un'istanza dell'applicazione. Questo elenco è esposto dal <xref:System.Windows.Application.Windows%2A> proprietà.  
  
-   Per impostazione predefinita <xref:System.Windows.Application.MainWindow%2A> viene impostato automaticamente con un riferimento al primo <xref:System.Windows.Window> che viene creata un'istanza in un'applicazione. Questo, rendendo la finestra della finestra principale dell'applicazione.  
  
 Oggetto <xref:System.Windows.Window> può essere implementata tramite markup, markup e code-behind o codice.  
  
 <xref:System.Windows.Window> viene utilizzato principalmente per visualizzare le finestre di dialogo per applicazioni autonome. Tuttavia, per le applicazioni che richiedono lo spostamento a livello di finestra, ad esempio le procedure guidate, è possibile utilizzare <xref:System.Windows.Navigation.NavigationWindow> invece; <xref:System.Windows.Navigation.NavigationWindow> deriva da <xref:System.Windows.Window> ed esteso con supporto di navigazione di tipo browser.  
  
> [!NOTE]
>  Contenuto esplorabile può essere incorporate in altri contenitori, contenuti e il contenuto utilizzando <xref:System.Windows.Controls.Frame>.  
  
 <xref:System.Windows.Window> è necessario `UnmanagedCode` autorizzazione di sicurezza deve essere creata un'istanza. Questo approccio sono le seguenti conseguenze:  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-le applicazioni autonome distribuite richiederà elevazione delle autorizzazioni quando vengono avviate dalle aree Internet o Intranet locale.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] che non richiedono le autorizzazioni complete non sarà in grado di creare un'istanza di windows o finestre di dialogo.  
  
 Per informazioni sulla distribuzione delle applicazioni autonome e considerazioni sulla sicurezza, vedere [strategia di sicurezza di WPF - sicurezza della piattaforma](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 Un <xref:System.Windows.Window> è un <xref:System.Windows.Controls.ContentControl>, il che significa che può contenere un singolo oggetto di qualsiasi tipo (ad esempio una stringa, un'immagine o un pannello). Per altre informazioni, vedere la classe <xref:System.Windows.Controls.ContentControl>. Inoltre, <xref:System.Windows.Window> è un elemento radice e, pertanto, non possono far parte del contenuto di un altro elemento.  
  
> [!NOTE]
>  Il <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, e <xref:System.Windows.Window.Left%2A> proprietà impostate in un <xref:System.Windows.Window> tramite uno stile non verrà applicata in fase di esecuzione.  
  
## <a name="customizing-the-window-control"></a>Personalizzazione del controllo di finestra  
 Per applicare le stesse impostazioni di proprietà al multiplo <xref:System.Windows.Window> controlli, utilizzare il <xref:System.Windows.FrameworkElement.Style%2A> proprietà. È possibile modificare il valore predefinito <xref:System.Windows.Controls.ControlTemplate> il controllo e conferire un aspetto univoco. Per ulteriori informazioni sulla creazione di un <xref:System.Windows.Controls.ControlTemplate>, vedere [personalizzazione dell'aspetto di un controllo esistente tramite la creazione di ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Per visualizzare le parti e stati specifiche per la <xref:System.Windows.Window>, vedere [finestra Stili e modelli](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Proprietà di dipendenza per questo controllo potrebbe essere impostata dallo stile predefinito del controllo.  Se una proprietà viene impostata da uno stile predefinito, la proprietà può variare rispetto al valore predefinito quando il controllo viene visualizzato nell'applicazione. Lo stile predefinito è determinato dal tema del desktop viene utilizzato quando l'applicazione è in esecuzione.  Per altre informazioni, vedere [temi WPF predefiniti](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  L'impostazione di una proprietà visiva può avere effetto solo se tale proprietà è sia presente nel <xref:System.Windows.Window> controllo del modello predefinito e viene impostata tramite una. È possibile trovare un elenco di proprietà visive nella sezione "Modifica la struttura Visual di un controllo" [personalizzazione dell'aspetto di un controllo esistente tramite la creazione di ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come una finestra standard viene definito utilizzando solo il markup:  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 Nell'esempio seguente viene illustrato come una finestra standard viene definita utilizzando solo codice:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 Nell'esempio seguente viene illustrato come una finestra standard viene definito mediante una combinazione di markup e code-behind.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Window" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore inizializza la <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, e <xref:System.Windows.Window.Left%2A> proprietà sui valori predefiniti <xref:System.Windows.Window> valori.  
  
 Se viene creata una finestra all'interno di un <xref:System.AppDomain> dotato di un <xref:System.Windows.Application> dell'oggetto, il costruttore aggiunge il <xref:System.Windows.Window> oggetto al set di <xref:System.Windows.Application>-gestiti windows tramite il <xref:System.Windows.Application.Windows%2A> proprietà del <xref:System.Windows.Application> oggetto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per l'autorizzazione per questo oggetto per chiamare metodi nativi unsafe. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attempts to bring the window to the foreground and activates it.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:System.Windows.Window" /> was successfully activated; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le regole che determinano se è attivata la finestra sono identici a quelli usati per la [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` funzione (User32. dll).  
  
 Se la finestra viene attivata in un'applicazione Windows Presentation Foundation che non è l'applicazione dell'utente in primo piano, <xref:System.Windows.Application.Activated> evento viene generato.  
  
> [!NOTE]
>  Questo metodo non può essere chiamato quando una finestra è ospitata in un browser.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">per l'autorizzazione attivare una finestra. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a window becomes the foreground window.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene attivata una finestra (diventa la finestra di primo piano) quando:  
  
-   Si apre la finestra.  
  
-   Un utente passa a una finestra, selezionarlo con il mouse, premere ALT + TAB, o da Gestione attività.  
  
-   Un utente fa clic sul pulsante della barra delle applicazioni della finestra.  
  
 Windows necessari per rilevare quando diventano attive in grado di gestire il <xref:System.Windows.Window.Activated> evento.  
  
 Dopo l'attivazione di una finestra, può disattivato e riattivato più volte durante la sua durata. Se il comportamento di un'applicazione o stato dipende dal relativo stato di attivazione, è possibile esaminare <xref:System.Windows.Window.IsActive%2A> per determinare quale stato di attivazione è in.  
  
 Un'applicazione può anche essere <xref:System.Windows.Application.Activated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window's client area supports transparency.</summary>
        <value>
          <see langword="true" /> Se la finestra supporta la trasparenza; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Windows.Controls.Control.Background%2A> di una finestra è impostata su un oggetto trasparente, il colore con il <xref:System.Windows.Media.Brushes.Transparent%2A> , ad esempio, la finestra rimane opaca. Ciò significa che non possono essere visualizzate sul desktop e le applicazioni in esecuzione "la finestra beneath". Per abilitare questo tipo di trasparenza <xref:System.Windows.Window.AllowsTransparency%2A> deve essere impostato su `true`.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> lo scopo di facilitare la creazione di finestre non rettangolari e, di conseguenza, quando <xref:System.Windows.Window.AllowsTransparency%2A> è impostata su `true`, una finestra <xref:System.Windows.Window.WindowStyle%2A> proprietà deve essere impostata su <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A window that has a <see cref="P:System.Windows.Window.WindowStyle" /> value of anything other than <see cref="F:System.Windows.WindowStyle.None" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.AllowsTransparency" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">A <see cref="T:System.Windows.Size" /> that reflects the final size that the window should use to arrange itself and its children.</param>
        <summary>Override this method to arrange and size a window and its child elements.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> that reflects the actual size that was used.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> non viene chiamato quando il <xref:System.Windows.UIElement.Visibility%2A> proprietà ha un valore pari <xref:System.Windows.Visibility.Collapsed>. Se il valore di <xref:System.Windows.UIElement.Visibility%2A> la proprietà <xref:System.Windows.Visibility.Hidden> o <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> viene chiamato.  
  
> [!NOTE]
>  Quando il <xref:System.Windows.Window.Show%2A> o <xref:System.Windows.Window.ShowDialog%2A> vengono chiamati, la <xref:System.Windows.UIElement.Visibility%2A> proprietà di una <xref:System.Windows.Window> è impostato su <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Manually closes a <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Window> possono essere chiusi utilizzando uno di diversi meccanismi noti, fornito dal sistema, che si trovano nella barra del titolo, tra cui:  
  
-   ALT + F4.  
  
-   Menu di sistema &#124; **Chiudi**.  
  
-   **Chiudi** pulsante.  
  
 Oggetto <xref:System.Windows.Window> possono anche essere chiusi utilizzando uno dei diversi meccanismi noti all'interno dell'area client fornite dagli sviluppatori, tra cui:  
  
-   **File** &#124; **Exit** in una finestra principale.  
  
-   **File** &#124; **Close** o un **Chiudi** pulsante in una finestra figlio.  
  
> [!NOTE]
>  **OK** e **annullare** pulsanti in una finestra di dialogo sono inoltre fornito dallo sviluppatore, anche se verrà set probabili <xref:System.Windows.Window.DialogResult%2A>, che chiude automaticamente una finestra che è stato aperto chiamando <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Questi meccanismi richiedono una chiamata esplicita a <xref:System.Windows.Window.Close%2A> per chiudere una finestra.  
  
> [!NOTE]
>  Se una finestra aperta chiamando <xref:System.Windows.Window.ShowDialog%2A>e con un <xref:System.Windows.Controls.Button> con il relativo <xref:System.Windows.Controls.Button.IsCancel%2A> proprietà impostata su true, verrà chiusa automaticamente quando il pulsante viene fatto o si preme ESC. Se è stata aperta la finestra utilizzando <xref:System.Windows.Window.Show%2A>, tuttavia <xref:System.Windows.Window.Close%2A> deve essere chiamato in modo esplicito, ad esempio dal <xref:System.Windows.Controls.Primitives.ButtonBase.Click> gestore eventi per il <xref:System.Windows.Controls.Button>.  
  
 Chiusura di una finestra determina il <xref:System.Windows.Window.Closing> evento da generare. Se il <xref:System.Windows.Window.Closing> evento non viene annullato, si verifica quanto segue:  
  
-   Il <xref:System.Windows.Window> viene rimosso dal <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (se un <xref:System.Windows.Application> oggetto esistente).  
  
-   Il <xref:System.Windows.Window> viene rimosso dal proprietario <xref:System.Windows.Window> se è stata stabilita la relazione proprietario/proprietà prima la proprietà <xref:System.Windows.Window> è stato illustrato e dopo il proprietario <xref:System.Windows.Window> è stato aperto.  
  
-   Viene generato l'evento <xref:System.Windows.Window.Closed>.  
  
-   Creato dalle risorse non gestite di <xref:System.Windows.Window> vengono eliminati.  
  
-   Se <xref:System.Windows.Window.ShowDialog%2A> è stato chiamato per mostrare la <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> restituisce.  
  
 Chiusura di un <xref:System.Windows.Window> fa sì che qualsiasi finestra proprietaria per essere chiuso. Inoltre, la chiusura una <xref:System.Windows.Window> potrebbe essere un'applicazione venga terminata l'esecuzione a seconda del modo in cui il <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> è impostata.  
  
> [!NOTE]
>  Questo metodo non può essere chiamato quando una finestra è ospitata in un browser.  
  
   
  
## Examples  
 L'esempio seguente illustra una **File** &#124; **Exit** menu gestito per chiamare in modo esplicito <xref:System.Windows.Window.Close%2A>.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">l'autorizzazione utilizzare tutte le finestre e gli eventi di input utente senza alcuna restrizione. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the window is about to close.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo questo evento viene generato, una finestra non è possibile impedire la chiusura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> is set, or <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, or <see cref="M:System.Windows.Window.Hide" /> is called while a window is closing.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs directly after <see cref="M:System.Windows.Window.Close" /> is called, and can be handled to cancel window closure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> può essere gestito per rilevare quando una finestra viene chiusa (ad esempio, quando <xref:System.Windows.Window.Close%2A> viene chiamato). Inoltre, <xref:System.Windows.Window.Closing> utilizzabile per impedire la chiusura di una finestra. Per impedire la chiusura di una finestra, è possibile impostare il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del <xref:System.ComponentModel.CancelEventArgs> argomento `true`.  
  
 Il <xref:System.Windows.Window.Closing> evento viene generato quando <xref:System.Windows.Window.Close%2A> viene chiamato, facendo clic su un pulsante Chiudi finestra oppure se l'utente preme ALT + F4.  
  
 Se è stato aperto una finestra di proprietà dalla finestra proprietaria tramite <xref:System.Windows.Window.Show%2A>e il proprietario della finestra è chiusa, la finestra di proprietà <xref:System.Windows.Window.Closing> evento non viene generato. Se il proprietario di una finestra viene chiusa (vedere <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> non viene generato nella finestra Proprietà.  
  
 Se <xref:System.Windows.Application.Shutdown%2A> viene chiamato, il <xref:System.Windows.Window.Closing> generato per ogni finestra. Tuttavia, se <xref:System.Windows.Window.Closing> viene annullato, annullamento viene ignorato.  
  
 Se una sessione viene interrotta perché un utente si disconnette o arrestato <xref:System.Windows.Window.Closing> non viene generato; gestire <xref:System.Windows.Application.SessionEnding> per implementare il codice che consente di annullare la chiusura dell'applicazione.  
  
 Se si desidera visualizzare e nascondere una finestra più volte nel corso della durata di un'applicazione e non si desidera creare una nuova finestra ogni volta che è la visualizzazione, è possibile gestire il <xref:System.Windows.Window.Closing> evento, annullarlo e chiamare il <xref:System.Windows.Window.Hide%2A> metodo. Quindi, è possibile chiamare <xref:System.Windows.Window.Show%2A> nella stessa istanza per riaprirla.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un <xref:System.Windows.Window> che determina se è necessario l'intervento dell'utente per chiudere.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.UIElement.Visibility" /> is set, or <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" />, or <see cref="M:System.Windows.Window.Close" /> is called while a window is closing.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a window's content has been rendered.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la finestra non dispone di alcun contenuto, questo evento non viene generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a window becomes a background window.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una finestra viene disattivata (diventa una finestra in background) quando:  
  
-   Un utente passa a un'altra finestra dell'applicazione corrente.  
  
-   Un utente passa alla finestra in un'altra applicazione usando ALT + TAB o utilizzare Task Manager.  
  
-   Un utente fa clic sul pulsante della barra delle applicazioni per una finestra in un'altra applicazione.  
  
 Windows necessari per rilevare quando diventano disattivate gestendo il <xref:System.Windows.Window.Deactivated> evento.  
  
 Dopo che una finestra prima di tutto è disattivata, potrebbe riattivato e disattivato più volte durante la sua durata. Se il comportamento di un'applicazione o stato dipende dal relativo stato di attivazione, è possibile esaminare <xref:System.Windows.Window.IsActive%2A> per determinare quale stato di attivazione è in.  
  
 Un'applicazione può anche essere <xref:System.Windows.Application.Deactivated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the dialog result value, which is the value that is returned from the <see cref="M:System.Windows.Window.ShowDialog" /> method.</summary>
        <value>Un <see cref="T:System.Nullable`1" /> valore di tipo <see cref="T:System.Boolean" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> può essere utilizzato dal codice che mostrano una finestra di dialogo per determinare se un utente è stato accettato (`true`) oppure annullata (`false`) nella finestra di dialogo. Se una finestra di dialogo è stata accettata, ciò significa che per il codice che ha aperto la finestra di dialogo per recuperare i dati raccolti dall'utente ed elaborarlo. Se una finestra di dialogo è stata annullata, tuttavia, ciò significa che la chiamata di codice è necessario interrompere altre elaborazioni.  
  
 Per impostazione predefinita, una finestra di dialogo viene annullata quando un utente esegue uno dei valori seguenti:  
  
-   PressesALT + F4.  
  
-   Seleziona il **Chiudi** pulsante.  
  
-   Seleziona **Chiudi** dal menu di sistema.  
  
 In tutti questi casi <xref:System.Windows.Window.DialogResult%2A> è `false` per impostazione predefinita.  
  
 Una finestra di dialogo in genere fornisce un pulsante speciale per annullare una finestra di dialogo, che corrisponde al pulsante la cui <xref:System.Windows.Controls.Button.IsCancel%2A> è impostata su `true`. Un pulsante configurato in questo modo verrà chiusa automaticamente una finestra quando è premuto o quando viene premuto il tasto ESC. In entrambi i casi, <xref:System.Windows.Window.DialogResult%2A> rimane `false`.  
  
 Una finestra di dialogo in genere disponibile anche un pulsante di conferma, che corrisponde al pulsante la cui <xref:System.Windows.Controls.Button.IsDefault%2A> è impostata su `true`. Un pulsante configurato in questo modo verrà generato il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento quando viene premuto, o il tasto INVIO. Tuttavia, non verrà chiusa automaticamente la finestra di dialogo non verrà impostata <xref:System.Windows.Window.DialogResult%2A> a `true`. È necessario scrivere manualmente questo codice, in genere dal <xref:System.Windows.Controls.Primitives.ButtonBase.Click> gestore eventi per il pulsante predefinito.  
  
 <xref:System.Windows.Window.DialogResult%2A> è `null` quando viene visualizzata la finestra di dialogo non viene accettata né annullata.  
  
 Al termine di una finestra di dialogo, è possibile ottenere la finestra risultante dal valore restituito da <xref:System.Windows.Window.ShowDialog%2A> metodo, o controllando il <xref:System.Windows.Window.DialogResult%2A> proprietà.  
  
 <xref:System.Windows.Window.DialogResult%2A> può essere impostata solo quando un <xref:System.Windows.Window> aperto, chiamando il relativo <xref:System.Windows.Window.ShowDialog%2A> metodo.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come configurare un pulsante OK e un pulsante di annullamento per restituire l'oggetto appropriato <xref:System.Windows.Window.DialogResult%2A>.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.DialogResult" /> is set before a window is opened by calling <see cref="M:System.Windows.Window.ShowDialog" />.  -or-  <see cref="P:System.Windows.Window.DialogResult" /> is set on a window that is opened by calling <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after the DPI of the screen on which the Window is displayed changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:System.Windows.RoutedEvent" /> for when the DPI of the screen the Window is on changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Allows a window to be dragged by a mouse with its left button down over an exposed area of the window's client area.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il pulsante sinistro del mouse deve essere inattivo quando <xref:System.Windows.Window.DragMove%2A> viene chiamato. Per rilevare quando viene premuto il pulsante sinistro del mouse, è possibile gestire il <xref:System.Windows.UIElement.MouseLeftButtonDown> evento.  
  
 Quando <xref:System.Windows.Window.DragMove%2A> viene chiamato, sinistra deve essere premuto il pulsante del mouse su un'area esposta dell'area client della finestra.  
  
> [!NOTE]
>  Questo metodo non può essere chiamato quando una finestra è ospitata in un browser.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come eseguire l'override <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> chiamare <xref:System.Windows.Window.DragMove%2A>.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The left mouse button is not down.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">l'autorizzazione trascinare una finestra. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">The dependency object.</param>
        <summary>Returns a reference to the <see cref="T:System.Windows.Window" /> object that hosts the content tree within which the dependency object is located.</summary>
        <returns>A <see cref="T:System.Windows.Window" /> reference to the host window.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Makes a window invisible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una finestra non viene chiuso quando è nascosto e né la <xref:System.Windows.Window.Closing> né <xref:System.Windows.Window.Closed> evento viene generato. Al contrario, la finestra <xref:System.Windows.UIElement.Visibility%2A> è impostata su <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>.  
  
 Se l'applicazione è una finestra <xref:System.Windows.Application.MainWindow%2A> e l'applicazione <xref:System.Windows.Application.ShutdownMode%2A> è <xref:System.Windows.ShutdownMode.OnMainWindowClose>, l'applicazione non viene arrestato. Analogamente, l'applicazione viene arrestata se una finestra è l'unica finestra e modalità di arresto dell'applicazione è <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Se si desidera visualizzare e nascondere una finestra più volte nel corso della durata di un'applicazione e non si desidera creare nuovamente la finestra ogni volta che è la visualizzazione, è possibile gestire il <xref:System.Windows.Window.Closing> evento, annullarlo e chiamare il <xref:System.Windows.Window.Hide%2A> metodo. Quindi, è possibile chiamare <xref:System.Windows.Window.Show%2A> nella stessa istanza per riaprirla.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Hide" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a window's icon.</summary>
        <value>Un <see cref="T:System.Windows.Media.ImageSource" /> oggetto che rappresenta l'icona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Applicazioni autonome di Windows Presentation Foundation (WPF) sono due tipi di icone:  
  
-   Icona di un assembly, viene specificata utilizzando il `<ApplicationIcon>` file di compilazione proprietà nel progetto dell'applicazione. Questa icona viene utilizzata come icona del desktop di un assembly.  
  
    > [!NOTE]
    >  Durante il debug in Visual Studio, non verrà visualizzata l'icona a causa del processo di hosting. Se si esegue il file eseguibile, verrà visualizzata l'icona. Per altre informazioni, vedere [Processo di hosting (vshost.exe)](http://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Un'icona per ogni finestra che viene specificato impostando <xref:System.Windows.Window.Icon%2A>. Per ogni finestra, questa icona viene utilizzata nella barra del titolo, il relativo pulsante nella barra e nella relativa voce di elenco Selezione applicazione ALT + TAB.  
  
 Una finestra WPF viene sempre visualizzata un'icona. Quando non viene specificato impostando <xref:System.Windows.Window.Icon%2A>, WPF viene scelta un'icona da visualizzare in base alle regole seguenti:  
  
1.  Utilizzare l'icona di assembly, se specificato.  
  
2.  Se l'icona di assembly non viene specificato, utilizzare l'icona predefinita di Microsoft Windows.  
  
 Se si utilizza <xref:System.Windows.Window.Icon%2A> per specificare un'icona di finestra personalizzati, è possibile ripristinare l'icona dell'applicazione predefinita impostando <xref:System.Windows.Window.Icon%2A> a `null`.  
  
 Una singola icona può essere utilizzata in diversi modi in Windows, tra cui viene visualizzato nella barra del titolo di una finestra, sulla barra delle applicazioni per una finestra, l'elenco di selezione file ALT + TAB. Ognuno di questi Mostra l'icona con dimensioni diverse. viene visualizzata un'icona di 16x16 pixel nella barra del titolo di una finestra e sulla barra delle applicazioni, mentre viene visualizzata un'icona di 32 x 32 pixel nell'elenco di selezione file ALT + TAB. Alcune applicazioni, ad esempio [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], fornire un **vista** menu che consente di scegliere le dimensioni dell'icona di cui si desidera visualizzare.  
  
 Per soddisfare le varie dimensioni di visualizzazione, un file dell'icona è composta da uno o più icone effettive in cui ognuno rappresenta una versione dell'icona destinato a una profondità di colore e dimensione specifica. Ad esempio, un'icona può avere una singola icona di 16x16 pixel con 16 colori, mentre un altro può contenere 16 x 16 pixel e icone di 32 x 32 pixel con 16 colori e 256 colori.  
  
 Se le icone per tutti i possibili formati e intensità di colore esistono all'interno di un file di icona, <xref:System.Windows.Window> utilizzerà sull'icona appropriata. Se un file icona contiene solo un subset di tutte le icone possibili, <xref:System.Windows.Window> utilizza l'icona più appropriato in ordine decrescente di dimensioni e profondità di colore.  
  
 Il risultato è che verrà sempre utilizzata un'icona da <xref:System.Windows.Window>, anche se l'icona utilizzata non potrebbero avere come destinazione la profondità di colore e dimensione obbligatoria. Ad esempio, un'icona di 16x16 pixel con 16 colori è utilizzabile per la visualizzazione come un'icona di 32 x 32 pixel con 256 colori. Questo può causare effetti visivi indesiderati, ad esempio dei mezzitoni, ma è possibile evitare la creazione di icone per tutte le dimensioni e intensità di colore.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.IconProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare un'icona di finestra.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">l'autorizzazione impostare l'icona. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Icon" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the window is active.</summary>
        <value>
          <see langword="true" /> Se la finestra sia attiva; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una finestra attiva è visualizzata in primo piano corrente dell'utente e ha lo stato attivo, che è identificato dall'aspetto attivo della barra del titolo. Una finestra attiva anche sarà superiore di tutte le finestre di primo livello non vengono impostate in modo esplicito il <xref:System.Windows.Window.Topmost%2A> proprietà.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.IsActiveProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.IsActive" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the position of the window's left edge, in relation to the desktop.</summary>
        <value>La posizione della finestra a sinistra del bordo, in unità logiche (1/96 ° di pollice).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Windows.Window> viene ingrandita o ridotta, questo valore rappresenta il bordo sinistro dell'operazione di ripristino punto per il <xref:System.Windows.Window>.  
  
 Questa proprietà non può essere impostata tramite uno stile.  
  
 Se non si specifica un valore, <xref:System.Windows.Window.Left%2A> è impostata sul valore predefinito di sistema. È inoltre possibile specificare il valore predefinito di sistema impostando <xref:System.Windows.Window.Left%2A> a <xref:System.Double.NaN>. Né <xref:System.Double.NegativeInfinity> né <xref:System.Double.PositiveInfinity> è un valore valido per <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.LeftProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Left" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the window's location changes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizione della finestra cambia quando:  
  
-   Un utente si sposta una finestra trascinandola con barra del titolo della finestra.  
  
-   Una finestra viene spostata dopo <xref:System.Windows.Window.DragMove%2A> viene chiamato.  
  
-   Sia il <xref:System.Windows.Window.Left%2A> o <xref:System.Windows.Window.Top%2A> viene impostata a livello di codice.  
  
-   Il **spostare** del menu di sistema di una finestra viene scelto.  
  
-   Il <xref:System.Windows.Window.WindowState%2A> proprietà viene modificata.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an enumerator for a window's logical child elements.</summary>
        <value>Un <see cref="T:System.Collections.IEnumerator" /> elementi figlio logici di una finestra.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">A <see cref="T:System.Windows.Size" /> that reflects the available size that this window can give to the child. Infinity can be given as a value to indicate that the window will size to whatever content is available.</param>
        <summary>Override this method to measure the size of a window.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> that reflects the size that this window determines it needs during layout, based on its calculations of children's sizes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> non viene chiamato quando il <xref:System.Windows.UIElement.Visibility%2A> proprietà ha un valore pari <xref:System.Windows.Visibility.Collapsed>. Se il valore di <xref:System.Windows.UIElement.Visibility%2A> la proprietà <xref:System.Windows.Visibility.Hidden> o <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> viene chiamato.  
  
> [!NOTE]
>  Quando il <xref:System.Windows.Window.Show%2A> o <xref:System.Windows.Window.ShowDialog%2A> vengono chiamati, la <xref:System.Windows.UIElement.Visibility%2A> proprietà di una <xref:System.Windows.Window> è impostato su <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Activated" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A> genera l'evento <xref:System.Windows.Window.Activated>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnActivated%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnActivated%2A> sulla classe base se <xref:System.Windows.Window.Activated> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Closed" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A> genera l'evento <xref:System.Windows.Window.Closed>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnClosed%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnClosed%2A> sulla classe base se <xref:System.Windows.Window.Closed> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.CancelEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Closing" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A> genera l'evento <xref:System.Windows.Window.Closing>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnClosing%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnClosing%2A> sulla classe base se <xref:System.Windows.Window.Closing> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">A reference to the root of the old content tree.</param>
        <param name="newContent">A reference to the root of the new content tree.</param>
        <summary>Called when the <see cref="P:System.Windows.Controls.ContentControl.Content" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.ContentRendered" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A> genera l'evento <xref:System.Windows.Window.ContentRendered>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnContentRendered%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnContentRendered%2A> sulla classe base se <xref:System.Windows.Window.ContentRendered> deve essere generato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates and returns a <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> object for this <see cref="T:System.Windows.Window" />.</summary>
        <returns>A <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> object for this <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.Deactivated" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A> genera l'evento <xref:System.Windows.Window.Deactivated>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnDeactivated%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnDeactivated%2A> sulla classe base se <xref:System.Windows.Window.Deactivated> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">The previous DPI scale setting.</param>
        <param name="newDpi">The new DPI scale setting.</param>
        <summary>Called when the DPI at which this window is rendered changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.LocationChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A> genera l'evento <xref:System.Windows.Window.LocationChanged>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnLocationChanged%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnLocationChanged%2A> sulla classe base se <xref:System.Windows.Window.LocationChanged> deve essere generato.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The data for the event.</param>
        <summary>Called when the <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> event occurs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione non modifica lo stato gestito (il <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà) del <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> dati dell'evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se esegue l'override <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, chiamare sempre l'implementazione di base <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> implementazione. Impossibile chiamare l'implementazione di base impedisce che classi base la gestione dell'evento, il che potrebbe modificare il comportamento di runtime della classe finale. È possibile chiamare l'implementazione di base prima o dopo la gestione speciale, a seconda dei requisiti.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.SourceInitialized" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A> genera l'evento <xref:System.Windows.Window.SourceInitialized>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnSourceInitialized%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnSourceInitialized%2A> sulla classe base se <xref:System.Windows.Window.SourceInitialized> deve essere generato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Windows.Window.StateChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A> genera l'evento <xref:System.Windows.Window.StateChanged>.  
  
 Un tipo che deriva da <xref:System.Windows.Window> può eseguire l'override <xref:System.Windows.Window.OnStateChanged%2A>. Il metodo sottoposto a override deve chiamare <xref:System.Windows.Window.OnStateChanged%2A> sulla classe base se <xref:System.Windows.Window.StateChanged> deve essere generato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">The previous parent. Set to null if the <see cref="T:System.Windows.DependencyObject" /> did not have a previous parent.</param>
        <summary>Called when the parent of the window is changed.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of windows for which this window is the owner.</summary>
        <value>Oggetto <see cref="T:System.Windows.WindowCollection" /> contenente riferimenti a windows per il quale questa finestra è il proprietario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una finestra di proprietà fa parte il cui <xref:System.Windows.Window.Owner%2A> viene impostata con un riferimento a un'altra finestra, è nota come finestra proprietaria. Per trovare tutte le finestre che una finestra proprietaria, è possibile enumerare <xref:System.Windows.WindowCollection> restituito dal <xref:System.Windows.Window.OwnedWindows%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come enumerare <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Window" /> that owns this <see cref="T:System.Windows.Window" />.</summary>
        <value>Un <see cref="T:System.Windows.Window" /> oggetto che rappresenta il proprietario di questo <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando una finestra figlio viene aperto da una finestra padre chiamando <xref:System.Windows.Window.ShowDialog%2A>, viene stabilita una relazione implicita tra la finestra padre e figlio. Questa relazione applica determinati comportamenti, tra cui rispetto alla riduzione, ottimizzazione e il ripristino.  
  
 Quando una finestra figlio viene creata da una finestra padre chiamando <xref:System.Windows.Window.Show%2A>, tuttavia, la finestra figlio non ha una relazione con la finestra padre. Vale a dire che:  
  
-   La finestra figlio non dispone di un riferimento alla finestra padre.  
  
-   Il comportamento della finestra figlio non dipende il comportamento della finestra padre. entrambe le finestre possono coprire l'altra o essere ridotta a icona, ingrandito e ripristinati in modo indipendente da altri.  
  
 Consente di creare una relazione tra una finestra figlio e una finestra padre, <xref:System.Windows.Window> supporta la nozione di proprietà. La proprietà viene stabilita quando la <xref:System.Windows.Window.Owner%2A> proprietà di una finestra (finestra proprietà) è impostata con un riferimento a un'altra finestra (finestra proprietaria).  
  
 Una volta stabilita la relazione, si verificano i comportamenti seguenti:  
  
-   Se è ridotta a icona una finestra proprietaria, siano minime anche tutte le finestre di proprietà.  
  
-   Se è ridotta a icona una finestra di proprietà, il proprietario non viene ridotta a icona.  
  
-   Se una finestra proprietaria è ingrandita, sia la finestra proprietaria e le finestre di proprietà vengono ripristinate.  
  
-   Una finestra proprietaria non è in grado di coprire una finestra di proprietà.  
  
-   Proprietà che non sono state aperte usando <xref:System.Windows.Window.ShowDialog%2A> non sono modale. L'utente può interagire con la finestra proprietaria.  
  
-   Se si chiude una finestra proprietaria, le finestre di proprietà vengono chiusi.  
  
-   Se è stato aperto una finestra di proprietà dalla finestra proprietaria tramite <xref:System.Windows.Window.Show%2A>e il proprietario della finestra è chiusa, la finestra di proprietà <xref:System.Windows.Window.Closing> evento non viene generato.  
  
 Quando si apre una finestra figlio chiamando <xref:System.Windows.Window.ShowDialog%2A>, è necessario impostare anche la <xref:System.Windows.Window.Owner%2A> proprietà della finestra figlio. Se non sono presenti, gli utenti non sono in grado di ripristinare sia finestre figlio e padre premendo il pulsante della barra. Al contrario, il premendo il pulsante della barra restituirà un elenco di finestre, tra cui finestra padre e figlio, per poter selezionare; viene ripristinata solo sulla finestra selezionata.  
  
> [!IMPORTANT]
>  È necessario impostare anche il <xref:System.Windows.Window.Owner%2A> proprietà in una finestra che che sia aperta chiamando <xref:System.Windows.Window.ShowDialog%2A> per assicurare il corretto funzionamento con.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come stabilire la relazione proprietario/proprietà.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A window tries to own itself  -or-  Two windows try to own each other.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Windows.Window.Owner" /> property is set on a visible window shown using <see cref="M:System.Windows.Window.ShowDialog" />  -or-  The <see cref="P:System.Windows.Window.Owner" /> property is set with a window that has not been previously shown.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">l'autorizzazione utilizzare tutte le finestre e gli eventi di input utente senza alcuna restrizione. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the resize mode.</summary>
        <value>Oggetto <see cref="T:System.Windows.ResizeMode" /> valore che specifica la modalità di ridimensionamento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esistono quattro opzioni:  
  
-   **NoResize**. L'utente non è possibile ridimensionare la finestra. Non vengono visualizzate le caselle di ingrandimento e riduzione a icona.  
  
-   **CanMinimize**. L'utente può solo ridurre a icona la finestra e ripristinarlo nella barra delle applicazioni. Le caselle di riduzione a icona e Ingrandisci sia sono visualizzate, ma solo la casella di riduzione a icona è abilitata.  
  
-   **CanResize**. L'utente ha la possibilità completa di ridimensionare la finestra utilizzando le caselle di riduzione a icona e Ingrandisci e una struttura draggable intorno alla finestra. Le caselle Riduci a icona e Ingrandisci sono visualizzate e abilitate. (Impostazione predefinita).  
  
-   **CanResizeWithGrip**. Questa opzione ha la stessa funzionalità <xref:System.Windows.ResizeMode.CanResize>, ma aggiunge un "ridimensionamento" nell'angolo inferiore destro della finestra.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.ResizeModeProperty>|  
|Impostare le proprietà dei metadati su `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.ResizeMode" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size and location of a window before being either minimized or maximized.</summary>
        <value>Oggetto <see cref="T:System.Windows.Rect" /> che specifica le dimensioni e la posizione di una finestra prima della riduzione a icona o ingrandita.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il rettangolo di ripristino è l'area occupata dalla finestra prima che è stata ridotta a icona o ingrandita. È possibile utilizzare <xref:System.Windows.Window.RestoreBounds%2A> per salvare le ultime dimensioni e la posizione di una finestra prima della chiusura di un'applicazione e per recuperare i valori al successivo avvio di un'applicazione per ripristinare il modo in cui un utente ha lasciato una finestra.  
  
 Se si esegue una query <xref:System.Windows.Window.RestoreBounds%2A> prima che la finestra è stata visualizzata o dopo che è stato chiuso, <xref:System.Windows.Rect.Empty%2A> viene restituito.  
  
> [!NOTE]
>  È possibile ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Windows.Window.RestoreBounds%2A> e isolato per verificare che le dimensioni e la posizione di una finestra corrispondono a quelle cui si trovavano all'esecuzione precedente è stata visualizzata la finestra.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">l'autorizzazione eseguire una query per le dimensioni e la posizione di una finestra rettangolo di delimitazione. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opens a window and returns without waiting for the newly opened window to close.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Windows.Window> viene creata un'istanza di classe, non è visibile per impostazione predefinita. <xref:System.Windows.Window.Show%2A> viene visualizzata una finestra e viene restituito immediatamente, senza attendere la chiusura della finestra. Di conseguenza, la finestra aperta non impedire agli utenti di interagire con altre finestre nell'applicazione. Questo tipo di finestra viene chiamato un *non modale* finestra. Esempi comuni di windows non modali sono tavolozze, le caselle e finestre delle proprietà. Per impedire un utente di interagire con una finestra specifica, la finestra deve essere aperto chiamando <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Una finestra che viene aperto chiamando <xref:System.Windows.Window.Show%2A> does automaticamente hanno una relazione con la finestra stato aperto, in particolare, la finestra aperta non conosce quale finestra stato aperto. Questa relazione può essere stabilita utilizzando il <xref:System.Windows.Window.Owner%2A> proprietà e gestiti mediante il <xref:System.Windows.Window.OwnedWindows%2A> proprietà.  
  
 La chiamata <xref:System.Windows.Window.Show%2A> ottenga lo stesso risultato finale come impostazione <xref:System.Windows.UIElement.Visibility%2A> proprietà del <xref:System.Windows.Window> oggetto <xref:System.Windows.Visibility.Visible>. Tuttavia, sussiste una differenza tra i due termini di intervallo.  
  
 La chiamata <xref:System.Windows.Window.Show%2A> è un'operazione sincrona che restituisce solo dopo che il <xref:System.Windows.FrameworkElement.Loaded> sulla finestra figlio dell'evento:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Impostazione <xref:System.Windows.UIElement.Visibility%2A>, tuttavia, è un'operazione asincrona che restituisce immediatamente un risultato:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 Quando si imposta <xref:System.Windows.UIElement.Visibility%2A>, gli eventi di finestra è registrare prima di impostare <xref:System.Windows.UIElement.Visibility%2A> non può essere generato dopo il metodo in cui è impostato <xref:System.Windows.UIElement.Visibility%2A> ha completato l'esecuzione.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come aprire una finestra non modale.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.Show" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window is activated when first shown.</summary>
        <value>
          <see langword="true" /> Se una finestra viene attivata quando viene visualizzata; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando una finestra con il relativo <xref:System.Windows.Window.ShowActivated%2A> proprietà impostata su `false` è aperto, la finestra non è attivata e il relativo <xref:System.Windows.Window.Activated> non viene generato finché un utente attiva manualmente la finestra, selezionarlo. Dopo aver selezionata, la finestra attiva e disattiva normalmente.  
  
 Per impedire che una finestra viene attivato quando viene aperto, il <xref:System.Windows.Window.ShowActivated%2A> proprietà deve essere impostata su `false` prima che venga mostrata la finestra (chiamando <xref:System.Windows.Window.Show%2A>); impostazione <xref:System.Windows.Window.ShowActivated%2A> a `false` dopo avere visualizzata una finestra non ha alcun effetto.  
  
 L'impostazione <xref:System.Windows.Window.ShowActivated%2A> al `false` in una finestra che viene aperto come form modale, chiamando <xref:System.Windows.Window.ShowDialog%2A>, non ha alcun impatto reale. Anche se non verrà attivata la finestra modale, la finestra modale impedirà all'utente di attivare altre finestre dell'applicazione aperte.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.ShowActivatedProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare markup per configurare una finestra per essere aperto senza essere attivato.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 Nell'esempio seguente viene illustrato come usare il codice per configurare una finestra per essere aperto senza di esso in corso l'attivazione.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.ShowActivated" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opens a window and returns only when the newly opened window is closed.</summary>
        <returns>A <see cref="T:System.Nullable`1" /> value of type <see cref="T:System.Boolean" /> that specifies whether the activity was accepted (<see langword="true" />) or canceled (<see langword="false" />). The return value is the value of the <see cref="P:System.Windows.Window.DialogResult" /> property before a window closes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un <xref:System.Windows.Window> viene creata un'istanza di classe, non è visibile per impostazione predefinita. <xref:System.Windows.Window.ShowDialog%2A> Mostra la finestra, disabilita tutte le altre finestre nell'applicazione e viene restituita solo quando la finestra è chiusa. Questo tipo di finestra è noto come un *modale* finestra.  
  
 Finestre modali vengono utilizzate principalmente come finestre di dialogo. Una finestra di dialogo è un tipo speciale della finestra utilizzata dalle applicazioni per interagire con gli utenti per completare le attività, ad esempio apertura di file o la stampa di documenti. Finestre di dialogo comunemente consentono agli utenti di accettare o annullare l'attività per il quale vengono visualizzate prima che la finestra di dialogo viene chiusa. <xref:System.Windows.Window.ShowDialog%2A> Restituisce un <xref:System.Nullable%601> <xref:System.Boolean> valore che specifica se l'attività è stata accettata o annullata. Il valore restituito è il valore di <xref:System.Windows.Window.DialogResult%2A> proprietà prima della chiusura di una finestra. Per altre informazioni, vedere <xref:System.Windows.Window.DialogResult%2A>.  
  
 Una finestra che viene aperto, chiamando la <xref:System.Windows.Window.ShowDialog%2A> (metodo) non dispone automaticamente di una relazione con la finestra stato aperto, in particolare, la finestra aperta non conosce quale finestra stato aperto. Questa relazione può essere stabilita utilizzando il <xref:System.Windows.Window.Owner%2A> proprietà e gestiti mediante il <xref:System.Windows.Window.OwnedWindows%2A> proprietà. Per supportare [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] automazione (vedere [Panoramica di automazione dell'interfaccia utente](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> deve essere impostato per una finestra aperta chiamando <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Quando un oggetto modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] finestra (aperta una finestra chiamando <xref:System.Windows.Window.ShowDialog%2A>) è chiusa, attivata in precedenza viene riattivata finestra. Se modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] finestra dispone di una finestra proprietaria (vedere <xref:System.Windows.Window.Owner%2A>), la finestra proprietaria non è riattivata quando il modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] finestra viene chiusa a meno che non si tratti della finestra attivata in precedenza.  
  
> [!NOTE]
>  Questo metodo non può essere chiamato quando una finestra è ospitata in un browser.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come aprire una finestra modale.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Window.ShowDialog" /> is called on a window that is closing (<see cref="E:System.Windows.Window.Closing" />) or has been closed (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">per l'autorizzazione attivare una finestra. Enumerazione associata: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the window has a task bar button.</summary>
        <value>
          <see langword="true" /> Se la finestra ha un pulsante sulla barra attività. in caso contrario, <see langword="false" />. Non è applicabile quando la finestra è ospitata in un browser.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Windows.Window.ShowInTaskbar%2A> è impostata su `true`, la finestra verrà anche visualizzata nell'elenco di selezione applicazione ALT + TAB.  
  
 L'icona viene utilizzata per il pulsante della barra sia l'elenco di selezione applicazione ALT + TAB è il valore di <xref:System.Windows.Window.Icon%2A> proprietà.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.ShowInTaskbar" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window will automatically size itself to fit the size of its content.</summary>
        <value>Valore <see cref="T:System.Windows.SizeToContent" />. Il valore predefinito è <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si <xref:System.Windows.Window.SizeToContent%2A> è impostata su <xref:System.Windows.SizeToContent.WidthAndHeight>, impostazione <xref:System.Windows.FrameworkElement.Height%2A> o <xref:System.Windows.FrameworkElement.Width%2A> non ha alcun effetto; è possibile impostare entrambe le proprietà, ma non vengono applicati i valori che sono stati impostati con alla finestra.  
  
 Quando si <xref:System.Windows.Window.SizeToContent%2A> è impostata su <xref:System.Windows.SizeToContent.Height>, l'impostazione <xref:System.Windows.FrameworkElement.Height%2A> non modifica l'altezza della finestra.  
  
 Quando si <xref:System.Windows.Window.SizeToContent%2A> è impostata su <xref:System.Windows.SizeToContent.Width>, l'impostazione <xref:System.Windows.FrameworkElement.Width%2A> non modifica la larghezza della finestra.  
  
 Se <xref:System.Windows.Window.SizeToContent%2A> presenta un valore diverso da <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> viene impostato automaticamente su <xref:System.Windows.SizeToContent.Manual> se un utente ridimensiona la finestra utilizzando il ridimensionamento o trascinando il bordo.  
  
-   Se le dimensioni del contenuto viene modificato in modo che la finestra di ridimensionamento, <xref:System.Windows.FrameworkElement.SizeChanged> viene generato.  
  
 Se una finestra è trasparente (vedere <xref:System.Windows.Window.AllowsTransparency%2A>), è consigliabile impostare <xref:System.Windows.Window.SizeToContent%2A> a <xref:System.Windows.SizeToContent.WidthAndHeight> per garantire la finestra non siano maggiore del relativo contenuto visibile.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.SizeToContentProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il <xref:System.Windows.Window.SizeToContent%2A> proprietà nel codice per specificare come una finestra viene ridimensionata per adattarsi al contenuto.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.SizeToContent" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised to support interoperation with [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]. See <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the window's <see cref="P:System.Windows.Window.WindowState" /> property changes.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the [!INCLUDE[win7](~/includes/win7-md.md)] taskbar thumbnail for the <see cref="T:System.Windows.Window" />.</summary>
        <value>Il [! Anteprima della barra delle applicazioni include[Win7](~/Includes/win7-MD.MD)] per il <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni su come usare il [!INCLUDE[win7](~/includes/win7-md.md)] sulla barra delle applicazioni in anteprima, vedere il <xref:System.Windows.Shell.TaskbarItemInfo> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.TaskbarItemInfo" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a window's title.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene il titolo della finestra.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il titolo di un <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, o [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], può essere impostato anche tramite <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.TitleProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Title" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the position of the window's top edge, in relation to the desktop.</summary>
        <value>Posizione della parte superiore della finestra, in unità logiche (1/96").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il <xref:System.Windows.Window> viene ingrandita o ridotta, questo valore rappresenta il bordo superiore del ripristino punto per il <xref:System.Windows.Window>.  
  
 Questa proprietà non può essere impostata tramite uno stile.  
  
 Se non si specifica un valore, <xref:System.Windows.Window.Top%2A> è impostata sul valore predefinito di sistema. È inoltre possibile specificare il valore predefinito di sistema impostando <xref:System.Windows.Window.Top%2A> a <xref:System.Double.NaN>. Né <xref:System.Double.NegativeInfinity> né <xref:System.Double.PositiveInfinity> è un valore valido per <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.TopProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window appears in the topmost z-order.</summary>
        <value>
          <see langword="true" /> Se la finestra in primo piano; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una finestra di cui <xref:System.Windows.Window.Topmost%2A> è impostata su `true` viene visualizzato sopra tutte le finestre la cui proprietà <xref:System.Windows.Window.Topmost%2A> sono impostate su `false`.  
  
 Nel gruppo di windows che hanno <xref:System.Windows.Window.Topmost%2A> è impostata su `true`, la finestra che viene attualmente attivata è la finestra in primo piano. Allo stesso modo per il gruppo di windows che hanno <xref:System.Windows.Window.Topmost%2A> è impostata su `false`.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.TopmostProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Topmost" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.Top" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the position of the window when first shown.</summary>
        <value>Oggetto <see cref="T:System.Windows.WindowStartupLocation" /> valore che specifica la posizione dell'angolo superiore sinistro di una finestra quando viene visualizzata. Il valore predefinito è <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'impostazione <xref:System.Windows.WindowStartupLocation> al <xref:System.Windows.WindowStartupLocation.Manual> fa sì che una finestra deve essere posizionato in base al relativo <xref:System.Windows.Window.Left%2A> e <xref:System.Windows.Window.Top%2A> i valori delle proprietà. Se il <xref:System.Windows.Window.Left%2A> o <xref:System.Windows.Window.Top%2A> non sono specificate proprietà, i relativi valori vengono determinati da Windows.  
  
 Impostazione <xref:System.Windows.WindowStartupLocation.CenterScreen> fa sì che una finestra deve essere posizionato al centro dello schermo che contiene il cursore del mouse.  
  
 L'impostazione <xref:System.Windows.WindowStartupLocation> al <xref:System.Windows.WindowStartupLocation.CenterOwner> fa sì che una finestra deve essere posizionato al centro della relativa finestra proprietaria (vedere <xref:System.Windows.Window.Owner%2A>), se non specificato. La finestra proprietaria può essere un'altra finestra WPF o una finestra non WPF.  
  
> [!NOTE]
>  Per altre informazioni sulle finestre WPF in windows non WPF, vedere [interoperatività di WPF e Win32](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) e <xref:System.Windows.Interop.WindowInteropHelper>.  
  
 Se una finestra proprietaria non è specificata, la posizione della finestra è determinata esattamente come se <xref:System.Windows.WindowStartupLocation> è impostata su <xref:System.Windows.WindowStartupLocation.Manual>.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere il valore di questa proprietà quando una finestra è ospitata in un browser.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a window is restored, minimized, or maximized.</summary>
        <value>Oggetto <see cref="T:System.Windows.WindowState" /> che determina se una finestra è ripristinata, ridotta a icona o ingrandita. Il valore predefinito è <see cref="F:System.Windows.WindowState.Normal" /> (ripristinata).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prima di una finestra ridotta a icona o ingrandita, le dimensioni e posizione vengono archiviati <xref:System.Windows.Window.RestoreBounds%2A>. Quando una finestra viene successivamente ripristinata, i valori di dimensioni e la posizione vengono ripristinati con i valori da <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 Quando il <xref:System.Windows.Window.WindowState%2A> proprietà viene modificata, <xref:System.Windows.Window.StateChanged> viene generato.  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.WindowStateProperty>|  
|Impostare le proprietà dei metadati su `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.WindowState" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a window's border style.</summary>
        <value>Oggetto <see cref="T:System.Windows.WindowStyle" /> che specifica lo stile del bordo della finestra. Il valore predefinito è <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> può essere uno del <xref:System.Windows.WindowStyle> valori di enumerazione, inclusi <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (predefinito), e <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 La figura seguente illustra gli stili di finestra in [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (tema Windows Vista Aero, con la trasparenza abilitata):  
  
 ![Stili finestra](~/add/media/windowoverviewfigure6.PNG "stili finestra")  
  
> [!NOTE]
>  Non è possibile impostare o ottenere questa proprietà quando una finestra è ospitata in un browser.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.Window.WindowStyleProperty>|  
|Impostare le proprietà dei metadati su `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Window.WindowStyle" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>