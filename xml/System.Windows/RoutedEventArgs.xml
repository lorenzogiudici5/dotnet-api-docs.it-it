<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="86f523bef7f76ecf3e0fc2ab9adc3b6f2590fe25" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39915996" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contiene informazioni sullo stato e dati evento associati a un evento indirizzato.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diversi <xref:System.Windows.RoutedEventArgs> può essere usato con un singolo <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Questa classe è responsabile della creazione del pacchetto di dati per un <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, fornendo le informazioni sullo stato di eventi aggiuntivi e viene utilizzata dal sistema degli eventi per richiamare il gestore associato all'evento indirizzato.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo costruttore senza parametri, tutte le proprietà pubbliche del nuovo <xref:System.Windows.RoutedEventArgs> istanza assumono i valori predefiniti seguenti:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> Per impostazione predefinita `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Per impostazione predefinita `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> Per impostazione predefinita `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Per impostazione predefinita `null`.  
  
 I valori null per <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> indicano che solo il <xref:System.Windows.RoutedEventArgs> dati in alcun modo per specificare l'origine. Quando si usa questa istanza in una chiamata a <xref:System.Windows.UIElement.RaiseEvent%2A>, il <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> i valori vengono popolati in base all'elemento che ha generato l'evento e viene passato al listener tramite il routing.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identificatore dell'evento indirizzato per questa istanza della classe <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.RoutedEventArgs" /> utilizzando l'identificatore dell'evento indirizzato specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo costruttore di overload, non viene specificato le proprietà del nuovo <xref:System.Windows.RoutedEventArgs> istanza assumono i valori predefiniti seguenti:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Per impostazione predefinita `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> Per impostazione predefinita `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Per impostazione predefinita `null`.  
  
 I valori null per <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> indicano solo che <xref:System.Windows.RoutedEventArgs> in alcun modo per specificare l'origine. Quando si usa questa istanza in una chiamata a <xref:System.Windows.UIElement.RaiseEvent%2A>, il <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> i valori vengono popolati in base all'elemento che ha generato l'evento e viene passato al listener tramite il routing.  
  
   
  
## Examples  
 L'esempio seguente crea una nuova <xref:System.Windows.RoutedEventArgs> da usare in una chiamata a <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identificatore dell'evento indirizzato per questa istanza della classe <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <param name="source">Origine alternativa che verrà segnalata durante la gestione dell'evento. In questo modo, viene prepopolata la proprietà <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.RoutedEventArgs" /> utilizzando l'identificatore dell'evento indirizzato specificato e consentendo di dichiarare un'origine diversa per l'evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo costruttore di overload, non viene specificato le proprietà del nuovo <xref:System.Windows.RoutedEventArgs> istanza assumono i valori predefiniti seguenti:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Per impostazione predefinita `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Per impostazione predefinita `null`.  
  
 I valori null per <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> vengono popolate in base all'elemento che ha generato l'evento e passati tramite il routing, ma leggerà `null` prima della chiamata.  
  
 Usare questa firma quando si passano <xref:System.Windows.RoutedEventArgs> a oggetti virtuali, ad esempio <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, in cui gli argomenti vengono utilizzati per chiamare <xref:System.Windows.UIElement.RaiseEvent%2A> internamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica lo stato presente della gestione degli eventi per un evento indirizzato quando percorre la route.</summary>
        <value>Se l'impostazione, impostare su <see langword="true" /> se l'evento deve essere contrassegnato come gestito; in caso contrario <see langword="false" />. Se la lettura di questo valore, <see langword="true" /> indica che un gestore classi o alcuni gestori di istanze lungo la route ha già contrassegnato questo evento come gestito. <see langword="false" /> indica che nessun gestore ha contrassegnato l'evento come gestito.  
  
Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrassegnare l'evento come gestito si limita la visibilità dell'evento indirizzato al listener lungo la route dell'evento. L'evento comunque seguire il resto della route, ma solo i gestori aggiunti in modo specifico con `HandledEventsToo` `true` nel <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> chiamata al metodo verrà richiamata nella risposta. I gestori sul listener dell'istanza predefiniti (ad esempio quelli espressi in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) non verrà richiamato. Gestione degli eventi che sono contrassegnati come gestiti non è uno scenario comune.  
  
 Se si è autore di un controllo che definisce gli eventi, le decisioni prese relativo all'evento gestione a livello di classe influirà su utenti del controllo, nonché tutti gli utenti della controlli derivati e potenzialmente altri elementi che possono essere contenuti dal controllo o che contengono il controllo. Per altre informazioni, vedere [Contrassegno degli eventi indirizzati come gestiti e gestione delle classi](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 In rare circostanze, è opportuno gestire gli eventi in cui <xref:System.Windows.RoutedEventArgs.Handled%2A> contrassegnato `true`e modificare gli argomenti dell'evento modificando <xref:System.Windows.RoutedEventArgs.Handled%2A> a `false`. Ciò può essere necessario in determinate aree di eventi di input di controlli, ad esempio la gestione dei tasti <xref:System.Windows.UIElement.KeyDown> rispetto a <xref:System.Windows.UIElement.TextInput> dove a basso livello e gli eventi di input di alto livelli sono in conflitto per la gestione e ognuno tenta di utilizzare una diversa strategia di routing.  
  
   
  
## Examples  
 L'esempio seguente implementa un gestore eventi che contrassegna l'evento come gestito.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Implementazione del delegato/gestore generico da richiamare.</param>
        <param name="genericTarget">Destinazione in cui deve essere richiamato il gestore specificato.</param>
        <summary>In caso di override in una classe derivata, consente di richiamare i gestori eventi in base al tipo, aumentando l'efficienza nell'implementazione di base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implementazione di base incorpora la reflection per determinare il gestore corretto tutti i casi in cui il gestore di non è letteralmente <xref:System.Windows.RoutedEventHandler>, e questo passaggio la reflection dispone di alcune conseguenze sulle prestazioni. Le chiamate possono essere rese più efficiente non basarsi sulla reflection. Questo è lo scenario che rappresenta uno stimolo questo metodo saranno disponibili per qualsiasi classe di argomenti di evento indirizzato che scegliere di eseguirne l'override. Le implementazioni non devono chiamare la base per questo metodo, perché l'implementazione deve già essere responsabile per richiamare i gestori indipendenti dai tipi.  
  
   
  
## Examples  
 Di seguito è pseudocodice che illustra un modello di base che può essere utilizzato per l'implementazione. In questo caso, `MyRoutedEventHandler` è una sottoclasse di <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Questo metodo deve essere sottoposta a override dalle classi di dati di evento derivata per fornire più efficienti chiamate dei delegati. L'implementazione deve eseguire il cast specificato <paramref name="genericHandler" /> specifica del tipo delegato e quindi richiamare il gestore.  L'implementazione predefinita tenterà di richiamare il gestore fornito, il tentativo di eseguire il cast come <see cref="T:System.Windows.RoutedEventHandler" />. Se uno dei due <paramref name="genericHandler" /> oppure <paramref name="genericTarget" /> viene fornito come <see langword="null" />, vengono generate eccezioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Nuovo valore su cui viene impostato <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>Se sottoposto a override in una classe derivata, fornisce un punto di ingresso di callback di notifica a ogni modifica del valore della proprietà <see cref="P:System.Windows.RoutedEventArgs.Source" /> di un'istanza.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Modifica l'origine specificata di un evento a livello di codice può potenzialmente richiedere l'aggiornamento dei dati di tipo specifico all'interno dell'evento. Per questo motivo, il <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> metodo virtuale protetto e deve essere sottoposta a override dalle sottoclassi di <see cref="T:System.Windows.RoutedEventArgs" />.  Questo metodo presenta alcuna implementazione predefinita.</para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'origine di segnalazione originale in base a quanto determinato dall'hit testing puro, prima di qualsiasi possibile modifica di <see cref="P:System.Windows.RoutedEventArgs.Source" /> da parte di una classe padre.</summary>
        <value>Origine di segnalazione originale, prima di qualsiasi possibile modifica di <see cref="P:System.Windows.RoutedEventArgs.Source" /> da parte della gestione delle classi, che potrebbe essere stata apportata per semplificare strutture ad albero di elementi composte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà consente di acquisire il relativo valore una volta, prima della classe vengono richiamati, i gestori eventi o qualsiasi gestore di istanze e non viene mai modificata dopo questo punto. Le informazioni di origine originale sono di sola lettura per i gestori classi o implementazioni della classe, esattamente come viene segnalato nei dati dell'evento.  
  
 I casi comuni in cui è possibile modificare l'origine includono gli elementi di contenuto all'interno di un modello di contenuto per un controllo (il contenuto di un elemento di elenco, ad esempio, verrà segnalato l'elemento di elenco come il <xref:System.Windows.RoutedEventArgs.Source%2A> e l'elemento effettivo all'interno dell'elemento di elenco sarà il <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 La modifica dell'origine da vari elementi e modelli di contenuto varia da una classe per classe. Ogni classe che consente di modificare le origini eventi tenta di prevedere l'origine è il più utile eseguire un report degli scenari più inpui e gli scenari per cui la classe è destinata, e quindi imposta tale origine come il <xref:System.Windows.RoutedEventArgs.Source%2A>. Se l'origine non è quella che ha pertinente per la gestione dell'evento, provare a controllare <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> invece se segnala un'origine diversa che risulta più appropriata. Per altre informazioni sugli eventi di input, vedere [Cenni preliminari sull'Input](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associato a questa istanza di <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <value>Identificatore per l'evento richiamato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è possibile impostare questo valore su un <xref:System.Windows.RoutedEventArgs> che è già stata distribuita (ad esempio, se è stato acquistato tramite un gestore di argomenti). Tentativo di eseguire questa operazione genera un'eccezione. È possibile impostare solo in un'istanza che non è ancora stata usata per generare una chiamata dell'evento.  
  
 Il valore di <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> non può essere `null` in qualsiasi momento.  
  
   
  
## Examples  
 Nell'esempio seguente crea nuovi dati di evento indirizzato con un costruttore iniziale e quindi imposta il <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> proprietà come un'operazione successiva. È necessario disporre di <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> impostato prima della generazione dell'evento indirizzato.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tentativo di modificare il valore <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> durante il routing dell'evento.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un riferimento all'oggetto che ha generato l'evento.</summary>
        <value>Oggetto che ha generato l'evento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per qualsiasi tipo di bubbling evento indirizzato che è stato effettivamente trasferito oltre l'elemento che lo ha generato la route e per qualsiasi tunneling evento indirizzato che non abbia ancora tunneling all'elemento che ha generato, il valore di <xref:System.Windows.RoutedEventArgs.Source%2A> saranno diversi rispetto al valore della `sender` parametro della classe di argomenti di evento. Quale dei due elementi coinvolti nell'evento è più importante in qualsiasi gestore specificato (<xref:System.Windows.RoutedEventArgs.Source%2A>, l'elemento che ha generato, o `sender`, l'elemento che si sta gestendo) dipende dalla logica dell'applicazione che il gestore di è indirizzamento.  
  
 Impostazione di questa proprietà viene in genere eseguito solo quando si esegue l'override o l'implementazione di altre [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] che modificano le origini evento, ad esempio, quando la gestione di un evento della classe. La reimpostazione di origini evento evidente dai gestori di istanze non è consigliabile, in particolare quando il gestore non contrassegna l'evento come gestito.  
  
 Se si reimposta <xref:System.Windows.RoutedEventArgs.Source%2A> per segnalare un'origine di eventi differenti, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> continuerà a inviare l'origine come primo sollevata di origine <xref:System.Windows.UIElement.RaiseEvent%2A> chiamare.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>