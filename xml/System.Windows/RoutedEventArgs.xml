<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8f6112c09b1f961b689a530d29b65eeca46e3156" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30679765" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contiene informazioni sullo stato e dati evento associati a un evento indirizzato.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diversi <xref:System.Windows.RoutedEventArgs> può essere utilizzato con un singolo <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Questa classe è responsabile per comprimere i dati dell'evento per un <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, fornisce informazioni aggiuntive evento dello stato e viene utilizzato dal sistema di eventi per richiamare il gestore associato all'evento indirizzato.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza questo costruttore senza parametri, tutte le proprietà pubbliche del nuovo <xref:System.Windows.RoutedEventArgs> istanza si supponga che i valori predefiniti seguenti:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> Per impostazione predefinita `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Per impostazione predefinita `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> Per impostazione predefinita `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Per impostazione predefinita `null`.  
  
 I valori null per <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> indicano solo che la <xref:System.Windows.RoutedEventArgs> dati eseguono alcun tentativo di specificare l'origine. Quando l'istanza viene usata in una chiamata a <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> i valori vengono popolati in base all'elemento che ha generato l'evento e viene inviato ai listener tramite il routing.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identificatore dell'evento indirizzato per questa istanza della classe <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.RoutedEventArgs" /> utilizzando l'identificatore dell'evento indirizzato specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza il costruttore di overload, non viene specificato le proprietà del nuovo <xref:System.Windows.RoutedEventArgs> istanza si supponga che i valori predefiniti seguenti:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Per impostazione predefinita `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> Per impostazione predefinita `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Per impostazione predefinita `null`.  
  
 I valori null per <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> indicano solo che <xref:System.Windows.RoutedEventArgs> esegue alcun tentativo di specificare l'origine. Quando l'istanza viene usata in una chiamata a <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> i valori vengono popolati in base all'elemento che ha generato l'evento e viene inviato ai listener tramite il routing.  
  
   
  
## Examples  
 Nell'esempio seguente crea un nuovo <xref:System.Windows.RoutedEventArgs> per l'utilizzo in una chiamata a <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identificatore dell'evento indirizzato per questa istanza della classe <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <param name="source">Origine alternativa che verrà segnalata durante la gestione dell'evento. In questo modo, viene prepopolata la proprietà <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.RoutedEventArgs" /> utilizzando l'identificatore dell'evento indirizzato specificato e consentendo di dichiarare un'origine diversa per l'evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si utilizza il costruttore di overload, non viene specificato le proprietà del nuovo <xref:System.Windows.RoutedEventArgs> istanza si supponga che i valori predefiniti seguenti:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> Per impostazione predefinita `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Per impostazione predefinita `null`.  
  
 I valori null per <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> vengono popolati in base all'elemento che ha generato l'evento e passati tramite il routing, ma verranno lette `null` prima della chiamata.  
  
 Usare questa firma quando si passa <xref:System.Windows.RoutedEventArgs> a oggetti virtuali, ad esempio <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, in cui gli argomenti vengono utilizzati per chiamare <xref:System.Windows.UIElement.RaiseEvent%2A> internamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica lo stato presente della gestione degli eventi per un evento indirizzato quando percorre la route.</summary>
        <value>Se l'impostazione, impostare su <see langword="true" /> se l'evento deve essere contrassegnato come gestito; in caso contrario <see langword="false" />. Se la lettura di questo valore, <see langword="true" /> indica che un gestore di classe o un gestore di istanze lungo la route è già contrassegnato questo evento come gestito. <see langword="false" /> indica che nessun gestore ha contrassegnato l'evento come gestito.  
  
 Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrassegnare l'evento come gestito si limita la visibilità dell'evento indirizzato ai listener lungo la route dell'evento. L'evento comunque seguire il resto della route, ma solo i gestori sono aggiunti in modo specifico con `HandledEventsToo` `true` nel <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> chiamata al metodo verrà richiamata nella risposta. Gestori predefiniti nei listener dell'istanza (ad esempio quelli espressi in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) non verrà richiamato. Gestione degli eventi che sono contrassegnati come gestiti non è in uno scenario comune.  
  
 Se si è autore di un controllo che definisce gli eventi personalizzati, le decisioni prese relativo all'evento gestione a livello di classe influirà utenti del controllo, nonché tutti gli utenti della controlli derivati e potenzialmente altri elementi che possono essere contenuti dal controllo o che contengono il controllo. Per altre informazioni, vedere [Contrassegno degli eventi indirizzati come gestiti e gestione delle classi](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 In casi molto rari è appropriato gestire gli eventi in cui <xref:System.Windows.RoutedEventArgs.Handled%2A> è contrassegnato come `true`e modificare gli argomenti dell'evento modificando <xref:System.Windows.RoutedEventArgs.Handled%2A> a `false`. Ciò può essere necessario in determinate aree di eventi di input dei controlli, ad esempio la gestione dei tasti <xref:System.Windows.UIElement.KeyDown> e <xref:System.Windows.UIElement.TextInput> in basso livello e gli eventi di input di alto livelli si contendono la gestione e ciascuno tenta di utilizzare una diversa strategia di routing.  
  
   
  
## Examples  
 Nell'esempio seguente implementa un gestore eventi che contrassegna l'evento come gestito.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Implementazione del delegato/gestore generico da richiamare.</param>
        <param name="genericTarget">Destinazione in cui deve essere richiamato il gestore specificato.</param>
        <summary>In caso di override in una classe derivata, consente di richiamare i gestori eventi in base al tipo, aumentando l'efficienza nell'implementazione di base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementazione di base incorpora la reflection per determinare il gestore corretto per qualsiasi caso in cui il gestore non è letteralmente <xref:System.Windows.RoutedEventHandler>, e questo è alcune conseguenze sulle prestazioni. Non basarsi sulla reflection le chiamate possono essere rese più efficiente. Questo è lo scenario che rappresenta uno stimolo questo metodo sono disponibili per qualsiasi classe di argomenti dell'evento indirizzato che è possibile eseguirne l'override. Le implementazioni non devono chiamare la base per questo metodo, perché l'implementazione deve già essere responsabile per richiamare i gestori indipendenti dai tipi.  
  
   
  
## Examples  
 Di seguito è pseudocodice che illustra un modello di base che può essere utilizzato per l'implementazione. In questo caso, `MyRoutedEventHandler` è una sottoclasse di <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Questo metodo deve essere sottoposta a override dalle classi di dati degli eventi derivati per consentire chiamate più efficienti dei delegati. L'implementazione deve eseguire il cast forniti <paramref name="genericHandler" /> di specifica del tipo delegato e quindi richiamare il gestore.  
  
 L'implementazione predefinita verrà eseguito un tentativo di richiamare il gestore specificato, il tentativo di eseguire il cast come <see cref="T:System.Windows.RoutedEventHandler" />. Se il valore <paramref name="genericHandler" /> o <paramref name="genericTarget" /> viene fornito come <see langword="null" />, verranno generate eccezioni.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Nuovo valore su cui viene impostato <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>Se sottoposto a override in una classe derivata, fornisce un punto di ingresso di callback di notifica a ogni modifica del valore della proprietà <see cref="P:System.Windows.RoutedEventArgs.Source" /> di un'istanza.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Modifica l'origine specificata di un evento a livello di codice può potenzialmente richiedere l'aggiornamento dei dati di tipo specifico all'interno dell'evento. Per questo motivo, il <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> metodo virtuale è protetto e deve essere sottoposta a override dalle sottoclassi di <see cref="T:System.Windows.RoutedEventArgs" />.  
  
 Questo metodo non è Nessuna implementazione predefinita.</para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'origine di segnalazione originale in base a quanto determinato dall'hit testing puro, prima di qualsiasi possibile modifica di <see cref="P:System.Windows.RoutedEventArgs.Source" /> da parte di una classe padre.</summary>
        <value>Origine di segnalazione originale, prima di qualsiasi possibile modifica di <see cref="P:System.Windows.RoutedEventArgs.Source" /> da parte della gestione delle classi, che potrebbe essere stata apportata per semplificare strutture ad albero di elementi composte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà acquisisce il valore di una volta, prima della classe vengono richiamati, i gestori eventi o eventuali gestori di istanza e non viene mai modificata dopo questo punto. Le informazioni di origine originale sono di sola lettura per i gestori di classi o implementazioni della classe, solo come indicato nei dati dell'evento.  
  
 Casi comuni in cui è possibile modificare l'origine includono gli elementi di contenuto all'interno di un modello di contenuto per un controllo (il contenuto di un elemento di elenco, ad esempio, verrà segnalato l'elemento di elenco come il <xref:System.Windows.RoutedEventArgs.Source%2A> e l'elemento effettivo all'interno dell'elemento di elenco sarà il <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 La modifica dell'origine da vari elementi e modelli di contenuto varia da una classe per classe. Ogni classe che modifica origini evento tenta di prevedere l'origine è estremamente utile per scenari di più input e gli scenari per cui la classe è destinata, e quindi imposta tale origine come il <xref:System.Windows.RoutedEventArgs.Source%2A>. Se l'origine non è quello che è pertinente per la gestione dell'evento, controllare <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> invece per verificare se segnala un'origine diversa più appropriata. Per ulteriori informazioni sugli eventi di input, vedere [Panoramica Input](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associato a questa istanza di <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <value>Identificatore per l'evento richiamato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è possibile impostare questo valore su un <xref:System.Windows.RoutedEventArgs> che è già stata distribuita (ad esempio, se è stato ottenuto tramite un gestore argomenti). Il tentativo di eseguire questa operazione genera un'eccezione. È possibile impostare solo in un'istanza non è ancora stata utilizzata per generare una chiamata dell'evento.  
  
 Il valore di <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> non può essere `null` in qualsiasi momento.  
  
   
  
## Examples  
 Nell'esempio seguente crea i nuovi dati dell'evento indirizzato con un costruttore iniziale e quindi imposta il <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> proprietà come operazione successiva. È necessario disporre di <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> impostato prima della generazione dell'evento indirizzato.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tentativo di modificare il valore <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> durante il routing dell'evento.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un riferimento all'oggetto che ha generato l'evento.</summary>
        <value>Oggetto che ha generato l'evento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per qualsiasi bubbling evento indirizzato che è effettivamente trasferito lungo la route oltre l'elemento che lo ha generato, e per qualsiasi tunneling indirizzato che non abbia ancora tunneling all'elemento che ha generato, il valore di <xref:System.Windows.RoutedEventArgs.Source%2A> saranno diversi rispetto al valore della `sender` parametro della classe di argomenti dell'evento. Quale dei due elementi coinvolto nell'evento è la più importante in qualsiasi gestore specificato (<xref:System.Windows.RoutedEventArgs.Source%2A>, l'elemento che ha generato, o `sender`, l'elemento che si sta gestendo) dipende dalla logica dell'applicazione che è il gestore indirizzamento.  
  
 L'impostazione di questa proprietà viene in genere eseguita quando si esegue l'override o l'implementazione di altre [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] che modificano le origini eventi, ad esempio quando la gestione di un evento della classe. Non è consigliabile reimpostare le origini evento apparenti dai gestori di istanza, in particolare quando il gestore non contrassegna l'evento come gestito.  
  
 Se si reimposta <xref:System.Windows.RoutedEventArgs.Source%2A> per segnalare un'origine evento diversa, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> continuerà a segnalare l'origine come primo generato da di origine <xref:System.Windows.UIElement.RaiseEvent%2A> chiamare.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>