<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="PropertyMetadata.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac55c5dfef7a02e9b858a22854c1ef79b198ef1d9bc.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5c5dfef7a02e9b858a22854c1ef79b198ef1d9bc</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.PropertyMetadata">
          <source>Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</source>
          <target state="translated">Definisce determinati aspetti del comportamento di una proprietà di dipendenza applicata a un tipo specifico, incluse le condizioni con cui è stata registrata.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>Property metadata can be defined and used during dependency property registration when calling the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> method.</source>
          <target state="translated">I metadati della proprietà possono essere definito e utilizzato durante la registrazione di proprietà di dipendenza quando si chiama il <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> metodo (o varianti per le proprietà associate o le proprietà di dipendenza di sola lettura) o dopo la registrazione del proprietario originale quando si chiama il <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> also takes property metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> accetta anche i metadati della proprietà.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>This class is a concrete base class that can be used in each of these calls.</source>
          <target state="translated">Questa classe è una classe base concreta che può essere usata in ognuna di queste chiamate.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>However, it is very common to specify metadata using one of the derived classes such as <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</source>
          <target state="translated">Tuttavia, è molto comune per specificare i metadati utilizzando una delle classi derivate, ad esempio <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> framework level.</source>
          <target state="translated">Queste classi derivate supportano metadati più dettagliati riportati come valori di proprietà booleano, che sono utili per rilevare e abilitare alcuni comportamenti sistema e il layout di proprietà che vengono implementati solo il <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> livello di framework.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph>.</source>
          <target state="translated">Molte proprietà di questa classe sono lettura e scrittura per il modello a oggetti, ma può essere scritto prima l'istanza venga utilizzata in un'operazione di sistema di proprietà, ad esempio <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>Each of these properties could also have been set by the constructor but are exposed so that <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt;</ph> method implementations can set them.</source>
          <target state="translated">Ognuna di queste proprietà potrebbero inoltre essere impostate dal costruttore ma vengono esposte in modo che <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt;</ph> impostare tali implementazioni del metodo.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>XAML Text Usage</source>
          <target state="translated">Utilizzo di testo XAML</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.PropertyMetadata">
          <source>This type, and members of this type, are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Questo tipo e i membri di questo tipo, non sono in genere usati <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="T:System.Windows.PropertyMetadata">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>The default value to specify for a dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">Valore predefinito da specificare per una proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class with a specified default value for the dependency property that this metadata will be applied to.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> con un valore predefinito specificato per la proprietà di dipendenza a cui verranno applicati i metadati.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Il tipo di valore fornito per <ph id="ph1">`defaultValue`</ph> deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Mancata corrispondenza tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza applicata a può essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione (ma genera un'eccezione in fase di esecuzione).</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be specified.</source>
          <target state="translated">Anche se è il valore predefinito per il costruttore senza parametri, un <ph id="ph1">`defaultValue`</ph> di <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> non può essere specificato.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Il tentativo di eseguire questa operazione verrà generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> cannot be set to the value <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> non può essere impostato sul valore <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Riferimento a un'implementazione del gestore che il sistema di proprietà chiamerà a ogni modifica del valore effettivo della proprietà.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> implementation reference.</source>
          <target state="translated">Inizializza una nuova istanza della classe  <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> con il riferimento all'implementazione di <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> specificato.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Riferimento a un'implementazione del gestore che il sistema di proprietà chiamerà a ogni modifica del valore effettivo della proprietà.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class with the specified default value and <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> implementation reference.</source>
          <target state="translated">Inizializza una nuova istanza della classe  <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> con il valore predefinito e il riferimento all'implementazione di <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> specificati.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The type of the value provided <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Il tipo di valore fornito <ph id="ph1">`defaultValue`</ph> deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Mancata corrispondenza tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza applicata a può essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione (ma genera un'eccezione in fase di esecuzione).</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be specified.</source>
          <target state="translated">Anche se è il valore predefinito per il costruttore senza parametri, un <ph id="ph1">`defaultValue`</ph> di <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> non può essere specificato.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Il tentativo di eseguire questa operazione verrà generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> cannot be set to the value <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> non può essere impostato sul valore <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
          <target state="translated">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
          <target state="translated">Riferimento a un'implementazione del gestore che il sistema di proprietà chiamerà a ogni modifica del valore effettivo della proprietà.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Reference to a handler implementation that is to be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> against this property.</source>
          <target state="translated">Riferimento a un'implementazione del gestore che verrà chiamata ogni volta che il sistema di proprietà chiama <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> per la proprietà.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> class with the specified default value and callbacks.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph>, con il valore predefinito e i callback specificati.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>If you want to specify a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> but not a <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, you can pass <ph id="ph3">`null`</ph> for the <ph id="ph4">`propertyChangedCallback`</ph> parameter.</source>
          <target state="translated">Se si desidera specificare un <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> ma non un <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, è possibile passare <ph id="ph3">`null`</ph> per il <ph id="ph4">`propertyChangedCallback`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Il tipo di valore fornito per <ph id="ph1">`defaultValue`</ph> deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
          <target state="translated">Mancata corrispondenza tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza applicata a può essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione (ma genera un'eccezione in fase di esecuzione).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be specified.</source>
          <target state="translated">Anche se è il valore predefinito per il costruttore senza parametri, un <ph id="ph1">`defaultValue`</ph> di <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> non può essere specificato.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Il tentativo di eseguire questa operazione verrà generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> cannot be set to the value <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> non può essere impostato sul valore <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>Gets or sets a reference to a <ph id="ph1">&lt;see cref="T:System.Windows.CoerceValueCallback" /&gt;</ph> implementation specified in this metadata.</source>
          <target state="translated">Ottiene o imposta un riferimento a un'implementazione di <ph id="ph1">&lt;see cref="T:System.Windows.CoerceValueCallback" /&gt;</ph> specificata nei metadati.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.CoerceValueCallback" /&gt;</ph> implementation reference.</source>
          <target state="translated">Riferimento all'implementazione di <ph id="ph1">&lt;see cref="T:System.Windows.CoerceValueCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">I callback nei metadati della proprietà non sono in genere membri pubblici nel tipo contenitore, pertanto il valore di questa proprietà non è importante per la maggior parte degli scenari che utilizzano solo i metadati della proprietà di dipendenza un'esistente.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</source>
          <target state="translated">È di un motivo per cui questa proprietà viene esposta in modo che le sottoclassi di metadati di eseguire la logica di unione desiderata se sia i metadati di base che si esegue l'override o l'aggiunta di metadati specificano un <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>However, the default merge logic for a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> is to replace the previous one.</source>
          <target state="translated">Tuttavia, il valore predefinito logica di unione per un <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> consiste nel sostituire quella precedente.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> is defined in the object model as read-write.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> è definito nel modello a oggetti di lettura e scrittura.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>This is so <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> can be adjusted after initialization of the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
          <target state="translated">In tal caso <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> può essere modificato dopo l'inizializzazione del <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> oggetto stesso.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Tuttavia, dopo che i metadati vengono utilizzati come parte di una chiamata a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e le proprietà ora sono considerate immutabili.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>Attempting to set <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph3">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Il tentativo di impostare <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> una volta <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> è <ph id="ph3">`true`</ph> i metadati di questa istanza verrà generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.CoerceValueCallback">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Impossibile impostare una proprietà dei metadati dopo averla applicata a un'operazione relativa alla proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Gets or sets the default value of the dependency property.</source>
          <target state="translated">Ottiene o imposta il valore predefinito della proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>The default value of the property.</source>
          <target state="translated">Valore predefinito della proprietà.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>The default value on a <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> instance created with the parameterless constructor will be <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">Il valore predefinito in un <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> istanza creata con il costruttore senza parametri sarà <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> is defined in the object model as read-write.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> è definito nel modello a oggetti di lettura e scrittura.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>This is so <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> can be adjusted after initialization of the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
          <target state="translated">In tal caso <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> può essere modificato dopo l'inizializzazione del <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> oggetto stesso.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Tuttavia, dopo che i metadati vengono utilizzati come parte di una chiamata a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e le proprietà ora sono considerate immutabili.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Attempting to set <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph3">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Il tentativo di impostare <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> una volta <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> è <ph id="ph3">`true`</ph> i metadati di questa istanza verrà generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be set using either <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> or the constructor.</source>
          <target state="translated">Anche se è il valore predefinito per il costruttore senza parametri, un <ph id="ph1">`defaultValue`</ph> di <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> non può essere impostato utilizzando <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> o il costruttore.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Attempting to do so will raise an exception.</source>
          <target state="translated">Il tentativo di eseguire questa operazione verrà generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>XAML Text Usage</source>
          <target state="translated">Utilizzo di testo XAML</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Members of this type are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membri di questo tipo non vengono utilizzati in genere <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Cannot be set to the value <ph id="ph1">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph> once created.</source>
          <target state="translated">Non possono essere impostati sul valore <ph id="ph1">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph> successivamente alla creazione.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.DefaultValue">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Impossibile impostare una proprietà dei metadati dopo averla applicata a un'operazione relativa alla proprietà di dipendenza.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</source>
          <target state="translated">Ottiene un valore che determina se i metadati sono stati applicati a una proprietà in qualche modo e di conseguenza lo stato dell'istanza di metadati è diventato non modificabile.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the metadata instance is immutable; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'istanza di metadati non è modificabile; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>Various properties of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, such as <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, are defined in the object model as read-write.</source>
          <target state="translated">Varie proprietà di <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, ad esempio <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, sono definiti nel modello a oggetti di lettura e scrittura.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>This is so those properties can be adjusted after initialization of the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
          <target state="translated">Si tratta di tali proprietà possono essere modificate dopo l'inizializzazione del <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> oggetto stesso.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>However, once the metadata is applied to a dependency property as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Tuttavia, dopo aver applicato i metadati per una proprietà di dipendenza come parte di una chiamata a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e le proprietà ora sono considerate immutabili.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>At the time of one of these calls, <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</ph> is called, and the value of this property is set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Al momento di una di queste chiamate, <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</ph> viene chiamato e il valore di questa proprietà è impostato su <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.IsSealed">
          <source>The following example  checks <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> prior to a set operation of a custom metadata property.</source>
          <target state="translated">Nell'esempio seguente viene controllato <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> prima di un'operazione di impostazione di una proprietà di metadati personalizzati.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The base metadata to merge with this instance's values.</source>
          <target state="translated">Metadati di base da unire con i valori dell'istanza.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The dependency property to which this metadata is being applied.</source>
          <target state="translated">Proprietà di dipendenza alla quale vengono applicati i metadati.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Merges this metadata with the base metadata.</source>
          <target state="translated">Unisce i metadati con i metadati di base.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>This method is used internally when metadata is being overridden (<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method).</source>
          <target state="translated">Questo metodo viene utilizzato internamente durante l'override di metadati (<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> (metodo)).</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</source>
          <target state="translated">Nell'esempio seguente viene implementa un'operazione di unione per un tipo di metadati personalizzati che aggiunge una proprietà aggiuntiva per i metadati della proprietà.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Class implementations that derive from <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> should override this method to account for any metadata properties they have added in their implementations.</source>
          <target state="translated">Le implementazioni che derivano dalla classe <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> deve eseguire l'override di questo metodo per l'account per tutte le proprietà dei metadati che hanno aggiunto nelle rispettive implementazioni.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>For instance, your implementation might have added a new flagwise enumeration value, and the <ph id="ph1">&lt;see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementation should then be able to combine those flags correctly.</source>
          <target state="translated">Ad esempio, l'implementazione potrebbe essere aggiunto un nuovo valore di enumerazione flag per flag e <ph id="ph1">&lt;see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementazione deve quindi essere in grado di combinare correttamente tali flag.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> type.</source>
          <target state="translated">Chiamare sempre l'implementazione di base prima del codice di implementazione, perché l'implementazione di base si occupa dell'unione di tutte le proprietà già definite per il <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The exact behavior of the merge is up to you.</source>
          <target state="translated">Il comportamento dell'operazione di unione è responsabilità dell'utente.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</source>
          <target state="translated">È possibile scegliere di combinare i valori, ripristinare il valore di base se i metadati derivati sono stato mantenuti, il valore predefinito o molti altri comportamenti in base ai tipi di proprietà che aggiunte per la classe di metadati specifico e i relativi significati.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The dependency property to which the metadata has been applied.</source>
          <target state="translated">Proprietà di dipendenza alla quale sono stati applicati i metadati.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
          <target state="translated">Il tipo associato a questi metadati se questi sono metadati di tipo specifico.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>If this is default metadata, this value is a null reference.</source>
          <target state="translated">Se si tratta di metadati predefiniti, il valore è un riferimento null.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
          <target state="translated">Chiamata effettuata quando questi metadati sono stati applicati ad una proprietà che indica che i metadati sono sealed.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Subclasses should assure that any mutability of the data structure of a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> subclass should be marked as immutable once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</ph> is called.</source>
          <target state="translated">Le sottoclassi devono assicurare che qualsiasi mutabilità della struttura di dati di un <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> sottoclasse deve essere contrassegnata come non modificabile di una volta <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</ph> viene chiamato.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</source>
          <target state="translated">Questo evento viene chiamato dopo aver applicato i metadati per un'operazione di sistema di proprietà (registrare, aggiungere proprietario, eseguire l'override dei metadati).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>Gets or sets a reference to a <ph id="ph1">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> implementation specified in this metadata.</source>
          <target state="translated">Ottiene o imposta un riferimento a un'implementazione di <ph id="ph1">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> specificata nei metadati.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> implementation reference.</source>
          <target state="translated">Riferimento all'implementazione di <ph id="ph1">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
          <target state="translated">I callback nei metadati della proprietà non sono in genere membri pubblici nel tipo di definizione, pertanto il valore di questa proprietà non è importante per la maggior parte degli scenari che utilizzano solo i metadati della proprietà di dipendenza un'esistente.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>.</source>
          <target state="translated">È di un motivo per cui questa proprietà viene esposta in modo che le classi di metadati di eseguire la logica di unione desiderata se sia i metadati di base che si esegue l'override o l'aggiunta di metadati specificano un <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>The default merge logic for is to maintain all <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</source>
          <target state="translated">La logica di unione predefinita è la gestione di tutte <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> implementazioni in una tabella e la chiamata di ognuna, i callback stabiliti per la classe più in basso nella gerarchia in esecuzione.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> is defined in the object model as read-write.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> è definito nel modello a oggetti di lettura e scrittura.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>This is so <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> can be adjusted after initialization of the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
          <target state="translated">In tal caso <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> può essere modificato dopo l'inizializzazione del <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> oggetto stesso.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
          <target state="translated">Tuttavia, dopo che i metadati vengono utilizzati come parte di una chiamata a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e le proprietà ora sono considerate immutabili.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>Attempting to set <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph3">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Il tentativo di impostare <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> una volta <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> è <ph id="ph3">`true`</ph> i metadati di questa istanza verrà generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="P:System.Windows.PropertyMetadata.PropertyChangedCallback">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
          <target state="translated">Impossibile impostare una proprietà dei metadati dopo averla applicata a un'operazione relativa alla proprietà di dipendenza.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>