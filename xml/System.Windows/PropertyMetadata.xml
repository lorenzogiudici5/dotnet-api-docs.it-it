<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7bab463ec19438453c1818b250c1ed9bf8e3cb1f" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37490972" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="b640e-101">Definisce determinati aspetti del comportamento di una proprietà di dipendenza applicata a un tipo specifico, incluse le condizioni con cui è stata registrata.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b640e-101">Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b640e-102">I metadati della proprietà possono essere definito e usato durante la registrazione di proprietà di dipendenza quando si chiama il <xref:System.Windows.DependencyProperty.Register%2A> metodo (o varianti per le proprietà associate o le proprietà di dipendenza di sola lettura), o dopo la registrazione di proprietario originale quando si chiama la <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b640e-102">Property metadata can be defined and used during dependency property registration when calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> method.</span></span> <span data-ttu-id="b640e-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> accetta anche i metadati della proprietà.</span><span class="sxs-lookup"><span data-stu-id="b640e-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> also takes property metadata.</span></span>  
  
 <span data-ttu-id="b640e-104">Questa classe è una classe di base concreta che può essere usata in ognuna di queste chiamate.</span><span class="sxs-lookup"><span data-stu-id="b640e-104">This class is a concrete base class that can be used in each of these calls.</span></span> <span data-ttu-id="b640e-105">Tuttavia, è molto comune per specificare i metadati utilizzando una delle classi derivate, ad esempio <xref:System.Windows.FrameworkPropertyMetadata>.</span><span class="sxs-lookup"><span data-stu-id="b640e-105">However, it is very common to specify metadata using one of the derived classes such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="b640e-106">Queste classi derivate supportano più dettagliata dei metadati trasportata come valori di proprietà booleana, che sono utili per rilevare e abilitare alcuni comportamenti di layout e del sistema proprietà solo implementati nel [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] a livello di framework.</span><span class="sxs-lookup"><span data-stu-id="b640e-106">These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework level.</span></span>  
  
 <span data-ttu-id="b640e-107">Molte proprietà di questa classe sono in lettura / scrittura per il modello a oggetti, ma può essere scritta solo prima l'istanza utilizzata in un'operazione di sistema di proprietà, ad esempio <xref:System.Windows.DependencyProperty.Register%2A> o <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span><span class="sxs-lookup"><span data-stu-id="b640e-107">Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span></span> <span data-ttu-id="b640e-108">Ognuna di queste proprietà potrebbero inoltre essere impostate dal costruttore, ma vengono esposte in modo che <xref:System.Windows.PropertyMetadata.Merge%2A> implementazioni del metodo possono impostarle.</span><span class="sxs-lookup"><span data-stu-id="b640e-108">Each of these properties could also have been set by the constructor but are exposed so that <xref:System.Windows.PropertyMetadata.Merge%2A> method implementations can set them.</span></span>  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="b640e-109">Utilizzo di testo XAML</span><span class="sxs-lookup"><span data-stu-id="b640e-109">XAML Text Usage</span></span>  
 <span data-ttu-id="b640e-110">Questo tipo e i membri di questo tipo, non sono in genere usati [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b640e-110">This type, and members of this type, are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b640e-111">Inizializza una nuova istanza della classe <see cref="T:System.Windows.PropertyMetadata" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-111">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b640e-112">Inizializza una nuova istanza della classe <see cref="T:System.Windows.PropertyMetadata" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-112">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="b640e-113">Valore predefinito da specificare per una proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-113">The default value to specify for a dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b640e-114">Inizializza una nuova istanza della classe <see cref="T:System.Windows.PropertyMetadata" /> con un valore predefinito specificato per la proprietà di dipendenza a cui verranno applicati i metadati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-114">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with a specified default value for the dependency property that this metadata will be applied to.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b640e-115">Il tipo del valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati.</span><span class="sxs-lookup"><span data-stu-id="b640e-115">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="b640e-116">Mancate corrispondenze tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza per che viene applicato possono essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione (la mancata corrispondenza genereranno un'eccezione di run-time).</span><span class="sxs-lookup"><span data-stu-id="b640e-116">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="b640e-117">Anche se è il valore predefinito per il costruttore senza parametri, un `defaultValue` di <xref:System.Windows.DependencyProperty.UnsetValue> non può essere specificato.</span><span class="sxs-lookup"><span data-stu-id="b640e-117">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="b640e-118">Tentativo di eseguire questa operazione genererà un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b640e-118">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b640e-119">
            <paramref name="defaultValue" /> non può essere impostato sul valore <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-119">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">
          <span data-ttu-id="b640e-120">Riferimento a un'implementazione del gestore che il sistema di proprietà chiamerà a ogni modifica del valore effettivo della proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-120">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b640e-121">Inizializza una nuova istanza della classe  <see cref="T:System.Windows.PropertyMetadata" /> con il riferimento all'implementazione di <see cref="T:System.Windows.PropertyChangedCallback" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-121">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="b640e-122">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-122">The default value of the dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="b640e-123">Riferimento a un'implementazione del gestore che il sistema di proprietà chiamerà a ogni modifica del valore effettivo della proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-123">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b640e-124">Inizializza una nuova istanza della classe  <see cref="T:System.Windows.PropertyMetadata" /> con il valore predefinito e il riferimento all'implementazione di <see cref="T:System.Windows.PropertyChangedCallback" /> specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-124">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b640e-125">Il tipo del valore fornito `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati.</span><span class="sxs-lookup"><span data-stu-id="b640e-125">The type of the value provided `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="b640e-126">Mancate corrispondenze tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza per che viene applicato possono essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione (la mancata corrispondenza genereranno un'eccezione di run-time).</span><span class="sxs-lookup"><span data-stu-id="b640e-126">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="b640e-127">Anche se è il valore predefinito per il costruttore senza parametri, un `defaultValue` di <xref:System.Windows.DependencyProperty.UnsetValue> non può essere specificato.</span><span class="sxs-lookup"><span data-stu-id="b640e-127">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="b640e-128">Tentativo di eseguire questa operazione genererà un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b640e-128">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b640e-129">
            <paramref name="defaultValue" /> non può essere impostato sul valore <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-129">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="b640e-130">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-130">The default value of the dependency property, usually provided as a value of some specific type.</span>
          </span>
        </param>
        <param name="propertyChangedCallback">
          <span data-ttu-id="b640e-131">Riferimento a un'implementazione del gestore che il sistema di proprietà chiamerà a ogni modifica del valore effettivo della proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-131">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span>
          </span>
        </param>
        <param name="coerceValueCallback">
          <span data-ttu-id="b640e-132">Riferimento a un'implementazione del gestore che verrà chiamata ogni volta che il sistema di proprietà chiama <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> per la proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-132">Reference to a handler implementation that is to be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b640e-133">Inizializza una nuova istanza della classe <see cref="T:System.Windows.PropertyMetadata" />, con il valore predefinito e i callback specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-133">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and callbacks.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b640e-134">Se si desidera specificare una <xref:System.Windows.CoerceValueCallback> ma non una <xref:System.Windows.PropertyChangedCallback>, è possibile passare `null` per il `propertyChangedCallback` parametro.</span><span class="sxs-lookup"><span data-stu-id="b640e-134">If you want to specify a <xref:System.Windows.CoerceValueCallback> but not a <xref:System.Windows.PropertyChangedCallback>, you can pass `null` for the `propertyChangedCallback` parameter.</span></span>  
  
 <span data-ttu-id="b640e-135">Il tipo del valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati.</span><span class="sxs-lookup"><span data-stu-id="b640e-135">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="b640e-136">Mancate corrispondenze tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza per che viene applicato possono essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione (la mancata corrispondenza genereranno un'eccezione di run-time).</span><span class="sxs-lookup"><span data-stu-id="b640e-136">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="b640e-137">Anche se è il valore predefinito per il costruttore senza parametri, un `defaultValue` di <xref:System.Windows.DependencyProperty.UnsetValue> non può essere specificato.</span><span class="sxs-lookup"><span data-stu-id="b640e-137">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="b640e-138">Tentativo di eseguire questa operazione genererà un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b640e-138">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b640e-139">
            <paramref name="defaultValue" /> non può essere impostato sul valore <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-139">
              <paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b640e-140">Ottiene o imposta un riferimento a un'implementazione di <see cref="T:System.Windows.CoerceValueCallback" /> specificata nei metadati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-140">Gets or sets a reference to a <see cref="T:System.Windows.CoerceValueCallback" /> implementation specified in this metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b640e-141">Riferimento all'implementazione di <see cref="T:System.Windows.CoerceValueCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-141">A <see cref="T:System.Windows.CoerceValueCallback" /> implementation reference.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b640e-142">I callback nei metadati della proprietà non sono in genere membri pubblici nel tipo contenitore, pertanto il valore di questa proprietà non è importante per la maggior parte degli scenari che utilizzano solo i metadati della proprietà di dipendenza un'esistente.</span><span class="sxs-lookup"><span data-stu-id="b640e-142">The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="b640e-143">Un motivo per cui questa proprietà viene visualizzata sia in modo che le sottoclassi di metadati di eseguire la logica di unione desiderato se viene sottoposto a override o l'aggiunta dei metadati sia i metadati di base specificano un <xref:System.Windows.CoerceValueCallback>.</span><span class="sxs-lookup"><span data-stu-id="b640e-143">One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="b640e-144">Tuttavia, il valore predefinito merge per la logica per un <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> consiste nel sostituire quella precedente.</span><span class="sxs-lookup"><span data-stu-id="b640e-144">However, the default merge logic for a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is to replace the previous one.</span></span>  
  
 <span data-ttu-id="b640e-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> è definito nel modello a oggetti in lettura e scrittura.</span><span class="sxs-lookup"><span data-stu-id="b640e-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="b640e-146">In tal caso <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> può essere modificato dopo l'inizializzazione del <xref:System.Windows.PropertyMetadata> oggetto stesso.</span><span class="sxs-lookup"><span data-stu-id="b640e-146">This is so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="b640e-147">Tuttavia, dopo che i metadati vengono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e le proprietà sono ora considerate immutabili.</span><span class="sxs-lookup"><span data-stu-id="b640e-147">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="b640e-148">Tentativo di impostare <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> una volta <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b640e-148">Attempting to set <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b640e-149">Impossibile impostare una proprietà dei metadati dopo averla applicata a un'operazione relativa alla proprietà di dipendenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-149">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b640e-150">Ottiene o imposta il valore predefinito della proprietà di dipendenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-150">Gets or sets the default value of the dependency property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b640e-151">Valore predefinito della proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-151">The default value of the property.</span>
          </span>
          <span data-ttu-id="b640e-152">Il valore predefinito in un <see cref="T:System.Windows.PropertyMetadata" /> istanza creata con il costruttore senza parametri sarà <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-152">The default value on a <see cref="T:System.Windows.PropertyMetadata" /> instance created with the parameterless constructor will be <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b640e-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> è definito nel modello a oggetti in lettura e scrittura.</span><span class="sxs-lookup"><span data-stu-id="b640e-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="b640e-154">In tal caso <xref:System.Windows.PropertyMetadata.DefaultValue%2A> può essere modificato dopo l'inizializzazione del <xref:System.Windows.PropertyMetadata> oggetto stesso.</span><span class="sxs-lookup"><span data-stu-id="b640e-154">This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="b640e-155">Tuttavia, dopo che i metadati vengono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e le proprietà sono ora considerate immutabili.</span><span class="sxs-lookup"><span data-stu-id="b640e-155">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="b640e-156">Tentativo di impostare <xref:System.Windows.PropertyMetadata.DefaultValue%2A> una volta <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b640e-156">Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 <span data-ttu-id="b640e-157">Anche se è il valore predefinito per il costruttore senza parametri, un `defaultValue` dei <xref:System.Windows.DependencyProperty.UnsetValue> non può essere impostata usando <xref:System.Windows.PropertyMetadata.DefaultValue%2A> o il costruttore.</span><span class="sxs-lookup"><span data-stu-id="b640e-157">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor.</span></span> <span data-ttu-id="b640e-158">Tentativo di eseguire questa operazione genererà un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b640e-158">Attempting to do so will raise an exception.</span></span>  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="b640e-159">Utilizzo di testo XAML</span><span class="sxs-lookup"><span data-stu-id="b640e-159">XAML Text Usage</span></span>  
 <span data-ttu-id="b640e-160">I membri di questo tipo non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b640e-160">Members of this type are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b640e-161">Non possono essere impostati sul valore <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> successivamente alla creazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-161">Cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> once created.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b640e-162">Impossibile impostare una proprietà dei metadati dopo averla applicata a un'operazione relativa alla proprietà di dipendenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-162">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b640e-163">Ottiene un valore che determina se i metadati sono stati applicati a una proprietà in qualche modo e di conseguenza lo stato dell'istanza di metadati è diventato non modificabile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-163">Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b640e-164">
            <see langword="true" /> se l'istanza di metadati non è modificabile; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-164">
              <see langword="true" /> if the metadata instance is immutable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b640e-165">Varie proprietà del <xref:System.Windows.PropertyMetadata>, ad esempio <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, sono definite nel modello a oggetti in lettura e scrittura.</span><span class="sxs-lookup"><span data-stu-id="b640e-165">Various properties of <xref:System.Windows.PropertyMetadata>, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are defined in the object model as read-write.</span></span> <span data-ttu-id="b640e-166">Si tratta in modo che tali proprietà possono essere modificate dopo l'inizializzazione del <xref:System.Windows.PropertyMetadata> oggetto stesso.</span><span class="sxs-lookup"><span data-stu-id="b640e-166">This is so those properties can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="b640e-167">Tuttavia, dopo aver applicato i metadati per una proprietà di dipendenza come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e le proprietà sono ora considerate immutabili.</span><span class="sxs-lookup"><span data-stu-id="b640e-167">However, once the metadata is applied to a dependency property as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="b640e-168">Al momento di una di queste chiamate <xref:System.Windows.PropertyMetadata.OnApply%2A> viene chiamato, e il valore di questa proprietà è impostato su `true`.</span><span class="sxs-lookup"><span data-stu-id="b640e-168">At the time of one of these calls, <xref:System.Windows.PropertyMetadata.OnApply%2A> is called, and the value of this property is set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b640e-169">Nell'esempio seguente viene controllato <xref:System.Windows.PropertyMetadata.IsSealed%2A> prima un'operazione di impostazione di una proprietà di metadati personalizzati.</span><span class="sxs-lookup"><span data-stu-id="b640e-169">The following example  checks <xref:System.Windows.PropertyMetadata.IsSealed%2A> prior to a set operation of a custom metadata property.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">
          <span data-ttu-id="b640e-170">Metadati di base da unire con i valori dell'istanza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-170">The base metadata to merge with this instance's values.</span>
          </span>
        </param>
        <param name="dp">
          <span data-ttu-id="b640e-171">Proprietà di dipendenza alla quale vengono applicati i metadati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-171">The dependency property to which this metadata is being applied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b640e-172">Unisce i metadati con i metadati di base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-172">Merges this metadata with the base metadata.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b640e-173">Questo metodo viene usato internamente quando sono in corso l'override dei metadati (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> (metodo)).</span><span class="sxs-lookup"><span data-stu-id="b640e-173">This method is used internally when metadata is being overridden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b640e-174">L'esempio seguente implementa un'operazione di merge per un tipo di metadati personalizzato che aggiunge una proprietà aggiuntiva per i metadati della proprietà.</span><span class="sxs-lookup"><span data-stu-id="b640e-174">The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="b640e-175">
            <para>Le implementazioni che derivano dalla classe <see cref="T:System.Windows.PropertyMetadata" /> deve eseguire l'override di questo metodo per conto di qualsiasi proprietà di metadati che sono aggiunti nelle rispettive implementazioni. Ad esempio, l'implementazione potrebbe avere aggiunto un nuovo valore di enumerazione flag per flag e il <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementazione dovrebbe quindi essere in grado di combinare correttamente i flag.  Chiamare sempre l'implementazione di base prima del codice di implementazione, poiché l'implementazione di base si occupa di unione di tutte le proprietà già definite nel <see cref="T:System.Windows.PropertyMetadata" /> tipo.  Il comportamento esatto del merge è responsabilità dell'utente. È possibile scegliere di combinare i valori, verranno ripristinate al valore di base se i metadati derivati sono stati lasciati l'impostazione predefinita e molti altri comportamenti in base ai tipi di proprietà che è stato aggiunto per la classe di metadati specifico e i relativi significati.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-175">
              <para>Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations. For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.  Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.  The exact behavior of the merge is up to you. You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="b640e-176">Proprietà di dipendenza alla quale sono stati applicati i metadati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-176">The dependency property to which the metadata has been applied.</span>
          </span>
        </param>
        <param name="targetType">
          <span data-ttu-id="b640e-177">Il tipo associato a questi metadati se questi sono metadati di tipo specifico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-177">The type associated with this metadata if this is type-specific metadata.</span>
          </span>
          <span data-ttu-id="b640e-178">Se si tratta di metadati predefiniti, il valore è un riferimento null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-178">If this is default metadata, this value is a null reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b640e-179">Chiamata effettuata quando questi metadati sono stati applicati ad una proprietà che indica che i metadati sono sealed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-179">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b640e-180">Le sottoclassi devono assicurare che eventuali modificabilità della struttura dei dati di un <xref:System.Windows.PropertyMetadata> sottoclasse deve essere contrassegnata come non modificabile di una volta <xref:System.Windows.PropertyMetadata.OnApply%2A> viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="b640e-180">Subclasses should assure that any mutability of the data structure of a <xref:System.Windows.PropertyMetadata> subclass should be marked as immutable once <xref:System.Windows.PropertyMetadata.OnApply%2A> is called.</span></span> <span data-ttu-id="b640e-181">Questo evento viene chiamato dopo che i metadati vengano applicato a un'operazione di sistema di proprietà (registrazione, aggiungere un proprietario, eseguire l'override dei metadati).</span><span class="sxs-lookup"><span data-stu-id="b640e-181">This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b640e-182">Ottiene o imposta un riferimento a un'implementazione di <see cref="T:System.Windows.PropertyChangedCallback" /> specificata nei metadati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-182">Gets or sets a reference to a <see cref="T:System.Windows.PropertyChangedCallback" /> implementation specified in this metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b640e-183">Riferimento all'implementazione di <see cref="T:System.Windows.PropertyChangedCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-183">A <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b640e-184">I callback nei metadati della proprietà non sono in genere membri pubblici nel tipo di definizione, pertanto il valore di questa proprietà non è importante per la maggior parte degli scenari che utilizzano solo i metadati della proprietà di dipendenza un'esistente.</span><span class="sxs-lookup"><span data-stu-id="b640e-184">The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="b640e-185">Un motivo per cui questa proprietà viene visualizzata sia in modo che le classi di metadati possono eseguire la logica di unione desiderato se viene sottoposto a override o l'aggiunta dei metadati sia i metadati di base specificano un <xref:System.Windows.PropertyChangedCallback>.</span><span class="sxs-lookup"><span data-stu-id="b640e-185">One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="b640e-186">La logica di unione predefinita consiste nel mantenere tutti <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementazioni in una tabella e ogni chiamata di esse, con i callback stabiliti dalla classe più in basso nella gerarchia che esegue prima.</span><span class="sxs-lookup"><span data-stu-id="b640e-186">The default merge logic for is to maintain all <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</span></span>  
  
 <span data-ttu-id="b640e-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> è definito nel modello a oggetti in lettura e scrittura.</span><span class="sxs-lookup"><span data-stu-id="b640e-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="b640e-188">In tal caso <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> può essere modificato dopo l'inizializzazione del <xref:System.Windows.PropertyMetadata> oggetto stesso.</span><span class="sxs-lookup"><span data-stu-id="b640e-188">This is so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="b640e-189">Tuttavia, dopo che i metadati vengono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e le proprietà sono ora considerate immutabili.</span><span class="sxs-lookup"><span data-stu-id="b640e-189">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="b640e-190">Tentativo di impostare <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> una volta <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b640e-190">Attempting to set <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="b640e-191">Impossibile impostare una proprietà dei metadati dopo averla applicata a un'operazione relativa alla proprietà di dipendenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b640e-191">Cannot set a metadata property once it is applied to a dependency property operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>