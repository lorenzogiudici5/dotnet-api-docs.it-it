<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f336eba4edb0ad64b57c0fcad8979eddefe757d8" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39808282" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un oggetto che fa parte del sistema di proprietà di dipendenza.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.DependencyObject> classe abilita [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] servizi del sistema di proprietà nelle varie classi derivate.  
  
 Funzione principale del sistema di proprietà è per calcolare i valori delle proprietà e per fornire la notifica di sistema sui valori che sono stati modificati. Un'altra classe principale che partecipa al sistema di proprietà è <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> Abilita la registrazione delle proprietà di dipendenza nel sistema di proprietà e vengono fornite informazioni di identificazione e su ogni proprietà di dipendenza, mentre <xref:System.Windows.DependencyObject> come una classe di base consente agli oggetti di usare le proprietà di dipendenza.  
  
 <xref:System.Windows.DependencyObject> servizi e le caratteristiche seguenti:  
  
-   Supporto per l'hosting di proprietà di dipendenza. Si registra una proprietà di dipendenza chiamando il <xref:System.Windows.DependencyProperty.Register%2A> (metodo) e l'archiviazione di valore restituito del metodo come un campo statico pubblico della classe.  
  
-   Supporto per l'hosting proprietà associata. Si registra una proprietà associata chiamando il <xref:System.Windows.DependencyProperty.RegisterAttached%2A> (metodo) e l'archiviazione di valore restituito del metodo come un campo di sola lettura statico pubblico della classe. (Sono inoltre presenti requisiti di altri membri; si noti che questo rappresenti un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementazione specifica per le proprietà associate. Per informazioni dettagliate, vedere [Cenni preliminari sulle proprietà associate](~/docs/framework/wpf/advanced/attached-properties-overview.md).) La proprietà associata può quindi essere impostata su qualsiasi classe che deriva da <xref:System.Windows.DependencyObject>.  
  
-   Get, set e deselezionare i metodi di utilità per i valori di qualsiasi proprietà di dipendenza che esiste nel <xref:System.Windows.DependencyObject>.  
  
-   I metadati, soggetti a coercizione supporto dei valori, la notifica di modifica proprietà e i callback di sostituzione per le proprietà di dipendenza o le proprietà associate. Inoltre, il <xref:System.Windows.DependencyObject> classe facilita i metadati della proprietà per ogni proprietario di una proprietà di dipendenza.  
  
-   Una classe di base comune per le classi derivate da <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, o <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, un'altra classe di elementi di base, ha una gerarchia di classi che include <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 L'esempio seguente deriva dalla <xref:System.Windows.DependencyObject> per creare una nuova classe astratta. La classe quindi Registra una proprietà associata e include i membri di supporto per la proprietà associata.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cancella il valore locale di una proprietà.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Proprietà di dipendenza da cancellare, identificata da un riferimento a un oggetto <see cref="T:System.Windows.DependencyProperty" />.</param>
        <summary>Cancella il valore locale di una proprietà. La proprietà da cancellare è specificata da un identificatore <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cancellare il valore della proprietà chiamando <xref:System.Windows.DependencyObject.ClearValue%2A> non necessariamente assegnare una proprietà di dipendenza il valore predefinito specificato nei metadati della proprietà di dipendenza. Deselezionare la proprietà solo in particolare Cancella qualsiasi valore locale sono stati applicati. Per altre informazioni, vedere [Precedenza del valore della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Nell'esempio seguente esegue l'iterazione di tutte le proprietà che presentano valori locali impostati su un oggetto, quindi chiama <xref:System.Windows.DependencyObject.ClearValue%2A> per cancellare i valori di tali proprietà.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si è tentato di chiamare <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> in un oggetto <see cref="T:System.Windows.DependencyObject" /> sealed.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Chiave per la proprietà di dipendenza da cancellare.</param>
        <summary>Cancella il valore locale di una proprietà di sola lettura. La proprietà da cancellare è specificata da un oggetto <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.DependencyPropertyKey> identifica una proprietà di dipendenza di sola lettura per le operazioni di sistema di proprietà. Le classi che definiscono le proprietà di dipendenza di sola lettura non devono esporre questa chiave con accesso pubblico. Una chiave esposta pubblicamente fornisce un percorso di code pubbliche che nega il carattere di sola lettura della proprietà, se i metodi come <xref:System.Windows.DependencyObject.ClearValue%2A> o <xref:System.Windows.DependencyObject.SetValue%2A> può essere chiamata all'esterno della classe o un assembly, facendo riferimento alla chiave.  
  
 Cancellare il valore della proprietà chiamando <xref:System.Windows.DependencyObject.ClearValue%2A> non necessariamente assegnare una proprietà di dipendenza il valore predefinito specificato nei metadati della proprietà di dipendenza. Cancellazione del valore in modo specifico solo Cancella qualsiasi valore locale sono stati applicati. Per altre informazioni, vedere [Precedenza del valore della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si è tentato di chiamare <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> in un oggetto <see cref="T:System.Windows.DependencyObject" /> sealed.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificatore della proprietà di dipendenza da assegnare forzatamente.</param>
        <summary>Assegna forzatamente il valore della proprietà di dipendenza specificata. Questa operazione viene eseguita richiamando qualsiasi funzione <see cref="T:System.Windows.CoerceValueCallback" /> specificata nei metadati della proprietà di dipendenza esistente nell'oggetto <see cref="T:System.Windows.DependencyObject" /> chiamante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oltre a essere richiamato in modo esplicito tramite la chiamata <xref:System.Windows.DependencyObject.CoerceValue%2A>, il <xref:System.Windows.CoerceValueCallback> una dipendenza da proprietà inoltre viene chiamata internamente ogni volta che il valore di proprietà di dipendenza viene rivalutato dal [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema di proprietà.  
  
 Quando si richiama il <xref:System.Windows.DependencyObject.CoerceValue%2A> metodo, si richiama il callback soggetti a coercizione del valore della proprietà specificato. In genere si richiamerà <xref:System.Windows.DependencyObject.CoerceValue%2A> solo se si sa che esista un callback di soggetti a coercizione del valore, e se si conoscono i criteri del callback per l'assegnazione forzata.  
  
 Lo scenario più comune per la chiamata <xref:System.Windows.DependencyObject.CoerceValue%2A> si trova all'interno di callback di modifica di proprietà o la gestione delle classe di proprietà correlate che influenzano i rispettivi valori in modo dipendente. Per altre informazioni, vedere [Callback e convalida delle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene chiamato <xref:System.Windows.DependencyObject.CoerceValue%2A> all'interno di un <xref:System.Windows.PropertyChangedCallback> implementazione che viene utilizzato come il <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> per una proprietà di dipendenza diverse sulla stessa classe. Si tratta di un modello comune per introdurre il valore true dipendenze tra le proprietà di dipendenza.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il parametro <paramref name="dp" /> specificato o il relativo valore non è valido o non esiste.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la classe <see cref="T:System.Windows.DependencyObjectType" /> che include il tipo [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] di questa istanza.</summary>
        <value>Classe <see cref="T:System.Windows.DependencyObjectType" /> che include il tipo [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] di questa istanza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è utile se un oggetto restituito da un metodo ha un tipo di valore restituito di <xref:System.Windows.DependencyObject> e si desidera eseguire proprietà sistema specifiche operazioni su di esso a seconda del tipo. Ad esempio risulta più efficiente per chiamare <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> usando il <xref:System.Windows.DependencyObjectType> anziché il [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] tipo. <xref:System.Windows.DependencyObjectType> facilita le ricerche più veloci.  
  
   
  
## Examples  
 Nell'esempio seguente pseudocodice `MySubClass` preannuncia che altre classi derivate potrebbero modificare il valore predefinito di `MyCustom` proprietà di dipendenza. La classe implementa un costruttore predefinito che può determinare l'effettiva classe derivata sfruttando i vantaggi di polimorfismo <xref:System.Windows.DependencyObjectType> valore ogni volta che il costruttore viene utilizzato come instantiator una classe derivata.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto <see cref="T:System.Windows.DependencyObject" /> da confrontare con l'istanza corrente.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Windows.DependencyObject" /> specificato equivale all'oggetto <see cref="T:System.Windows.DependencyObject" /> corrente.</summary>
        <returns>
          <see langword="true" /> se le due istanze sono uguali. In caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione è solo l'uguaglianza dei riferimenti e non tenta di valutare l'uguaglianza di valori delle proprietà contenute.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> esegue l'override e quindi esegue il sealing basic due <see cref="T:System.Object" /> metodi: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> e <see cref="M:System.Windows.DependencyObject.GetHashCode" />. La chiamata esegue l'override di <see cref="T:System.Object" /> implementazioni, determinando un comportamento di verificarne l'uguaglianza di oggetti. Lo scopo di questi override intenzionali è impedire che le classi derivate tenti di definire l'uguaglianza di un valore per un <see cref="T:System.Windows.DependencyObject" />. Predicati di uguaglianza per valore <see cref="T:System.Windows.DependencyObject" /> mai saranno accurati a causa delle funzionalità Modifica valore proprietà innata di un <see cref="T:System.Windows.DependencyObject" /> e le relative proprietà di dipendenza. Ciò include fondamentali [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funzionalità quali associazione dati e di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema di proprietà.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un codice hash per l'oggetto <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Codice hash di valori interi a 32 bit con segno.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> esegue l'override e quindi esegue il sealing due <see cref="T:System.Object" /> metodi: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> e <see cref="M:System.Windows.DependencyObject.GetHashCode" />. La chiamata esegue l'override di <see cref="T:System.Object" /> implementazioni, determinando un comportamento di verificarne l'uguaglianza di oggetti. Lo scopo di questi override intenzionali è impedire che le classi derivate tenti di definire l'uguaglianza di un valore per un <see cref="T:System.Windows.DependencyObject" />. Predicati di uguaglianza per valore <see cref="T:System.Windows.DependencyObject" /> mai saranno accurati a causa delle funzionalità Modifica valore proprietà innata di un <see cref="T:System.Windows.DependencyObject" /> e le relative proprietà di dipendenza. Ciò include fondamentali [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funzionalità quali associazione dati e di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema di proprietà.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un enumeratore specializzato per determinare le proprietà di dipendenza che presentano valori impostati localmente nell'oggetto <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Enumeratore specializzato dei valori locali.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto *valore locale* è qualsiasi valore di proprietà di dipendenza che è stato impostato da <xref:System.Windows.DependencyObject.SetValue%2A>, a differenza di altri aspetti del sistema di proprietà.  
  
 Il <xref:System.Windows.LocalValueEnumerator> ottenuto chiamando <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> può essere utilizzato per enumerare le proprietà che hanno impostato localmente valore su un <xref:System.Windows.DependencyObject> istanza. Ogni proprietà è rappresentata nell'enumeratore per un <xref:System.Windows.LocalValueEntry> object, che contiene proprietà che fanno riferimento le specifiche <xref:System.Windows.DependencyProperty> e i relativi valori. Questa tecnica dell'enumerazione impostata localmente valori utilizzabile per l'ottimizzazione o per la gestione di altro tipo di valori locali, ad esempio per determinare quali valori di proprietà di un <xref:System.Windows.DependencyObject> cambierebbe se cancellati.  
  
> [!IMPORTANT]
>  L'oggetto restituito <xref:System.Windows.LocalValueEnumerator> potrebbe contenere <xref:System.Windows.LocalValueEntry> record per le proprietà di dipendenza che sono di sola lettura, o le proprietà di dipendenza in cui i valori vengono calcolati dal sistema di proprietà. Ad esempio, un elemento del framework visual con una larghezza stabilita tramite layout segnalerà un valore locale per <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Se si ricevono i valori locali al fine di reimpostarli, controllare la <xref:System.Windows.DependencyProperty.ReadOnly%2A> valore nell'identificatore di proprietà della ognuno <xref:System.Windows.LocalValueEntry> per verificare che il <xref:System.Windows.DependencyProperty> in questione non è in sola lettura.  
  
   
  
## Examples  
 Nell'esempio seguente esegue l'iterazione di tutte le proprietà che presentano valori locali impostati su un oggetto, quindi chiama <xref:System.Windows.DependencyObject.ClearValue%2A> per cancellare i valori di tali proprietà.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificatore <see cref="T:System.Windows.DependencyProperty" /> della proprietà per cui recuperare il valore.</param>
        <summary>Restituisce il valore effettivo corrente di una proprietà di dipendenza in questa istanza di <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Restituisce il valore effettivo corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il *il valore effettivo* è il valore della proprietà che qualsiasi chiamante che sta richiedendo il valore viene restituito dal sistema di proprietà. Il valore effettivo è il risultato del sistema di proprietà avere valutato tutte le possibili input che partecipano alla precedenza dei valori di sistema di proprietà. Ciò include la coercizione e animazione. Per altre informazioni, vedere [Precedenza del valore della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Questo metodo non restituisce mai <xref:System.Windows.DependencyProperty.UnsetValue>. Il <xref:System.Windows.DependencyProperty.UnsetValue> è un valore di sentinel per il sistema di proprietà che viene usato in varie capacità internamente e talvolta anche esposta tramite i callback di coercizione.  
  
 Se non si conosce ciò che deve essere il tipo della proprietà, è possibile eseguire una query l'identificatore della proprietà di dipendenza richiesta per determinare se è presente una specifica più <xref:System.Windows.DependencyProperty.PropertyType%2A> che il valore restituito può essere convertito in.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il parametro <paramref name="dp" /> specificato o il relativo valore non è valido oppure il parametro <paramref name="dp" /> non esiste.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">L’identificatore <see cref="T:System.Windows.DependencyProperty" /> della proprietà di dipendenza da invalidare.</param>
        <summary>Valuta di nuovo il valore effettivo della proprietà di dipendenza specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama <xref:System.Windows.DependencyObject.InvalidateProperty%2A>associati e qualsiasi applicabili <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funzioni registrato per quella proprietà di dipendenza può essere richiamato.  
  
 La chiamata a <xref:System.Windows.DependencyObject.InvalidateProperty%2A> su una proprietà che è stato impostato il valore locale avrà alcun effetto, poiché il valore locale ha la precedenza su altri input di sistema di proprietà, ad eccezione delle animazioni. Tuttavia, è possibile chiamare <xref:System.Windows.DependencyObject.ClearValue%2A>, quindi chiamare <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Per altre informazioni, vedere [Precedenza del valore della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 La chiamata a <xref:System.Windows.DependencyObject.InvalidateProperty%2A> non è necessariamente applicabili per molti scenari di proprietà di dipendenza. Se una proprietà di dipendenza viene invalidata a causa di modifiche dei valori in uno dei componenti, il sistema di proprietà invalida e Rivaluta automaticamente la proprietà di dipendenza. Tuttavia, esistono ancora alcuni scenari appropriate in cui <xref:System.Windows.DependencyObject.InvalidateProperty%2A> è utile. In particolare, è possibile usare <xref:System.Windows.DependencyObject.InvalidateProperty%2A> all'interno di valori soggetti a coercizione o di proprietà modificata callback per una proprietà di dipendenza diverse. È anche possibile usare <xref:System.Windows.DependencyObject.InvalidateProperty%2A> per forzare la rivalutazione di un'associazione in un'origine dati che non è in grado di implementare l'elemento consigliato <xref:System.ComponentModel.INotifyPropertyChanged> meccanismo di notifica (ad esempio se utilizzano le classi di dati che non può essere derivato da o in cui i dati sono un valore statico membro).  
  
   
  
## Examples  
 L'esempio seguente chiama <xref:System.Windows.DependencyObject.InvalidateProperty%2A> su una proprietà personalizzata, ogni volta che le proprietà che sono coinvolti nei calcoli della proprietà invalidata modificare. Si tratta di una tecnica alternativa alla chiamata di <xref:System.Windows.DependencyObject.CoerceValue%2A> metodo, in quanto invalidando le proprietà vengono chiamati anche qualsiasi registrato <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'istanza è attualmente sealed (di sola lettura).</summary>
        <value>
          <see langword="true" /> se l'istanza è sealed. In caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo valore è impostato internamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento che conterranno l'identificatore della proprietà di dipendenza di interesse, i metadati della proprietà per il tipo e i valori precedenti e nuovi.</param>
        <summary>Richiamato ogni volta che il valore effettivo di una qualsiasi proprietà di dipendenza di questo oggetto <see cref="T:System.Windows.DependencyObject" /> viene aggiornato. La proprietà di dipendenza specifica modificata viene indicata nei dati dell'evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è in genere rileva le modifiche alle singole proprietà o di eseguire le convalide delle proprietà per ogni caso. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> è invece destinato alle modifiche del criterio di invalidamento generale, se sono noto che alcune informazioni sulle classificazioni a livello delle proprietà. Ad esempio, viene modificato una <xref:System.Windows.Freezable> potrebbero essere modifiche nei tipi di valore del <xref:System.Windows.Freezable>, o potrebbe essere sottoproprietà, in cui le modifiche sono all'interno di altri <xref:System.Windows.Freezable> riferimenti. Il <xref:System.Windows.Freezable> eseguire l'override dell'implementazione <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> utilizza le informazioni interne per determinare se le proprietà sono le sottoproprietà e fornisce la logica di classe di base appropriata per entrambi i casi.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> viene richiamato potenzialmente più volte nel corso della durata di un oggetto. Pertanto, è possibile ottenere prestazioni migliorate per il sistema di proprietà complessivo se esegue l'override di metadati di proprietà specifiche e quindi collegarli <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funzioni per le singole proprietà. Questo metodo, tuttavia, è consigliabile se un <xref:System.Windows.DependencyObject> include un numero significativo di proprietà di dipendenza correlata al valore, o se ne include la logica, ad esempio il comportamento di rendering, che deve essere ripetuto per molti casi di convalide di proprietà correlati.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Chiamare sempre l'implementazione di base. Errore eseguire questa operazione disabiliterà in modo significativo l'intera [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema di proprietà, provocando valori non corretti da segnalare.</para>
        </block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificatore <see cref="T:System.Windows.DependencyProperty" /> della proprietà per cui recuperare il valore.</param>
        <summary>Restituisce il valore locale di una proprietà di dipendenza, se presente.</summary>
        <returns>Restituisce il valore locale oppure il valore sentinel <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> se non è impostato alcun valore locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È consigliabile usare <xref:System.Windows.DependencyObject.GetValue%2A> per le operazioni più comuni "get" per una proprietà di dipendenza. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> non restituisce il valore effettivo per un'ampia gamma di casi in cui il valore non è impostato localmente.  
  
 I valori impostati per gli stili, temi, modelli, il valore predefinito da metadati o ereditarietà del valore della proprietà non sono considerati sia i valori locali. Tuttavia, associazioni e altre espressioni sono considerati sia i valori locali, dopo che sono state valutate.  
  
 Quando è impostato alcun valore locale, questo metodo restituisce <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Se il valore restituito è diverso da <xref:System.Windows.DependencyProperty.UnsetValue>, è possibile eseguire una query di metadati della proprietà di dipendenza richiesta per determinare se è presente un tipo più specifico che il valore restituito può essere convertito in.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Identificatore della proprietà di dipendenza da impostare.</param>
        <param name="value">Nuovo valore locale.</param>
        <summary>Imposta il valore di una proprietà di dipendenza senza modificare l'origine del valore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato da un componente che a livello di codice imposta il valore di una delle sue proprietà senza disabilitare uso dichiarato di un'applicazione della proprietà. Il <xref:System.Windows.DependencyObject.SetCurrentValue%2A> metodo modifica il valore effettivo della proprietà, ma i trigger esistenti, data binding e stili continueranno a funzionare.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">È stato effettuato un tentativo di modificare una proprietà di dipendenza di sola lettura o una proprietà in un oggetto <see cref="T:System.Windows.DependencyObject" /> sealed.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> non è il tipo corretto registrato per la proprietà <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta il valore locale di una proprietà di dipendenza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Identificatore della proprietà di dipendenza da impostare.</param>
        <param name="value">Nuovo valore locale.</param>
        <summary>Imposta il valore locale di una proprietà di dipendenza, specificato dal relativo identificatore della proprietà di dipendenza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il tipo fornito non corrisponde al tipo dichiarato della proprietà di dipendenza in cui è stata originariamente registrata, viene generata un'eccezione. Il `value` parametro deve sempre essere fornito come il tipo appropriato.  
  
 Le condizioni di eccezione sono potenzialmente influenzate dal <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> callback che è presente nell'identificatore di proprietà di dipendenza della proprietà di dipendenza da impostare. In caso contrario, il valore fornito non riesca condizioni generali di controllo del tipo (ad esempio, passando una stringa quando il tipo nativo è Double).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">È stato effettuato un tentativo di modificare una proprietà di dipendenza di sola lettura o una proprietà in un oggetto <see cref="T:System.Windows.DependencyObject" /> sealed.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> non è il tipo corretto registrato per la proprietà <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Identificatore <see cref="T:System.Windows.DependencyPropertyKey" /> della proprietà da impostare.</param>
        <param name="value">Nuovo valore locale.</param>
        <summary>Imposta il valore locale di una proprietà di dipendenza di sola lettura, specificato dall'identificatore <see cref="T:System.Windows.DependencyPropertyKey" /> della proprietà di dipendenza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa firma viene in genere utilizzata quando si impostano i valori per le proprietà di dipendenza di sola lettura che sono definiti dalle classi personalizzate. In generale, <xref:System.Windows.DependencyObject.SetValue%2A> viene chiamato solo dal tipo registrato la proprietà di dipendenza, che implementa la logica interna che fornisce il valore della proprietà di dipendenza. Per altre informazioni, vedere [Proprietà di dipendenza di sola lettura](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Se il tipo fornito non corrisponde al tipo dichiarato della proprietà di dipendenza in cui è stata originariamente registrata, viene generata un'eccezione. Il `value` parametro deve sempre essere fornito come il tipo appropriato. Le condizioni di eccezione sono potenzialmente influenzate dal <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> callback che è presente nell'identificatore di proprietà di dipendenza della proprietà di dipendenza da impostare.  
  
   
  
## Examples  
 L'esempio seguente definisce una proprietà di dipendenza di sola lettura, insieme a un `public static readonly` <xref:System.Windows.DependencyProperty> che fornisce l'esposizione di sola lettura necessaria per i consumer di proprietà e la funzione di accesso get per il [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificatore della proprietà di dipendenza da serializzare.</param>
        <summary>Restituisce un valore che indica se i processi di serializzazione devono serializzare il valore della proprietà di dipendenza specificata.</summary>
        <returns>
          <see langword="true" /> se per la proprietà di dipendenza fornita deve essere eseguita la serializzazione del valore. In caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implementazione predefinita restituisce `true` per tutti i casi in cui una proprietà di dipendenza è un valore locale stabilito nel <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Le sostituzioni per questo metodo potrebbero gestire le proprietà di dipendenza specifica in modo diverso.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>