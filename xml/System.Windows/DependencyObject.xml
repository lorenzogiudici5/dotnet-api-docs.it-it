<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b20096950e5ef29b8ab06fba5406a44bbc3ff7f2" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36461255" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents an object that participates in the dependency property system.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.DependencyObject> classe abilita [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] servizi di sistema di proprietà in varie classi derivate.  
  
 Funzione principale del sistema di proprietà è per calcolare i valori delle proprietà e per fornire la notifica di sistema sui valori che sono stati modificati. Un'altra classe principale che partecipa al sistema di proprietà è <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> Abilita la registrazione delle proprietà di dipendenza nel sistema di proprietà e vengono fornite informazioni di identificazione e su ogni proprietà di dipendenza, mentre <xref:System.Windows.DependencyObject> come una classe di base consente agli oggetti di usare le proprietà di dipendenza.  
  
 <xref:System.Windows.DependencyObject> servizi e le caratteristiche, tra cui:  
  
-   Supporto per l'hosting di proprietà di dipendenza. Si registra una proprietà di dipendenza chiamando il <xref:System.Windows.DependencyProperty.Register%2A> (metodo) e l'archiviazione di valore restituito del metodo come un campo statico pubblico della classe.  
  
-   Supporto per l'hosting proprietà associata. Si registra una proprietà associata chiamando il <xref:System.Windows.DependencyProperty.RegisterAttached%2A> (metodo) e l'archiviazione di valore restituito del metodo come un campo di sola lettura statico pubblico della classe. (Sono inoltre disponibili i requisiti di membri aggiuntivi; si noti che questo rappresenta un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementazione specifica per le proprietà associate. Per informazioni dettagliate, vedere [collegato Cenni preliminari sulle proprietà](~/docs/framework/wpf/advanced/attached-properties-overview.md).) La proprietà associata può quindi essere impostare su qualsiasi classe che deriva da <xref:System.Windows.DependencyObject>.  
  
-   Get, set e cancellare i metodi di utilità per i valori di qualsiasi proprietà di dipendenza che esiste nel <xref:System.Windows.DependencyObject>.  
  
-   I metadati, forzare il supporto di valore, la notifica di modifica proprietà e i callback di sostituzione per le proprietà di dipendenza o proprietà associate. Inoltre, il <xref:System.Windows.DependencyObject> classe semplifica i metadati della proprietà per ogni proprietario di una proprietà di dipendenza.  
  
-   Una classe di base comune per le classi derivate <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, o <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, un'altra classe di elemento di base, ha una gerarchia di classi che include <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 Nell'esempio seguente deriva da <xref:System.Windows.DependencyObject> per creare una nuova classe astratta. La classe quindi Registra una proprietà associata e include i membri di supporto per la proprietà associata.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.DependencyObject" /> class.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Clears the local value of a property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The dependency property to be cleared, identified by a <see cref="T:System.Windows.DependencyProperty" /> object reference.</param>
        <summary>Clears the local value of a property. The property to be cleared is specified by a <see cref="T:System.Windows.DependencyProperty" /> identifier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cancellare il valore della proprietà chiamando <xref:System.Windows.DependencyObject.ClearValue%2A> non necessariamente fornire una proprietà di dipendenza il valore predefinito specificato nei metadati della proprietà di dipendenza. Deselezionare la proprietà solo in particolare Cancella qualsiasi valore locale sono stati applicati. Per altre informazioni, vedere [Precedenza del valore della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Nell'esempio seguente esegue l'iterazione di tutte le proprietà che presentano valori locali impostati su un oggetto, quindi chiama <xref:System.Windows.DependencyObject.ClearValue%2A> per cancellare i valori di tali proprietà.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to call <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">The key for the dependency property to be cleared.</param>
        <summary>Clears the local value of a read-only property. The property to be cleared is specified by a <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.DependencyPropertyKey> identifica una proprietà di dipendenza di sola lettura per le operazioni di sistema di proprietà. Le classi che definiscono le proprietà di dipendenza di sola lettura non devono esporre questa chiave con accesso pubblico. Una chiave esposta pubblicamente fornisce un percorso di codice pubblico che nega il carattere di sola lettura della proprietà, se i metodi come <xref:System.Windows.DependencyObject.ClearValue%2A> o <xref:System.Windows.DependencyObject.SetValue%2A> può essere chiamata all'esterno della classe o un assembly, la chiave di riferimento.  
  
 Cancellare il valore della proprietà chiamando <xref:System.Windows.DependencyObject.ClearValue%2A> non necessariamente fornire una proprietà di dipendenza il valore predefinito specificato nei metadati della proprietà di dipendenza. La cancellazione del valore in modo specifico solo Cancella qualsiasi valore locale sono stati applicati. Per altre informazioni, vedere [Precedenza del valore della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to call <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier for the dependency property to coerce.</param>
        <summary>Coerces the value of the specified dependency property. This is accomplished by invoking any <see cref="T:System.Windows.CoerceValueCallback" /> function specified in property metadata for the dependency property as it exists on the calling <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oltre a essere richiamato in modo esplicito tramite la chiamata <xref:System.Windows.DependencyObject.CoerceValue%2A>, il <xref:System.Windows.CoerceValueCallback> per una dipendenza di proprietà viene anche richiamata internamente ogni volta che il valore di proprietà di dipendenza è rivalutate dal [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema di proprietà.  
  
 Quando si richiama il <xref:System.Windows.DependencyObject.CoerceValue%2A> metodo, si richiama il callback del valore soggetto a coercizione per la proprietà specificati. In genere si richiamerà <xref:System.Windows.DependencyObject.CoerceValue%2A> solo se si è certi che esista un callback di valore soggetto a coercizione, e se si conoscono i criteri del callback per la coercizione.  
  
 Lo scenario più comune per chiamare <xref:System.Windows.DependencyObject.CoerceValue%2A> si trova all'interno di callback di modifica di gestione o proprietà classe di proprietà correlate che influenzano i rispettivi valori in modo dipendente. Per altre informazioni, vedere [Callback e convalida delle proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene chiamato <xref:System.Windows.DependencyObject.CoerceValue%2A> all'interno di un <xref:System.Windows.PropertyChangedCallback> implementazione che viene utilizzato come il <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> per proprietà di dipendenza diverse sulla stessa classe. Si tratta di un modello comune per l'introduzione valore true dipendenze tra le proprietà di dipendenza.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The specified <paramref name="dp" /> or its value were invalid or do not exist.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Windows.DependencyObjectType" /> that wraps the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] type of this instance.</summary>
        <value>Oggetto <see cref="T:System.Windows.DependencyObjectType" /> che esegue il wrapping di [! Tipo include[TLA2#tla_clr](~/Includes/tla2sharptla-CLR-MD.MD)] di questa istanza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è utile se un oggetto che viene restituito da un metodo ha un tipo di valore restituito di <xref:System.Windows.DependencyObject> e si desidera eseguire proprietà sistema determinate operazioni su di esso a seconda del tipo. Ad esempio risulta più efficiente per chiamare <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> utilizzando il <xref:System.Windows.DependencyObjectType> invece che al [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] tipo. <xref:System.Windows.DependencyObjectType> facilita le ricerche più veloci.  
  
   
  
## Examples  
 Nell'esempio seguente pseudocodice `MySubClass` preannuncia che ulteriori classi derivate potrebbero modificare il valore predefinito di `MyCustom` proprietà di dipendenza. La classe implementa un costruttore predefinito in grado di determinare l'effettiva classe derivata da sfruttando la possibilità di polimorfismo <xref:System.Windows.DependencyObjectType> valore ogni volta che il costruttore viene utilizzato come instantiator una classe derivata.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Windows.DependencyObject" /> to compare to the current instance.</param>
        <summary>Determines whether a provided <see cref="T:System.Windows.DependencyObject" /> is equivalent to the current <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>
          <see langword="true" /> if the two instances are the same; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione è solo l'uguaglianza dei riferimenti e non tenta di valutare l'uguaglianza di valori delle proprietà contenute.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> esegue l'override e quindi esegue il sealing basic due <see cref="T:System.Object" /> metodi: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> e <see cref="M:System.Windows.DependencyObject.GetHashCode" />. La chiamata di sostituzioni il <see cref="T:System.Object" /> implementazioni, determinando un comportamento di uguaglianza di oggetti. Lo scopo di questi override intenzionali consiste nell'impedire alle classi derivate di provare a definire l'uguaglianza di valori per un <see cref="T:System.Windows.DependencyObject" />. Valore di predicati di uguaglianza per <see cref="T:System.Windows.DependencyObject" /> non potranno mai essere accurati a causa delle funzionalità di Modifica valore proprietà noto di un <see cref="T:System.Windows.DependencyObject" /> e le relative proprietà di dipendenza. Ciò include fondamentali [! Funzionalità include[TLA2#tla_winclient](~/Includes/tla2sharptla-WinClient-MD.MD)], ad esempio associazione dati e di [! Sistema di proprietà include[TLA2#tla_winclient](~/Includes/tla2sharptla-WinClient-MD.MD)].</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a hash code for this <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>A signed 32-bit integer hash code.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> esegue l'override e quindi esegue il sealing due <see cref="T:System.Object" /> metodi: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> e <see cref="M:System.Windows.DependencyObject.GetHashCode" />. La chiamata di sostituzioni il <see cref="T:System.Object" /> implementazioni, determinando un comportamento di uguaglianza di oggetti. Lo scopo di questi override intenzionali consiste nell'impedire alle classi derivate di provare a definire l'uguaglianza di valori per un <see cref="T:System.Windows.DependencyObject" />. Valore di predicati di uguaglianza per <see cref="T:System.Windows.DependencyObject" /> non potranno mai essere accurati a causa delle funzionalità di Modifica valore proprietà noto di un <see cref="T:System.Windows.DependencyObject" /> e le relative proprietà di dipendenza. Ciò include fondamentali [! Funzionalità include[TLA2#tla_winclient](~/Includes/tla2sharptla-WinClient-MD.MD)], ad esempio associazione dati e di [! Sistema di proprietà include[TLA2#tla_winclient](~/Includes/tla2sharptla-WinClient-MD.MD)].</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a specialized enumerator for determining which dependency properties have locally set values on this <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>A specialized local value enumerator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *valore locale* è qualsiasi valore di proprietà di dipendenza che è stato impostato da <xref:System.Windows.DependencyObject.SetValue%2A>, a differenza di altri aspetti del sistema di proprietà.  
  
 Il <xref:System.Windows.LocalValueEnumerator> ottenuto chiamando <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> può essere utilizzata per enumerare le proprietà che hanno impostato localmente valore su un <xref:System.Windows.DependencyObject> istanza. Ogni proprietà è rappresentata nell'enumeratore da un <xref:System.Windows.LocalValueEntry> object, che contiene le proprietà che fanno riferimento alle specifico <xref:System.Windows.DependencyProperty> e i relativi valori. Questa tecnica di enumerazione impostati localmente valori utilizzabile per l'ottimizzazione o per la gestione di altro tipo di valori locali, ad esempio per determinare quali valori di proprietà di un <xref:System.Windows.DependencyObject> comporterebbe la modifica se cancellati.  
  
> [!IMPORTANT]
>  L'oggetto restituito <xref:System.Windows.LocalValueEnumerator> potrebbe contenere <xref:System.Windows.LocalValueEntry> record per la proprietà di dipendenza che sono di sola lettura, o le proprietà di dipendenza in cui i valori vengono calcolati del sistema di proprietà. Ad esempio, un elemento visual framework con una larghezza stabilita mediante layout verrà segnalato un valore locale per <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Se si ottengono valori locali per reimpostarli, controllare la <xref:System.Windows.DependencyProperty.ReadOnly%2A> valore nell'identificatore di proprietà di ogni <xref:System.Windows.LocalValueEntry> per verificare che il <xref:System.Windows.DependencyProperty> in questione non è in sola lettura.  
  
   
  
## Examples  
 Nell'esempio seguente esegue l'iterazione di tutte le proprietà che presentano valori locali impostati su un oggetto, quindi chiama <xref:System.Windows.DependencyObject.ClearValue%2A> per cancellare i valori di tali proprietà.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to retrieve the value for.</param>
        <summary>Returns the current effective value of a dependency property on this instance of a <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Returns the current effective value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il *valore effettivo* è il valore della proprietà che viene restituito dal sistema di proprietà per qualsiasi chiamante che richiede il valore. Il valore effettivo è il risultato del sistema di proprietà con valutati tutti i possibili input che partecipano alla precedenza dei valori di sistema di proprietà. Ciò include la coercizione e animazione. Per altre informazioni, vedere [Precedenza del valore della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Questo metodo non restituisce mai <xref:System.Windows.DependencyProperty.UnsetValue>. Il <xref:System.Windows.DependencyProperty.UnsetValue> è un valore di sentinel per il sistema di proprietà che viene utilizzato in vario modo internamente e talvolta anche esposto tramite callback di coercizione.  
  
 Se non si conoscono quale deve essere il tipo della proprietà, è possibile eseguire una query l'identificatore della proprietà di dipendenza richiesta per determinare se è presente un oggetto più specifico <xref:System.Windows.DependencyProperty.PropertyType%2A> che il valore restituito può essere convertito in.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The specified <paramref name="dp" /> or its value was invalid, or the specified <paramref name="dp" /> does not exist.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to invalidate.</param>
        <summary>Re-evaluates the effective value for the specified dependency property</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si chiama <xref:System.Windows.DependencyObject.InvalidateProperty%2A>associati e qualsiasi applicabile <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funzioni registrate per tale proprietà di dipendenza può essere richiamato.  
  
 La chiamata <xref:System.Windows.DependencyObject.InvalidateProperty%2A> su una proprietà che è stato impostato il valore locale non avrà alcun effetto, perché il valore locale ha la precedenza su altri input di sistema di proprietà, ad eccezione delle animazioni. Tuttavia, è possibile chiamare <xref:System.Windows.DependencyObject.ClearValue%2A>, quindi chiamare <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Per altre informazioni, vedere [Precedenza del valore della proprietà di dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 La chiamata <xref:System.Windows.DependencyObject.InvalidateProperty%2A> non è necessariamente applicabili per molti scenari di proprietà di dipendenza. Se una proprietà di dipendenza viene invalidata a causa di modifiche apportate ai componenti di valori, il sistema di proprietà invalida e Rivaluta automaticamente la proprietà di dipendenza. Tuttavia, esistono ancora alcuni scenari appropriati in cui <xref:System.Windows.DependencyObject.InvalidateProperty%2A> è utile. In particolare, è possibile utilizzare <xref:System.Windows.DependencyObject.InvalidateProperty%2A> del valore soggetto a coercizione o nelle proprietà modificato callback per una proprietà di dipendenza diversi. È anche possibile usare <xref:System.Windows.DependencyObject.InvalidateProperty%2A> per forzare la valutazione di un'associazione in un'origine dati che non è in grado di implementare il <xref:System.ComponentModel.INotifyPropertyChanged> meccanismo di notifica (ad esempio se l'utilizzo di classi di dati che non può essere derivata da, o in cui i dati sono un valore statico membro).  
  
   
  
## Examples  
 L'esempio seguente chiama <xref:System.Windows.DependencyObject.InvalidateProperty%2A> su una proprietà personalizzata, ogni volta che proprietà coinvolti nei calcoli della proprietà cambiano. Si tratta di una tecnica alternativa alla chiamata di <xref:System.Windows.DependencyObject.CoerceValue%2A> metodo, perché invalidando la proprietà verrà chiamata anche qualsiasi registrato <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether this instance is currently sealed (read-only).</summary>
        <value>
          <see langword="true" /> Se questa istanza è sealed. in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo valore è impostato internamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event data that will contain the dependency property identifier of interest, the property metadata for the type, and old and new values.</param>
        <summary>Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.DependencyObject" /> has been updated. The specific dependency property that changed is reported in the event data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non deve in genere rilevare le modifiche alle singole proprietà o eseguire le convalide delle proprietà per ogni caso. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> è invece destinato alle modifiche del criterio di invalidamento generale, se sono noto determinate informazioni sulle classificazioni generali delle proprietà. Ad esempio, modifica un <xref:System.Windows.Freezable> potrebbero essere modifiche nei tipi di valore del <xref:System.Windows.Freezable>, o potrebbero essere sottoproprietà, in cui le modifiche sono all'interno di altri <xref:System.Windows.Freezable> riferimenti. Il <xref:System.Windows.Freezable> eseguire l'override dell'implementazione <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> utilizza informazioni interne per determinare se le proprietà sono sottoproprietà e fornisce la logica di classe di base appropriata per entrambi i casi.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> viene potenzialmente richiamato più volte durante il ciclo di vita di un oggetto. Pertanto, è possibile ottenere un miglioramento delle prestazioni del sistema di proprietà globale se si ignora i metadati di proprietà specifico e quindi collegare <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funzioni per le singole proprietà. Tuttavia, utilizzare questo metodo se un <xref:System.Windows.DependencyObject> include un numero significativo di proprietà di dipendenza correlata al valore, o se ne include logica, ad esempio il comportamento di rendering, che deve essere ripetuto per molti casi correlati delle convalide di proprietà.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Chiamare sempre l'implementazione di base. Errore per eseguire questa operazione disabiliterà in modo significativo l'intero [! Sistema di proprietà include[TLA2#tla_winclient](~/Includes/tla2sharptla-WinClient-MD.MD)], provocando valori non corretti da segnalare.</para>
        </block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to retrieve the value for.</param>
        <summary>Returns the local value of a dependency property, if it exists.</summary>
        <returns>Returns the local value, or returns the sentinel value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> if no local value is set.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È consigliabile utilizzare <xref:System.Windows.DependencyObject.GetValue%2A> per le operazioni più comuni "get" per una proprietà di dipendenza. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> Restituisce il valore effettivo per un'ampia gamma di circostanze in cui il valore non è impostato localmente.  
  
 Valori impostati da stili, temi e modelli, il valore predefinito di metadati o ereditarietà del valore di proprietà non vengono considerati come valori locali. Tuttavia, associazioni e altre espressioni vengono considerati valori locali, dopo essere state valutate.  
  
 Quando viene impostato alcun valore locale, questo metodo restituisce <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Se il valore restituito è diverso da <xref:System.Windows.DependencyProperty.UnsetValue>, è possibile eseguire una query di metadati della proprietà di dipendenza richiesta per determinare se è presente un tipo più specifico che il valore restituito può essere convertito in.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier of the dependency property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the value of a dependency property without changing its value source.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato da un componente che a livello di codice imposta il valore di una delle sue proprietà senza disabilitare utilizzazione di un'applicazione della proprietà. Il <xref:System.Windows.DependencyObject.SetCurrentValue%2A> metodo diventa il valore effettivo della proprietà, ma i trigger esistenti, data binding e stili continueranno a funzionare correttamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to modify a read-only dependency property, or a property on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> was not the correct type as registered for the <paramref name="dp" /> property.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the local value of a dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier of the dependency property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the local value of a dependency property, specified by its dependency property identifier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il tipo fornito non corrisponde al tipo dichiarato della proprietà di dipendenza in cui è stata registrata originariamente, viene generata un'eccezione. Il `value` deve sempre essere specificato come tipo appropriato.  
  
 Le condizioni di eccezione sono potenzialmente influenzate dal <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> callback che sia disponibile l'identificatore della proprietà di dipendenza della proprietà di dipendenza viene impostata. In caso contrario, il valore fornito potrebbe essersi verificato un errore generale condizioni di controllo dei tipi (ad esempio, passando una stringa quando il tipo nativo è Double).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to modify a read-only dependency property, or a property on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> was not the correct type as registered for the <paramref name="dp" /> property.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">The <see cref="T:System.Windows.DependencyPropertyKey" /> identifier of the property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the local value of a read-only dependency property, specified by the <see cref="T:System.Windows.DependencyPropertyKey" /> identifier of the dependency property.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa firma viene generalmente usata quando si impostano i valori per le proprietà di dipendenza di sola lettura che sono definiti nelle classi personalizzate. In genere, <xref:System.Windows.DependencyObject.SetValue%2A> viene chiamato solo dal tipo che ha registrato la proprietà di dipendenza, implementa la logica interna che fornisce il valore della proprietà di dipendenza. Per altre informazioni, vedere [Proprietà di dipendenza di sola lettura](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Se il tipo fornito non corrisponde al tipo dichiarato della proprietà di dipendenza in cui è stata registrata originariamente, viene generata un'eccezione. Il `value` deve sempre essere specificato come tipo appropriato. Le condizioni di eccezione sono potenzialmente influenzate dal <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> callback che sia disponibile l'identificatore della proprietà di dipendenza della proprietà di dipendenza viene impostata.  
  
   
  
## Examples  
 L'esempio seguente definisce una proprietà di dipendenza di sola lettura, insieme a un `public static readonly` <xref:System.Windows.DependencyProperty> che fornisce l'esposizione di sola lettura necessaria per i consumer di proprietà e la funzione di accesso get per il [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier for the dependency property that should be serialized.</param>
        <summary>Returns a value that indicates whether serialization processes should serialize the value for the provided dependency property.</summary>
        <returns>
          <see langword="true" /> if the dependency property that is supplied should be value-serialized; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implementazione predefinita restituisce `true` per tutti i casi in cui una proprietà di dipendenza dispone di un valore locale definito per il <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Esegue l'override di questo metodo potrebbero gestire le proprietà di dipendenza specifica in modo diverso.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>