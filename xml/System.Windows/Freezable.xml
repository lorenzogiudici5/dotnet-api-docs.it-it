<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="12a1be02c542dfe0d4b2b31c8c4e0fbee60ca7d5" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37549381" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Defines an object that has a modifiable state and a read-only (frozen) state. Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Freezable> classe fornisce funzionalità speciali che consentono di migliorare le prestazioni dell'applicazione quando si usano gli oggetti che sono costosi da modificare o copiare. Esempi di <xref:System.Windows.Freezable> oggetti includono quanto segue:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Che derivano da Freezable  
 Una classe che deriva da <xref:System.Windows.Freezable> Ottiene le funzionalità seguenti:  
  
-   Stati speciali: (una sola lettura bloccato) e uno stato accessibile in scrittura.  
  
-   Sicurezza dei thread: un oggetto bloccato <xref:System.Windows.Freezable> oggetto può essere condivisi tra thread.  
  
-   Notifica dettagliata delle modifiche: a differenza di altri <xref:System.Windows.DependencyObject> oggetti, un <xref:System.Windows.Freezable> oggetto fornisce notifiche di modifica quando cambiano i valori delle sottoproprietà.  
  
-   La clonazione semplice: la classe Freezable ha già implementato diversi metodi che producono cloni.  
  
 Per informazioni sull'uso e crearne una propria <xref:System.Windows.Freezable> oggetti, vedere [Cenni preliminari sugli oggetti Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Qualsiasi membro pubblico <see langword="static" /> membri di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  Quando la <see cref="P:System.Windows.Freezable.IsFrozen" /> proprietà viene <see langword="false" />, un <see cref="T:System.Windows.Freezable" /> oggetto sono accessibili solo dal thread in cui è stato creato. Il tentativo di accedervi da un altro thread genererà un <see cref="T:System.InvalidOperationException" />. Il <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> e <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> metodi forniscono supporto per il marshalling al thread corretto.  Quando le <see cref="P:System.Windows.Freezable.IsFrozen" /> proprietà viene <see langword="true" />, <see cref="T:System.Windows.Freezable" /> sono oggetti a thread libero.  Per altre informazioni, vedere [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) oggetti Freezable.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo è il costruttore di accessibilità protected di una classe astratta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the object can be made unmodifiable.</summary>
        <value>
          <see langword="true" /> se l'oggetto corrente può essere impostato come non modificabile o è già non modificabile. In caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Questa implementazione del metodo Usa il <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metodo con <paramref name="isChecking" /> impostata su <see langword="true" /> per determinare se un <see cref="T:System.Windows.Freezable" /> può essere reso immodificabile. Per modificare il comportamento di questa proprietà in una classe derivata, esegue l'override di <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (metodo).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si tenta di aggiungere o rimuovere i gestori eventi quando l'oggetto corrente non è modificabile (quando il <xref:System.Windows.Freezable.IsFrozen%2A> è di proprietà `true`), viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values. When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</summary>
        <returns>A modifiable clone of the current object. The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> producono modificabili cloni di bloccato <xref:System.Windows.Freezable> oggetti (clonare anche i metodi <xref:System.Windows.Freezable> gli oggetti che non sono bloccati). Il clone in modo efficace è una copia completa dell'oggetto corrente.  
  
 Nella tabella seguente riepiloga le differenze tra il <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> metodi.  
  
|Operazione|Comportamento del metodo Clone|Metodo CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Copia di una proprietà di dipendenza che dispone di un'espressione|L'espressione viene copiato, ma non è più potrebbe essere risolto. Per altre informazioni, vedere [Cenni preliminari sugli oggetti Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Il valore corrente dell'espressione viene copiato, ma non l'espressione stessa.|  
|Copia di una proprietà di dipendenza animata|Il valore della proprietà base (non animati) viene copiato. Le animazioni non vengono copiate.|Il valore della proprietà corrente animata viene copiato. Le animazioni non vengono copiate.|  
  
 Si noti che non vengono copiate le proprietà non impostate. Se una proprietà non impostata ha un valore predefinito che è un oggetto bloccato <xref:System.Windows.Freezable>, che rimane bloccato nel clone modificabile in caso contrario, un valore della proprietà.  
  
## <a name="move-a-freezable-between-threads"></a>Spostare un oggetto Freezable tra thread  
 Questo metodo può essere utile per lo spostamento di un <xref:System.Windows.Freezable> tra thread. In primo luogo, verificare i <xref:System.Windows.Freezable> immodificabile chiamando relativo <xref:System.Windows.Freezable.Freeze%2A> (metodo). È ora possibile accedere a un altro thread il <xref:System.Windows.Freezable> e apportare una variabile locale <xref:System.Windows.Freezable.Clone%2A> che possa accedere.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> per produrre il clone. Per modificare il comportamento di questo metodo in una classe derivata, esegue l'override di <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> (metodo).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The object to clone.</param>
        <summary>Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal <xref:System.Windows.Freezable.Clone%2A> metodo e non può essere chiamato direttamente dal codice, tranne quando si chiama l'implementazione di base durante l'override di questo metodo. Per creare una copia modificabile dell'oggetto corrente, chiamare <xref:System.Windows.Freezable.Clone%2A> invece di chiamare direttamente questo metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se si deriva da <see cref="T:System.Windows.Freezable" />, potrebbe essere necessario eseguire l'override di questo metodo. Motivi per eseguire l'override includono quanto segue:-la classe derivata dispone di dati che non vengono esposti tramite proprietà di dipendenza.  -La classe derivata deve eseguire operazioni di inizializzazione aggiuntive che non possono essere eseguita sostituendo semplicemente <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Ad esempio, si applica se la classe derivata implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Le classi che archiviano tutti i dati nelle proprietà di dipendenza e che non è necessario effettuare operazioni di inizializzazione aggiuntiva non sono necessario eseguire l'override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  È essenziale che tutte le implementazioni di chiamano l'implementazione di base di questo metodo. Le implementazioni devono solo eseguire operazioni che non viene eseguita dall'implementazione predefinita. L'implementazione predefinita esegue copie complete di tutte le proprietà scrivibili, impostate localmente, incluse le espressioni interne.  Se l'oggetto ha proprietà di dipendenza associata a dati, le espressioni vengono copiate ma non è più possano risolvere. Per altre informazioni sugli oggetti associati a dati duplicati, vedere [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) oggetti Freezable. Se l'oggetto ha proprietà di dipendenza animate, viene copiato il valore di base (non animati) delle proprietà. Le animazioni non vengono copiate.  Si noti che non vengono copiate le proprietà non impostate né sono proprietà di sola lettura. Se questa proprietà ha un valore predefinito che è un oggetto bloccato <see cref="T:System.Windows.Freezable" />, che rimane bloccato nel clone modificabile in caso contrario, un valore della proprietà.  L'elenco seguente riepiloga il comportamento previsto per questo metodo:-la copia del prodotto contiene copie di tutti <see cref="T:System.Windows.Freezable" /> oggetti secondari.  -Proprietà unset e di sola lettura non vengono copiate.  -Le espressioni vengono copiate.  -Nessuno di questi oggetti secondari vengono bloccate al momento della creazione.  -La copia di se stesso non sia bloccata.  -Le animazioni non vengono copiate.  -Solo i valori di base proprietà sono valori animati copiati, non attualmente.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</summary>
        <returns>A modifiable clone of the current object. The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> producono modificabili cloni di bloccato <xref:System.Windows.Freezable> oggetti (clonare anche i metodi <xref:System.Windows.Freezable> gli oggetti che non sono bloccati). Il clone in modo efficace è una copia completa dell'oggetto corrente.  
  
 Nella tabella seguente riepiloga le differenze tra il <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> metodi.  
  
|Operazione|Comportamento del metodo Clone|Metodo CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Copia di una proprietà di dipendenza che dispone di un'espressione|L'espressione viene copiato, ma non è più potrebbe essere risolto. Per altre informazioni, vedere [Cenni preliminari sugli oggetti Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Il valore corrente dell'espressione viene copiato, ma non l'espressione stessa.|  
|Copia di una proprietà di dipendenza animata|Il valore della proprietà base (non animati) viene copiato. Le animazioni non vengono copiate.|Il valore della proprietà corrente animata viene copiato. Le animazioni non vengono copiate.|  
  
 Si noti che non vengono copiate le proprietà non impostate. Se una proprietà non impostata ha un valore predefinito che è un oggetto bloccato <xref:System.Windows.Freezable>, che rimane bloccato nel clone modificabile in caso contrario, un valore della proprietà.  
  
## <a name="move-a-freezable-between-threads"></a>Spostare un oggetto Freezable tra thread  
 Questo metodo può essere utile per lo spostamento di un <xref:System.Windows.Freezable> tra thread. In primo luogo, verificare i <xref:System.Windows.Freezable> immodificabile usando relativo <xref:System.Windows.Freezable.Freeze%2A> (metodo). È ora possibile accedere a un altro thread il <xref:System.Windows.Freezable> e creare un clone locale che può accedere.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa il <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> per produrre il clone; (metodo) <see cref="T:System.Windows.Freezable" /> gli implementatori di che eseguire l'override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> necessario assicurarsi che la copia non viene bloccata durante la creazione.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The <see cref="T:System.Windows.Freezable" /> to be cloned.</param>
        <summary>Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal <xref:System.Windows.Freezable.CloneCurrentValue%2A> metodo e non può essere chiamato direttamente dal codice, tranne quando si chiama l'implementazione di base durante l'override di questo metodo. Per creare una copia modificabile dell'oggetto corrente, chiamare <xref:System.Windows.Freezable.CloneCurrentValue%2A> invece di chiamare direttamente questo metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se si deriva da <see cref="T:System.Windows.Freezable" />, potrebbe essere necessario eseguire l'override di questo metodo. Motivi per eseguire l'override includono quanto segue:-la classe derivata dispone di dati che non vengono esposti tramite proprietà di dipendenza.  -La classe derivata deve eseguire operazioni di inizializzazione aggiuntive che non possono essere eseguita sostituendo semplicemente <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Ad esempio, si applica se la classe derivata implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Le classi che archiviano tutti i dati nelle proprietà di dipendenza e che non è necessario effettuare operazioni di inizializzazione aggiuntiva non sono necessario eseguire l'override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  È essenziale che tutte le implementazioni di chiamano l'implementazione di base di questo metodo. Le implementazioni devono solo eseguire operazioni che non viene eseguita dall'implementazione predefinita. L'implementazione predefinita esegue copie complete di tutte le proprietà scrivibili, impostate localmente. Se l'oggetto contiene le proprietà di dipendenza con espressioni (ad esempio, un'associazione di dati), ma non l'espressione stessa viene copiato il valore corrente dell'espressione.  Se l'oggetto ha proprietà di dipendenza animate, viene copiato il valore animato corrente di tali proprietà, ma non le animazioni.  Si noti che non vengono copiate le proprietà non impostate né sono proprietà di sola lettura. Se questa proprietà ha un valore predefinito che è un oggetto bloccato <see cref="T:System.Windows.Freezable" />, che rimane bloccato nel clone modificabile in caso contrario, un valore della proprietà.  L'elenco seguente riepiloga il comportamento previsto per questo metodo.  -La copia del prodotto contiene copie di tutti <see cref="T:System.Windows.Freezable" /> oggetti secondari.  -Proprietà unset e di sola lettura non vengono copiate.  -Se una proprietà è animata, viene copiato il valore corrente, ma non dell'animazione stessa.  -Nessuno di questi oggetti secondari vengono bloccate al momento della creazione.  -La copia di se stesso non sia bloccata.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</summary>
        <returns>The new instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo protetto, e le implementazioni specifiche dell'oggetto effettive per il comportamento dipende l'implementazione di override di <xref:System.Windows.Freezable.CreateInstanceCore%2A> metodo, che questo metodo chiama internamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</summary>
        <returns>The new instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non chiamare questo metodo direttamente (tranne quando la chiamata a base in un'implementazione). Questo metodo viene chiamato internamente dal <xref:System.Windows.Freezable.CreateInstance%2A> metodo ogni volta che una nuova istanza del <xref:System.Windows.Freezable> viene creato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata un'implementazione tipica delle <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ogni <see cref="T:System.Windows.Freezable" /> classe derivata deve implementare questo metodo. Un'implementazione tipica è semplicemente chiamare il costruttore predefinito e restituire il risultato.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per evitare la possibilità di un' <xref:System.InvalidOperationException> quando si chiama questo metodo, verificare la <xref:System.Windows.Freezable.CanFreeze%2A> proprietà per determinare se il <xref:System.Windows.Freezable> può essere reso immodificabile prima di chiamare questo metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</exception>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa il <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metodo per rendere il <see cref="T:System.Windows.Freezable" /> immodificabile. Per modificare il comportamento di blocco, eseguire l'override di <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (metodo).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">The object to check or make unmodifiable. If <c>isChecking</c> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable. If <c>isChecking</c> is <see langword="false" />, the object is made unmodifiable, if possible.</param>
        <param name="isChecking">
          <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</param>
        <summary>If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable. If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</summary>
        <returns>If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable. If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non chiamare questo metodo a meno che non si deriva da <xref:System.Windows.Freezable> ed eseguire l'override di <xref:System.Windows.Freezable.FreezeCore%2A> (metodo).  Questo metodo può essere usato nel <xref:System.Windows.Freezable.FreezeCore%2A> metodo per bloccare i membri dati della classe a loro volta <xref:System.Windows.Freezable> oggetti.  
  
 Bene. ora è chiamare questo metodo nuovamente su un <xref:System.Windows.Freezable> oggetto che è già bloccata (non modificabile).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</exception>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa il <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metodo per rendere il <see cref="T:System.Windows.Freezable" /> immodificabile. Per modificare il comportamento di blocco, eseguire l'override di <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (metodo).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</param>
        <summary>Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</summary>
        <returns>If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable. If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non chiamare questo metodo direttamente (tranne quando la chiamata a base in un'implementazione). Questo metodo viene chiamato internamente dal <xref:System.Windows.Freezable.CanFreeze%2A> proprietà (con `isChecking` uguale a `true`) e il <xref:System.Windows.Freezable.Freeze%2A> metodo (con `isChecking` uguale a `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.Freezable" /> gli implementatori devono eseguire l'override di questo metodo quando la classe contiene i dati che non vengono archiviati utilizzando le proprietà di dipendenza.  Un'implementazione tipica potrebbe chiamare il metodo base, quindi chiamare il metodo statico <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> metodo in tutti i <see cref="T:System.Windows.Freezable" /> le proprietà che contiene la classe, restituendo tipizzate <see langword="true" /> solo se tutte le proprietà sono state bloccate (o potrebbero essere state bloccate, in caso di specifica <see langword="true" /> per <paramref name="isChecking" />).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values. Because the copy is frozen, any frozen sub-objects are copied by reference.</summary>
        <returns>A frozen copy of the <see cref="T:System.Windows.Freezable" />. The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È consigliabile controllare la <xref:System.Windows.Freezable.CanFreeze%2A> proprietà prima di chiamare questo metodo per verificare che il <xref:System.Windows.Freezable> può essere bloccato. Con questo metodo è simile alla creazione di una copia usando il <xref:System.Windows.Freezable.Clone%2A> e quindi bloccandolo con la <xref:System.Windows.Freezable.Freeze%2A> (metodo).  
  
 Il <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metodi possono migliorare le prestazioni di copia perché non duplicano <xref:System.Windows.Freezable> oggetti secondari che sono già bloccati, li copiano solo per riferimento.  
  
 Nella tabella seguente riepiloga le differenze tra il <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metodi.  
  
|Operazione|Metodo GetAsFrozen|Metodo GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Copia di una proprietà di dipendenza che dispone di un'espressione|Il metodo genera un' <xref:System.InvalidOperationException> perché non è possibile <xref:System.Windows.Freezable.Freeze%2A> la proprietà.|Il valore corrente dell'espressione viene copiato, ma non l'espressione stessa.|  
|Copia di una proprietà di dipendenza animata|Il valore della proprietà base (non animati) viene copiato. Le animazioni non vengono copiate.|Il valore della proprietà corrente animata viene copiato. Le animazioni non vengono copiate.|  
  
 Si noti che non vengono copiate le proprietà non impostate né sono proprietà di sola lettura.  
  
 Per creare una copia del <xref:System.Windows.Freezable> vale a dire non bloccato, utilizzare il <xref:System.Windows.Freezable.Clone%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</exception>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa virtuale <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> metodo per produrre il clone.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The instance to copy.</param>
        <summary>Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal <xref:System.Windows.Freezable.GetAsFrozen%2A> metodo e non può essere chiamato direttamente dal codice, tranne quando si chiama l'implementazione di base durante l'override di questo metodo. Per creare una copia bloccata dell'oggetto corrente, chiamare <xref:System.Windows.Freezable.GetAsFrozen%2A> invece di chiamare direttamente questo metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se si deriva da <see cref="T:System.Windows.Freezable" /> potrebbe essere necessario eseguire l'override di questo metodo. Motivi per eseguire l'override includono quanto segue:-la classe derivata dispone di dati che non vengono esposti tramite proprietà di dipendenza.  -La classe derivata deve eseguire operazioni di inizializzazione aggiuntive che non possono essere eseguita sostituendo semplicemente <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Ad esempio, si applica se la classe derivata implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Le classi che archiviano tutti i dati nelle proprietà di dipendenza e che non è necessario effettuare operazioni di inizializzazione aggiuntiva non sono necessario eseguire l'override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  È essenziale che tutte le implementazioni di chiamano l'implementazione di base di questo metodo. Le implementazioni devono solo eseguire operazioni che non viene eseguita dall'implementazione predefinita. L'implementazione predefinita esegue copie complete di eventuali oggetti Freezable non bloccati e superficiale copie di tutte le altre proprietà scrivibili, in locale che contiene le proprietà del set. Se l'oggetto ha proprietà di dipendenza associata a dati, le espressioni vengono copiate ma non è più possano risolvere; per altre informazioni sugli oggetti associati a dati duplicati, vedere [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) oggetti Freezable. Se l'oggetto ha proprietà di dipendenza animate, vengono copiati i valori di base (non animati) delle proprietà. Le animazioni non vengono copiate.  Si noti che non vengono copiate le proprietà non impostate né sono proprietà di sola lettura.  Se si esegue l'override di questo metodo, è necessario chiamare l'implementazione di base.  Non è necessario per <see cref="M:System.Windows.Freezable.Freeze" /> quando vengono copiati i valori.  Il risultato è stato bloccato dal <see cref="M:System.Windows.Freezable.GetAsFrozen" /> prima di essere restituiti.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values. Because the copy is frozen, any frozen sub-objects are copied by reference.</summary>
        <returns>A frozen copy of the <see cref="T:System.Windows.Freezable" />. The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con questo metodo è simile alla creazione di una copia usando il <xref:System.Windows.Freezable.CloneCurrentValue%2A> e quindi bloccandolo con la <xref:System.Windows.Freezable.Freeze%2A> (metodo).  
  
 Il <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metodi possono migliorare le prestazioni di copia perché non duplicano <xref:System.Windows.Freezable> oggetti secondari che sono già bloccati, li copiano solo per riferimento.  
  
 Nella tabella seguente riepiloga le differenze tra il <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metodi.  
  
|Operazione|Metodo GetAsFrozen|Metodo GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Copia di una proprietà di dipendenza che dispone di un'espressione|Il metodo genera un' <xref:System.InvalidOperationException> perché non è possibile <xref:System.Windows.Freezable.Freeze%2A> la proprietà.|Il valore corrente dell'espressione viene copiato, ma non l'espressione stessa.|  
|Copia di una proprietà di dipendenza animata|Il valore della proprietà base (non animati) viene copiato. Le animazioni non vengono copiate.|Il valore della proprietà corrente animata viene copiato. Le animazioni non vengono copiate.|  
  
 Si noti che non vengono copiate le proprietà non impostate né sono proprietà di sola lettura.  
  
 Per creare una copia del <xref:System.Windows.Freezable> vale a dire non bloccato, utilizzare il <xref:System.Windows.Freezable.CloneCurrentValue%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa virtuale <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> metodo per produrre il clone.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</param>
        <summary>Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />. If the object has animated dependency properties, their current animated values are copied.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metodo e non può essere chiamato direttamente dal codice, tranne quando si chiama l'implementazione di base durante l'override di questo metodo. Per creare una copia bloccata dell'oggetto corrente, chiamare <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> invece di chiamare direttamente questo metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se si deriva da <see cref="T:System.Windows.Freezable" />, potrebbe essere necessario eseguire l'override di questo metodo. Motivi per eseguire l'override includono quanto segue:-la classe derivata dispone di dati che non vengono esposti tramite proprietà di dipendenza.  -La classe derivata deve eseguire operazioni di inizializzazione aggiuntive che non possono essere eseguita sostituendo semplicemente <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Ad esempio, si applica se la classe derivata implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Le classi che archiviano tutti i dati nelle proprietà di dipendenza e che non è necessario effettuare operazioni di inizializzazione aggiuntiva non sono necessario eseguire l'override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  È essenziale che tutte le implementazioni di chiamano l'implementazione di base di questo metodo. Le implementazioni devono solo eseguire operazioni che non viene eseguita dall'implementazione predefinita. L'implementazione predefinita crea un nuovo <see cref="T:System.Windows.Freezable" /> utilizzando il <see cref="M:System.Windows.Freezable.CreateInstance" /> (metodo) e la imposta come copie complete di oggetti Freezable non bloccati e copia superficiale di tutte le altre proprietà scrivibili, in locale impostare proprietà in essa contenute. Se l'oggetto ha proprietà di dipendenza associata a dati, le associazioni dati vengono copiate ma non è più potrebbero risolvere; per altre informazioni sugli oggetti associati a dati duplicati, vedere [Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md) oggetti Freezable. Se l'oggetto ha proprietà di dipendenza animate, viene copiato il valore animato corrente di tali proprietà, ma non le animazioni.  Le proprietà di dipendenza di sola lettura all'interno di un <see cref="T:System.Windows.Freezable" /> non vengono copiati da questa implementazione predefinita.  Se si esegue l'override di questo metodo, è necessario chiamare l'implementazione di base.  Non è necessario per <see cref="M:System.Windows.Freezable.Freeze" /> quando vengono copiati i valori.  Il risultato è stato bloccato dal <see cref="M:System.Windows.Freezable.GetAsFrozen" /> prima di essere restituiti.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the object is currently modifiable.</summary>
        <value>
          <see langword="true" /> Se l'oggetto è bloccato e non può essere modificato. <see langword="false" /> se l'oggetto può essere modificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenta di modificare un oggetto quando relativi <xref:System.Windows.Freezable.IsFrozen%2A> proprietà viene `true` genera un <xref:System.InvalidOperationException>.  
  
 Questa proprietà è di sola lettura dalla prospettiva del modello oggetto. Parte della documentazione sui <xref:System.Windows.Freezable> comportamenti possono menzionare "imposta <xref:System.Windows.Freezable.IsFrozen%2A> al `true`" o un linguaggio simile durante l'analisi del comportamento di altri metodi di <xref:System.Windows.Freezable>, ma questo comportamento avviene internamente nelle istanze della classe, i metodi dell'istanza quando modificano le variabili private presenti all'interno della classe astratta. Per impostare il valore di questa proprietà, è necessario chiamare <xref:System.Windows.Freezable.Freeze%2A>. Questa operazione una tantum per modificare in modo efficace è il <xref:System.Windows.Freezable.IsFrozen%2A> proprietà dal valore predefinito iniziale `false` torni allo stato di `true` dello stato. Non c'è alcun mezzo disponibili per impostare il valore al `false`. In alternativa, è possibile modificare qualsiasi copia completa eseguita dalla versione originale (vedere il <xref:System.Windows.Freezable.Clone%2A> (metodo)). Si tratta per impostazione predefinita ed è come qualsiasi classe derivata deve comportarsi quando applicato ai case in cui il <xref:System.Windows.Freezable> modello è utile.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato ogni volta che il <xref:System.Windows.Freezable.Changed> evento si verifica.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si implementa una classe che deriva da <see cref="T:System.Windows.Freezable" />, si può eseguire l'override di questo metodo per eseguire le attività.</para>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">The previous value of the data member.</param>
        <param name="newValue">The current value of the data member.</param>
        <summary>Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere chiamato da <xref:System.Windows.Freezable> eredi ogni volta che un <xref:System.Windows.DependencyObject> membro dati che non verrà archiviato come un <xref:System.Windows.DependencyProperty> è impostata.  
  
 Questo metodo non deve essere chiamato per <xref:System.Windows.DependencyObject> i membri dati vengono archiviati usando un <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">The previous value of the data member.</param>
        <param name="newValue">The current value of the data member.</param>
        <param name="property">The property that changed.</param>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event data that contains information about which property changed, and its old and new values.</param>
        <summary>Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati dell'evento contengono informazioni su solo il <xref:System.Windows.Freezable> stesso. Eventuali informazioni sulle proprietà secondarie devono essere ottenute tramite il <xref:System.Windows.Freezable.Changed> gestori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread. Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Le classi che derivano da <see cref="T:System.Windows.Freezable" /> chiami la <see cref="M:System.Windows.Freezable.ReadPreamble" /> metodo prima di tentare di accedere a qualsiasi membro che non è proprietà di dipendenza. Il <see cref="M:System.Windows.Freezable.WritePreamble" /> metodo deve essere chiamato prima che tali membri vengono scritti.  Questo metodo in modo efficace non esegue alcuna operazione fa altro che chiamare <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method. Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Le classi che derivano da <see cref="T:System.Windows.Freezable" /> consigliabile chiamare questo metodo alla fine di qualsiasi API che modifica un membro della classe che non verrà archiviato come un <see cref="T:System.Windows.DependencyProperty" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context. <see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> per verificare il contesto di threading è accessibile e viene generata un'eccezione se il <xref:System.Windows.Freezable> istanza è già bloccata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</exception>
        <block subset="none" type="overrides">
          <para>Le classi che derivano da <see cref="T:System.Windows.Freezable" /> consigliabile chiamare <see cref="M:System.Windows.Freezable.WritePreamble" /> prima di tentare di scrivere in qualsiasi membro che non è proprietà di dipendenza. Se si chiama <see cref="M:System.Windows.Freezable.WritePreamble" /> in un [! INCLUDE[TLA#tla_api](~/Includes/tlasharptla-API-MD.MD)], è possibile omettere una chiamata a <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>