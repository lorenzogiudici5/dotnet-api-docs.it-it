<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="973c346f1874ce6fbdd0454e4370d678d8bcf9de" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39786884" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definisce un oggetto che ha uno stato modificabile e uno stato di sola lettura (bloccato). Classi che derivano da <see cref="T:System.Windows.Freezable" /> forniscono notifica dettagliata di modifiche, possono essere rese immutabili e possono duplicarsi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Freezable> classe fornisce funzionalità speciali che consentono di migliorare le prestazioni dell'applicazione quando si usano gli oggetti che sono costosi da modificare o copiare. Esempi di <xref:System.Windows.Freezable> oggetti includono quanto segue:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Che derivano da Freezable  
 Una classe che deriva da <xref:System.Windows.Freezable> Ottiene le funzionalità seguenti:  
  
-   Stati speciali: (una sola lettura bloccato) e uno stato accessibile in scrittura.  
  
-   Sicurezza dei thread: un oggetto bloccato <xref:System.Windows.Freezable> oggetto può essere condivisi tra thread.  
  
-   Notifica dettagliata delle modifiche: a differenza di altri <xref:System.Windows.DependencyObject> oggetti, un <xref:System.Windows.Freezable> oggetto fornisce notifiche di modifica quando cambiano i valori delle sottoproprietà.  
  
-   La clonazione semplice: la classe Freezable ha già implementato diversi metodi che producono cloni.  
  
 Per informazioni sull'uso e crearne una propria <xref:System.Windows.Freezable> oggetti, vedere [Cenni preliminari sugli oggetti Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Qualsiasi membro pubblico <see langword="static" /> membri di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  Quando la <see cref="P:System.Windows.Freezable.IsFrozen" /> proprietà viene <see langword="false" />, un <see cref="T:System.Windows.Freezable" /> oggetto sono accessibili solo dal thread in cui è stato creato. Il tentativo di accedervi da un altro thread genererà un <see cref="T:System.InvalidOperationException" />. Il <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> e <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> metodi forniscono supporto per il marshalling al thread corretto.  Quando le <see cref="P:System.Windows.Freezable.IsFrozen" /> proprietà viene <see langword="true" />, <see cref="T:System.Windows.Freezable" /> sono oggetti a thread libero.  Per altre informazioni, vedere [Cenni preliminari sugli oggetti Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza di una classe derivata <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo è il costruttore di accessibilità protected di una classe astratta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto può essere impostato come non modificabile.</summary>
        <value>
          <see langword="true" /> se l'oggetto corrente può essere impostato come non modificabile o è già non modificabile. In caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Questa implementazione del metodo Usa il <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metodo con <paramref name="isChecking" /> impostata su <see langword="true" /> per determinare se un <see cref="T:System.Windows.Freezable" /> può essere reso immodificabile. Per modificare il comportamento di questa proprietà in una classe derivata, esegue l'override di <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (metodo).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando <see cref="T:System.Windows.Freezable" /> o un oggetto che contiene è modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si tenta di aggiungere o rimuovere i gestori eventi quando l'oggetto corrente non è modificabile (quando il <xref:System.Windows.Freezable.IsFrozen%2A> è di proprietà `true`), viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clone modificabile dell'oggetto <see cref="T:System.Windows.Freezable" />, eseguendo copie complete dei valori dell'oggetto. Durante la copia delle proprietà di dipendenza di questo oggetto, questo metodo copia le espressioni (che potrebbero non essere più risolte), ma non le animazioni né i relativi valori correnti.</summary>
        <returns>Clone modificabile dell'oggetto corrente. La proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto clonato è <see langword="false" />, anche se la proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto di origine è <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> producono modificabili cloni di bloccato <xref:System.Windows.Freezable> oggetti (clonare anche i metodi <xref:System.Windows.Freezable> gli oggetti che non sono bloccati). Il clone in modo efficace è una copia completa dell'oggetto corrente.  
  
 Nella tabella seguente riepiloga le differenze tra il <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> metodi.  
  
|Operazione|Comportamento del metodo Clone|Metodo CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Copia di una proprietà di dipendenza che dispone di un'espressione|L'espressione viene copiato, ma non è più potrebbe essere risolto. Per altre informazioni, vedere [Cenni preliminari sugli oggetti Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Il valore corrente dell'espressione viene copiato, ma non l'espressione stessa.|  
|Copia di una proprietà di dipendenza animata|Il valore della proprietà base (non animati) viene copiato. Le animazioni non vengono copiate.|Il valore della proprietà corrente animata viene copiato. Le animazioni non vengono copiate.|  
  
 Si noti che non vengono copiate le proprietà non impostate. Se una proprietà non impostata ha un valore predefinito che è un oggetto bloccato <xref:System.Windows.Freezable>, che rimane bloccato nel clone modificabile in caso contrario, un valore della proprietà.  
  
## <a name="move-a-freezable-between-threads"></a>Spostare un oggetto Freezable tra thread  
 Questo metodo può essere utile per lo spostamento di un <xref:System.Windows.Freezable> tra thread. In primo luogo, verificare i <xref:System.Windows.Freezable> immodificabile chiamando relativo <xref:System.Windows.Freezable.Freeze%2A> (metodo). È ora possibile accedere a un altro thread il <xref:System.Windows.Freezable> e apportare una variabile locale <xref:System.Windows.Freezable.Clone%2A> che possa accedere.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> per produrre il clone. Per modificare il comportamento di questo metodo in una classe derivata, esegue l'override di <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> (metodo).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Oggetto da clonare.</param>
        <summary>Rende l'istanza un clone (copia completa) dell'oggetto <see cref="T:System.Windows.Freezable" /> specificato usando i valori di proprietà di base (non animati).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal <xref:System.Windows.Freezable.Clone%2A> metodo e non può essere chiamato direttamente dal codice, tranne quando si chiama l'implementazione di base durante l'override di questo metodo. Per creare una copia modificabile dell'oggetto corrente, chiamare <xref:System.Windows.Freezable.Clone%2A> invece di chiamare direttamente questo metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se si deriva da <see cref="T:System.Windows.Freezable" />, potrebbe essere necessario eseguire l'override di questo metodo. Motivi per eseguire l'override includono quanto segue:-la classe derivata dispone di dati che non vengono esposti tramite proprietà di dipendenza.  -La classe derivata deve eseguire operazioni di inizializzazione aggiuntive che non possono essere eseguita sostituendo semplicemente <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Ad esempio, si applica se la classe derivata implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Le classi che archiviano tutti i dati nelle proprietà di dipendenza e che non è necessario effettuare operazioni di inizializzazione aggiuntiva non sono necessario eseguire l'override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  È essenziale che tutte le implementazioni di chiamano l'implementazione di base di questo metodo. Le implementazioni devono solo eseguire operazioni che non viene eseguita dall'implementazione predefinita. L'implementazione predefinita esegue copie complete di tutte le proprietà scrivibili, impostate localmente, incluse le espressioni interne.  Se l'oggetto ha proprietà di dipendenza associata a dati, le espressioni vengono copiate ma non è più possano risolvere. Per altre informazioni sugli oggetti associati a dati duplicati, vedere [Cenni preliminari sugli oggetti Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Se l'oggetto ha proprietà di dipendenza animate, viene copiato il valore di base (non animati) delle proprietà. Le animazioni non vengono copiate.  Si noti che non vengono copiate le proprietà non impostate né sono proprietà di sola lettura. Se questa proprietà ha un valore predefinito che è un oggetto bloccato <see cref="T:System.Windows.Freezable" />, che rimane bloccato nel clone modificabile in caso contrario, un valore della proprietà.  L'elenco seguente riepiloga il comportamento previsto per questo metodo:-la copia del prodotto contiene copie di tutti <see cref="T:System.Windows.Freezable" /> oggetti secondari.  -Proprietà unset e di sola lettura non vengono copiate.  -Le espressioni vengono copiate.  -Nessuno di questi oggetti secondari vengono bloccate al momento della creazione.  -La copia di se stesso non sia bloccata.  -Le animazioni non vengono copiate.  -Solo i valori di base proprietà sono valori animati copiati, non attualmente.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clone modificabile (copia completa) di <see cref="T:System.Windows.Freezable" /> utilizzando i valori correnti.</summary>
        <returns>Clone modificabile dell'oggetto corrente. La proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto clonato è <see langword="false" />, anche se la proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> dell'oggetto di origine è <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> producono modificabili cloni di bloccato <xref:System.Windows.Freezable> oggetti (clonare anche i metodi <xref:System.Windows.Freezable> gli oggetti che non sono bloccati). Il clone in modo efficace è una copia completa dell'oggetto corrente.  
  
 Nella tabella seguente riepiloga le differenze tra il <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> metodi.  
  
|Operazione|Comportamento del metodo Clone|Metodo CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Copia di una proprietà di dipendenza che dispone di un'espressione|L'espressione viene copiato, ma non è più potrebbe essere risolto. Per altre informazioni, vedere [Cenni preliminari sugli oggetti Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Il valore corrente dell'espressione viene copiato, ma non l'espressione stessa.|  
|Copia di una proprietà di dipendenza animata|Il valore della proprietà base (non animati) viene copiato. Le animazioni non vengono copiate.|Il valore della proprietà corrente animata viene copiato. Le animazioni non vengono copiate.|  
  
 Si noti che non vengono copiate le proprietà non impostate. Se una proprietà non impostata ha un valore predefinito che è un oggetto bloccato <xref:System.Windows.Freezable>, che rimane bloccato nel clone modificabile in caso contrario, un valore della proprietà.  
  
## <a name="move-a-freezable-between-threads"></a>Spostare un oggetto Freezable tra thread  
 Questo metodo può essere utile per lo spostamento di un <xref:System.Windows.Freezable> tra thread. In primo luogo, verificare i <xref:System.Windows.Freezable> immodificabile usando relativo <xref:System.Windows.Freezable.Freeze%2A> (metodo). È ora possibile accedere a un altro thread il <xref:System.Windows.Freezable> e creare un clone locale che può accedere.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa il <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> per produrre il clone; (metodo) <see cref="T:System.Windows.Freezable" /> gli implementatori di che eseguire l'override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> necessario assicurarsi che la copia non viene bloccata durante la creazione.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Costruttore <see cref="T:System.Windows.Freezable" /> da duplicare.</param>
        <summary>Rende l'istanza un clone (copia completa) modificabile dell'oggetto <see cref="T:System.Windows.Freezable" /> specificato usando i valori di proprietà correnti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal <xref:System.Windows.Freezable.CloneCurrentValue%2A> metodo e non può essere chiamato direttamente dal codice, tranne quando si chiama l'implementazione di base durante l'override di questo metodo. Per creare una copia modificabile dell'oggetto corrente, chiamare <xref:System.Windows.Freezable.CloneCurrentValue%2A> invece di chiamare direttamente questo metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se si deriva da <see cref="T:System.Windows.Freezable" />, potrebbe essere necessario eseguire l'override di questo metodo. Motivi per eseguire l'override includono quanto segue:-la classe derivata dispone di dati che non vengono esposti tramite proprietà di dipendenza.  -La classe derivata deve eseguire operazioni di inizializzazione aggiuntive che non possono essere eseguita sostituendo semplicemente <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Ad esempio, si applica se la classe derivata implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Le classi che archiviano tutti i dati nelle proprietà di dipendenza e che non è necessario effettuare operazioni di inizializzazione aggiuntiva non sono necessario eseguire l'override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  È essenziale che tutte le implementazioni di chiamano l'implementazione di base di questo metodo. Le implementazioni devono solo eseguire operazioni che non viene eseguita dall'implementazione predefinita. L'implementazione predefinita esegue copie complete di tutte le proprietà scrivibili, impostate localmente. Se l'oggetto contiene le proprietà di dipendenza con espressioni (ad esempio, un'associazione di dati), ma non l'espressione stessa viene copiato il valore corrente dell'espressione.  Se l'oggetto ha proprietà di dipendenza animate, viene copiato il valore animato corrente di tali proprietà, ma non le animazioni.  Si noti che non vengono copiate le proprietà non impostate né sono proprietà di sola lettura. Se questa proprietà ha un valore predefinito che è un oggetto bloccato <see cref="T:System.Windows.Freezable" />, che rimane bloccato nel clone modificabile in caso contrario, un valore della proprietà.  L'elenco seguente riepiloga il comportamento previsto per questo metodo.  -La copia del prodotto contiene copie di tutti <see cref="T:System.Windows.Freezable" /> oggetti secondari.  -Proprietà unset e di sola lettura non vengono copiate.  -Se una proprietà è animata, viene copiato il valore corrente, ma non dell'animazione stessa.  -Nessuno di questi oggetti secondari vengono bloccate al momento della creazione.  -La copia di se stesso non sia bloccata.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>Nuova istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo protetto, e le implementazioni specifiche dell'oggetto effettive per il comportamento dipende l'implementazione di override di <xref:System.Windows.Freezable.CreateInstanceCore%2A> metodo, che questo metodo chiama internamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando è implementato in una classe derivata, crea una nuova istanza della classe derivata <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>Nuova istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non chiamare questo metodo direttamente (tranne quando la chiamata a base in un'implementazione). Questo metodo viene chiamato internamente dal <xref:System.Windows.Freezable.CreateInstance%2A> metodo ogni volta che una nuova istanza del <xref:System.Windows.Freezable> viene creato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata un'implementazione tipica delle <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ogni <see cref="T:System.Windows.Freezable" /> classe derivata deve implementare questo metodo. Un'implementazione tipica è semplicemente chiamare il costruttore predefinito e restituire il risultato.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rende immodificabile l'oggetto <see cref="T:System.Windows.Freezable" /> ed imposta la proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> su <see langword="true" />, o verifica se è possibile rendere immodificabile un oggetto <see cref="T:System.Windows.Freezable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rende immodificabile l'oggetto corrente e imposta la proprietà <see cref="P:System.Windows.Freezable.IsFrozen" /> su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per evitare la possibilità di un' <xref:System.InvalidOperationException> quando si chiama questo metodo, verificare la <xref:System.Windows.Freezable.CanFreeze%2A> proprietà per determinare se il <xref:System.Windows.Freezable> può essere reso immodificabile prima di chiamare questo metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossibile rendere immodificabile<see cref="T:System.Windows.Freezable" />.</exception>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa il <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metodo per rendere il <see cref="T:System.Windows.Freezable" /> immodificabile. Per modificare il comportamento di blocco, eseguire l'override di <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (metodo).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Oggetto da controllare o da rendere immodificabile. Se <c>isChecking</c> è <see langword="true" />, l'oggetto è controllato per determinare se può essere reso immodificabile. Se <c>isChecking</c> è <see langword="false" />, l'oggetto è reso non modificabile, se possibile.</param>
        <param name="isChecking">
          <see langword="true" /> da cui restituire un'indicazione che dichiari se l'oggetto può essere bloccato (senza bloccarlo davvero); <see langword="false" /> per bloccare davvero l'oggetto.</param>
        <summary>Se il parametro <paramref name="isChecking" /> è <see langword="true" />, questo metodo indica se è possibile rendere immodificabile <see cref="T:System.Windows.Freezable" /> specificato. Se il parametro <paramref name="isChecking" /> è <see langword="false" />, questo metodo tenta di rendere immodificabile il <see cref="T:System.Windows.Freezable" /> specificato e indica se l'operazione è riuscita.</summary>
        <returns>Se <paramref name="isChecking" /> è <see langword="true" />, questo metodo restituisce <see langword="true" /> se <see cref="T:System.Windows.Freezable" /> specificato può essere reso immodificabile, o <see langword="false" /> se non può essere reso immodificabile. Se <paramref name="isChecking" /> è <see langword="false" />, questo metodo restituisce <see langword="true" /> se <see cref="T:System.Windows.Freezable" /> specificato è ora immodificabile, oppure <see langword="false" /> se non può essere reso immodificabile.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non chiamare questo metodo a meno che non si deriva da <xref:System.Windows.Freezable> ed eseguire l'override di <xref:System.Windows.Freezable.FreezeCore%2A> (metodo).  Questo metodo può essere usato nel <xref:System.Windows.Freezable.FreezeCore%2A> metodo per bloccare i membri dati della classe a loro volta <xref:System.Windows.Freezable> oggetti.  
  
 Bene. ora è chiamare questo metodo nuovamente su un <xref:System.Windows.Freezable> oggetto che è già bloccata (non modificabile).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Quando <paramref name="isChecking" /> è <see langword="false" />, il tentativo di rendere immodificabile <paramref name="freezable" /> non è stato completato correttamente; l'oggetto ora è in uno stato sconosciuto (potrebbe essere parzialmente bloccato).</exception>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa il <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> metodo per rendere il <see cref="T:System.Windows.Freezable" /> immodificabile. Per modificare il comportamento di blocco, eseguire l'override di <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (metodo).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <see langword="true" /> da cui restituire un'indicazione che dichiari se l'oggetto può essere bloccato (senza bloccarlo davvero); <see langword="false" /> per bloccare davvero l'oggetto.</param>
        <summary>Rende immodificabile l'oggetto <see cref="T:System.Windows.Freezable" /> o verifica se può essere reso immodificabile.</summary>
        <returns>Se <paramref name="isChecking" /> è <see langword="true" />, questo metodo restituisce <see langword="true" /> se <see cref="T:System.Windows.Freezable" /> può essere reso immodificabile, o <see langword="false" /> se non può essere reso immodificabile. Se <paramref name="isChecking" /> è <see langword="false" />, questo metodo restituisce <see langword="true" /> se <see cref="T:System.Windows.Freezable" /> specificato è ora immodificabile, oppure <see langword="false" /> se non può essere reso immodificabile.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non chiamare questo metodo direttamente (tranne quando la chiamata a base in un'implementazione). Questo metodo viene chiamato internamente dal <xref:System.Windows.Freezable.CanFreeze%2A> proprietà (con `isChecking` uguale a `true`) e il <xref:System.Windows.Freezable.Freeze%2A> metodo (con `isChecking` uguale a `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.Freezable" /> gli implementatori devono eseguire l'override di questo metodo quando la classe contiene i dati che non vengono archiviati utilizzando le proprietà di dipendenza.  Un'implementazione tipica potrebbe chiamare il metodo base, quindi chiamare il metodo statico <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> metodo in tutti i <see cref="T:System.Windows.Freezable" /> le proprietà che contiene la classe, restituendo tipizzate <see langword="true" /> solo se tutte le proprietà sono state bloccate (o potrebbero essere state bloccate, in caso di specifica <see langword="true" /> per <paramref name="isChecking" />).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia bloccata di <see cref="T:System.Windows.Freezable" />, utilizzando valori delle proprietà di base (non-animati). Dato che la copia è bloccata, gli oggetti secondari bloccati sono copiati dal riferimento.</summary>
        <returns>Una copia bloccata di <see cref="T:System.Windows.Freezable" />. La proprietà della copia <see cref="P:System.Windows.Freezable.IsFrozen" /> è impostata su <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È consigliabile controllare la <xref:System.Windows.Freezable.CanFreeze%2A> proprietà prima di chiamare questo metodo per verificare che il <xref:System.Windows.Freezable> può essere bloccato. Con questo metodo è simile alla creazione di una copia usando il <xref:System.Windows.Freezable.Clone%2A> e quindi bloccandolo con la <xref:System.Windows.Freezable.Freeze%2A> (metodo).  
  
 Il <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metodi possono migliorare le prestazioni di copia perché non duplicano <xref:System.Windows.Freezable> oggetti secondari che sono già bloccati, li copiano solo per riferimento.  
  
 Nella tabella seguente riepiloga le differenze tra il <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metodi.  
  
|Operazione|Metodo GetAsFrozen|Metodo GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Copia di una proprietà di dipendenza che dispone di un'espressione|Il metodo genera un' <xref:System.InvalidOperationException> perché non è possibile <xref:System.Windows.Freezable.Freeze%2A> la proprietà.|Il valore corrente dell'espressione viene copiato, ma non l'espressione stessa.|  
|Copia di una proprietà di dipendenza animata|Il valore della proprietà base (non animati) viene copiato. Le animazioni non vengono copiate.|Il valore della proprietà corrente animata viene copiato. Le animazioni non vengono copiate.|  
  
 Si noti che non vengono copiate le proprietà non impostate né sono proprietà di sola lettura.  
  
 Per creare una copia del <xref:System.Windows.Freezable> vale a dire non bloccato, utilizzare il <xref:System.Windows.Freezable.Clone%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Freezable" /> non può essere bloccato perché contiene espressioni o proprietà animate.</exception>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa virtuale <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> metodo per produrre il clone.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Istanza da copiare.</param>
        <summary>Si prenda ad esempio una copia bloccata di <see cref="T:System.Windows.Freezable" /> specificato utilizzando valori della proprietà di base (non-animati).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal <xref:System.Windows.Freezable.GetAsFrozen%2A> metodo e non può essere chiamato direttamente dal codice, tranne quando si chiama l'implementazione di base durante l'override di questo metodo. Per creare una copia bloccata dell'oggetto corrente, chiamare <xref:System.Windows.Freezable.GetAsFrozen%2A> invece di chiamare direttamente questo metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se si deriva da <see cref="T:System.Windows.Freezable" /> potrebbe essere necessario eseguire l'override di questo metodo. Motivi per eseguire l'override includono quanto segue:-la classe derivata dispone di dati che non vengono esposti tramite proprietà di dipendenza.  -La classe derivata deve eseguire operazioni di inizializzazione aggiuntive che non possono essere eseguita sostituendo semplicemente <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Ad esempio, si applica se la classe derivata implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Le classi che archiviano tutti i dati nelle proprietà di dipendenza e che non è necessario effettuare operazioni di inizializzazione aggiuntiva non sono necessario eseguire l'override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  È essenziale che tutte le implementazioni di chiamano l'implementazione di base di questo metodo. Le implementazioni devono solo eseguire operazioni che non viene eseguita dall'implementazione predefinita. L'implementazione predefinita esegue copie complete di eventuali oggetti Freezable non bloccati e superficiale copie di tutte le altre proprietà scrivibili, in locale che contiene le proprietà del set. Se l'oggetto ha proprietà di dipendenza associata a dati, le espressioni vengono copiate ma non è più possano risolvere; per altre informazioni sugli oggetti associati a dati duplicati, vedere [Cenni preliminari sugli oggetti Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Se l'oggetto ha proprietà di dipendenza animate, vengono copiati i valori di base (non animati) delle proprietà. Le animazioni non vengono copiate.  Si noti che non vengono copiate le proprietà non impostate né sono proprietà di sola lettura.  Se si esegue l'override di questo metodo, è necessario chiamare l'implementazione di base.  Non è necessario per <see cref="M:System.Windows.Freezable.Freeze" /> quando vengono copiati i valori.  Il risultato è stato bloccato dal <see cref="M:System.Windows.Freezable.GetAsFrozen" /> prima di essere restituiti.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia bloccata di <see cref="T:System.Windows.Freezable" /> utilizzando valori della proprietà correnti. Dato che la copia è bloccata, gli oggetti secondari bloccati sono copiati dal riferimento.</summary>
        <returns>Una copia bloccata di <see cref="T:System.Windows.Freezable" />. La proprietà della copia <see cref="P:System.Windows.Freezable.IsFrozen" /> è impostata su <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con questo metodo è simile alla creazione di una copia usando il <xref:System.Windows.Freezable.CloneCurrentValue%2A> e quindi bloccandolo con la <xref:System.Windows.Freezable.Freeze%2A> (metodo).  
  
 Il <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metodi possono migliorare le prestazioni di copia perché non duplicano <xref:System.Windows.Freezable> oggetti secondari che sono già bloccati, li copiano solo per riferimento.  
  
 Nella tabella seguente riepiloga le differenze tra il <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metodi.  
  
|Operazione|Metodo GetAsFrozen|Metodo GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Copia di una proprietà di dipendenza che dispone di un'espressione|Il metodo genera un' <xref:System.InvalidOperationException> perché non è possibile <xref:System.Windows.Freezable.Freeze%2A> la proprietà.|Il valore corrente dell'espressione viene copiato, ma non l'espressione stessa.|  
|Copia di una proprietà di dipendenza animata|Il valore della proprietà base (non animati) viene copiato. Le animazioni non vengono copiate.|Il valore della proprietà corrente animata viene copiato. Le animazioni non vengono copiate.|  
  
 Si noti che non vengono copiate le proprietà non impostate né sono proprietà di sola lettura.  
  
 Per creare una copia del <xref:System.Windows.Freezable> vale a dire non bloccato, utilizzare il <xref:System.Windows.Freezable.CloneCurrentValue%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Questo metodo Usa virtuale <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> metodo per produrre il clone.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Oggetto <see cref="T:System.Windows.Freezable" /> da copiare e bloccare.</param>
        <summary>Rende l’istanza corrente una copia bloccata di <see cref="T:System.Windows.Freezable" />specificato. Se l'oggetto ha proprietà di dipendenza animate, i valori animati correnti vengono copiati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> metodo e non può essere chiamato direttamente dal codice, tranne quando si chiama l'implementazione di base durante l'override di questo metodo. Per creare una copia bloccata dell'oggetto corrente, chiamare <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> invece di chiamare direttamente questo metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se si deriva da <see cref="T:System.Windows.Freezable" />, potrebbe essere necessario eseguire l'override di questo metodo. Motivi per eseguire l'override includono quanto segue:-la classe derivata dispone di dati che non vengono esposti tramite proprietà di dipendenza.  -La classe derivata deve eseguire operazioni di inizializzazione aggiuntive che non possono essere eseguita sostituendo semplicemente <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Ad esempio, si applica se la classe derivata implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Le classi che archiviano tutti i dati nelle proprietà di dipendenza e che non è necessario effettuare operazioni di inizializzazione aggiuntiva non sono necessario eseguire l'override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  È essenziale che tutte le implementazioni di chiamano l'implementazione di base di questo metodo. Le implementazioni devono solo eseguire operazioni che non viene eseguita dall'implementazione predefinita. L'implementazione predefinita crea un nuovo <see cref="T:System.Windows.Freezable" /> utilizzando il <see cref="M:System.Windows.Freezable.CreateInstance" /> (metodo) e la imposta come copie complete di oggetti Freezable non bloccati e copia superficiale di tutte le altre proprietà scrivibili, in locale impostare proprietà in essa contenute. Se l'oggetto ha proprietà di dipendenza associata a dati, le associazioni dati vengono copiate ma non è più potrebbero risolvere; per altre informazioni sugli oggetti associati a dati duplicati, vedere [Cenni preliminari sugli oggetti Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Se l'oggetto ha proprietà di dipendenza animate, viene copiato il valore animato corrente di tali proprietà, ma non le animazioni.  Le proprietà di dipendenza di sola lettura all'interno di un <see cref="T:System.Windows.Freezable" /> non vengono copiati da questa implementazione predefinita.  Se si esegue l'override di questo metodo, è necessario chiamare l'implementazione di base.  Non è necessario per <see cref="M:System.Windows.Freezable.Freeze" /> quando vengono copiati i valori.  Il risultato è stato bloccato dal <see cref="M:System.Windows.Freezable.GetAsFrozen" /> prima di essere restituiti.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto è attualmente modificabile.</summary>
        <value>
          <see langword="true" /> se l'oggetto è bloccato e non può essere modificato; <see langword="false" /> se l'oggetto può essere modificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenta di modificare un oggetto quando relativi <xref:System.Windows.Freezable.IsFrozen%2A> proprietà viene `true` genera un <xref:System.InvalidOperationException>.  
  
 Questa proprietà è di sola lettura dalla prospettiva del modello oggetto. Parte della documentazione sui <xref:System.Windows.Freezable> comportamenti possono menzionare "imposta <xref:System.Windows.Freezable.IsFrozen%2A> al `true`" o un linguaggio simile durante l'analisi del comportamento di altri metodi di <xref:System.Windows.Freezable>, ma questo comportamento avviene internamente nelle istanze della classe, i metodi dell'istanza quando modificano le variabili private presenti all'interno della classe astratta. Per impostare il valore di questa proprietà, è necessario chiamare <xref:System.Windows.Freezable.Freeze%2A>. Questa operazione una tantum per modificare in modo efficace è il <xref:System.Windows.Freezable.IsFrozen%2A> proprietà dal valore predefinito iniziale `false` torni allo stato di `true` dello stato. Non c'è alcun mezzo disponibili per impostare il valore al `false`. In alternativa, è possibile modificare qualsiasi copia completa eseguita dalla versione originale (vedere il <xref:System.Windows.Freezable.Clone%2A> (metodo)). Si tratta per impostazione predefinita ed è come qualsiasi classe derivata deve comportarsi quando applicato ai case in cui il <xref:System.Windows.Freezable> modello è utile.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Viene chiamato quando l'oggetto <see cref="T:System.Windows.Freezable" /> corrente viene modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato ogni volta che il <xref:System.Windows.Freezable.Changed> evento si verifica.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si implementa una classe che deriva da <see cref="T:System.Windows.Freezable" />, si può eseguire l'override di questo metodo per eseguire le attività.</para>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Assicura che adatti puntatori del contesto siano stabiliti per un membro dati di tipo <see cref="T:System.Windows.DependencyObject" /> che è appena stato modificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Precedente valore del membro dati.</param>
        <param name="newValue">Valore corrente del membro dati.</param>
        <summary>Assicura che adatti puntatori del contesto siano stabiliti per un membro dati <see cref="T:System.Windows.DependencyObjectType" /> che è appena stato impostato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere chiamato da <xref:System.Windows.Freezable> eredi ogni volta che un <xref:System.Windows.DependencyObject> membro dati che non verrà archiviato come un <xref:System.Windows.DependencyProperty> è impostata.  
  
 Questo metodo non deve essere chiamato per <xref:System.Windows.DependencyObject> i membri dati vengono archiviati usando un <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Precedente valore del membro dati.</param>
        <param name="newValue">Valore corrente del membro dati.</param>
        <param name="property">Proprietà modificata.</param>
        <summary>Questo membro supporta l'infrastruttura di [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] e non deve essere usato direttamente dal codice.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento con le informazioni sulla proprietà modificata e i valori precedente e corrente corrispondenti.</param>
        <summary>Esegue l'override dell'implementazione di <see cref="T:System.Windows.DependencyObject" /> di <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> per richiamare anche eventuali gestori <see cref="E:System.Windows.Freezable.Changed" /> in risposta alla modifica di una proprietà di dipendenza di tipo <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I dati dell'evento contengono informazioni su solo il <xref:System.Windows.Freezable> stesso. Eventuali informazioni sulle proprietà secondarie devono essere ottenute tramite il <xref:System.Windows.Freezable.Changed> gestori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Assicura che l’accesso di <see cref="T:System.Windows.Freezable" /> sia stato eseguito da un thread valido. Gli eredi di <see cref="T:System.Windows.Freezable" /> devono chiamare questo metodo all'inizio di qualsiasi [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] che legge i membri dei dati che non sono proprietà della dipendenza.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Le classi che derivano da <see cref="T:System.Windows.Freezable" /> chiami la <see cref="M:System.Windows.Freezable.ReadPreamble" /> metodo prima di tentare di accedere a qualsiasi membro che non è proprietà di dipendenza. Il <see cref="M:System.Windows.Freezable.WritePreamble" /> metodo deve essere chiamato prima che tali membri vengono scritti.  Questo metodo in modo efficace non esegue alcuna operazione fa altro che chiamare <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera l'evento <see cref="E:System.Windows.Freezable.Changed" /> per <see cref="T:System.Windows.Freezable" /> e richiama il metodo <see cref="M:System.Windows.Freezable.OnChanged" />. Le classi che derivano da <see cref="T:System.Windows.Freezable" /> devono chiamare questo metodo alla fine di qualsiasi API che modifica i membri di classe che non sono archiviati come proprietà di dipendenza.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Le classi che derivano da <see cref="T:System.Windows.Freezable" /> consigliabile chiamare questo metodo alla fine di qualsiasi API che modifica un membro della classe che non verrà archiviato come un <see cref="T:System.Windows.DependencyProperty" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifica che l'oggetto <see cref="T:System.Windows.Freezable" /> non sia bloccato e che l'accesso sia eseguito da un contesto di threading valido. Gli eredi di <see cref="T:System.Windows.Freezable" /> devono chiamare questo metodo all'inizio di qualsiasi [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] che scrive sui membri dei dati che non sono proprietà della dipendenza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> per verificare il contesto di threading è accessibile e viene generata un'eccezione se il <xref:System.Windows.Freezable> istanza è già bloccata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'istanza <see cref="T:System.Windows.Freezable" /> è bloccata e non è possibile scrivere nei suoi membri.</exception>
        <block subset="none" type="overrides">
          <para>Le classi che derivano da <see cref="T:System.Windows.Freezable" /> consigliabile chiamare <see cref="M:System.Windows.Freezable.WritePreamble" /> prima di tentare di scrivere in qualsiasi membro che non è proprietà di dipendenza. Se si chiama <see cref="M:System.Windows.Freezable.WritePreamble" /> in un [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], è possibile omettere una chiamata a <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>