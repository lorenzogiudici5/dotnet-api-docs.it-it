<Type Name="DataTemplate" FullName="System.Windows.DataTemplate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3e534e860871276c35131f0f34bfc9bad0a2912" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51313550" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTemplate : System.Windows.FrameworkTemplate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataTemplate extends System.Windows.FrameworkTemplate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DataTemplate" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTemplate&#xA;Inherits FrameworkTemplate" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTemplate : System::Windows::FrameworkTemplate" />
  <TypeSignature Language="F#" Value="type DataTemplate = class&#xA;    inherit FrameworkTemplate" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkTemplate</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.DictionaryKeyProperty("DataTemplateKey")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Descrive la struttura visiva di un oggetto dati.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si utilizza un <xref:System.Windows.DataTemplate> per specificare la visualizzazione degli oggetti dati. <xref:System.Windows.DataTemplate> gli oggetti sono particolarmente utili quando si associa un <xref:System.Windows.Controls.ItemsControl> , ad esempio un <xref:System.Windows.Controls.ListBox> a un'intera raccolta. Senza istruzioni specifiche, un <xref:System.Windows.Controls.ListBox> Visualizza la rappresentazione di stringa degli oggetti in una raccolta. In tal caso, è possibile usare un <xref:System.Windows.DataTemplate> per definire l'aspetto degli oggetti dati. Il contenuto di <xref:System.Windows.DataTemplate> diventa la struttura visiva degli oggetti dati.  
  
 Per un'analisi approfondita, vedere [Cenni preliminari sui modelli di dati](~/docs/framework/wpf/data/data-templating-overview.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un <xref:System.Windows.DataTemplate> inline. Il <xref:System.Windows.DataTemplate> specifica che ogni elemento di dati viene visualizzato come tre <xref:System.Windows.Controls.TextBlock> gli elementi all'interno di un <xref:System.Windows.Controls.StackPanel>. In questo esempio, l'oggetto dati è una classe denominata `Task`. Si noti che ogni <xref:System.Windows.Controls.TextBlock> elemento in questo modello è associato a una proprietà del `Task` classe.  
  
 [!code-xaml[DataTemplatingIntro_snip#Inline](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#inline)]  
  
 È più comune per definire un <xref:System.Windows.DataTemplate> nella sezione delle risorse, pertanto può essere un oggetto riutilizzabile, come nell'esempio seguente:  
  
 [!code-xaml[DataTemplatingIntro_snip#R1](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r1)]  
[!code-xaml[DataTemplatingIntro_snip#AsResource](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#asresource)]  
[!code-xaml[DataTemplatingIntro_snip#R2](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r2)]  
  
 È possibile a questo punto usare `myTaskTemplate` come risorsa, come illustrato nell'esempio seguente:  
  
 [!code-xaml[DataTemplatingIntro_snip#MyTaskTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#mytasktemplate)]  
  
 Per l'esempio completo, vedere [Introduction to Data Templating Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Data%20Binding/DataTemplatingIntro) (Introduzione a un esempio di applicazione di modello).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Data.Binding" />
    <altmember cref="T:System.Windows.Controls.DataTemplateSelector" />
    <altmember cref="T:System.Windows.HierarchicalDataTemplate" />
    <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=163703">Demo di Data Binding</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.DataTemplate" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTemplate();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.DataTemplate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTemplate (object dataType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object dataType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataType As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTemplate(System::Object ^ dataType);" />
      <MemberSignature Language="F#" Value="new System.Windows.DataTemplate : obj -&gt; System.Windows.DataTemplate" Usage="new System.Windows.DataTemplate dataType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataType" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dataType">Se il modello è destinato ai dati dell'oggetto, questo è il nome del tipo dell'oggetto dati.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.DataTemplate" /> con la proprietà <see cref="P:System.Windows.DataTemplate.DataType" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per fare riferimento al nome del tipo della classe, usare il [estensione di Markup X:Type](~/docs/framework/xaml-services/x-type-markup-extension.md). Se il modello è destinato [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] dati, si tratta della stringa che rappresenta il nome del tag dei dati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataTemplateKey">
      <MemberSignature Language="C#" Value="public object DataTemplateKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataTemplateKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.DataTemplateKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataTemplateKey As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataTemplateKey { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataTemplateKey : obj" Usage="System.Windows.DataTemplate.DataTemplateKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la chiave predefinita di <see cref="T:System.Windows.DataTemplate" />.</summary>
        <value>Chiave predefinita di <see cref="T:System.Windows.DataTemplate" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non si imposta la [direttiva X:Key](~/docs/framework/xaml-services/x-key-directive.md) in un <xref:System.Windows.DataTemplate> che si trova in un <xref:System.Windows.ResourceDictionary>, il <xref:System.Windows.DataTemplate.DataTemplateKey%2A> viene usato come chiave.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataType">
      <MemberSignature Language="C#" Value="public object DataType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.DataType" />
      <MemberSignature Language="VB.NET" Value="Public Property DataType As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataType { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataType : obj with get, set" Usage="System.Windows.DataTemplate.DataType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il tipo per cui l'oggetto <see cref="T:System.Windows.DataTemplate" /> è destinato.</summary>
        <value>Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è molto simile al <xref:System.Windows.Style.TargetType%2A> proprietà del <xref:System.Windows.Style> classe. Quando si imposta questa proprietà per il tipo di dati senza specificare un `x:Key`, il <xref:System.Windows.DataTemplate> viene applicato automaticamente a oggetti di dati di quel tipo. Si noti che caso in questo il `x:Key` è impostato in modo implicito. Pertanto, se si assegna questo <xref:System.Windows.DataTemplate> un' `x:Key` valore, si esegue l'override implicito `x:Key` e il <xref:System.Windows.DataTemplate> non verrà applicato automaticamente.  
  
 Si noti anche che se si esegue l'associazione una <xref:System.Windows.Controls.ContentControl> a una raccolta di `Task` oggetti, il <xref:System.Windows.Controls.ContentControl> non usa il <xref:System.Windows.DataTemplate> automaticamente. Infatti, l'associazione in un <xref:System.Windows.Controls.ContentControl> richiede più informazioni per capire se si desidera associare a un'intera raccolta o a singoli oggetti. Se il <xref:System.Windows.Controls.ContentControl> tiene traccia della selezione di un <xref:System.Windows.Controls.ItemsControl> tipo, è possibile impostare il <xref:System.Windows.Data.Binding.Path%2A> proprietà della <xref:System.Windows.Controls.ContentControl> associazione a "`/`" per indicare che si è interessati all'elemento corrente. Per un esempio, vedere [procedura: associare a una raccolta e visualizzare informazioni base alla selezione](~/docs/framework/wpf/data/how-to-bind-to-a-collection-and-display-information-based-on-selection.md). In caso contrario, è necessario specificare il <xref:System.Windows.DataTemplate> in modo esplicito, impostando il <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> proprietà.  
  
 Il <xref:System.Windows.DataTemplate.DataType%2A> proprietà è particolarmente utile quando si dispone di un <xref:System.Windows.Data.CompositeCollection> di diversi tipi di oggetti dati.  
  
 Se questa proprietà è destinata a un elemento XML che non è incluso nello spazio dei nomi predefinito, è necessario anteporre il nome dell'elemento con lo spazio dei nomi o un identificatore dello spazio dei nomi. Per XML esposto tramite LINQ to XML, lo spazio dei nomi viene visualizzato tra parentesi graffe, precedute da una sequenza di escape delle parentesi graffe:  
  
```xaml  
<DataTemplate DataType="{}{http://myNamespace}Details">  
```  
  
 Per XML esposti tramite XPath, il nome dell'elemento è preceduto da un identificatore dello spazio dei nomi stabilito da un'istanza di <xref:System.Windows.Data.XmlNamespaceMapping>:  
  
```xaml  
<DataTemplate DataType="mn:Details">  
```  
  
<a name="xamlAttributeUsage_DataType"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object DataType="typeName"/>  
```  
  
<a name="xamlValues_DataType"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *typeName*  
 Se il modello è destinato ai dati dell'oggetto, questa proprietà contiene il nome del tipo dell'oggetto dati (sotto forma di stringa). Per fare riferimento al nome del tipo della classe, usare il [estensione di Markup X:Type](~/docs/framework/xaml-services/x-type-markup-extension.md). Se il modello è destinato [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] dati, questa proprietà contengano il nome dell'elemento XML. Vedere i commenti di documentazione per informazioni dettagliate su come specificare uno spazio dei nomi non predefiniti per l'elemento XML.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=160009">Introduction to Data Templating Sample</related>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DataTemplate.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.DataTemplate.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DependsOn("VisualTree")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DependsOn("Template")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un insieme di trigger che applicano valori di proprietà o eseguono azioni in base a una o più condizioni.</summary>
        <value>Insieme di oggetti trigger. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si creano trigger all'interno di un modello di dati, i metodi di impostazione dei trigger devono impostare le proprietà che rientrano nell'ambito del modello di dati. In caso contrario, potrebbe essere più appropriato creare trigger utilizzando uno stile destinato al tipo che contiene i dati. Ad esempio, se si associa un <xref:System.Windows.Controls.ListBox> (controllo), i contenitori sono <xref:System.Windows.Controls.ListBoxItem> oggetti. Se si utilizza per impostare le proprietà che non sono nell'ambito del trigger la <xref:System.Windows.DataTemplate>, quindi potrebbe essere più adatto creare un <xref:System.Windows.Controls.ListBoxItem> applicare uno stile e creare trigger all'interno di tale stile. Per altre informazioni, vedere ciò che appartiene a un DataTemplate? nel [Cenni preliminari sui modelli di dati](~/docs/framework/wpf/data/data-templating-overview.md).  
  
> [!NOTE]
>  Questa proprietà può essere impostata solo [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] tramite la sintassi delle raccolte illustrato, oppure accedendo all'oggetto collection e utilizzando i vari metodi, ad esempio Add. La proprietà per accedere all'oggetto raccolta stesso è di sola lettura, l'insieme è di lettura / scrittura.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Utilizzo della sintassi XAML per elementi proprietà  
  
```  
<object>  
  <object.Triggers>  
    OneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *oneOrMoreTriggers*  
 Zero o più <xref:System.Windows.TriggerBase> oggetti.  
  
   
  
## Examples  
 Quanto segue <xref:System.Windows.DataTemplate> viene illustrato come utilizzare il <xref:System.Windows.DataTemplate.Triggers%2A> proprietà.  
  
 [!code-xaml[DataBindingLab#AuctionItemDataTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataBindingLab/CSharp/DataBindingLabApp.xaml#auctionitemdatatemplate)]  
  
 Per l'esempio completo, vedere [Demo di Data Binding](http://go.microsoft.com/fwlink/?LinkID=163703).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DataTrigger" />
        <altmember cref="T:System.Windows.MultiDataTrigger" />
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=160009">Introduction to Data Templating Sample</related>
      </Docs>
    </Member>
    <Member MemberName="ValidateTemplatedParent">
      <MemberSignature Language="C#" Value="protected override void ValidateTemplatedParent (System.Windows.FrameworkElement templatedParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ValidateTemplatedParent(class System.Windows.FrameworkElement templatedParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DataTemplate.ValidateTemplatedParent(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ValidateTemplatedParent (templatedParent As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ValidateTemplatedParent(System::Windows::FrameworkElement ^ templatedParent);" />
      <MemberSignature Language="F#" Value="override this.ValidateTemplatedParent : System.Windows.FrameworkElement -&gt; unit" Usage="dataTemplate.ValidateTemplatedParent templatedParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templatedParent" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="templatedParent">L'elemento al quale viene applicato questo modello.</param>
        <summary>Controlla il padre basato su modelli rispetto a un insieme di regole.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo Usa le regole seguenti:  
  
-   Il `templatedParent` deve essere non null <xref:System.Windows.FrameworkElement>.  
  
-   Il <xref:System.Windows.DataTemplate> deve essere applicato a un <xref:System.Windows.Controls.ContentPresenter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>