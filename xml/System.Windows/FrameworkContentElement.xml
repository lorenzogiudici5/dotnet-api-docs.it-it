<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b6371f460f8b6c0d055ff1e6a06d2b95b363c7c1" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39942048" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="af268-101">
        <see cref="T:System.Windows.FrameworkContentElement" /> è l'implementazione e l'espansione a livello di framework WPF della classe base <see cref="T:System.Windows.ContentElement" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="af268-101">
          <see cref="T:System.Windows.FrameworkContentElement" /> is the WPF framework-level implementation and expansion of the <see cref="T:System.Windows.ContentElement" /> base class.</span>
      </span>
      <span data-ttu-id="af268-102">
        <see cref="T:System.Windows.FrameworkContentElement" /> aggiunge supporto per API di input aggiuntive (inclusi descrizioni comando e menu contestuali), storyboard, contesto dei dati per il data binding, supporto per gli stili e API di supporto dell'albero logico.</span>
      <span class="sxs-lookup">
        <span data-stu-id="af268-102">
          <see cref="T:System.Windows.FrameworkContentElement" /> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-103"><xref:System.Windows.FrameworkContentElement> non definisce il proprio comportamento di rendering. creare un'istanza di un vero e proprio <xref:System.Windows.FrameworkContentElement> istanza di classe nel codice o markup è possibile ma non visualizzerà niente in un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] applicazione [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="af268-103"><xref:System.Windows.FrameworkContentElement> does not yet define its own rendering behavior; instantiating an actual <xref:System.Windows.FrameworkContentElement> class instance in code or markup is possible but displays nothing in a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="af268-104">Rendering per la logica deve essere fornita dalle classi che accettano <xref:System.Windows.FrameworkContentElement> gli elementi figlio nell'ambito del proprio modello di contenuto, oppure in <xref:System.Windows.FrameworkContentElement> classi derivate.</span><span class="sxs-lookup"><span data-stu-id="af268-104">Rendering logic must be provided by classes that take <xref:System.Windows.FrameworkContentElement> child elements as part of their content model, or in <xref:System.Windows.FrameworkContentElement> derived classes.</span></span>  
  
 <span data-ttu-id="af268-105"><xref:System.Windows.FrameworkContentElement> paralleli molte delle stesse [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] come <xref:System.Windows.FrameworkElement>.</span><span class="sxs-lookup"><span data-stu-id="af268-105"><xref:System.Windows.FrameworkContentElement> deliberately parallels many of the same [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] as <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="af268-106">Si noti che alcuni [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] TransportCredentialOnly <xref:System.Windows.FrameworkElement> non avranno un <xref:System.Windows.FrameworkContentElement> equivalente.</span><span class="sxs-lookup"><span data-stu-id="af268-106">Note that certain [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] found on <xref:System.Windows.FrameworkElement> will not have a <xref:System.Windows.FrameworkContentElement> equivalent.</span></span> <span data-ttu-id="af268-107">Numerosi il <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] sono per la funzionalità, ad esempio la rappresentazione di geometria o di layout, che non sono rilevanti per un <xref:System.Windows.FrameworkContentElement>.</span><span class="sxs-lookup"><span data-stu-id="af268-107">Several of the <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] are for functionality such as geometry representation or layout, which are not relevant for a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 <span data-ttu-id="af268-108">La maggior parte delle esistente <xref:System.Windows.FrameworkContentElement> si trova in classi derivate i <xref:System.Windows.Documents> dello spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="af268-108">The majority of existing <xref:System.Windows.FrameworkContentElement> derived classes will be found in the <xref:System.Windows.Documents> namespace.</span></span> <span data-ttu-id="af268-109">Molte di queste classi derivate implementano gli elementi per il modello di documento dinamico.</span><span class="sxs-lookup"><span data-stu-id="af268-109">Many of these derived classes implement elements for the flow document model.</span></span> <span data-ttu-id="af268-110">Alcune classi derivate, ad esempio <xref:System.Windows.Documents.Hyperlink> dispongono di funzionalità simili, ma sono derivati da <xref:System.Windows.FrameworkContentElement> in modo che gli elementi simili possono comunque partecipare il modello di documento dinamico.</span><span class="sxs-lookup"><span data-stu-id="af268-110">Certain derived classes such as <xref:System.Windows.Documents.Hyperlink> have some control-like functionality, but are derived from <xref:System.Windows.FrameworkContentElement> such that the control-like elements can still participate in the flow document model.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="af268-111">Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-111">Initializes a new instance of the <see cref="T:System.Windows.FrameworkContentElement" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">
          <span data-ttu-id="af268-112">Elemento figlio da aggiungere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-112">The child element to be added.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-113">Aggiunge l'elemento specificato come figlio dell'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-113">Adds the provided element as a child of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-114">Questo metodo può generare un'eccezione se viene chiamato quando l'albero logico è in fase di iterazione da un altro processo.</span><span class="sxs-lookup"><span data-stu-id="af268-114">This method can throw an exception if called at a time when the logical tree is being iterated by another process.</span></span>  
  
 <span data-ttu-id="af268-115">La maggior parte delle <xref:System.Windows.FrameworkContentElement> alle classi derivate espongono raccolte dedicate che sono responsabili di contenimento (ad esempio, <xref:System.Windows.Documents.Span.Inlines%2A> nel <xref:System.Windows.Documents.Span> classe; <xref:System.Windows.Documents.Section.Blocks%2A> sul <xref:System.Windows.Documents.Section> classe).</span><span class="sxs-lookup"><span data-stu-id="af268-115">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="af268-116">In genere è possibile evitare qualsiasi esigenza di modificare direttamente l'albero logico se esegue la derivazione da queste classi.</span><span class="sxs-lookup"><span data-stu-id="af268-116">You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</span></span> <span data-ttu-id="af268-117">Utilizzo dell'albero logico per gli elementi di contenuto è uno scenario avanzato che potrebbe richiedere un parser specializzato o specializzata <xref:System.Windows.FrameworkElement> che funge da elemento padre per il rendering (host di contenuto).</span><span class="sxs-lookup"><span data-stu-id="af268-117">Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <xref:System.Windows.FrameworkElement> that acts as the parent rendering element (content host).</span></span>  
  
 <span data-ttu-id="af268-118">Per altre informazioni su come usare <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> e <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, vedere [strutture ad albero in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="af268-118">For more information about how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="af268-119">Chiamato prima che un elemento venga inizializzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-119">Called before an element is initialized.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="af268-120">
            <para>Eseguire l'override di questo metodo per fornire una gestione speciale che deve verificarsi prima che l'elemento viene inizializzato durante il processo di caricamento dell'elemento.  L'implementazione deve chiamare l'implementazione di base, perché l'implementazione di base (valore predefinito) imposta alcuni flag interno per tenere traccia di inizializzazione.  L'implementazione di base genererà un'eccezione se <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> viene chiamato più volte sullo stesso elemento prima di essere <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-120">
              <para>Override this method to provide special handling that should occur before your element is initialized during the element loading process.  Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.  The base implementation will throw an exception if <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> is called more than one time on the same element prior to reaching <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="af268-121">Inizia la sequenza di azioni contenuta nello storyboard fornito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-121">Begins the sequence of actions that are contained in the provided storyboard.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="af268-122">Storyboard da avviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-122">The storyboard to begin.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-123">Inizia la sequenza di azioni contenuta nello storyboard fornito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-123">Begins the sequence of actions that are contained in the provided storyboard.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-124">Per le firme che non usano i `isControllable`, parametro, o quando viene specificato questo parametro `false`, gli orologi di sequenza temporale associati dell'animazione vengono rimossi, non appena raggiunge il periodo di "Fill".</span><span class="sxs-lookup"><span data-stu-id="af268-124">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="af268-125">Pertanto l'animazione non può essere riavviata dopo essere stata eseguita una sola volta.</span><span class="sxs-lookup"><span data-stu-id="af268-125">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="af268-126">Si noti che anche controllo di un'animazione richiede che lo storyboard deve essere denominato o accessibile come un'istanza nel codice.</span><span class="sxs-lookup"><span data-stu-id="af268-126">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="af268-127">Storyboard da avviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-127">The storyboard to begin.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="af268-128">Valore dell'enumerazione che descrive il comportamento da utilizzare se una proprietà descritta nello storyboard è già animata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-128">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-129">Inizia la sequenza di azioni contenuta nello storyboard fornito, specificando le opzioni relative alle azioni che dovrebbero verificarsi se la proprietà è già animata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-129">Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-130">Per le firme che non usano i `isControllable`, parametro, o quando viene specificato questo parametro `false`, gli orologi di sequenza temporale associati dell'animazione vengono rimossi, non appena raggiunge il periodo di "Fill".</span><span class="sxs-lookup"><span data-stu-id="af268-130">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="af268-131">Pertanto l'animazione non può essere riavviata dopo essere stata eseguita una sola volta.</span><span class="sxs-lookup"><span data-stu-id="af268-131">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="af268-132">Si noti che anche controllo di un'animazione richiede che lo storyboard deve essere denominato o accessibile come un'istanza nel codice.</span><span class="sxs-lookup"><span data-stu-id="af268-132">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="af268-133">Utilizzo di Compose HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="af268-133">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="af268-134">Quando si applica una <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una proprietà utilizzando la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualsiasi <xref:System.Windows.Media.Animation.Clock> oggetti associati in precedenza a tale proprietà continueranno a utilizzare le risorse di sistema; il sistema di temporizzazione non non rimuovere automaticamente gli orologi.</span><span class="sxs-lookup"><span data-stu-id="af268-134">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</span></span>  
  
 <span data-ttu-id="af268-135">Per evitare problemi di prestazioni quando si applica un numero elevato di orologi usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, è necessario rimuovere gli orologi di composizione dalla proprietà animata una volta completati.</span><span class="sxs-lookup"><span data-stu-id="af268-135">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="af268-136">Esistono diversi modi per rimuovere un orologio:</span><span class="sxs-lookup"><span data-stu-id="af268-136">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="af268-137">Per rimuovere tutti gli orologi da una proprietà, usare il <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metodo dell'oggetto animato.</span><span class="sxs-lookup"><span data-stu-id="af268-137">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="af268-138">Specificare la proprietà animata come primo parametro, e `null` come il secondo.</span><span class="sxs-lookup"><span data-stu-id="af268-138">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="af268-139">Questo rimuove tutti gli orologi di animazione la proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-139">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="af268-140">Per rimuovere uno specifico <xref:System.Windows.Media.Animation.AnimationClock> da un elenco di orologi, usare il <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà delle <xref:System.Windows.Media.Animation.AnimationClock> per recuperare un <xref:System.Windows.Media.Animation.ClockController>, quindi chiamare il <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodo del <xref:System.Windows.Media.Animation.ClockController>.</span><span class="sxs-lookup"><span data-stu-id="af268-140">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="af268-141">Ciò avviene in genere il <xref:System.Windows.Media.Animation.Clock.Completed> gestore eventi per un orologio.</span><span class="sxs-lookup"><span data-stu-id="af268-141">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="af268-142">Si noti che solo gli orologi di radice possono essere controllati da un <xref:System.Windows.Media.Animation.ClockController>; la <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà di un orologio figlio restituirà `null`.</span><span class="sxs-lookup"><span data-stu-id="af268-142">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="af268-143">Si noti inoltre che il <xref:System.Windows.Media.Animation.Clock.Completed> evento non viene generato se la durata effettiva dell'orologio è infinita.</span><span class="sxs-lookup"><span data-stu-id="af268-143">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="af268-144">In tal caso, l'utente deve determinare quando chiamare <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="af268-144">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="af268-145">Si tratta principalmente di un problema relativo alle animazioni su oggetti di lunga durata.</span><span class="sxs-lookup"><span data-stu-id="af268-145">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="af268-146">Quando un oggetto viene sottoposto a garbage collection, gli orologi vengono disconnessi anche e sottoposti a garbage collection.</span><span class="sxs-lookup"><span data-stu-id="af268-146">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="af268-147">Per altre informazioni sugli oggetti orologio, vedere [Panoramica sistema di temporizzazione e animazione](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span><span class="sxs-lookup"><span data-stu-id="af268-147">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="af268-148">Storyboard da avviare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-148">The storyboard to begin.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="af268-149">Valore dell'enumerazione che descrive il comportamento da usare se una proprietà descritta nello storyboard è già animata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-149">A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</span>
          </span>
        </param>
        <param name="isControllable">
          <span data-ttu-id="af268-150">Dichiara se l'animazione è controllabile (può essere sospesa) dopo l'avvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-150">Declares whether the animation is controllable (can be paused) after it is started.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-151">Inizia la sequenza di azioni contenute nello storyboard fornito, specificando lo stato per il controllo dell'animazione dopo l'avvio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-151">Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-152">Per le firme che non usano i `isControllable`, parametro, o quando viene specificato questo parametro `false`, gli orologi di sequenza temporale associati dell'animazione vengono rimossi, non appena raggiunge il periodo di "Fill".</span><span class="sxs-lookup"><span data-stu-id="af268-152">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="af268-153">Pertanto l'animazione non può essere riavviata dopo essere stata eseguita una sola volta.</span><span class="sxs-lookup"><span data-stu-id="af268-153">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="af268-154">Si noti che anche controllo di un'animazione richiede che lo storyboard deve essere denominato o accessibile come un'istanza nel codice.</span><span class="sxs-lookup"><span data-stu-id="af268-154">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="af268-155">Utilizzo di Compose HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="af268-155">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="af268-156">Quando si applica una <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una proprietà utilizzando la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualsiasi <xref:System.Windows.Media.Animation.Clock> oggetti associati in precedenza a tale proprietà continueranno a utilizzare le risorse di sistema; il sistema di temporizzazione non non rimuovere automaticamente questi orologi.</span><span class="sxs-lookup"><span data-stu-id="af268-156">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</span></span>  
  
 <span data-ttu-id="af268-157">Per evitare problemi di prestazioni quando si applica un numero elevato di orologi usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, è necessario rimuovere gli orologi di composizione dalla proprietà animata una volta completati.</span><span class="sxs-lookup"><span data-stu-id="af268-157">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="af268-158">Esistono diversi modi per rimuovere un orologio:</span><span class="sxs-lookup"><span data-stu-id="af268-158">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="af268-159">Per rimuovere tutti gli orologi da una proprietà, usare il <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metodo dell'oggetto animato.</span><span class="sxs-lookup"><span data-stu-id="af268-159">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="af268-160">Specificare la proprietà animata come primo parametro, e `null` come il secondo.</span><span class="sxs-lookup"><span data-stu-id="af268-160">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="af268-161">Questo rimuove tutti gli orologi di animazione la proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-161">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="af268-162">Per rimuovere uno specifico <xref:System.Windows.Media.Animation.AnimationClock> da un elenco di orologi, usare il <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà delle <xref:System.Windows.Media.Animation.AnimationClock> per recuperare un <xref:System.Windows.Media.Animation.ClockController>, quindi chiamare il <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodo del <xref:System.Windows.Media.Animation.ClockController>.</span><span class="sxs-lookup"><span data-stu-id="af268-162">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="af268-163">Ciò avviene in genere il <xref:System.Windows.Media.Animation.Clock.Completed> gestore eventi per un orologio.</span><span class="sxs-lookup"><span data-stu-id="af268-163">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="af268-164">Si noti che solo gli orologi di radice possono essere controllati da un <xref:System.Windows.Media.Animation.ClockController>; la <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà di un orologio figlio restituirà `null`.</span><span class="sxs-lookup"><span data-stu-id="af268-164">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="af268-165">Si noti inoltre che il <xref:System.Windows.Media.Animation.Clock.Completed> evento non viene generato se la durata effettiva dell'orologio è infinita.</span><span class="sxs-lookup"><span data-stu-id="af268-165">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="af268-166">In tal caso, l'utente deve determinare quando chiamare <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="af268-166">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="af268-167">Si tratta principalmente di un problema relativo alle animazioni su oggetti di lunga durata.</span><span class="sxs-lookup"><span data-stu-id="af268-167">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="af268-168">Quando un oggetto viene sottoposto a garbage collection, gli orologi vengono disconnessi anche e sottoposti a garbage collection.</span><span class="sxs-lookup"><span data-stu-id="af268-168">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="af268-169">Per altre informazioni sugli oggetti orologio, vedere [Panoramica sistema di temporizzazione e animazione](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span><span class="sxs-lookup"><span data-stu-id="af268-169">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-170">Ottiene o imposta l'oggetto <see cref="T:System.Windows.Data.BindingGroup" /> utilizzato per l'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-170">Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-171">Oggetto <see cref="T:System.Windows.Data.BindingGroup" /> utilizzato per l'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-171">The <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-172">Oggetto <xref:System.Windows.Data.BindingGroup> può essere utilizzato per convalidare i valori delle proprietà più di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="af268-172">A <xref:System.Windows.Data.BindingGroup> can be used to validate the values of multiple properties of an object.</span></span> <span data-ttu-id="af268-173">Ad esempio, si supponga che un'applicazione richiede all'utente di immettere un indirizzo e quindi popola un oggetto di tipo `Address`, che presenta le proprietà `Street`, `City`, `ZipCode`, e `Country`, con i valori che l'utente fornito.</span><span class="sxs-lookup"><span data-stu-id="af268-173">For example, suppose that an application prompts the user to enter an address and then populates an object of type `Address`, which has the properties `Street`, `City`, `ZipCode`, and `Country`, with the values that the user provided.</span></span> <span data-ttu-id="af268-174">L'applicazione dispone di un pannello che contiene quattro <xref:System.Windows.Controls.TextBox> controlli, ognuno dei quali è associato a una delle proprietà dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="af268-174">The application has a panel that contains four <xref:System.Windows.Controls.TextBox> controls, each of which is bound to one of the object’s properties.</span></span> <span data-ttu-id="af268-175">È possibile usare una <xref:System.Windows.Controls.ValidationRule> in un <xref:System.Windows.Data.BindingGroup> convalidare il `Address` oggetto.</span><span class="sxs-lookup"><span data-stu-id="af268-175">You can use a <xref:System.Windows.Controls.ValidationRule> in a <xref:System.Windows.Data.BindingGroup> to validate the `Address` object.</span></span> <span data-ttu-id="af268-176">Ad esempio, il <xref:System.Windows.Controls.ValidationRule> può verificare che il codice postale zip sia valido per il paese dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="af268-176">For example, the <xref:System.Windows.Controls.ValidationRule> can ensure that the zip code is valid for the country of the address.</span></span>  
  
 <span data-ttu-id="af268-177">Gli elementi figlio ereditano il <xref:System.Windows.Data.BindingGroup> dagli elementi padre, proprio come per qualsiasi altra proprietà ereditabile.</span><span class="sxs-lookup"><span data-stu-id="af268-177">Child elements inherit the <xref:System.Windows.Data.BindingGroup> from their parent elements, just as with any other inheritable property.</span></span>  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-178">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-178">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-179">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-179">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|<span data-ttu-id="af268-180">Impostare le proprietà dei metadati **true**</span><span class="sxs-lookup"><span data-stu-id="af268-180">Metadata properties set to **true**</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-181">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-181">Identifies the <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="af268-182">Tenta di visualizzare questo elemento all'interno di qualsiasi area di scorrimento che lo contiene.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-182">Attempts to bring this element into view, within any scrollable regions it is contained within.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-183">Chiamando questo metodo, verrà chiamato effettivamente <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> in qualsiasi area di scorrevole padre che contiene l'elemento (l'elemento padre potrebbe essere un <xref:System.Windows.FrameworkElement>, non un <xref:System.Windows.FrameworkContentElement>).</span><span class="sxs-lookup"><span data-stu-id="af268-183">By calling this method, you effectively will call <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> on any parent scrollable area that contains the element (the parent may very well be a <xref:System.Windows.FrameworkElement>, not a <xref:System.Windows.FrameworkContentElement>).</span></span> <span data-ttu-id="af268-184">Se questo elemento non è contenuto in un'area scorrevole, l'evento viene generato ugualmente, ma non vi sarà alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="af268-184">If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-185">Ottiene o imposta l'elemento menu di scelta rapida che deve essere visualizzato ogni volta che il menu di scelta rapida viene richiesto dall'interno di questo elemento tramite l'[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-185">Gets or sets the context menu element that should appear whenever the context menu is requested via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] from within this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-186">Menu di scelta rapida utilizzato da questo elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-186">The context menu that this element uses.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-187">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-187">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-188">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-188">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|<span data-ttu-id="af268-189">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-189">Metadata properties set to `true`</span></span>|<span data-ttu-id="af268-190">nessuno</span><span class="sxs-lookup"><span data-stu-id="af268-190">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="af268-191">L'esempio seguente viene inserito un <xref:System.Windows.Controls.ContextMenu> su un <xref:System.Windows.Documents.Paragraph>.</span><span class="sxs-lookup"><span data-stu-id="af268-191">The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-192">Si verifica subito prima che venga chiuso un menu di scelta rapida relativo all'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-192">Occurs just before any context menu on the element is closed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-193">Per evitare la chiusura menu di scelta rapida, i gestori dell'evento che venga contrassegnato come gestito.</span><span class="sxs-lookup"><span data-stu-id="af268-193">To suppress closing context menus, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="af268-194">Per utilizzare questo evento come un <xref:System.Windows.EventTrigger> in uno stile, è necessario fare riferimento all'identificatore dell'evento servizio sottostante:</span><span class="sxs-lookup"><span data-stu-id="af268-194">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 <span data-ttu-id="af268-195">(Questo utilizzo è obbligatorio poiché l'implementazione di eventi in <xref:System.Windows.FrameworkContentElement> che espone l'evento servizio sottostante non esegue correttamente il mapping di <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identificatore da utilizzare in trigger).</span><span class="sxs-lookup"><span data-stu-id="af268-195">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="af268-196">Informazioni evento indirizzato</span><span class="sxs-lookup"><span data-stu-id="af268-196">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-197">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-197">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|<span data-ttu-id="af268-198">Strategia di routing</span><span class="sxs-lookup"><span data-stu-id="af268-198">Routing strategy</span></span>|<span data-ttu-id="af268-199">Bubbling</span><span class="sxs-lookup"><span data-stu-id="af268-199">Bubbling</span></span>|  
|<span data-ttu-id="af268-200">delegato</span><span class="sxs-lookup"><span data-stu-id="af268-200">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 <span data-ttu-id="af268-201">L'esempio seguente implementa un gestore che modifica il cursore su un'area denominata `DisplayArea` (non illustrato).</span><span class="sxs-lookup"><span data-stu-id="af268-201">The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown).</span></span> <span data-ttu-id="af268-202">Il commento suggerisce una <xref:System.Windows.UIElement> sull'utilizzo, ma in realtà in questo esempio è identico se `DisplayArea` erano un <xref:System.Windows.FrameworkContentElement>.</span><span class="sxs-lookup"><span data-stu-id="af268-202">The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-203">Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-203">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-204">Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="af268-204">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="af268-205">Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.</span><span class="sxs-lookup"><span data-stu-id="af268-205">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-206">Si verifica quando viene aperto un menu di scelta rapida relativo all'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-206">Occurs when any context menu on the element is opened.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-207">Per aprire manualmente menu di scelta rapida, i gestori degli eventi devono contrassegnare l'evento rilevante come gestito.</span><span class="sxs-lookup"><span data-stu-id="af268-207">To manually open context menus, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="af268-208">In caso contrario, il valore esistente del <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> proprietà verrà utilizzata per aprire automaticamente un menu di scelta rapida.</span><span class="sxs-lookup"><span data-stu-id="af268-208">Otherwise, the existing value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="af268-209">Contrassegnare l'evento come gestito in modo efficace annullerà l'azione predefinita e può essere un'opportunità per reimpostare il valore dei <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> proprietà e quindi aprire il nuovo <xref:System.Windows.Controls.ContextMenu>.</span><span class="sxs-lookup"><span data-stu-id="af268-209">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="af268-210">Tuttavia, vi è un problema di temporizzazione di che è necessario essere consapevoli.</span><span class="sxs-lookup"><span data-stu-id="af268-210">However, there is a timing issue you should be aware of.</span></span> <span data-ttu-id="af268-211">Per sostituire completamente il menu di scelta rapida attraverso un <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> gestore, i menu di scelta rapida iniziale non deve essere null / vuoto.</span><span class="sxs-lookup"><span data-stu-id="af268-211">In order to completely replace the context menu through a <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> handler, the initial context menu must not be null / empty.</span></span> <span data-ttu-id="af268-212">In alternativa, potrebbe essere necessario gestire l'evento e quindi aprire manualmente un nuovo menu di scelta rapida.</span><span class="sxs-lookup"><span data-stu-id="af268-212">Alternatively, you might need to handle the event and then manually open a new context menu.</span></span> <span data-ttu-id="af268-213">Per informazioni dettagliate, vedere [procedura: gestire l'evento ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span><span class="sxs-lookup"><span data-stu-id="af268-213">For details, see [How to: Handle the ContextMenuOpening Event](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span></span>  
  
 <span data-ttu-id="af268-214">Per utilizzare questo evento come un <xref:System.Windows.EventTrigger> in uno stile, è necessario fare riferimento all'identificatore dell'evento servizio sottostante:</span><span class="sxs-lookup"><span data-stu-id="af268-214">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 <span data-ttu-id="af268-215">(Questo utilizzo è obbligatorio poiché l'implementazione di eventi in <xref:System.Windows.FrameworkContentElement> che espone l'evento servizio sottostante non esegue correttamente il mapping di <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identificatore da utilizzare in trigger).</span><span class="sxs-lookup"><span data-stu-id="af268-215">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="af268-216">Informazioni evento indirizzato</span><span class="sxs-lookup"><span data-stu-id="af268-216">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-217">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-217">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|<span data-ttu-id="af268-218">Strategia di routing</span><span class="sxs-lookup"><span data-stu-id="af268-218">Routing strategy</span></span>|<span data-ttu-id="af268-219">Bubbling</span><span class="sxs-lookup"><span data-stu-id="af268-219">Bubbling</span></span>|  
|<span data-ttu-id="af268-220">delegato</span><span class="sxs-lookup"><span data-stu-id="af268-220">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-221">Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-221">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-222">Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="af268-222">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="af268-223">Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.</span><span class="sxs-lookup"><span data-stu-id="af268-223">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-224">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-224">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-225">Recupera o imposta il cursore visualizzato quando il puntatore del mouse è posizionato sull'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-225">Gets or sets the cursor that displays when the mouse pointer is over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-226">Cursore da visualizzare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-226">The cursor to display.</span>
          </span>
          <span data-ttu-id="af268-227">Il valore predefinito è definito come <see langword="null" /> in base a questa proprietà di dipendenza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-227">The default value is defined as <see langword="null" /> per this dependency property.</span>
          </span>
          <span data-ttu-id="af268-228">Tuttavia, l'impostazione predefinita pratica in fase di esecuzione dipenderà da numerosi fattori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-228">However, the practical default at run time will come from a variety of factors.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-229">Quando si imposta questa proprietà [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], il [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processore si basa sulla conversione del tipo per il <xref:System.Windows.Input.Cursor> classe per valutare la stringa.</span><span class="sxs-lookup"><span data-stu-id="af268-229">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor relies on type conversion for the <xref:System.Windows.Input.Cursor> class to evaluate the string.</span></span> <span data-ttu-id="af268-230">La stringa fornita deve restituire un <xref:System.Windows.Input.CursorType> valore.</span><span class="sxs-lookup"><span data-stu-id="af268-230">The provided string should evaluate to a <xref:System.Windows.Input.CursorType> value.</span></span> <span data-ttu-id="af268-231">Per informazioni dettagliate, vedere <xref:System.Windows.Input.Cursor>.</span><span class="sxs-lookup"><span data-stu-id="af268-231">See <xref:System.Windows.Input.Cursor> for details.</span></span>  
  
 <span data-ttu-id="af268-232">Se il cursore definito da questa proprietà sarà o non venga visualizzato quando il puntatore del mouse è sopra questo elemento dipende anche il valore della <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-232">Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> property.</span></span> <span data-ttu-id="af268-233">Inoltre, considerazioni relative a eventi, ad esempio un trascinamento attivo, stato mouse capture, all'interno di controlli e così via, modalità di modifica del testo influirà anche il cursore con priorità più alta rispetto al valore specificato in questa proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-233">Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</span></span>  
  
 <span data-ttu-id="af268-234">Per ripristinare il comportamento dell'impostazione di questa proprietà sul valore predefinito finale, impostarla su `null` nuovamente.</span><span class="sxs-lookup"><span data-stu-id="af268-234">To revert the behavior of setting this property to the eventual default, set it to `null` again.</span></span>  
  
 <span data-ttu-id="af268-235">Il `null` predefinito in realtà indica che la definizione del valore del cursore pratico è rinviata qui e deve essere ottenuta da un' posizione.</span><span class="sxs-lookup"><span data-stu-id="af268-235">The `null` default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</span></span> <span data-ttu-id="af268-236">Se viene visualizzata senza valori a livello di codice da qualsiasi origine, il cursore predefinito su un [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] applicazione sarà una freccia.</span><span class="sxs-lookup"><span data-stu-id="af268-236">If presented with no programmatic values from any source, the default cursor over a [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application will be an arrow.</span></span>  
  
 <span data-ttu-id="af268-237">Ogni movimento del mouse su un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] applicazione genera un <xref:System.Windows.ContentElement.QueryCursor> evento.</span><span class="sxs-lookup"><span data-stu-id="af268-237">Each movement of the mouse over a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application raises a <xref:System.Windows.ContentElement.QueryCursor> event.</span></span> <span data-ttu-id="af268-238">Le bolle di eventi e qualsiasi altro elemento lungo la route ha la possibilità di gestire l'evento e di impostare il valore del cursore tramite gli argomenti dell'evento.</span><span class="sxs-lookup"><span data-stu-id="af268-238">The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</span></span> <span data-ttu-id="af268-239">In tal caso, il fatto che l'evento è gestito e ha un valore modificato negli argomenti di ha la precedenza sul valore della <xref:System.Windows.FrameworkContentElement.Cursor%2A> proprietà in qualsiasi livello, a meno che non <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> è impostata.</span><span class="sxs-lookup"><span data-stu-id="af268-239">If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <xref:System.Windows.FrameworkContentElement.Cursor%2A> property at any level, unless <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> is set.</span></span>  
  
 <span data-ttu-id="af268-240">Se non viene creato un cursore personalizzato, in genere impostare questa proprietà su un valore della proprietà statica il <xref:System.Windows.Input.Cursors> classe.</span><span class="sxs-lookup"><span data-stu-id="af268-240">If not creating a custom cursor, typically you set this property to a static property value of the <xref:System.Windows.Input.Cursors> class.</span></span>  
  
 <span data-ttu-id="af268-241">L'impostazione di <xref:System.Windows.Input.Cursor> su un valore personalizzato non è abilitato in attendibilità parziale.</span><span class="sxs-lookup"><span data-stu-id="af268-241">Setting the <xref:System.Windows.Input.Cursor> to a custom value is not enabled in partial trust.</span></span> <span data-ttu-id="af268-242">Per altre informazioni sui cursori personalizzati, vedere [Cenni preliminari sull'Input](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="af268-242">For more information on custom cursors, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-243">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-243">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-244">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-244">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|<span data-ttu-id="af268-245">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-245">Metadata properties set to `true`</span></span>|<span data-ttu-id="af268-246">nessuno</span><span class="sxs-lookup"><span data-stu-id="af268-246">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="af268-247">Nell'esempio seguente imposta il cursore su un valore personalizzato.</span><span class="sxs-lookup"><span data-stu-id="af268-247">The following example sets the cursor to a custom value.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-248">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.Cursor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-248">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-249">Ottiene o imposta il contesto dei dati per un elemento quando partecipa al data binding.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-249">Gets or sets the data context for an element when it participates in data binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-250">Oggetto da usare come contesto dei dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-250">The object to use as data context.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-251">*Contesto dati* è un concetto che consente agli elementi di ereditare informazioni dagli elementi padre sull'origine del binding che viene usato per associazione, nonché altre caratteristiche dell'associazione, ad esempio il percorso.</span><span class="sxs-lookup"><span data-stu-id="af268-251">*Data context* is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</span></span>  
  
 <span data-ttu-id="af268-252">Contesto dei dati può essere impostata direttamente su un [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] oggetto, con le associazioni che restituiscono le proprietà di quell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="af268-252">Data context can be set directly to a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] object, with the bindings evaluating to properties of that object.</span></span> <span data-ttu-id="af268-253">In alternativa, è possibile impostare il contesto dei dati un <xref:System.Windows.Data.DataSourceProvider> oggetto.</span><span class="sxs-lookup"><span data-stu-id="af268-253">Alternatively, you can set the data context to a <xref:System.Windows.Data.DataSourceProvider> object.</span></span>  
  
 <span data-ttu-id="af268-254">Questa proprietà di dipendenza eredita i valori delle proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-254">This dependency property inherits property values.</span></span> <span data-ttu-id="af268-255">Se sono presenti gli elementi figlio con nessun altro valore per <xref:System.Windows.FrameworkContentElement.DataContext%2A> stabilita tramite i valori locali o gli stili, il sistema di proprietà verrà impostato il valore sarà il <xref:System.Windows.FrameworkContentElement.DataContext%2A> valore dell'elemento padre più vicino con questo valore viene assegnato.</span><span class="sxs-lookup"><span data-stu-id="af268-255">If there are child elements with no other value for <xref:System.Windows.FrameworkContentElement.DataContext%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkContentElement.DataContext%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="af268-256">In alternativa, è possibile usare una delle seguenti proprietà del <xref:System.Windows.Data.Binding> classe per specificare l'origine del binding in modo esplicito: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, o <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span><span class="sxs-lookup"><span data-stu-id="af268-256">Alternatively, you can use one of the following properties of the <xref:System.Windows.Data.Binding> class to specify the binding source explicitly: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, or <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span></span> <span data-ttu-id="af268-257">Per altre informazioni, vedere [procedura: specificare l'origine del Binding](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span><span class="sxs-lookup"><span data-stu-id="af268-257">For more information, see [How to: Specify the Binding Source](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span></span>  
  
 <span data-ttu-id="af268-258">Nelle [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> è impostato più di frequente come un <xref:System.Windows.Data.Binding> dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="af268-258">In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> is most commonly set to as a <xref:System.Windows.Data.Binding> declaration.</span></span> <span data-ttu-id="af268-259">È possibile usare la sintassi degli elementi di proprietà o la sintassi degli attributi.</span><span class="sxs-lookup"><span data-stu-id="af268-259">You can use either property element syntax or attribute syntax.</span></span> <span data-ttu-id="af268-260">La sintassi degli attributi è illustrato nell'esempio in questa pagina.</span><span class="sxs-lookup"><span data-stu-id="af268-260">Attribute syntax is shown in the example on this page.</span></span> <span data-ttu-id="af268-261">È anche possibile impostare <xref:System.Windows.FrameworkContentElement.DataContext%2A> nel codice.</span><span class="sxs-lookup"><span data-stu-id="af268-261">You can also set <xref:System.Windows.FrameworkContentElement.DataContext%2A> in code.</span></span>  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="af268-262">Utilizzo della sintassi XAML per elementi proprietà</span><span class="sxs-lookup"><span data-stu-id="af268-262">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="af268-263">Uso della sintassi XAML per gli attributi</span><span class="sxs-lookup"><span data-stu-id="af268-263">XAML Attribute Usage</span></span>  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a><span data-ttu-id="af268-264">Valori XAML</span><span class="sxs-lookup"><span data-stu-id="af268-264">XAML Values</span></span>  
 <span data-ttu-id="af268-265">*dataContextObject*</span><span class="sxs-lookup"><span data-stu-id="af268-265">*dataContextObject*</span></span>  
 <span data-ttu-id="af268-266">Un oggetto direttamente incorporato che viene usato come contesto dei dati per tutti i binding all'interno dell'elemento padre.</span><span class="sxs-lookup"><span data-stu-id="af268-266">A directly embedded object that serves as data context for any bindings within the parent element.</span></span> <span data-ttu-id="af268-267">In genere, questo oggetto è un <xref:System.Windows.Data.Binding> o un altro <xref:System.Windows.Data.BindingBase> sottoclasse.</span><span class="sxs-lookup"><span data-stu-id="af268-267">Typically, this object is a <xref:System.Windows.Data.Binding> or another <xref:System.Windows.Data.BindingBase> subclass.</span></span> <span data-ttu-id="af268-268">In alternativa, i dati non elaborati di qualsiasi [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] dell'oggetto di tipo designato per l'associazione può essere inserita in questo caso, con le associazioni effettive definite in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="af268-268">Alternatively, raw data of any [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] object type intended for binding may be placed here, with the actual bindings defined later.</span></span>  
  
 <span data-ttu-id="af268-269">*bindingUsage*</span><span class="sxs-lookup"><span data-stu-id="af268-269">*bindingUsage*</span></span>  
 <span data-ttu-id="af268-270">Utilizzo di associazione che restituisce un contesto di dati appropriato.</span><span class="sxs-lookup"><span data-stu-id="af268-270">A binding usage that evaluates to an appropriate data context.</span></span> <span data-ttu-id="af268-271">Per informazioni dettagliate, vedere [Estensione di markup Binding](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="af268-271">For details, see [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span></span>  
  
 <span data-ttu-id="af268-272">*ResourceExtension*</span><span class="sxs-lookup"><span data-stu-id="af268-272">*resourceExtension*</span></span>  
 <span data-ttu-id="af268-273">Uno dei seguenti: `StaticResource`, o `DynamicResource`.</span><span class="sxs-lookup"><span data-stu-id="af268-273">One of the following: `StaticResource`, or `DynamicResource`.</span></span> <span data-ttu-id="af268-274">Questo utilizzo viene utilizzato quando si fa riferimento ai dati non elaborati, definiti come un oggetto nelle risorse.</span><span class="sxs-lookup"><span data-stu-id="af268-274">This usage is used when referring to raw data defined as an object in resources.</span></span> <span data-ttu-id="af268-275">Visualizzare [risorse XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="af268-275">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="af268-276">*contextResourceKey*</span><span class="sxs-lookup"><span data-stu-id="af268-276">*contextResourceKey*</span></span>  
 <span data-ttu-id="af268-277">L'identificatore di chiave per l'oggetto richiesto dall'interno una <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="af268-277">The key identifier for the object being requested from within a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-278">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-278">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-279">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-279">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|<span data-ttu-id="af268-280">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-280">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="af268-281">Nell'esempio seguente imposta un'associazione in un <xref:System.Windows.Documents.Paragraph> elemento, creando un nuovo oggetto di dati personalizzati, stabilire tale oggetto come <xref:System.Windows.FrameworkContentElement.DataContext%2A>e impostare il percorso di associazione a una proprietà all'interno di esso.</span><span class="sxs-lookup"><span data-stu-id="af268-281">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-282">Si verifica quando il contesto dati di questo elemento viene modificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-282">Occurs when this element's data context changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-283">Per una spiegazione dei contesti dei dati e il data binding, vedere [Panoramica sul Data Binding](~/docs/framework/wpf/data/data-binding-overview.md).</span><span class="sxs-lookup"><span data-stu-id="af268-283">For an explanation of data contexts and data binding, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="af268-284">Quando un elemento <xref:System.Windows.FrameworkContentElement.DataContext%2A> potenzialmente interessate delle modifiche, tutte le proprietà con associazione a dati sull'elemento.</span><span class="sxs-lookup"><span data-stu-id="af268-284">When an element's <xref:System.Windows.FrameworkContentElement.DataContext%2A> changes, all data-bound properties on this element are potentially affected.</span></span> <span data-ttu-id="af268-285">Questo vale per tutti gli elementi che sono gli elementi discendenti dell'elemento corrente, che eredita il contesto di dati, e anche lo stesso elemento corrente.</span><span class="sxs-lookup"><span data-stu-id="af268-285">This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</span></span> <span data-ttu-id="af268-286">Tali associazioni reinterpretano nuovo <xref:System.Windows.FrameworkContentElement.DataContext%2A> in modo da riflettere il nuovo valore nelle associazioni.</span><span class="sxs-lookup"><span data-stu-id="af268-286">All such bindings re-interpret the new <xref:System.Windows.FrameworkContentElement.DataContext%2A> to reflect the new value in bindings.</span></span> <span data-ttu-id="af268-287">Non c'è garanzia sull'ordine di queste modifiche rispetto alla generazione del <xref:System.Windows.FrameworkContentElement.DataContextChanged> evento.</span><span class="sxs-lookup"><span data-stu-id="af268-287">There is no guarantee made about the order of these changes relative to the raising of the <xref:System.Windows.FrameworkContentElement.DataContextChanged> event.</span></span>  <span data-ttu-id="af268-288">Le modifiche possono verificarsi prima dell'evento, dopo l'evento, o in qualsiasi combinazione.</span><span class="sxs-lookup"><span data-stu-id="af268-288">The changes can occur before the event, after the event, or in any mixture.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-289">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.DataContext" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-289">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-290">Ottiene o imposta la chiave da utilizzare per cercare il modello dello stile per questo controllo nei temi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-290">Gets or sets the key to use to find the style template for this control in themes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-291">Chiave di stile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-291">The style key.</span>
          </span>
          <span data-ttu-id="af268-292">Affinché funzioni correttamente durante la ricerca dello stile del tema, questo valore deve essere l'oggetto <see cref="T:System.Type" /> dell'elemento a cui viene applicato lo stile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-292">To work correctly as part of theme style lookup, this value is expected to be the <see cref="T:System.Type" /> of the element being styled.</span>
          </span>
          <span data-ttu-id="af268-293">
            <see langword="null" /> è un valore accettato per un determinato caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-293">
              <see langword="null" /> is an accepted value for a certain case.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-294">Questa proprietà non è in genere impostata tramite uno dei metodi di impostazione diretti.</span><span class="sxs-lookup"><span data-stu-id="af268-294">This property is typically not set through any of its direct setters.</span></span> <span data-ttu-id="af268-295">Al contrario, si esegue l'override i metadati specifici del tipo di questa proprietà di dipendenza ogni volta che si crea una nuova sottoclasse.</span><span class="sxs-lookup"><span data-stu-id="af268-295">Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</span></span> <span data-ttu-id="af268-296">Quando si crea una sottoclasse, chiamare il <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metodo contro il <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identificatore, all'interno del costruttore statico della sottoclasse del controllo.</span><span class="sxs-lookup"><span data-stu-id="af268-296">When you subclass, call the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method against the <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identifier, within the static constructor of the control subclass.</span></span>  
  
 <span data-ttu-id="af268-297">Ad esempio, una classe inline, ad esempio <xref:System.Windows.Documents.Bold> effettivamente ha pochissimo implementazione oltre a eseguire l'override di <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadati nel costruttore statico e l'esposizione di diversi costruttori di istanza.</span><span class="sxs-lookup"><span data-stu-id="af268-297">For instance, an inline class such as <xref:System.Windows.Documents.Bold> actually has very little implementation beyond overriding the <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadata in its static constructor, and exposing several instance constructors.</span></span> <span data-ttu-id="af268-298">Il fatto che gli elementi racchiusi tra il <xref:System.Windows.Documents.Bold> miglioramento del tag un <xref:System.Windows.Documents.TextElement.FontWeight%2A> proprietà di <xref:System.Windows.FontWeights.Bold%2A> viene implementato nello stile del tema che viene fatto riferimento tramite l'impostazione predefinita pari a <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> a `typeof(Bold)`.</span><span class="sxs-lookup"><span data-stu-id="af268-298">The fact that elements surrounded by the <xref:System.Windows.Documents.Bold> tag gain a <xref:System.Windows.Documents.TextElement.FontWeight%2A> property of <xref:System.Windows.FontWeights.Bold%2A> is implemented within the theme style that was referenced by setting the default value of <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> to `typeof(Bold)`.</span></span>  
  
 <span data-ttu-id="af268-299">Se si desidera che l'elemento o controllo deliberatamente non utilizzino gli stili di tema, impostare il <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> proprietà `true`.</span><span class="sxs-lookup"><span data-stu-id="af268-299">If you want your element or control to deliberately not use theme styles, set the <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> property to `true`.</span></span>  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-300">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-300">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-301">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-301">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|<span data-ttu-id="af268-302">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-302">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-303">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-303">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="af268-304">Chiamato immediatamente dopo l'inizializzazione di un elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-304">Called immediately after an element is initialized.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-305">Implementare questo metodo per fornire una gestione speciale che deve verificarsi quando l'elemento viene inizializzato durante il processo di caricamento dell'elemento.</span><span class="sxs-lookup"><span data-stu-id="af268-305">Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</span></span>  
  
 <span data-ttu-id="af268-306">L'implementazione deve chiamare l'implementazione di base, perché l'implementazione di base (valore predefinito) imposta alcuni flag interno per tenere traccia di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="af268-306">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
 <span data-ttu-id="af268-307">Se <xref:System.Windows.FrameworkContentElement.BeginInit%2A> è stato precedentemente chiamato, la base implementazione genererà il <xref:System.Windows.FrameworkContentElement.Initialized> evento.</span><span class="sxs-lookup"><span data-stu-id="af268-307">If <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was previously called, the base implementation will raise the <xref:System.Windows.FrameworkContentElement.Initialized> event.</span></span> <span data-ttu-id="af268-308">In caso contrario, se <xref:System.Windows.FrameworkContentElement.BeginInit%2A> non è stato chiamato o non è stato possibile determinare se <xref:System.Windows.FrameworkContentElement.BeginInit%2A> è stato chiamato, l'evento non viene generato.</span><span class="sxs-lookup"><span data-stu-id="af268-308">Otherwise, if <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was not called or it could not be determined whether <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was called, the event is not raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="af268-309">Nome dell'elemento di cui eseguire la ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-309">Name of the element to search for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-310">Trova un elemento con il nome dell'identificatore specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-310">Finds an element that has the provided identifier name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-311">Elemento richiesto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-311">The requested element.</span>
          </span>
          <span data-ttu-id="af268-312">Potrebbe essere <see langword="null" /> se non è stato trovato un elemento corrispondente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-312">May be <see langword="null" /> if no matching element was found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-313">Se questo elemento contiene elementi figlio, tali elementi figlio sono tutti effettuata in modo ricorsivo per il nome di elemento richiesto.</span><span class="sxs-lookup"><span data-stu-id="af268-313">If this element has child elements, these child elements are all searched recursively for the requested named element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="af268-314">L'esempio seguente imposta una proprietà su un elemento è stato trovato in base al nome all'interno di un riferimento <xref:System.Windows.Documents.FlowDocument> in una pagina.</span><span class="sxs-lookup"><span data-stu-id="af268-314">The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">
          <span data-ttu-id="af268-315">Identificatore della chiave della risorsa da trovare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-315">Key identifier of the resource to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-316">Cerca una risorsa con la chiave specificata e genera un'eccezione se la risorsa richiesta non viene trovata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-316">Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-317">La risorsa trovata oppure <see langword="null" /> se non viene trovata una risorsa corrispondente (ma genera anche un'eccezione se <see langword="null" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-317">The found resource, or <see langword="null" /> if no matching resource was found (but will also throw an exception if <see langword="null" />).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="af268-318">Se si chiama questo metodo per una chiave che non viene trovata, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="af268-318">If you call this method for a key that cannot be found, an exception is thrown.</span></span> <span data-ttu-id="af268-319">Se non vuoi gestire le eccezioni per questo caso, è necessario chiamare invece <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span><span class="sxs-lookup"><span data-stu-id="af268-319">If you do not want to handle exceptions for this case, you should instead call <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span></span> <span data-ttu-id="af268-320"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> Restituisce `null` quando viene trovata alcuna risorsa e non viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="af268-320"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> returns `null` when no resource is found, and does not throw an exception.</span></span>  
  
 <span data-ttu-id="af268-321">Se la risorsa non viene trovata nell'elemento chiamante, la struttura ad albero padre viene eseguita la ricerca usando l'albero logico, nello stesso modo che la struttura ad albero sarebbe effettuata se la risorsa richiesti dalla chiave in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="af268-321">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="af268-322">In genere si esegue immediatamente il cast del valore restituito al tipo della proprietà che si stava tentando di impostare con il valore di risorsa restituita.</span><span class="sxs-lookup"><span data-stu-id="af268-322">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="af268-323">Nell'esempio seguente viene trovata una risorsa definita nel markup e lo applica a una determinata proprietà di un elemento in risposta a un evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="af268-323">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">
          <span data-ttu-id="af268-324">La chiave della risorsa richiesta non è stata trovata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-324">The requested resource key was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="af268-325">
            <paramref name="resourceKey" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-325">
              <paramref name="resourceKey" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-326">Ottiene o imposta un oggetto che consente la personalizzazione dell'aspetto, degli effetti o di altre caratteristiche di stile che si applicheranno a questo elemento quando acquisisce lo stato attivo della tastiera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-326">Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-327">Stile desiderato da applicare allo stato attivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-327">The desired style to apply on focus.</span>
          </span>
          <span data-ttu-id="af268-328">Il valore predefinito dichiarato nella proprietà di dipendenza è un oggetto <see cref="T:System.Windows.Style" /> statico vuoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-328">The default value as declared in the dependency property is an empty static <see cref="T:System.Windows.Style" />.</span>
          </span>
          <span data-ttu-id="af268-329">Tuttavia, il valore effettivo in fase di esecuzione è spesso, ma non sempre, uno stile specificato dal supporto dei temi per i controlli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-329">However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-330">Quando si imposta questa proprietà [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], gli stili sono quasi sempre definiti come una risorsa, anziché inline come un elemento e che risorse viene in genere indicata come una <xref:System.Windows.StaticResourceExtension>.</span><span class="sxs-lookup"><span data-stu-id="af268-330">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <xref:System.Windows.StaticResourceExtension>.</span></span>  
  
 <span data-ttu-id="af268-331">Si noti che questa proprietà influisce sull'aspetto visivo, ma non viene segnalato nei metadati.</span><span class="sxs-lookup"><span data-stu-id="af268-331">Note that this property affects visual appearance but does not report so in metadata.</span></span> <span data-ttu-id="af268-332">Infatti, la modifica dell'aspetto visivo è basato sugli eventi e potrebbe non essere applicabile in qualsiasi momento e pertanto non deve in genere segnalare qualsiasi informazione visivo o layout nei metadati.</span><span class="sxs-lookup"><span data-stu-id="af268-332">This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</span></span>  
  
 <span data-ttu-id="af268-333">Concettualmente, il comportamento visivo dello stato attivo applicati a un controllo deve essere coerente da un elemento per elemento.</span><span class="sxs-lookup"><span data-stu-id="af268-333">Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</span></span> <span data-ttu-id="af268-334">Il modo più appropriato per imporre la coerenza consiste nel modificare solo lo stile di visualizzazione dello stato attivo se si sta componendo un tema completo.</span><span class="sxs-lookup"><span data-stu-id="af268-334">The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</span></span> <span data-ttu-id="af268-335">Impostazione di questa proprietà su singoli stili e non come parte di un tema non è l'utilizzo previsto di questa proprietà, perché ciò potrebbe causare confusione nell'esperienza utente relativamente allo stato attivo.</span><span class="sxs-lookup"><span data-stu-id="af268-335">Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</span></span> <span data-ttu-id="af268-336">Se si stanno prendendo in considerazione il comportamento specifico dell'elemento che viene deliberatamente non coerente all'interno di un tema, un approccio migliore consiste usare trigger negli stili per le proprietà dello stato di input singolo, ad esempio <xref:System.Windows.UIElement.IsFocused%2A> o <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>e per eseguire questa operazione in modo che non sono presenti visivamente interferire con gli stili di visualizzazione dello stato attivo esistente.</span><span class="sxs-lookup"><span data-stu-id="af268-336">If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <xref:System.Windows.UIElement.IsFocused%2A> or <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, and to do so in a way that does not visually interfere with any existing focus visual style.</span></span> <span data-ttu-id="af268-337">Per altre informazioni sugli scopi della progettazione del <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> e alternativi concentrare le proprietà, vedere [applicazione di stili per lo stato attivo nei controlli e FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span><span class="sxs-lookup"><span data-stu-id="af268-337">For more information on the design intention of <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> and alternative focus properties, see [Styling for Focus in Controls, and FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span></span>  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="af268-338">Uso della sintassi XAML per gli attributi</span><span class="sxs-lookup"><span data-stu-id="af268-338">XAML Attribute Usage</span></span>  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="af268-339">Utilizzo della sintassi XAML per elementi proprietà</span><span class="sxs-lookup"><span data-stu-id="af268-339">XAML Property Element Usage</span></span>  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a><span data-ttu-id="af268-340">Valori XAML</span><span class="sxs-lookup"><span data-stu-id="af268-340">XAML Values</span></span>  
 <span data-ttu-id="af268-341">*ResourceExtension*</span><span class="sxs-lookup"><span data-stu-id="af268-341">*resourceExtension*</span></span>  
 <span data-ttu-id="af268-342">Uno dei seguenti:, o.</span><span class="sxs-lookup"><span data-stu-id="af268-342">One of the following: , or .</span></span> <span data-ttu-id="af268-343">Visualizzare [risorse XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="af268-343">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="af268-344">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="af268-344">*styleResourceKey*</span></span>  
 <span data-ttu-id="af268-345">La chiave che identifica lo stile della richiesta.</span><span class="sxs-lookup"><span data-stu-id="af268-345">The key that identifies the style being requested.</span></span> <span data-ttu-id="af268-346">La chiave fa riferimento a una risorsa esistente in un <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="af268-346">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="af268-347">La sintassi degli elementi è tecnicamente possibile, ma non è consigliata.</span><span class="sxs-lookup"><span data-stu-id="af268-347">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="af268-348">Visualizzare [stili Inline e modelli](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span><span class="sxs-lookup"><span data-stu-id="af268-348">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="af268-349">Un riferimento dell'associazione usando o <xref:System.Windows.Data.Binding> è anche possibile, ma non comuni.</span><span class="sxs-lookup"><span data-stu-id="af268-349">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-350">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-350">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-351">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-351">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|<span data-ttu-id="af268-352">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-352">Metadata properties set to `true`</span></span>|<span data-ttu-id="af268-353">nessuno</span><span class="sxs-lookup"><span data-stu-id="af268-353">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-354">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-354">Identifies the <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-355">Ottiene o imposta un valore che indica se l'oggetto <see cref="T:System.Windows.FrameworkContentElement" /> deve forzare l'[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] per il rendering del cursore dichiarato dalla proprietà <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> di questa istanza</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-355">Gets or sets a value indicating whether this <see cref="T:System.Windows.FrameworkContentElement" /> should force the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] to render the cursor as declared by this instance's <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-356">
            <see langword="true" /> per forzare la presentazione del cursore mentre è posizionato su questo elemento a utilizzare le impostazioni di questa istanza per il cursore (inclusi tutti gli elementi figlio); in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-356">
              <see langword="true" /> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="af268-357">Il valore predefinito è <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-357">The default value is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-358">Impostando questa proprietà su `true` sostituiranno le preferenze di cursore stabilite dagli elementi figlio.</span><span class="sxs-lookup"><span data-stu-id="af268-358">Setting this property to `true` will override the cursor preferences established by child elements.</span></span> <span data-ttu-id="af268-359">Tale operazione pertanto in generale dell'applicazione [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] potrebbe risultare poco chiaro per l'utente, in particolare se gli elementi figlio sono se si specificano i cursori.</span><span class="sxs-lookup"><span data-stu-id="af268-359">Doing so in general application [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] might be confusing for the user, particularly if child elements are attempting to specify cursors.</span></span> <span data-ttu-id="af268-360">Impostazione <xref:System.Windows.FrameworkElement.ForceCursor%2A> più appropriato per scenari di creazione di una sottoclasse o la composizione del controllo.</span><span class="sxs-lookup"><span data-stu-id="af268-360">Setting <xref:System.Windows.FrameworkElement.ForceCursor%2A> is more appropriate in control subclassing or compositing scenarios.</span></span>  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-361">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-361">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-362">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-362">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|<span data-ttu-id="af268-363">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-363">Metadata properties set to `true`</span></span>|<span data-ttu-id="af268-364">nessuno</span><span class="sxs-lookup"><span data-stu-id="af268-364">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="af268-365">Nell'esempio seguente forza il cursore mentre è posizionato sull'elemento.</span><span class="sxs-lookup"><span data-stu-id="af268-365">The following example forces the cursor while over the element.</span></span>  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-366">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-366">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="af268-367">Oggetto <see cref="T:System.Windows.DependencyProperty" /> di destinazione dal quale ottenere l'associazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-367">The target <see cref="T:System.Windows.DependencyProperty" /> from which to get the binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-368">Ottiene l'oggetto <see cref="T:System.Windows.Data.BindingExpression" /> per l'associazione della proprietà specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-368">Gets the <see cref="T:System.Windows.Data.BindingExpression" /> for the specified property's binding.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-369">Restituisce un oggetto <see cref="T:System.Windows.Data.BindingExpression" /> se la destinazione è associata a dati; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-369">Returns a <see cref="T:System.Windows.Data.BindingExpression" /> if the target is data bound; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="af268-370">Nell'esempio seguente recupera un'associazione eseguendo una query di una proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-370">The following example retrieves a binding by querying a property.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="af268-371">Restituisce un elemento padre logico alternativo per questo elemento se non esiste un elemento padre visuale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-371">Returns an alternative logical parent for this element if there is no visual parent.</span>
          </span>
          <span data-ttu-id="af268-372">In questo caso, un elemento padre <see cref="T:System.Windows.FrameworkContentElement" /> ha sempre lo stesso valore della proprietà <see cref="P:System.Windows.FrameworkContentElement.Parent" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-372">In this case, a <see cref="T:System.Windows.FrameworkContentElement" /> parent is always the same value as the <see cref="P:System.Windows.FrameworkContentElement.Parent" /> property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-373">Restituisce un valore diverso da <see langword="null" /> ogni volta che un'implementazione a livello di framework WPF di questo metodo presenta una connessione padre non visuale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-373">Returns something other than <see langword="null" /> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-374">L'implementazione predefinita restituisce l'elemento padre visivo single previsto.</span><span class="sxs-lookup"><span data-stu-id="af268-374">The default implementation returns the expected single visual parent.</span></span> <span data-ttu-id="af268-375">Le implementazioni personalizzate potrebbero restituire le relazioni padre / alternativo.</span><span class="sxs-lookup"><span data-stu-id="af268-375">Custom implementations might return alternate parent relationships.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-376">Si verifica quando viene inizializzato l'oggetto <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-376">Occurs when this <see cref="T:System.Windows.FrameworkContentElement" /> is initialized.</span>
          </span>
          <span data-ttu-id="af268-377">che coincide con i casi in cui il valore della proprietà <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> viene modificato da <see langword="false" /> (o non definito) a <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-377">This coincides with cases where the value of the <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> property changes from <see langword="false" /> (or undefined) to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-378">Questo evento verrà generato ogni volta che il <xref:System.Windows.FrameworkContentElement.EndInit%2A> o <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> metodi vengono chiamati.</span><span class="sxs-lookup"><span data-stu-id="af268-378">This event will be raised whenever the <xref:System.Windows.FrameworkContentElement.EndInit%2A> or <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> methods are called.</span></span> <span data-ttu-id="af268-379">Chiamate a questi metodi è stato reso tramite codice intenzionale. exe o il [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] processo di caricamento.</span><span class="sxs-lookup"><span data-stu-id="af268-379">Calls to these methods could have been made by deliberate code, or by the [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] loading process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-380">Ottiene o imposta il contesto per l'input utilizzato dall'oggetto <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-380">Gets or sets the context for input used by this <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-381">Ambito di input, che modifica il modo in cui viene interpretato l'input proveniente da metodi di input alternativi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-381">The input scope, which modifies how input from alternative input methods is interpreted.</span>
          </span>
          <span data-ttu-id="af268-382">Il valore predefinito è <see langword="null" /> (che comporta la gestione predefinita dei comandi).</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-382">The default value is <see langword="null" /> (which results in a default handling of commands).</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-383">Questa proprietà di dipendenza eredita i valori delle proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-383">This dependency property inherits property values.</span></span> <span data-ttu-id="af268-384">Se sono presenti gli elementi figlio con nessun altro valore per <xref:System.Windows.FrameworkElement.InputScope%2A> stabilita tramite i valori locali o gli stili, il sistema di proprietà verrà impostato il valore sarà il <xref:System.Windows.FrameworkElement.InputScope%2A> valore dell'elemento padre più vicino con questo valore viene assegnato.</span><span class="sxs-lookup"><span data-stu-id="af268-384">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.InputScope%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.InputScope%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="af268-385">Anche se un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] utilizzo della sintassi viene elencato e sintatticamente è consentito, l'impostazione di questa proprietà [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] non è comune.</span><span class="sxs-lookup"><span data-stu-id="af268-385">Although a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax usage is listed and is syntactically allowed, setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] is not common.</span></span>  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-386">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-386">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-387">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-387">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|<span data-ttu-id="af268-388">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-388">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-389">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.InputScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-389">Identifies the <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-390">Ottiene un valore che indica se questo elemento è stato inizializzato, mediante il caricamento come [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] oppure mediante la chiamata esplicita al metodo <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-390">Gets a value indicating whether this element has been initialized, either by being loaded as [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], or by explicitly having its <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> method called.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-391">
            <see langword="true" /> se l'elemento viene inizializzato in base al processo di caricamento descritto in precedenza o con chiamate al metodo; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-391">
              <see langword="true" /> if the element is initialized per the aforementioned loading or method calls; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-392">Questa proprietà può anche essere `true` se questo elemento è stato spostato all'interno dell'albero degli elementi in modo che abbia un nuovo elemento padre e pertanto venga ricaricato nuovamente.</span><span class="sxs-lookup"><span data-stu-id="af268-392">This property may also be `true` if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-393">Ottiene un valore che indica se questo elemento è stato caricato per la presentazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-393">Gets a value indicating whether this element has been loaded for presentation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-394">
            <see langword="true" /> se l'elemento corrente è associato a una struttura ad albero dell'elemento e ne è stato eseguito il rendering; <see langword="false" /> se l'elemento non è mai stato associato a una struttura ad albero dell'elemento caricata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-394">
              <see langword="true" /> if the current element is attached to an element tree and has been rendered; <see langword="false" /> if the element has never been attached to a loaded element tree.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-395">Da un'istanza appena costruita, questa proprietà inizia `false`e rimane `true` dopo che è impostato su `true`, anche se successivamente viene rimossa dal codice.</span><span class="sxs-lookup"><span data-stu-id="af268-395">From a newly constructed instance, this property starts off `false`, and remains `true` once it is set to `true`, even if subsequently removed by  code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="af268-396">Il codice di esempio seguente usa <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> come controllo condizionale per assicurare che una funzione `displayData` (non mostrato) verranno dispone gli elementi validi caricato nella pagina da utilizzare, come parte di un gestore on demand.</span><span class="sxs-lookup"><span data-stu-id="af268-396">The following example code uses <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</span></span> <span data-ttu-id="af268-397">Che per la stessa logica viene eseguita come un gestore eventi per <xref:System.Windows.FrameworkContentElement.Loaded>.</span><span class="sxs-lookup"><span data-stu-id="af268-397">That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-398">Ottiene o imposta le informazioni relative alla lingua di localizzazione/globalizzazione che si applicano a un singolo elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-398">Gets or sets localization/globalization language information that applies to an individual element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-399">Informazioni relative alle impostazioni cultura per l'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-399">The culture information for this element.</span>
          </span>
          <span data-ttu-id="af268-400">Il valore predefinito è l'istanza di un oggetto <see cref="T:System.Windows.Markup.XmlLanguage" /> con il valore <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> impostato sulla stringa "en-US".</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-400">The default value is an <see cref="T:System.Windows.Markup.XmlLanguage" /> instance with its <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> value set to the string "en-US".</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-401">I formati di stringa conforme allo standard RFC 3066.</span><span class="sxs-lookup"><span data-stu-id="af268-401">The string formats follow the RFC 3066 standard.</span></span> <span data-ttu-id="af268-402">Ad esempio, Stati Uniti Inglese è "en-US".</span><span class="sxs-lookup"><span data-stu-id="af268-402">For example, U.S. English is "en-US".</span></span> <span data-ttu-id="af268-403">Vedere <xref:System.Windows.Markup.XmlLanguage> per altre informazioni su valori e formato.</span><span class="sxs-lookup"><span data-stu-id="af268-403">See <xref:System.Windows.Markup.XmlLanguage> for more information on the values and format.</span></span>  
  
 <span data-ttu-id="af268-404">Questa proprietà di dipendenza eredita i valori delle proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-404">This dependency property inherits property values.</span></span> <span data-ttu-id="af268-405">Se sono presenti gli elementi figlio con nessun altro valore per <xref:System.Windows.FrameworkElement.Language%2A> stabilita tramite i valori locali o gli stili, il sistema di proprietà verrà impostato il valore sarà il <xref:System.Windows.FrameworkElement.Language%2A> valore dell'elemento padre più vicino con questo valore viene assegnato.</span><span class="sxs-lookup"><span data-stu-id="af268-405">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.Language%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.Language%2A> value of the nearest parent element with this value assigned.</span></span>  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-406">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-406">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-407">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-407">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|<span data-ttu-id="af268-408">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-408">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-409">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.Language" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-409">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Language" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-410">Si verifica al termine del layout e del rendering, quando l'elemento è pronto per l'interazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-410">Occurs when the element is laid out, rendered, and ready for interaction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-411">Gli eventi indirizzati diretti non seguono una route, ma vengono gestiti solo all'interno dell'elemento stesso in cui vengono generati.</span><span class="sxs-lookup"><span data-stu-id="af268-411">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="af268-412">Indirizzare gli eventi indirizzati supportano altri comportamenti di eventi indirizzati: supportano una raccolta di gestori accessibile e può essere utilizzati come un <xref:System.Windows.EventTrigger> in uno stile.</span><span class="sxs-lookup"><span data-stu-id="af268-412">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="af268-413">Informazioni evento indirizzato</span><span class="sxs-lookup"><span data-stu-id="af268-413">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-414">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-414">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|<span data-ttu-id="af268-415">Strategia di routing</span><span class="sxs-lookup"><span data-stu-id="af268-415">Routing strategy</span></span>|<span data-ttu-id="af268-416">Direct</span><span class="sxs-lookup"><span data-stu-id="af268-416">Direct</span></span>|  
|<span data-ttu-id="af268-417">delegato</span><span class="sxs-lookup"><span data-stu-id="af268-417">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-418">Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.Loaded" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-418">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-419">Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="af268-419">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="af268-420">Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.</span><span class="sxs-lookup"><span data-stu-id="af268-420">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-421">Ottiene un enumeratore per gli elementi figlio logici di questo elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-421">Gets an enumerator for the logical child elements of this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-422">Ottiene un enumeratore per gli elementi figlio logici di questo elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-422">An enumerator for logical child elements of this element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-423">Per altre informazioni su come usare <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> e <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, vedere [strutture ad albero in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="af268-423">For more information on how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">
          <span data-ttu-id="af268-424">Direzione dello spostamento dello stato attivo, sotto forma di valore dell'enumerazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-424">The direction that focus is to be moved, as a value of the enumeration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-425">Sposta lo stato attivo da questo elemento a un altro elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-425">Moves the keyboard focus from this element to another element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-426">Restituisce <see langword="true" /> se lo stato attivo viene spostato correttamente; <see langword="false" /> se l'elemento di destinazione nella direzione specificata non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-426">Returns <see langword="true" /> if focus is moved successfully; <see langword="false" /> if the target element in direction as specified does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-427">Ottiene o imposta il nome identificativo dell'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-427">Gets or sets the identifying name of the element.</span>
          </span>
          <span data-ttu-id="af268-428">Il nome fornisce un riferimento a un'istanza che consenta al code-behind a livello di codice, ad esempio il codice del gestore eventi, di fare riferimento a un elemento dopo che questo è stato costruito durante l'analisi della sintassi [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-428">The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-429">Nome dell'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-429">The name of the element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-430">L'uso più comune di questa proprietà è quando si specifica un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nome elemento nel markup.</span><span class="sxs-lookup"><span data-stu-id="af268-430">The most common usage of this property is when specifying a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element name in markup.</span></span>  
  
 <span data-ttu-id="af268-431">Questa proprietà fornisce essenzialmente una proprietà di praticità a livello di framework WPF per impostare il [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [direttiva X:Name](~/docs/framework/xaml-services/x-name-directive.md).</span><span class="sxs-lookup"><span data-stu-id="af268-431">This property essentially provides a WPF framework-level convenience property to set the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name Directive](~/docs/framework/xaml-services/x-name-directive.md).</span></span>  
  
 <span data-ttu-id="af268-432">Recupero di un <xref:System.Windows.FrameworkContentElement.Name%2A> dal codice non è comune, poiché se si dispone già di riferimento appropriati nel codice, è possibile chiamare solo metodi e proprietà sull'elemento di riferimento e non li supportano in genere è necessario il <xref:System.Windows.FrameworkContentElement.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="af268-432">Getting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <xref:System.Windows.FrameworkContentElement.Name%2A>.</span></span> <span data-ttu-id="af268-433">È un'eccezione se la stringa ha un significato aggiuntivo, ad esempio se è utile visualizzare tale nome nel [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="af268-433">An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="af268-434">Impostazione di un <xref:System.Windows.FrameworkContentElement.Name%2A> dal codice se originale <xref:System.Windows.FrameworkContentElement.Name%2A> è stato impostato dal markup inoltre non è consigliabile, e la modifica della proprietà non cambia il riferimento all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="af268-434">Setting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code if the original <xref:System.Windows.FrameworkContentElement.Name%2A> was set from markup is also not recommended, and changing the property will not change the object reference.</span></span> <span data-ttu-id="af268-435">Riferimenti a tali oggetti vengono creati solo quando i NameScope sottostanti vengono creati esplicitamente durante [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] il caricamento.</span><span class="sxs-lookup"><span data-stu-id="af268-435">Such object references are created only when the underlying namescopes are explicitly created during [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] loading.</span></span>  
  
 <span data-ttu-id="af268-436">È necessario chiamare espressamente <xref:System.Windows.FrameworkContentElement.RegisterName%2A> per rendere effettiva una modifica nel <xref:System.Windows.FrameworkContentElement.Name%2A> proprietà di un elemento già caricato.</span><span class="sxs-lookup"><span data-stu-id="af268-436">You must specifically call <xref:System.Windows.FrameworkContentElement.RegisterName%2A> to make an effective change on the <xref:System.Windows.FrameworkContentElement.Name%2A> property of an already loaded element.</span></span>  
  
 <span data-ttu-id="af268-437">Un rilevanti caso in cui l'impostazione <xref:System.Windows.FrameworkContentElement.Name%2A> dal codice è importante è per la denominazione di elementi che storyboard verranno eseguite.</span><span class="sxs-lookup"><span data-stu-id="af268-437">One notable case where setting <xref:System.Windows.FrameworkContentElement.Name%2A> from  code is important is for naming elements that storyboards will run against.</span></span> <span data-ttu-id="af268-438">Prima di poter registrare un nome, potrebbe essere necessario anche creare un'istanza e assegnare un <xref:System.Windows.NameScope> istanza.</span><span class="sxs-lookup"><span data-stu-id="af268-438">Before you can register a name, might also need to instantiate and assign a <xref:System.Windows.NameScope> instance.</span></span> <span data-ttu-id="af268-439">Vedere la sezione di esempio, oppure [Cenni preliminari sugli storyboard](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="af268-439">See the Example section, or [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="af268-440">Impostazione <xref:System.Windows.FrameworkContentElement.Name%2A> dal codice con applicazioni limitate, ma ricerca di un elemento in base al nome è più comune, in particolare se si stanno utilizzando un modello di navigazione in cui le pagine vengono ricaricate all'applicazione e il codice in fase di esecuzione non è necessariamente il code-behind di tale pagina corrispondente.</span><span class="sxs-lookup"><span data-stu-id="af268-440">Setting <xref:System.Windows.FrameworkContentElement.Name%2A> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</span></span> <span data-ttu-id="af268-441">Il metodo di utilità <xref:System.Windows.FrameworkContentElement.FindName%2A>, disponibile da qualsiasi <xref:System.Windows.FrameworkContentElement>, può individuare qualsiasi elemento in base <xref:System.Windows.FrameworkContentElement.Name%2A> in modo ricorsivo albero logico dell'elemento.</span><span class="sxs-lookup"><span data-stu-id="af268-441">The utility method <xref:System.Windows.FrameworkContentElement.FindName%2A>, which is available from any <xref:System.Windows.FrameworkContentElement>, can find any element by <xref:System.Windows.FrameworkContentElement.Name%2A> in that element's logical tree recursively.</span></span> <span data-ttu-id="af268-442">Oppure è possibile usare la <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> metodo statico dei <xref:System.Windows.LogicalTreeHelper>, che accetta anche il <xref:System.Windows.FrameworkContentElement.Name%2A> stringa come argomento.</span><span class="sxs-lookup"><span data-stu-id="af268-442">Or you can use the <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> static method of <xref:System.Windows.LogicalTreeHelper>, which also takes the <xref:System.Windows.FrameworkContentElement.Name%2A> string as an argument.</span></span>  
  
 <span data-ttu-id="af268-443">In genere utilizzato elementi radice (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> ad esempio) implementano l'interfaccia <xref:System.Windows.Markup.INameScope>.</span><span class="sxs-lookup"><span data-stu-id="af268-443">Commonly used root elements (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> for example) implement the interface <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="af268-444">Le implementazioni di questa interfaccia devono imporre che i nomi di essere non ambigua nel proprio ambito.</span><span class="sxs-lookup"><span data-stu-id="af268-444">Implementations of this interface are expected to enforce that names be unambiguous within their scope.</span></span>  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-445">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-445">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-446">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-446">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|<span data-ttu-id="af268-447">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-447">Metadata properties set to `true`</span></span>|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-448">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.Name" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-448">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Name" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="af268-449">Fornisce i dati sull'evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-449">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-450">Richiamato ogni qualvolta l'evento indirizzato <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> raggiunge questa classe nella relativa route.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-450">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="af268-451">Implementare questo metodo per aggiungere la gestione delle classi per questo evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-451">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-452">Questo metodo presenta alcuna implementazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="af268-452">This method has no default implementation.</span></span> <span data-ttu-id="af268-453">È comunque necessario chiamare l'implementazione di base nel caso in cui una classe intermedia nell'ereditarietà ha implementato questo metodo.</span><span class="sxs-lookup"><span data-stu-id="af268-453">You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="af268-454">Lo scopo di questo metodo è un po' come [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] schema di eventi in \* metodi: fornisce i mezzi per gestire l'evento corrispondente dalle classi derivate con un gestore della classe anziché un gestore di istanze.</span><span class="sxs-lookup"><span data-stu-id="af268-454">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="af268-455">In questo caso l'evento corrispondente è un evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="af268-455">In this case the matching event is a routed event.</span></span> <span data-ttu-id="af268-456">Il modello di implementazione dei metodi On \* è diverso per gli eventi indirizzati, perché l'evento indirizzato può essere generato da un elemento figlio, non necessariamente l'elemento che richiama i gestori.</span><span class="sxs-lookup"><span data-stu-id="af268-456">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="af268-457">Pertanto, l'implementazione dovrà prendere in considerazione le proprietà dell'origine degli argomenti di evento (e non deve tentare di generare nuovamente l'evento nella maggior parte dei casi).</span><span class="sxs-lookup"><span data-stu-id="af268-457">Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="af268-458">Le sottoclassi di <xref:System.Windows.FrameworkContentElement> può scegliere di chiamare metodi del gestore di classe privata quando viene ricevuto l'evento lungo la route.</span><span class="sxs-lookup"><span data-stu-id="af268-458">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="af268-459">Uno scenario di potenziale prevede accettano gli argomenti dell'evento e deliberatamente contrassegnare l'evento come gestito per abbreviare la route.</span><span class="sxs-lookup"><span data-stu-id="af268-459">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="af268-460">Dati dell'evento per l'evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-460">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-461">Richiamato ogni qualvolta l'evento indirizzato <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> raggiunge questa classe nella relativa route.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-461">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="af268-462">Implementare questo metodo per aggiungere la gestione delle classi per questo evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-462">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-463">Questo metodo presenta alcuna implementazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="af268-463">This method has no default implementation.</span></span> <span data-ttu-id="af268-464">È comunque necessario chiamare base () nel caso in cui una classe intermedia nell'ereditarietà ha implementato questo metodo.</span><span class="sxs-lookup"><span data-stu-id="af268-464">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="af268-465">Lo scopo di questo metodo è un po' come [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] schema di eventi in \* metodi: fornisce i mezzi per gestire l'evento corrispondente dalle classi derivate con un gestore della classe anziché un gestore di istanze.</span><span class="sxs-lookup"><span data-stu-id="af268-465">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="af268-466">In questo caso l'evento corrispondente è un evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="af268-466">In this case the matching event is a routed event.</span></span> <span data-ttu-id="af268-467">Il modello di implementazione dei metodi On \* è diverso per gli eventi indirizzati, perché l'evento indirizzato può essere generato da un elemento figlio, non necessariamente l'elemento che richiama i gestori, in modo che l'implementazione dovrà richiedere origine degli argomenti dell'evento le proprietà in considerazione (e non deve tentare di generare nuovamente l'evento nella maggior parte dei casi).</span><span class="sxs-lookup"><span data-stu-id="af268-467">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="af268-468">Le sottoclassi di <xref:System.Windows.FrameworkContentElement> può scegliere di chiamare metodi del gestore di classe privata quando viene ricevuto l'evento lungo la route.</span><span class="sxs-lookup"><span data-stu-id="af268-468">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="af268-469">Uno scenario di potenziale prevede accettano gli argomenti dell'evento e deliberatamente contrassegnare l'evento come gestito per abbreviare la route.</span><span class="sxs-lookup"><span data-stu-id="af268-469">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="af268-470">Dati dell'evento per l'evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-470">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-471">Gestore di classe per l'evento <see cref="E:System.Windows.ContentElement.GotFocus" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-471">Class handler for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-472">Questo gestore della classe imposta il comportamento dello stato attivo appropriato su questo elemento se l'evento ha avuto origine da questo elemento.</span><span class="sxs-lookup"><span data-stu-id="af268-472">This class handler sets appropriate focus behavior on this element if the event originated from this element.</span></span> <span data-ttu-id="af268-473">Se l'origine dell'evento è stato un altro elemento nell'albero, il gestore non esegue alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="af268-473">If the event's source was another element in the tree, the handler does nothing.</span></span>  
  
 <span data-ttu-id="af268-474">Eseguire l'override di questo metodo per modificare il valore predefinito se ci fermiamo comportamento dell'elemento.</span><span class="sxs-lookup"><span data-stu-id="af268-474">Override this method in order to change these default focusing behavior on your element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="af268-475">Dati dell'evento per l'evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-475">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-476">Genera l'evento <see cref="E:System.Windows.FrameworkContentElement.Initialized" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-476">Raises the <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> event.</span>
          </span>
          <span data-ttu-id="af268-477">Questo metodo viene richiamato ogni volta che la proprietà <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> è impostata su <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-477">This method is invoked whenever <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> is set to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-478">L'implementazione predefinita di questo metodo virtuale genera l'evento come descritto in precedenza in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="af268-478">The default implementation of this virtual method raises the event as described earlier in this topic.</span></span> <span data-ttu-id="af268-479">Gli override devono chiamare base () per mantenere questo comportamento.</span><span class="sxs-lookup"><span data-stu-id="af268-479">Overrides should call base() to preserve this behavior.</span></span>  
  
 <span data-ttu-id="af268-480">Si noti che il <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> proprietà è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="af268-480">Note that the <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> property is read-only.</span></span> <span data-ttu-id="af268-481">Pertanto, è possibile impostarlo per forzare il comportamento di inizializzazione in questo modo.</span><span class="sxs-lookup"><span data-stu-id="af268-481">Therefore, you cannot set it to force initialization behavior that way.</span></span> <span data-ttu-id="af268-482">Impostazione di inizializzazione deve essere eseguita solo dal [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span><span class="sxs-lookup"><span data-stu-id="af268-482">Initialization setting is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="af268-483">Dati dell'evento che descrivono la proprietà modificata, inclusi i valori vecchi e nuovi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-483">The event data that describes the property that changed, including the old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-484">Richiamato ogni volta che il valore effettivo di una qualsiasi proprietà di dipendenza di questo oggetto <see cref="T:System.Windows.FrameworkContentElement" /> viene aggiornato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-484">Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.FrameworkContentElement" /> has been updated.</span>
          </span>
          <span data-ttu-id="af268-485">La proprietà di dipendenza specifica modificata viene indicata nel parametro degli argomenti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-485">The specific dependency property that changed is reported in the arguments parameter.</span>
          </span>
          <span data-ttu-id="af268-486">Esegue l'override di <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-486">Overrides <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-487">Questo metodo non è in genere rileva le modifiche alle proprietà o le convalide.</span><span class="sxs-lookup"><span data-stu-id="af268-487">This method is not intended to generally detect property changes or invalidations.</span></span> <span data-ttu-id="af268-488">Invece è destinato alle modifiche del modello generale di invalidamento se sono noto che alcune informazioni sulle classificazioni a livello delle proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-488">It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</span></span>  
  
 <span data-ttu-id="af268-489">Questo metodo viene richiamato potenzialmente più volte nel corso della durata di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="af268-489">This method is potentially invoked many times during the life of an object.</span></span> <span data-ttu-id="af268-490">Pertanto, è possibile ottenere prestazioni migliorate se esegue l'override di metadati di proprietà specifiche e quindi collegarli <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funzioni per le singole proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-490">Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <xref:System.Windows.CoerceValueCallback> or <xref:System.Windows.PropertyChangedCallback> functions for individual properties.</span></span> <span data-ttu-id="af268-491">Questo metodo, tuttavia, è consigliabile se un <xref:System.Windows.FrameworkContentElement> include un numero significativo di proprietà di dipendenza correlata al valore, o se ne include la logica, ad esempio il comportamento di rendering, che deve essere ripetuto per molti casi di convalide di proprietà correlati.</span><span class="sxs-lookup"><span data-stu-id="af268-491">However, you would use this method if a <xref:System.Windows.FrameworkContentElement> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</span></span>  
  
 <span data-ttu-id="af268-492">Si noti che vi sia un nome identico `OnPropertyChanged` metodo con una firma diversa (tipo di parametro non <xref:System.ComponentModel.PropertyChangedEventArgs>) che possono essere visualizzati in una serie di classi.</span><span class="sxs-lookup"><span data-stu-id="af268-492">Note that there is an identically named `OnPropertyChanged` method with a different signature (the parameter type is <xref:System.ComponentModel.PropertyChangedEventArgs>) that can appear on a number of classes.</span></span> <span data-ttu-id="af268-493">Che `OnPropertyChanged` viene usato per le notifiche di oggetti dati e fa parte del contratto per <xref:System.ComponentModel.INotifyPropertyChanged>.</span><span class="sxs-lookup"><span data-stu-id="af268-493">That `OnPropertyChanged` is used for data object notifications, and is part of the contract for <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="af268-494">
            <para>Chiamare sempre l'implementazione di base, come prima operazione nell'implementazione. Errore eseguire questa operazione disabiliterà in modo significativo l'intera [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema di proprietà, che fa sì che valori non corretti da segnalare.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-494">
              <para>Always call the base implementation, as the first operation in your implementation. Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, which causes incorrect values to be reported.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">
          <span data-ttu-id="af268-495">Stile precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-495">The old style.</span>
          </span>
        </param>
        <param name="newStyle">
          <span data-ttu-id="af268-496">Stile nuovo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-496">The new style.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-497">Richiamato quando lo stile utilizzato per questo elemento viene modificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-497">Invoked when the style that is in use on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-498">Questo metodo ha un'implementazione predefinita che consente di impostare un flag interno notare la condizione di stile di visualizzazione modificato.</span><span class="sxs-lookup"><span data-stu-id="af268-498">This method has a default implementation that sets an internal flag noting the style changed condition.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="af268-499">
            <para>Chiamare sempre l'implementazione di base, in caso contrario, non è possibile applicare degli stili. Scenari per eseguire l'override di questo metodo potrebbero includere se la classe derivata dispone di un selettore di stile specializzata o memorizza nella cache i valori di stile. Modifiche al tema potenzialmente richiama questo metodo.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-499">
              <para>Always call the base implementation, otherwise styles cannot be applied. Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values. Theme changes will potentially invoke this method.</para>
            </span>
          </span>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="af268-500">Fornisce i dati sull'evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-500">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-501">Richiamato ogni qualvolta l'evento indirizzato <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> raggiunge questa classe nella relativa route.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-501">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="af268-502">Implementare questo metodo per aggiungere la gestione delle classi per questo evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-502">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-503">Questo metodo presenta alcuna implementazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="af268-503">This method has no default implementation.</span></span> <span data-ttu-id="af268-504">È comunque necessario chiamare base () nel caso in cui una classe intermedia nell'ereditarietà ha implementato questo metodo.</span><span class="sxs-lookup"><span data-stu-id="af268-504">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="af268-505">Lo scopo di questo metodo è un po' come [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] schema di eventi in \* metodi: fornisce i mezzi per gestire l'evento corrispondente dalle classi derivate con un gestore della classe anziché un gestore di istanze.</span><span class="sxs-lookup"><span data-stu-id="af268-505">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="af268-506">In questo caso l'evento corrispondente è un evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="af268-506">In this case the matching event is a routed event.</span></span> <span data-ttu-id="af268-507">Il modello di implementazione dei metodi On \* è diverso per gli eventi indirizzati, perché l'evento indirizzato può essere generato da un elemento figlio, non necessariamente l'elemento che richiama i gestori, in modo che l'implementazione dovrà richiedere origine degli argomenti dell'evento le proprietà in considerazione (e non deve tentare di generare nuovamente l'evento nella maggior parte dei casi).</span><span class="sxs-lookup"><span data-stu-id="af268-507">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="af268-508">Le sottoclassi di <xref:System.Windows.FrameworkContentElement> può scegliere di chiamare metodi del gestore di classe privata quando viene ricevuto l'evento lungo la route.</span><span class="sxs-lookup"><span data-stu-id="af268-508">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="af268-509">Uno scenario di potenziale prevede accettano gli argomenti dell'evento e deliberatamente contrassegnare l'evento come gestito per abbreviare la route.</span><span class="sxs-lookup"><span data-stu-id="af268-509">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="af268-510">Fornisce i dati sull'evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-510">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-511">Richiamato ogni qualvolta l'evento indirizzato <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> raggiunge questa classe nella relativa route.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-511">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="af268-512">Implementare questo metodo per aggiungere la gestione delle classi per questo evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-512">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-513">Questo metodo presenta alcuna implementazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="af268-513">This method has no default implementation.</span></span> <span data-ttu-id="af268-514">È comunque necessario chiamare base () nel caso in cui una classe intermedia nell'ereditarietà ha implementato questo metodo.</span><span class="sxs-lookup"><span data-stu-id="af268-514">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="af268-515">Lo scopo di questo metodo è un po' come [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] schema di eventi in \* metodi: fornisce i mezzi per gestire l'evento corrispondente dalle classi derivate con un gestore della classe anziché un gestore di istanze.</span><span class="sxs-lookup"><span data-stu-id="af268-515">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="af268-516">In questo caso l'evento corrispondente è un evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="af268-516">In this case the matching event is a routed event.</span></span> <span data-ttu-id="af268-517">Il modello di implementazione dei metodi On \* è diverso per gli eventi indirizzati, perché l'evento indirizzato può essere generato da un elemento figlio, non necessariamente l'elemento che richiama i gestori, in modo che l'implementazione dovrà eseguire origine degli argomenti dell'evento le proprietà in considerazione (e non deve tentare di generare nuovamente l'evento nella maggior parte dei casi).</span><span class="sxs-lookup"><span data-stu-id="af268-517">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="af268-518">Le sottoclassi di <xref:System.Windows.FrameworkContentElement> può scegliere di chiamare metodi del gestore di classe privata quando viene ricevuto l'evento lungo la route.</span><span class="sxs-lookup"><span data-stu-id="af268-518">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="af268-519">Uno scenario di potenziale prevede accettano gli argomenti dell'evento e deliberatamente contrassegnare l'evento come gestito per abbreviare la route.</span><span class="sxs-lookup"><span data-stu-id="af268-519">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-520">Ottiene o imposta un valore che indica se questo elemento incorpora le proprietà di stile dagli stili del tema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-520">Gets or sets a value indicating whether this element incorporates style properties from theme styles.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-521">
            <see langword="true" /> se questo elemento non utilizza le proprietà di stile del tema; tutte le proprietà che hanno origine dallo stile provengono dagli stili dell'applicazione locale e le proprietà di stile del tema non sono applicabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-521">
              <see langword="true" /> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</span>
          </span>
          <span data-ttu-id="af268-522">
            <see langword="false" /> se vengono applicati prima gli stili dell'applicazione, quindi gli stili del tema per le proprietà non specificamente impostate negli stili dell'applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-522">
              <see langword="false" /> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-523">L'uso più comune di questa proprietà è un indiretto all'interno di setter di uno stile che include uno stile a tema.</span><span class="sxs-lookup"><span data-stu-id="af268-523">The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</span></span>  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-524">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-524">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-525">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-525">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|<span data-ttu-id="af268-526">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-526">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-527">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-527">Identifies the <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-528">Ottiene l'elemento padre nell'albero logico per questo elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-528">Gets the parent in the logical tree for this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-529">Elemento padre logico di questo elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-529">The logical parent for this element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-530">Si noti che l'elemento padre logico di un elemento può essere modificato a seconda delle funzionalità dell'applicazione, e mantenere il valore di questa proprietà non rifletterà le modifiche.</span><span class="sxs-lookup"><span data-stu-id="af268-530">Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</span></span> <span data-ttu-id="af268-531">È in genere deve ottenere il valore immediatamente prima che ti serve.</span><span class="sxs-lookup"><span data-stu-id="af268-531">You typically should get the value immediately before you need it.</span></span>  
  
 <span data-ttu-id="af268-532">Visualizzare [strutture ad albero in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) per altre informazioni sull'attraversamento di strutture ad albero logiche e gli scenari in cui questo approccio nei confronti di individuare l'elemento è appropriato.</span><span class="sxs-lookup"><span data-stu-id="af268-532">See [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</span></span>  
  
 <span data-ttu-id="af268-533">Il sistema di proprietà potrà ricalcolare tutti i valori di proprietà di un elemento quando viene riassociato come padre, perché alcune proprietà ereditano valori attraverso l'albero logico.</span><span class="sxs-lookup"><span data-stu-id="af268-533">The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</span></span> <span data-ttu-id="af268-534">Il <xref:System.Windows.FrameworkContentElement.DataContext%2A> che applica le associazioni possono essere modificato anche quando gli elementi vengono riassociate come elementi padre.</span><span class="sxs-lookup"><span data-stu-id="af268-534">The <xref:System.Windows.FrameworkContentElement.DataContext%2A> that applies for bindings can also change when elements are reparented.</span></span>  
  
 <span data-ttu-id="af268-535">Modifica padre di un elemento viene in genere eseguita mediante manipolazione di raccolte, utilizzando dedicato aggiungere o rimuovere metodi, o tramite l'impostazione delle proprietà del contenuto degli elementi.</span><span class="sxs-lookup"><span data-stu-id="af268-535">Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</span></span>  
  
 <span data-ttu-id="af268-536">Lo scenario più comune per l'uso di <xref:System.Windows.FrameworkContentElement.Parent%2A> proprietà consiste nell'ottenere un riferimento, quindi ottenere varie <xref:System.Windows.FrameworkContentElement> i valori delle proprietà dall'elemento padre.</span><span class="sxs-lookup"><span data-stu-id="af268-536">The most typical scenario for using the <xref:System.Windows.FrameworkContentElement.Parent%2A> property is to obtain a reference and then get various <xref:System.Windows.FrameworkContentElement> property values from the parent.</span></span> <span data-ttu-id="af268-537">Per i modelli, il <xref:System.Windows.FrameworkContentElement.Parent%2A> del modello alla fine saranno `null`.</span><span class="sxs-lookup"><span data-stu-id="af268-537">For templates, the <xref:System.Windows.FrameworkContentElement.Parent%2A> of the template eventually will be `null`.</span></span> <span data-ttu-id="af268-538">Per ottenere dopo questo passaggio e passare all'albero logico in cui viene fatto applicato il modello, usare <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span><span class="sxs-lookup"><span data-stu-id="af268-538">To get past this point and extend into the logical tree where the template is actually applied, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="af268-539">L'esempio seguente controlla per verificare se il <xref:System.Windows.FrameworkContentElement.Parent%2A> di un <xref:System.Windows.Documents.TextPointer> è di un determinato tipo.</span><span class="sxs-lookup"><span data-stu-id="af268-539">The following example checks to see whether the <xref:System.Windows.FrameworkContentElement.Parent%2A> of a <xref:System.Windows.Documents.TextPointer> is of a particular type.</span></span>  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">
          <span data-ttu-id="af268-540">Direzione per la quale deve essere determinata una potenziale modifica dello stato attivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-540">The direction for which a prospective focus change should be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-541">Determina il successivo elemento che riceverà lo stato attivo in relazione a questo elemento per una direzione dello spostamento dello stato attivo specificata, ma non sposta effettivamente lo stato attivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-541">Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</span>
          </span>
          <span data-ttu-id="af268-542">Questo metodo è sealed e non può essere sottoposto a override.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-542">This method is sealed and cannot be overridden.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-543">Elemento successivo su cui verrebbe spostato lo stato attivo in caso di effettivo attraversamento dello stato attivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-543">The next element that focus would move to if focus were actually traversed.</span>
          </span>
          <span data-ttu-id="af268-544">Potrebbe restituire <see langword="null" /> se lo stato attivo non può essere spostato in relazione a questo elemento per la direzione specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-544">May return <see langword="null" /> if focus cannot be moved relative to this element for the provided direction.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-545"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> è il metodo correlato che effettivamente spostare lo stato attivo.</span><span class="sxs-lookup"><span data-stu-id="af268-545"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> is the related method that actually does move focus.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="af268-546">Specificata per una delle seguenti direzioni in <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-546">Specified one of the following directions in the <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span>
          </span>
          <span data-ttu-id="af268-547">Queste direzioni non sono valide per <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />, ma lo sono per <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-547">These directions are not legal for <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (but they are legal for <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="af268-548">Nome da utilizzare per il mapping nome-oggetto specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-548">Name to use for the specified name-object mapping.</span>
          </span>
        </param>
        <param name="scopedElement">
          <span data-ttu-id="af268-549">Oggetto per il mapping.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-549">Object for the mapping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-550">Fornisce una funzione di accesso che semplifica l'accesso al metodo di registrazione di <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-550">Provides an accessor that simplifies access to the <see cref="T:System.Windows.NameScope" /> registration method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-551">Questo metodo è un metodo pratico per chiamare il metodo <xref:System.Windows.NameScope.RegisterName%2A>.</span><span class="sxs-lookup"><span data-stu-id="af268-551">This method is a convenience method for calling <xref:System.Windows.NameScope.RegisterName%2A>.</span></span> <span data-ttu-id="af268-552">L'implementazione controllerà gli elementi padre successivi fino a individuare applicabile <xref:System.Windows.NameScope> implementazione, che viene calcolata eseguendo la ricerca di un elemento che implementa <xref:System.Windows.Markup.INameScope>.</span><span class="sxs-lookup"><span data-stu-id="af268-552">The implementation will check successive parent elements until it finds the applicable <xref:System.Windows.NameScope> implementation, which is found by finding an element that implements <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="af268-553">Per altre informazioni su ambiti dei nomi, vedere [NameScope XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span><span class="sxs-lookup"><span data-stu-id="af268-553">For more information about namescopes, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="af268-554">La chiamata a <xref:System.Windows.FrameworkContentElement.RegisterName%2A> laborioso correttamente collegare gli storyboard per animazioni per le applicazioni create nel codice.</span><span class="sxs-lookup"><span data-stu-id="af268-554">Calling <xref:System.Windows.FrameworkContentElement.RegisterName%2A> is necessary in order to correctly hook up animation storyboards for applications when created in code.</span></span> <span data-ttu-id="af268-555">Infatti, proprietà, una delle principali storyboard <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, utilizza una ricerca in fase di esecuzione anziché essere in grado di accettare un riferimento a un elemento di destinazione.</span><span class="sxs-lookup"><span data-stu-id="af268-555">This is because one of the key storyboard properties, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, uses a run-time name lookup instead of being able to take a reference to a target element.</span></span> <span data-ttu-id="af268-556">Questo vale anche se tale elemento è accessibile mediante un riferimento dal codice.</span><span class="sxs-lookup"><span data-stu-id="af268-556">This is true even if that element is accessible by reference from the code.</span></span> <span data-ttu-id="af268-557">Per altre informazioni sul motivo per cui è necessario registrare i nomi per le destinazioni di storyboard, vedere [Cenni preliminari sugli storyboard](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="af268-557">For more information on why you need to register names for storyboard targets, see [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span> <span data-ttu-id="af268-558">Le animazioni per gli elementi di contenuto sono meno comuni animazioni su controlli, il [Cenni preliminari sugli storyboard](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) si concentra sugli scenari di controllo.</span><span class="sxs-lookup"><span data-stu-id="af268-558">Animations for content elements are less common than animations on controls, the [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) concentrates on control scenarios.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">
          <span data-ttu-id="af268-559">Elemento da rimuovere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-559">The element to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-560">Rimuove l'elemento specificato dall'albero logico per questo elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-560">Removes the specified element from the logical tree for this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-561">Ciò [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] riguarda principalmente per la classe che deriva scenari, quando si aggiunge il supporto per le raccolte figlio.</span><span class="sxs-lookup"><span data-stu-id="af268-561">This [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is mainly relevant for class deriving scenarios, when adding support for child collections.</span></span>  
  
 <span data-ttu-id="af268-562">La maggior parte delle <xref:System.Windows.FrameworkContentElement> alle classi derivate espongono raccolte dedicate che sono responsabili di contenimento (ad esempio, <xref:System.Windows.Documents.Span.Inlines%2A> nel <xref:System.Windows.Documents.Span> classe; <xref:System.Windows.Documents.Section.Blocks%2A> sul <xref:System.Windows.Documents.Section> classe).</span><span class="sxs-lookup"><span data-stu-id="af268-562">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="af268-563">Derivazione da tali classi in genere, è possibile evitare qualsiasi esigenza di modificare direttamente l'albero logico.</span><span class="sxs-lookup"><span data-stu-id="af268-563">Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-564">Ottiene o imposta il dizionario risorse corrente definito localmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-564">Gets or sets the current locally-defined resource dictionary.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-565">Le risorse correnti definite localmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-565">The current locally-defined resources.</span>
          </span>
          <span data-ttu-id="af268-566">Si tratta di un dizionario risorse in cui l'accesso alle risorse all'interno del dizionario viene eseguito tramite chiave.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-566">This is a dictionary of resources, where resources within the dictionary are accessed by key.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-567">Dizionari risorse che possono essere definiti completamente o parzialmente in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] vengono in genere creati jako prvek vlastnosti e sono in genere per l'elemento radice di qualsiasi pagina singola o per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="af268-567">Resource dictionaries that can be defined completely or partially in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] are typically created as a property element, and are typically on the root element for any individual page or for the application.</span></span> <span data-ttu-id="af268-568">Posizionando il dizionario risorse a questo livello rende più semplice trovare da singoli elementi figlio nella pagina (o da qualsiasi pagina, nel caso dell'applicazione).</span><span class="sxs-lookup"><span data-stu-id="af268-568">Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</span></span> <span data-ttu-id="af268-569">Nella maggior parte degli scenari di applicazione, è consigliabile che gli stili viene definita come elementi oggetto all'interno di un dizionario risorse, o essere definiti come risorse esterne in modo che la risorsa di stile intero può essere autonoma (questo approccio consente di progettazione separate le responsabilità di responsabilità degli sviluppatori, separando i file fisici che devono essere modificate).</span><span class="sxs-lookup"><span data-stu-id="af268-569">In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</span></span>  
  
 <span data-ttu-id="af268-570">Si noti che questa proprietà restituisce solo il dizionario risorse dichiarati direttamente all'interno di tale elemento.</span><span class="sxs-lookup"><span data-stu-id="af268-570">Note that this property returns only the resource dictionary declared directly within that element.</span></span> <span data-ttu-id="af268-571">Ciò è diverso rispetto al processo di ricerca di risorse effettivi, in cui un elemento figlio può accedere a tutte le risorse definite in ogni elemento padre, la ricerca in modo ricorsivo verso l'alto.</span><span class="sxs-lookup"><span data-stu-id="af268-571">This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</span></span>  
  
 <span data-ttu-id="af268-572">Può anche essere richiamate dal codice dall'interno dell'insieme di risorse, ma tenere presente che le risorse create [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] indubbiamente non sarà possibile accedere fino a dopo <xref:System.Windows.FrameworkContentElement.Loaded> viene generato dall'elemento che dichiara il dizionario.</span><span class="sxs-lookup"><span data-stu-id="af268-572">Resources can also be referenced by code from within the collection, but be aware that resources created in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] will definitely not be accessible until after <xref:System.Windows.FrameworkContentElement.Loaded> is raised by the element that declares the dictionary.</span></span> <span data-ttu-id="af268-573">In effetti, le risorse vengono analizzate in modo asincrono e non anche il <xref:System.Windows.FrameworkContentElement.Loaded> evento è una garanzia che è possibile fare riferimento a un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] risorsa definita.</span><span class="sxs-lookup"><span data-stu-id="af268-573">In fact, resources are parsed asynchronously, and not even the <xref:System.Windows.FrameworkContentElement.Loaded> event is an assurance that you can reference a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resource.</span></span> <span data-ttu-id="af268-574">Per questo motivo è consigliabile in genere solo accedere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] risorse definite come parte del codice in fase di esecuzione o tramite altri [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] tecniche, ad esempio stili o i riferimenti all'estensione di risorsa per i valori di attributo.</span><span class="sxs-lookup"><span data-stu-id="af268-574">For this reason you should generally only access [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resources as part of run-time code, or through other [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques such as styles or resource extension references for attribute values.</span></span> <span data-ttu-id="af268-575">Quando si accede alle risorse tramite codice, è essenzialmente equivalente a un riferimento effettuato da [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="af268-575">When you access resources through code, it is essentially equivalent to a  reference made from [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="af268-576">Sottostante <xref:System.Windows.ResourceDictionary> supporta i metodi necessari per aggiungere, rimuovere o eseguire una query sulle risorse dall'interno dell'insieme utilizzando il codice.</span><span class="sxs-lookup"><span data-stu-id="af268-576">The underlying <xref:System.Windows.ResourceDictionary> supports the methods required to add, remove, or query resources from within the collection by using code.</span></span> <span data-ttu-id="af268-577">Il <xref:System.Windows.FrameworkContentElement.Resources%2A> è possibile impostare per supportare lo scenario di sostituzione completa la raccolta di risorse di un elemento per ottenere un nuovo o diverso proprietà <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="af268-577">The <xref:System.Windows.FrameworkContentElement.Resources%2A> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="af268-578">Si noti che il [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintassi illustrata include un elemento per il <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="af268-578">Notice that the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax shown does not include an element for the <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="af268-579">Questo è un esempio di sintassi per raccolte implicite; un tag che rappresenta l'elemento della raccolta può essere omessa.</span><span class="sxs-lookup"><span data-stu-id="af268-579">This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</span></span> <span data-ttu-id="af268-580">Gli elementi che vengono aggiunte come elementi nella raccolta vengono invece specificati.</span><span class="sxs-lookup"><span data-stu-id="af268-580">The elements that are added as items to the collection are specified instead.</span></span> <span data-ttu-id="af268-581">Per altre informazioni sulle raccolte implicite e [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], vedere [XAML descrizione dettagliata della sintassi](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="af268-581">For more information about implicit collections and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], see [XAML Syntax In Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="af268-582">Un caso in cui un <xref:System.Windows.ResourceDictionary> sono ancora specificate in modo esplicito come un elemento è se si inserisce un dizionario unito, nel qual caso sono non presenti in genere elementi figlio per tale <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="af268-582">One case where a <xref:System.Windows.ResourceDictionary> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="af268-583">Per informazioni dettagliate, vedere [dizionari risorse uniti](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span><span class="sxs-lookup"><span data-stu-id="af268-583">For details, see [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span></span>  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="af268-584">Utilizzo della sintassi XAML per elementi proprietà</span><span class="sxs-lookup"><span data-stu-id="af268-584">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a><span data-ttu-id="af268-585">Valori XAML</span><span class="sxs-lookup"><span data-stu-id="af268-585">XAML Values</span></span>  
 <span data-ttu-id="af268-586">*oneOrMoreResourceElements*</span><span class="sxs-lookup"><span data-stu-id="af268-586">*oneOrMoreResourceElements*</span></span>  
 <span data-ttu-id="af268-587">Uno o più elementi oggetto, ognuno dei quali definisce una risorsa.</span><span class="sxs-lookup"><span data-stu-id="af268-587">One or more object elements, each of which defines a resource.</span></span> <span data-ttu-id="af268-588">Ogni elemento di proprietà della risorsa all'interno di ciascun <xref:System.Windows.ResourceDictionary> deve avere un valore univoco per il [direttiva X:Key](~/docs/framework/xaml-services/x-key-directive.md), che funge da chiave univoca quando vengono recuperati valori dal <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="af268-588">Each resource property element within each <xref:System.Windows.ResourceDictionary> must have a unique value for the [x:Key Directive](~/docs/framework/xaml-services/x-key-directive.md), which serves as the unique key when values are retrieved from the <xref:System.Windows.ResourceDictionary>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="af268-589">L'esempio seguente stabilisce un <xref:System.Windows.FrameworkContentElement.Resources%2A> insieme su un <xref:System.Windows.Documents.FlowDocument> elemento radice.</span><span class="sxs-lookup"><span data-stu-id="af268-589">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element.</span></span> <span data-ttu-id="af268-590"><xref:System.Windows.Documents.FlowDocument> è una scelta tipica perché è una delle poche <xref:System.Windows.FrameworkContentElement> le classi che è possano utilizzare come un elemento radice e le risorse sono in genere archiviate nella radice della pagina o a livelli ancora superiori ad esempio l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="af268-590"><xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="af268-591">Aggiunge un'associazione a questo elemento per la proprietà di dipendenza specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-591">Attaches a binding to this element for the specified dependency property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="af268-592">Identifica la proprietà associata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-592">Identifies the bound property.</span>
          </span>
        </param>
        <param name="path">
          <span data-ttu-id="af268-593">Nome della proprietà di origine o percorso della proprietà utilizzata per l'associazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-593">The source property name or the path to the property used for the binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-594">Connette un'associazione a questo elemento in base al nome della proprietà di origine specificata come qualificazione del percorso all'origine dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-594">Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-595">Registra le condizioni dell'associazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-595">Records the conditions of the binding.</span>
          </span>
          <span data-ttu-id="af268-596">Questo valore restituito può essere utile per il controllo degli errori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-596">This return value can be useful for error checking.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-597">Questo metodo è un metodo pratico per la chiamata <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, che consente di passare l'istanza corrente come il <xref:System.Windows.DependencyObject>e crea un nuovo <xref:System.Windows.Data.Binding> base fornito `path` parametro.</span><span class="sxs-lookup"><span data-stu-id="af268-597">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>, and creates a new <xref:System.Windows.Data.Binding> based on the provided `path` parameter.</span></span> <span data-ttu-id="af268-598">Questa firma è più pratica, se si stabilisce un binding predefinito semplice.</span><span class="sxs-lookup"><span data-stu-id="af268-598">This signature is more convenient if you are establishing a simple default binding.</span></span> <span data-ttu-id="af268-599">Se è necessario specificare alcuna proprietà di associazione per le condizioni non predefinito, o da usare una <xref:System.Windows.Data.MultiBinding> oppure <xref:System.Windows.Data.PriorityBinding>, è consigliabile usare il <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> firma.</span><span class="sxs-lookup"><span data-stu-id="af268-599">If you need to specify any binding properties to non-default conditions, or want to use a <xref:System.Windows.Data.MultiBinding> or <xref:System.Windows.Data.PriorityBinding>,you should use the <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="af268-600">Nell'esempio seguente imposta un'associazione in un <xref:System.Windows.Documents.Paragraph> elemento, creando un nuovo oggetto di dati personalizzati, stabilire tale oggetto come <xref:System.Windows.FrameworkContentElement.DataContext%2A>e impostare il percorso di associazione a una proprietà all'interno di esso.</span><span class="sxs-lookup"><span data-stu-id="af268-600">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="af268-601">Identifica la proprietà associata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-601">Identifies the bound property.</span>
          </span>
        </param>
        <param name="binding">
          <span data-ttu-id="af268-602">Rappresenta un'associazione dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-602">Represents a data binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-603">Collega un'associazione a questo elemento in base all'oggetto di associazione specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-603">Attaches a binding to this element, based on the provided binding object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-604">Registra le condizioni dell'associazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-604">Records the conditions of the binding.</span>
          </span>
          <span data-ttu-id="af268-605">Questo valore restituito può essere utile per il controllo degli errori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-605">This return value can be useful for error checking.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-606">Questo metodo è un metodo pratico per la chiamata <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, che consente di passare l'istanza corrente come il <xref:System.Windows.DependencyObject>.</span><span class="sxs-lookup"><span data-stu-id="af268-606">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="af268-607">Nell'esempio seguente imposta un'associazione in un <xref:System.Windows.Documents.Paragraph> creando un nuovo elemento <xref:System.Windows.Data.Binding> e impostando l'origine su un'appena compilata `DateTime` oggetto.</span><span class="sxs-lookup"><span data-stu-id="af268-607">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="af268-608">Proprietà a cui è associata la risorsa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-608">The property to which the resource is bound.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="af268-609">Nome della risorsa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-609">The name of the resource.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-610">Cerca una risorsa con il nome specificato e ne configura un riferimento alla risorsa per la proprietà specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-610">Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-611">Un riferimento a una risorsa è simile all'utilizzo di un [estensione di Markup DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) nel markup.</span><span class="sxs-lookup"><span data-stu-id="af268-611">A resource reference is similar to the use of a [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) in markup.</span></span> <span data-ttu-id="af268-612">Il riferimento di risorsa viene creata un'espressione interna che fornisce il valore della proprietà specificata in fase di esecuzione posticipata.</span><span class="sxs-lookup"><span data-stu-id="af268-612">The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</span></span> <span data-ttu-id="af268-613">L'espressione verrà riconsiderato ogni volta che il dizionario risorse indica un valore modificato tramite gli eventi interni o ogni volta che viene riassociate come elementi padre dell'elemento corrente (un elemento padre è cambiato modificherebbe il percorso di ricerca di dizionario).</span><span class="sxs-lookup"><span data-stu-id="af268-613">The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="af268-614">Restituisce un valore che indica se i processi di serializzazione devono serializzare il contenuto della proprietà <see cref="P:System.Windows.FrameworkContentElement.Resources" /> nelle istanze di questa classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-614">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-615">
            <see langword="true" /> se il valore della proprietà <see cref="P:System.Windows.FrameworkContentElement.Resources" /> deve essere serializzato; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-615">
              <see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-616">Verrà restituito `true` purché vi sia almeno una risorsa con chiave locale <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span><span class="sxs-lookup"><span data-stu-id="af268-616">This will return `true` so long as there is at least one keyed resource in the local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="af268-617">Restituisce un valore che indica se i processi di serializzazione devono serializzare il contenuto della proprietà <see cref="P:System.Windows.FrameworkContentElement.Style" /> nelle istanze di questa classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-617">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-618">
            <see langword="true" /> se il valore della proprietà <see cref="P:System.Windows.FrameworkContentElement.Style" /> deve essere serializzato; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-618">
              <see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-619">Verrà restituito `true` se il <xref:System.Windows.Style> è impostato localmente.</span><span class="sxs-lookup"><span data-stu-id="af268-619">This will return `true` if the <xref:System.Windows.Style> is locally set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-620">Si verifica quando una qualsiasi origine dati associata che partecipa a un'associazione in questo elemento viene modificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-620">Occurs when any associated data source participating in a binding on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-621">Questo evento mostra il <xref:System.Windows.Data.Binding.SourceUpdated> evento generato da qualsiasi <xref:System.Windows.Data.Binding> associato a questo elemento.</span><span class="sxs-lookup"><span data-stu-id="af268-621">This event surfaces the <xref:System.Windows.Data.Binding.SourceUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span>  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="af268-622">Uso della sintassi XAML per gli attributi</span><span class="sxs-lookup"><span data-stu-id="af268-622">XAML Attribute Usage</span></span>  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-623">Ottiene o imposta lo stile che l'elemento deve usare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-623">Gets or sets the style to be used by this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-624">Stile non predefinito applicato per l'elemento, se presente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-624">The applied, nondefault style for the element, if present.</span>
          </span>
          <span data-ttu-id="af268-625">In caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-625">Otherwise, <see langword="null" />.</span>
          </span>
          <span data-ttu-id="af268-626">Il valore predefinito per un oggetto <see cref="T:System.Windows.FrameworkContentElement" /> costruito in base all'impostazione predefinita è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-626">The default for a default-constructed <see cref="T:System.Windows.FrameworkContentElement" /> is <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-627">Lo stile corrente viene spesso fornito da uno stile predefinito dall'applicazione di temi, o dagli stili in genere applicati agli oggetti di quel tipo dalle risorse a livello di pagina o un'applicazione (uno stile implicito).</span><span class="sxs-lookup"><span data-stu-id="af268-627">The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</span></span> <span data-ttu-id="af268-628">Questa proprietà non stili (tema) predefiniti non impostato o restituito, ma restituisce lo stile implicito o uno stile esplicito.</span><span class="sxs-lookup"><span data-stu-id="af268-628">This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</span></span> <span data-ttu-id="af268-629">Nel caso di stili impliciti o espliciti, non è importante se lo stile è accessibile come una risorsa o definito in locale.</span><span class="sxs-lookup"><span data-stu-id="af268-629">In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</span></span>  
  
 <span data-ttu-id="af268-630">Impostare gli stili presenta alcune restrizioni.</span><span class="sxs-lookup"><span data-stu-id="af268-630">Setting the styles has some restrictions.</span></span> <span data-ttu-id="af268-631">È possibile reimpostare l'intera <xref:System.Windows.FrameworkContentElement.Style%2A> a una nuova proprietà <xref:System.Windows.Style> in qualsiasi momento, che forzerà la ricomposizione un layout.</span><span class="sxs-lookup"><span data-stu-id="af268-631">You can reset the entire <xref:System.Windows.FrameworkContentElement.Style%2A> property to a new <xref:System.Windows.Style> at any time, which will force a layout recomposition.</span></span> <span data-ttu-id="af268-632">Tuttavia, appena lo stile verrà utilizzato da un elemento caricato, il <xref:System.Windows.Style> deve essere considerato sealed.</span><span class="sxs-lookup"><span data-stu-id="af268-632">However, as soon as that style is placed in use by a loaded element, the <xref:System.Windows.Style> should be considered sealed.</span></span> <span data-ttu-id="af268-633">Tenta di apportare una modifica a una singola proprietà di uno stile in uso (ad esempio qualsiasi elemento all'interno dell'insieme di <xref:System.Windows.Style.Setters%2A>) viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="af268-633">Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <xref:System.Windows.Style.Setters%2A>) causes an exception to be thrown.</span></span> <span data-ttu-id="af268-634">Uno stile che viene definito nel markup viene considerato per essere in uso, non appena viene caricato da un dizionario di risorse (per le risorse) o (per gli stili inline) viene caricata la pagina che è contenuta.</span><span class="sxs-lookup"><span data-stu-id="af268-634">A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</span></span>  
  
 <span data-ttu-id="af268-635"><xref:System.Windows.FrameworkContentElement.Style%2A> è una proprietà di dipendenza con la precedenza speciale.</span><span class="sxs-lookup"><span data-stu-id="af268-635"><xref:System.Windows.FrameworkContentElement.Style%2A> is a dependency property with special precedence.</span></span> <span data-ttu-id="af268-636">Impostata localmente lo stile in genere ha la precedenza più alta nel sistema di proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-636">The locally set style generally operates at the highest precedence in the property system.</span></span> <span data-ttu-id="af268-637">Se il <xref:System.Windows.FrameworkContentElement.Style%2A> è null a questo punto, durante il caricamento del sistema di proprietà Cerca stili impliciti come risorse definite che specificano che il tipo.</span><span class="sxs-lookup"><span data-stu-id="af268-637">If the <xref:System.Windows.FrameworkContentElement.Style%2A> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</span></span> <span data-ttu-id="af268-638">Se lo stile è ancora null dopo questo passaggio, quindi lo stile deriva dallo stile (tema) predefiniti, ma lo stile predefinito non viene restituito nel <xref:System.Windows.FrameworkContentElement.Style%2A> valore della proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-638">If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <xref:System.Windows.FrameworkContentElement.Style%2A> property value.</span></span> <span data-ttu-id="af268-639">Visualizzare [precedenza del valore della proprietà dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span><span class="sxs-lookup"><span data-stu-id="af268-639">See [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="af268-640">Uso della sintassi XAML per gli attributi</span><span class="sxs-lookup"><span data-stu-id="af268-640">XAML Attribute Usage</span></span>  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a><span data-ttu-id="af268-641">Valori XAML</span><span class="sxs-lookup"><span data-stu-id="af268-641">XAML Values</span></span>  
 <span data-ttu-id="af268-642">*ResourceExtension*</span><span class="sxs-lookup"><span data-stu-id="af268-642">*resourceExtension*</span></span>  
 <span data-ttu-id="af268-643">Uno dei seguenti:, o.</span><span class="sxs-lookup"><span data-stu-id="af268-643">One of the following: , or .</span></span> <span data-ttu-id="af268-644">Visualizzare [risorse XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="af268-644">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="af268-645">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="af268-645">*styleResourceKey*</span></span>  
 <span data-ttu-id="af268-646">La chiave che identifica lo stile della richiesta.</span><span class="sxs-lookup"><span data-stu-id="af268-646">The key that identifies the style being requested.</span></span> <span data-ttu-id="af268-647">La chiave fa riferimento a una risorsa esistente in un <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="af268-647">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="af268-648">La sintassi degli elementi è tecnicamente possibile, ma non è consigliata.</span><span class="sxs-lookup"><span data-stu-id="af268-648">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="af268-649">Visualizzare [stili Inline e modelli](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span><span class="sxs-lookup"><span data-stu-id="af268-649">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="af268-650">Un riferimento dell'associazione usando o <xref:System.Windows.Data.Binding> è anche possibile, ma non comuni.</span><span class="sxs-lookup"><span data-stu-id="af268-650">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-651">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-651">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-652">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-652">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|<span data-ttu-id="af268-653">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-653">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="af268-654">L'esempio seguente stabilisce un <xref:System.Windows.FrameworkContentElement.Resources%2A> insieme in una <xref:System.Windows.Documents.FlowDocument> elemento radice e quindi farvi riferimento come una risorsa come uno stile specifico per un <xref:System.Windows.Documents.Paragraph>.</span><span class="sxs-lookup"><span data-stu-id="af268-654">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-655">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.Style" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-655">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Style" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">
          <span data-ttu-id="af268-656">Nome della proprietà di ambiente richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-656">The name of the requested ambient property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-657">Per una descrizione di questo membro, vedere il metodo <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-657">For a description of this member, see the <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-658">
            <see langword="true" /> se <paramref name="propertyName" /> è disponibile; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-658">
              <see langword="true" /> if <paramref name="propertyName" /> is available; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-659">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="af268-659">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="af268-660">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Windows.FrameworkContentElement> a un'interfaccia <xref:System.Windows.Markup.IQueryAmbient>.</span><span class="sxs-lookup"><span data-stu-id="af268-660">It can be used only when the <xref:System.Windows.FrameworkContentElement> instance is cast to an <xref:System.Windows.Markup.IQueryAmbient> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-661">Recupera o imposta un valore di oggetto arbitrario utilizzabile per archiviare informazioni personalizzate sull'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-661">Gets or sets an arbitrary object value that can be used to store custom information about this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-662">Valore previsto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-662">The intended value.</span>
          </span>
          <span data-ttu-id="af268-663">Nessun valore predefinito per questa proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-663">This property has no default value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-664">Questa proprietà è analoga alle proprietà di Tag in altri modelli di programmazione di Microsoft, ad esempio Visual Basic, Applications Edition o Windows Form.</span><span class="sxs-lookup"><span data-stu-id="af268-664">This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</span></span> <span data-ttu-id="af268-665">Consente di fornire una posizione già esistente per archiviare alcune informazioni personalizzate su qualsiasi elemento di base senza imporre agli sviluppatori di applicazioni per creare una sottoclasse.</span><span class="sxs-lookup"><span data-stu-id="af268-665">It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</span></span>  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a><span data-ttu-id="af268-666">Valori XAML</span><span class="sxs-lookup"><span data-stu-id="af268-666">XAML Values</span></span>  
 <span data-ttu-id="af268-667">Poiché questa proprietà accetta un oggetto, è necessario usare l'utilizzo dell'elemento di proprietà per impostare il <xref:System.Windows.FrameworkContentElement.Tag%2A> proprietà in XAML su un valore qualsiasi diverso da un oggetto con un convertitore di tipi noti e predefiniti, ad esempio una stringa.</span><span class="sxs-lookup"><span data-stu-id="af268-667">Because this property takes an object, you need to use the property element usage in order to set the <xref:System.Windows.FrameworkContentElement.Tag%2A> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</span></span> <span data-ttu-id="af268-668">Gli oggetti utilizzati in questo modo non sono in genere all'interno di spazi dei nomi standard di WPF e pertanto possono richiedere il mapping dello spazio dei nomi per lo spazio dei nomi esterno per poter essere introdotti come elementi XAML.</span><span class="sxs-lookup"><span data-stu-id="af268-668">Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</span></span>  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-669">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-669">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-670">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-670">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|<span data-ttu-id="af268-671">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-671">Metadata properties set to `true`</span></span>|<span data-ttu-id="af268-672">nessuno</span><span class="sxs-lookup"><span data-stu-id="af268-672">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-673">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.Tag" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-673">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Tag" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-674">Si verifica in seguito alla modifica di qualsiasi proprietà di destinazione associata coinvolta in un'associazione per l'elemento corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-674">Occurs when any associated target property participating in a binding on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-675">Questo evento mostra il <xref:System.Windows.Data.Binding.TargetUpdated> evento generato da qualsiasi <xref:System.Windows.Data.Binding> associato a questo elemento.</span><span class="sxs-lookup"><span data-stu-id="af268-675">This event surfaces the <xref:System.Windows.Data.Binding.TargetUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span> <span data-ttu-id="af268-676">Ciò in genere significa che l'associazione in questione è un'associazione bidirezionale, e che la proprietà di dipendenza associata un invalidamento dei dati del valore della proprietà precedente per qualsiasi schema di convalida o memorizzazione nella cache che supporta la proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-676">This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</span></span>  
  
 <span data-ttu-id="af268-677">Gli argomenti dell'evento di questo evento indicherà quale proprietà associata è stata modificata.</span><span class="sxs-lookup"><span data-stu-id="af268-677">The event arguments of this event will inform you which bound property was changed.</span></span>  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="af268-678">Uso della sintassi XAML per gli attributi</span><span class="sxs-lookup"><span data-stu-id="af268-678">XAML Attribute Usage</span></span>  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-679">Ottiene un riferimento al modello padre di questo elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-679">Gets a reference to the template parent of this element.</span>
          </span>
          <span data-ttu-id="af268-680">Questa proprietà non è pertinente se l'elemento non è stato creato con un modello.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-680">This property is not relevant if the element was not created through a template.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-681">L'elemento il cui <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> ha causato questo elemento deve essere creato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-681">The element whose <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> caused this element to be created.</span>
          </span>
          <span data-ttu-id="af268-682">Questo valore è spesso <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-682">This value is frequently <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-683">I modelli sono oggetti condivisi in realtà, in cui il contenuto del modello viene creato una sola volta.</span><span class="sxs-lookup"><span data-stu-id="af268-683">Templates are actually shared objects, where the contents of the template are created only once.</span></span> <span data-ttu-id="af268-684">Pertanto, se si ottiene un riferimento all'oggetto a un elemento che proviene da un modello, è possibile che l'albero logico evidente non raggiunge la radice della pagina.</span><span class="sxs-lookup"><span data-stu-id="af268-684">Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</span></span> <span data-ttu-id="af268-685">Per connettersi a tale riferimento del modello alla struttura ad albero logica della pagina, è necessario ottenere il <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> valore e continuare a esplorare tale albero degli elementi in base alle esigenze.</span><span class="sxs-lookup"><span data-stu-id="af268-685">In order to connect such a template reference to the page's logical tree, you should get the <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> value and continue to navigate that element tree as desired.</span></span>  
  
 <span data-ttu-id="af268-686"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> sarà spesso costituita da `null` per oggetti comuni, perché se è stato ottenuto un riferimento all'oggetto dall'esterno di una pagina nell'applicazione tramite gli strumenti standard, è probabile quell'elemento non sia stato creato da un modello.</span><span class="sxs-lookup"><span data-stu-id="af268-686"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> will frequently be `null` for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</span></span> <span data-ttu-id="af268-687">Casi in cui <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> potrebbe non essere `null` includono operazioni quali eventi hit testing, la gestione di determinati eventi di input a basso livello, o l'utilizzo enumeratori che potrebbero essere restituiti gli elementi creati da modelli.</span><span class="sxs-lookup"><span data-stu-id="af268-687">Cases where <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> might not be `null` would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-688">Ottiene o imposta l'oggetto della descrizione comandi visualizzato per questo elemento nell'[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-688">Gets or sets the tool-tip object that is displayed for this element in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="af268-689">Oggetto della descrizione comandi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-689">The tooltip object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-690">Se il valore di questa proprietà è di tipo <xref:System.Windows.Controls.ToolTip>, quindi è la descrizione che verrà usata nel [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="af268-690">If the value of this property is of type <xref:System.Windows.Controls.ToolTip>, then that is the tool-tip that will be used in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  <span data-ttu-id="af268-691">Se il valore è di altro tipo, quindi tale valore verrà utilizzato come il *contenuto* per un <xref:System.Windows.Controls.ToolTip> specificato (costruito) dal sistema.</span><span class="sxs-lookup"><span data-stu-id="af268-691">If the value is of any other type, then that value will be used as the *content* for a <xref:System.Windows.Controls.ToolTip> provided (constructed) by the system.</span></span> <span data-ttu-id="af268-692">Per altre informazioni, vedere <xref:System.Windows.Controls.ToolTipService>.</span><span class="sxs-lookup"><span data-stu-id="af268-692">For more information see <xref:System.Windows.Controls.ToolTipService>.</span></span> <span data-ttu-id="af268-693">La classe di servizio fornisce le proprietà associate che possono essere utilizzate per personalizzare ulteriormente una descrizione comandi.</span><span class="sxs-lookup"><span data-stu-id="af268-693">The service class provides attached properties that can be used to further customize a tool-tip.</span></span>  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="af268-694">Uso della sintassi XAML per gli attributi</span><span class="sxs-lookup"><span data-stu-id="af268-694">XAML Attribute Usage</span></span>  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="af268-695">Utilizzo della sintassi XAML per elementi proprietà</span><span class="sxs-lookup"><span data-stu-id="af268-695">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a><span data-ttu-id="af268-696">Valori XAML</span><span class="sxs-lookup"><span data-stu-id="af268-696">XAML Values</span></span>  
 <span data-ttu-id="af268-697">*toolTipContent*</span><span class="sxs-lookup"><span data-stu-id="af268-697">*toolTipContent*</span></span>  
 <span data-ttu-id="af268-698">Stringa che entra il testo visualizzato per il <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span><span class="sxs-lookup"><span data-stu-id="af268-698">A string that becomes the display text for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span></span>  
  
 <span data-ttu-id="af268-699">*toolTipObjectContent*</span><span class="sxs-lookup"><span data-stu-id="af268-699">*toolTipObjectContent*</span></span>  
 <span data-ttu-id="af268-700">Un oggetto, specificato nel formato dell'elemento oggetto, che deve essere utilizzato come il contenuto per il <xref:System.Windows.FrameworkContentElement> .</span><span class="sxs-lookup"><span data-stu-id="af268-700">Some object, provided in object element form, that should be used as the content for the <xref:System.Windows.FrameworkContentElement> .</span></span> <span data-ttu-id="af268-701">In genere il risultato sarà un <xref:System.Windows.FrameworkElement> o un altro elemento che crea la composizione di layout per il <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, alla fine che contiene il contenuto di testo all'interno della composizione.</span><span class="sxs-lookup"><span data-stu-id="af268-701">Typically this would be a <xref:System.Windows.FrameworkElement> or some other element that creates layout compositing for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, eventually containing text content within the compositing.</span></span> <span data-ttu-id="af268-702">In questo caso, il <xref:System.Windows.Controls.ToolTip> elemento creato in modo implicito da analizzata [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]e il *toolTipObjectContent* content è impostato come relativo <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="af268-702">In this usage, the <xref:System.Windows.Controls.ToolTip> element is created implicitly from the parsed [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], and the *toolTipObjectContent* content is set as its <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="af268-703"><`ToolTip` .../></span><span class="sxs-lookup"><span data-stu-id="af268-703"><`ToolTip` .../></span></span>  
 <span data-ttu-id="af268-704">Vedere <xref:System.Windows.Controls.ToolTip>.</span><span class="sxs-lookup"><span data-stu-id="af268-704">See <xref:System.Windows.Controls.ToolTip>.</span></span>  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="af268-705">Informazioni proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="af268-705">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-706">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-706">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|<span data-ttu-id="af268-707">Impostare le proprietà dei metadati `true`</span><span class="sxs-lookup"><span data-stu-id="af268-707">Metadata properties set to `true`</span></span>|<span data-ttu-id="af268-708">nessuno</span><span class="sxs-lookup"><span data-stu-id="af268-708">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="af268-709">Nell'esempio seguente imposta il valore della <xref:System.Windows.FrameworkElement.ToolTip%2A> proprietà direttamente a una stringa.</span><span class="sxs-lookup"><span data-stu-id="af268-709">The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.</span></span>  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-710">Si verifica subito prima che venga chiusa una descrizione comandi relativa all'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-710">Occurs just before any tooltip on the element is closed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-711">Per evitare la chiusura della descrizione comandi, i gestori dell'evento che venga contrassegnato come gestito.</span><span class="sxs-lookup"><span data-stu-id="af268-711">To suppress closing the tooltip, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="af268-712">Questo evento non può essere un <xref:System.Windows.EventTrigger> in uno stile.</span><span class="sxs-lookup"><span data-stu-id="af268-712">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="af268-713">Questo avviene perché il campo dell'identificatore di questo evento viene nuovamente utilizzata un'implementazione da un servizio che espone i metodi di aggiunta/rimozione dell'evento.</span><span class="sxs-lookup"><span data-stu-id="af268-713">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="af268-714">Informazioni evento indirizzato</span><span class="sxs-lookup"><span data-stu-id="af268-714">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-715">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-715">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|<span data-ttu-id="af268-716">Strategia di routing</span><span class="sxs-lookup"><span data-stu-id="af268-716">Routing strategy</span></span>|<span data-ttu-id="af268-717">Direct</span><span class="sxs-lookup"><span data-stu-id="af268-717">Direct</span></span>|  
|<span data-ttu-id="af268-718">delegato</span><span class="sxs-lookup"><span data-stu-id="af268-718">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-719">Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-719">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-720">Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="af268-720">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="af268-721">Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.</span><span class="sxs-lookup"><span data-stu-id="af268-721">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-722">Si verifica all'apertura di qualsiasi descrizione per l'elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-722">Occurs when any tooltip on the element is opened.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-723">Per aprire manualmente le descrizioni comandi, i gestori degli eventi devono contrassegnare l'evento rilevante come gestito.</span><span class="sxs-lookup"><span data-stu-id="af268-723">To manually open tooltips, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="af268-724">In caso contrario, il valore della <xref:System.Windows.FrameworkContentElement.ToolTip%2A> proprietà verrà utilizzata per aprire automaticamente un menu di scelta rapida.</span><span class="sxs-lookup"><span data-stu-id="af268-724">Otherwise, the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="af268-725">Contrassegnare l'evento come gestito in modo efficace annullerà l'azione predefinita e può essere un'opportunità per reimpostare il valore dei <xref:System.Windows.FrameworkContentElement.ToolTip%2A> proprietà e quindi aprire il nuovo <xref:System.Windows.Controls.ContextMenu>.</span><span class="sxs-lookup"><span data-stu-id="af268-725">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="af268-726">Si noti che questo evento non verrà generato se <xref:System.Windows.FrameworkContentElement.ToolTip%2A> è un riferimento null o in caso contrario, non impostato.</span><span class="sxs-lookup"><span data-stu-id="af268-726">Note that this event will not be raised if <xref:System.Windows.FrameworkContentElement.ToolTip%2A> is a null reference or otherwise unset.</span></span>  
  
 <span data-ttu-id="af268-727">Questo evento non può essere un <xref:System.Windows.EventTrigger> in uno stile.</span><span class="sxs-lookup"><span data-stu-id="af268-727">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="af268-728">Questo avviene perché il campo dell'identificatore di questo evento viene nuovamente utilizzata un'implementazione da un servizio che espone i metodi di aggiunta/rimozione dell'evento.</span><span class="sxs-lookup"><span data-stu-id="af268-728">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="af268-729">Informazioni evento indirizzato</span><span class="sxs-lookup"><span data-stu-id="af268-729">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-730">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-730">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|<span data-ttu-id="af268-731">Strategia di routing</span><span class="sxs-lookup"><span data-stu-id="af268-731">Routing strategy</span></span>|<span data-ttu-id="af268-732">Direct</span><span class="sxs-lookup"><span data-stu-id="af268-732">Direct</span></span>|  
|<span data-ttu-id="af268-733">delegato</span><span class="sxs-lookup"><span data-stu-id="af268-733">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-734">Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-734">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-735">Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="af268-735">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="af268-736">Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.</span><span class="sxs-lookup"><span data-stu-id="af268-736">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-737">Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.ToolTip" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-737">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">
          <span data-ttu-id="af268-738">Identificatore della chiave della risorsa da trovare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-738">Key identifier of the resource to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-739">Cerca una risorsa con la chiave specificata e restituisce tale risorsa, se trovata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-739">Searches for a resource with the specified key, and returns that resource if found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="af268-740">Risorsa trovata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-740">The found resource.</span>
          </span>
          <span data-ttu-id="af268-741">Se non viene trovata alcuna risorsa, viene restituito <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-741">If no resource was found, <see langword="null" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-742">Se la risorsa non viene trovata nell'elemento di chiamata, viene eseguita la ricerca nella struttura ad albero padre usando l'albero logico, nello stesso modo che la struttura ad albero sarebbe cercati se un riferimento di risorsa dinamica sono stati richiesti da chiave in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="af268-742">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="af268-743">In genere si esegue immediatamente il cast del valore restituito al tipo della proprietà che si stava tentando di impostare con il valore di risorsa restituita.</span><span class="sxs-lookup"><span data-stu-id="af268-743">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
 <span data-ttu-id="af268-744">Il <xref:System.Windows.FrameworkContentElement.FindResource%2A> metodo presenta un comportamento simile, ad eccezione del fatto che verrà generata un'eccezione nel caso non viene trovata una risorsa con la chiave fornita.</span><span class="sxs-lookup"><span data-stu-id="af268-744">The <xref:System.Windows.FrameworkContentElement.FindResource%2A> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="af268-745">Nell'esempio seguente viene trovata una risorsa definita nel markup e lo applica a una determinata proprietà di un elemento in risposta a un evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="af268-745">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-746">Si verifica quando l'elemento viene rimosso da una struttura ad albero di elementi caricati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-746">Occurs when the element is removed from an element tree of loaded elements.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-747">Gli eventi indirizzati diretti non seguono una route, ma vengono gestiti solo all'interno dell'elemento stesso in cui vengono generati.</span><span class="sxs-lookup"><span data-stu-id="af268-747">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="af268-748">Indirizzare gli eventi indirizzati supportano altri comportamenti di eventi indirizzati: supportano una raccolta di gestori accessibile e può essere utilizzati come un <xref:System.Windows.EventTrigger> in uno stile.</span><span class="sxs-lookup"><span data-stu-id="af268-748">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="af268-749">Informazioni evento indirizzato</span><span class="sxs-lookup"><span data-stu-id="af268-749">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="af268-750">Campo dell'identificatore</span><span class="sxs-lookup"><span data-stu-id="af268-750">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|<span data-ttu-id="af268-751">Strategia di routing</span><span class="sxs-lookup"><span data-stu-id="af268-751">Routing strategy</span></span>|<span data-ttu-id="af268-752">Direct</span><span class="sxs-lookup"><span data-stu-id="af268-752">Direct</span></span>|  
|<span data-ttu-id="af268-753">delegato</span><span class="sxs-lookup"><span data-stu-id="af268-753">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="af268-754">Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.Unloaded" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-754">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-755">Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="af268-755">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="af268-756">Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.</span><span class="sxs-lookup"><span data-stu-id="af268-756">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="af268-757">Nome della coppia nome-oggetto da rimuovere dall'ambito corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-757">Name of the name-object pair to remove from the current scope.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="af268-758">Semplifica l'accesso al metodo di annullamento della registrazione <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-758">Simplifies access to the <see cref="T:System.Windows.NameScope" /> de-registration method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="af268-759">È necessario solo per i nomi di annullare la registrazione se si prevede di registrare nuovamente un altro elemento con lo stesso nome.</span><span class="sxs-lookup"><span data-stu-id="af268-759">You only need to un-register names if you intend to re-register another element with that same name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="af268-760">Riapplica lo stile predefinito al controllo <see cref="T:System.Windows.FrameworkContentElement" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="af268-760">Reapplies the default style to the current <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>