<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fa112b67988d89807201b31758464c713a866c6b" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48607808" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see cref="T:System.Windows.FrameworkContentElement" /> è l'implementazione e l'espansione a livello di framework WPF della classe base <see cref="T:System.Windows.ContentElement" />. <see cref="T:System.Windows.FrameworkContentElement" /> aggiunge supporto per API di input aggiuntive (inclusi descrizioni comando e menu contestuali), storyboard, contesto dei dati per il data binding, supporto per gli stili e API di supporto dell'albero logico.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> non definisce il proprio comportamento di rendering. creare un'istanza di un vero e proprio <xref:System.Windows.FrameworkContentElement> istanza di classe nel codice o markup è possibile ma non visualizzerà niente in un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] applicazione [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Rendering per la logica deve essere fornita dalle classi che accettano <xref:System.Windows.FrameworkContentElement> gli elementi figlio nell'ambito del proprio modello di contenuto, oppure in <xref:System.Windows.FrameworkContentElement> classi derivate.  
  
 <xref:System.Windows.FrameworkContentElement> paralleli molte delle stesse [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] come <xref:System.Windows.FrameworkElement>. Si noti che alcuni [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] TransportCredentialOnly <xref:System.Windows.FrameworkElement> non avranno un <xref:System.Windows.FrameworkContentElement> equivalente. Numerosi il <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] sono per la funzionalità, ad esempio la rappresentazione di geometria o di layout, che non sono rilevanti per un <xref:System.Windows.FrameworkContentElement>.  
  
 La maggior parte delle esistente <xref:System.Windows.FrameworkContentElement> si trova in classi derivate i <xref:System.Windows.Documents> dello spazio dei nomi. Molte di queste classi derivate implementano gli elementi per il modello di documento dinamico. Alcune classi derivate, ad esempio <xref:System.Windows.Documents.Hyperlink> dispongono di funzionalità simili, ma sono derivati da <xref:System.Windows.FrameworkContentElement> in modo che gli elementi simili possono comunque partecipare il modello di documento dinamico.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Elemento figlio da aggiungere.</param>
        <summary>Aggiunge l'elemento specificato come figlio dell'elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può generare un'eccezione se viene chiamato quando l'albero logico è in fase di iterazione da un altro processo.  
  
 La maggior parte delle <xref:System.Windows.FrameworkContentElement> alle classi derivate espongono raccolte dedicate che sono responsabili di contenimento (ad esempio, <xref:System.Windows.Documents.Span.Inlines%2A> nel <xref:System.Windows.Documents.Span> classe; <xref:System.Windows.Documents.Section.Blocks%2A> sul <xref:System.Windows.Documents.Section> classe). In genere è possibile evitare qualsiasi esigenza di modificare direttamente l'albero logico se esegue la derivazione da queste classi. Utilizzo dell'albero logico per gli elementi di contenuto è uno scenario avanzato che potrebbe richiedere un parser specializzato o specializzata <xref:System.Windows.FrameworkElement> che funge da elemento padre per il rendering (host di contenuto).  
  
 Per altre informazioni su come usare <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> e <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, vedere [strutture ad albero in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiamato prima che un elemento venga inizializzato.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Eseguire l'override di questo metodo per fornire una gestione speciale che deve verificarsi prima che l'elemento viene inizializzato durante il processo di caricamento dell'elemento.  
  
L'implementazione deve chiamare l'implementazione di base, perché l'implementazione di base (valore predefinito) imposta alcuni flag interno per tenere traccia di inizializzazione.  
  
L'implementazione di base genererà un'eccezione se <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> viene chiamato più volte sullo stesso elemento prima di essere <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizia la sequenza di azioni contenuta nello storyboard fornito.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Storyboard da avviare.</param>
        <summary>Inizia la sequenza di azioni contenuta nello storyboard fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le firme che non usano i `isControllable`, parametro, o quando viene specificato questo parametro `false`, gli orologi di sequenza temporale associati dell'animazione vengono rimossi, non appena raggiunge il periodo di "Fill". Pertanto l'animazione non può essere riavviata dopo essere stata eseguita una sola volta. Si noti che anche controllo di un'animazione richiede che lo storyboard deve essere denominato o accessibile come un'istanza nel codice.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Storyboard da avviare.</param>
        <param name="handoffBehavior">Valore dell'enumerazione che descrive il comportamento da utilizzare se una proprietà descritta nello storyboard è già animata.</param>
        <summary>Inizia la sequenza di azioni contenuta nello storyboard fornito, specificando le opzioni relative alle azioni che dovrebbero verificarsi se la proprietà è già animata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le firme che non usano i `isControllable`, parametro, o quando viene specificato questo parametro `false`, gli orologi di sequenza temporale associati dell'animazione vengono rimossi, non appena raggiunge il periodo di "Fill". Pertanto l'animazione non può essere riavviata dopo essere stata eseguita una sola volta. Si noti che anche controllo di un'animazione richiede che lo storyboard deve essere denominato o accessibile come un'istanza nel codice.  
  
## <a name="using-the-compose-handoffbehavior"></a>Utilizzo di Compose HandoffBehavior  
 Quando si applica una <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una proprietà utilizzando la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualsiasi <xref:System.Windows.Media.Animation.Clock> oggetti associati in precedenza a tale proprietà continueranno a utilizzare le risorse di sistema; il sistema di temporizzazione non non rimuovere automaticamente gli orologi.  
  
 Per evitare problemi di prestazioni quando si applica un numero elevato di orologi usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, è necessario rimuovere gli orologi di composizione dalla proprietà animata una volta completati. Esistono diversi modi per rimuovere un orologio:  
  
-   Per rimuovere tutti gli orologi da una proprietà, usare il <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metodo dell'oggetto animato. Specificare la proprietà animata come primo parametro, e `null` come il secondo. Questo rimuove tutti gli orologi di animazione la proprietà.  
  
-   Per rimuovere uno specifico <xref:System.Windows.Media.Animation.AnimationClock> da un elenco di orologi, usare il <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà delle <xref:System.Windows.Media.Animation.AnimationClock> per recuperare un <xref:System.Windows.Media.Animation.ClockController>, quindi chiamare il <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodo del <xref:System.Windows.Media.Animation.ClockController>. Ciò avviene in genere il <xref:System.Windows.Media.Animation.Clock.Completed> gestore eventi per un orologio. Si noti che solo gli orologi di radice possono essere controllati da un <xref:System.Windows.Media.Animation.ClockController>; la <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà di un orologio figlio restituirà `null`. Si noti inoltre che il <xref:System.Windows.Media.Animation.Clock.Completed> evento non viene generato se la durata effettiva dell'orologio è infinita.  In tal caso, l'utente deve determinare quando chiamare <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Si tratta principalmente di un problema relativo alle animazioni su oggetti di lunga durata.  Quando un oggetto viene sottoposto a garbage collection, gli orologi vengono disconnessi anche e sottoposti a garbage collection.  
  
 Per altre informazioni sugli oggetti orologio, vedere [Panoramica sistema di temporizzazione e animazione](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Storyboard da avviare.</param>
        <param name="handoffBehavior">Valore dell'enumerazione che descrive il comportamento da usare se una proprietà descritta nello storyboard è già animata.</param>
        <param name="isControllable">Dichiara se l'animazione è controllabile (può essere sospesa) dopo l'avvio.</param>
        <summary>Inizia la sequenza di azioni contenute nello storyboard fornito, specificando lo stato per il controllo dell'animazione dopo l'avvio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le firme che non usano i `isControllable`, parametro, o quando viene specificato questo parametro `false`, gli orologi di sequenza temporale associati dell'animazione vengono rimossi, non appena raggiunge il periodo di "Fill". Pertanto l'animazione non può essere riavviata dopo essere stata eseguita una sola volta. Si noti che anche controllo di un'animazione richiede che lo storyboard deve essere denominato o accessibile come un'istanza nel codice.  
  
## <a name="using-the-compose-handoffbehavior"></a>Utilizzo di Compose HandoffBehavior  
 Quando si applica una <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una proprietà utilizzando la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualsiasi <xref:System.Windows.Media.Animation.Clock> oggetti associati in precedenza a tale proprietà continueranno a utilizzare le risorse di sistema; il sistema di temporizzazione non non rimuovere automaticamente questi orologi.  
  
 Per evitare problemi di prestazioni quando si applica un numero elevato di orologi usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, è necessario rimuovere gli orologi di composizione dalla proprietà animata una volta completati. Esistono diversi modi per rimuovere un orologio:  
  
-   Per rimuovere tutti gli orologi da una proprietà, usare il <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> metodo dell'oggetto animato. Specificare la proprietà animata come primo parametro, e `null` come il secondo. Questo rimuove tutti gli orologi di animazione la proprietà.  
  
-   Per rimuovere uno specifico <xref:System.Windows.Media.Animation.AnimationClock> da un elenco di orologi, usare il <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà delle <xref:System.Windows.Media.Animation.AnimationClock> per recuperare un <xref:System.Windows.Media.Animation.ClockController>, quindi chiamare il <xref:System.Windows.Media.Animation.ClockController.Remove%2A> metodo del <xref:System.Windows.Media.Animation.ClockController>. Ciò avviene in genere il <xref:System.Windows.Media.Animation.Clock.Completed> gestore eventi per un orologio. Si noti che solo gli orologi di radice possono essere controllati da un <xref:System.Windows.Media.Animation.ClockController>; la <xref:System.Windows.Media.Animation.Clock.Controller%2A> proprietà di un orologio figlio restituirà `null`. Si noti inoltre che il <xref:System.Windows.Media.Animation.Clock.Completed> evento non viene generato se la durata effettiva dell'orologio è infinita.  In tal caso, l'utente deve determinare quando chiamare <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Si tratta principalmente di un problema relativo alle animazioni su oggetti di lunga durata.  Quando un oggetto viene sottoposto a garbage collection, gli orologi vengono disconnessi anche e sottoposti a garbage collection.  
  
 Per altre informazioni sugli oggetti orologio, vedere [Panoramica sistema di temporizzazione e animazione](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Data.BindingGroup" /> utilizzato per l'elemento.</summary>
        <value>Oggetto <see cref="T:System.Windows.Data.BindingGroup" /> utilizzato per l'elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Data.BindingGroup> può essere utilizzato per convalidare i valori delle proprietà più di un oggetto. Ad esempio, si supponga che un'applicazione richiede all'utente di immettere un indirizzo e quindi popola un oggetto di tipo `Address`, che presenta le proprietà `Street`, `City`, `ZipCode`, e `Country`, con i valori che l'utente fornito. L'applicazione dispone di un pannello che contiene quattro <xref:System.Windows.Controls.TextBox> controlli, ognuno dei quali è associato a una delle proprietà dell'oggetto. È possibile usare una <xref:System.Windows.Controls.ValidationRule> in un <xref:System.Windows.Data.BindingGroup> convalidare il `Address` oggetto. Ad esempio, il <xref:System.Windows.Controls.ValidationRule> può verificare che il codice postale zip sia valido per il paese dell'indirizzo.  
  
 Gli elementi figlio ereditano il <xref:System.Windows.Data.BindingGroup> dagli elementi padre, proprio come per qualsiasi altra proprietà ereditabile.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|Impostare le proprietà dei metadati **true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tenta di visualizzare questo elemento all'interno di qualsiasi area di scorrimento che lo contiene.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamando questo metodo, verrà chiamato effettivamente <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> in qualsiasi area di scorrevole padre che contiene l'elemento (l'elemento padre potrebbe essere un <xref:System.Windows.FrameworkElement>, non un <xref:System.Windows.FrameworkContentElement>). Se questo elemento non è contenuto in un'area scorrevole, l'evento viene generato ugualmente, ma non vi sarà alcun effetto.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">Procedura: creare un elemento ScrollViewer</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'elemento menu di scelta rapida che deve essere visualizzato ogni volta che il menu di scelta rapida viene richiesto dall'interno di questo elemento tramite l'[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Menu di scelta rapida utilizzato da questo elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 L'esempio seguente viene inserito un <xref:System.Windows.Controls.ContextMenu> su un <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica subito prima che venga chiuso un menu di scelta rapida relativo all'elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per evitare la chiusura menu di scelta rapida, i gestori dell'evento che venga contrassegnato come gestito.  
  
 Per utilizzare questo evento come un <xref:System.Windows.EventTrigger> in uno stile, è necessario fare riferimento all'identificatore dell'evento servizio sottostante:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Questo utilizzo è obbligatorio poiché l'implementazione di eventi in <xref:System.Windows.FrameworkContentElement> che espone l'evento servizio sottostante non esegue correttamente il mapping di <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identificatore da utilizzare in trigger).  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informazioni evento indirizzato  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|Strategia di routing|Bubbling|  
|delegato|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 L'esempio seguente implementa un gestore che modifica il cursore su un'area denominata `DisplayArea` (non illustrato). Il commento suggerisce una <xref:System.Windows.UIElement> sull'utilizzo, ma in realtà in questo esempio è identico se `DisplayArea` erano un <xref:System.Windows.FrameworkContentElement>.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene aperto un menu di scelta rapida relativo all'elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per aprire manualmente menu di scelta rapida, i gestori degli eventi devono contrassegnare l'evento rilevante come gestito. In caso contrario, il valore esistente del <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> proprietà verrà utilizzata per aprire automaticamente un menu di scelta rapida. Contrassegnare l'evento come gestito in modo efficace annullerà l'azione predefinita e può essere un'opportunità per reimpostare il valore dei <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> proprietà e quindi aprire il nuovo <xref:System.Windows.Controls.ContextMenu>. Tuttavia, vi è un problema di temporizzazione di che è necessario essere consapevoli. Per sostituire completamente il menu di scelta rapida attraverso un <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> gestore, i menu di scelta rapida iniziale non deve essere null / vuoto. In alternativa, potrebbe essere necessario gestire l'evento e quindi aprire manualmente un nuovo menu di scelta rapida. Per informazioni dettagliate, vedere [procedura: gestire l'evento ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Per utilizzare questo evento come un <xref:System.Windows.EventTrigger> in uno stile, è necessario fare riferimento all'identificatore dell'evento servizio sottostante:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Questo utilizzo è obbligatorio poiché l'implementazione di eventi in <xref:System.Windows.FrameworkContentElement> che espone l'evento servizio sottostante non esegue correttamente il mapping di <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identificatore da utilizzare in trigger).  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informazioni evento indirizzato  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|Strategia di routing|Bubbling|  
|delegato|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o imposta il cursore visualizzato quando il puntatore del mouse è posizionato sull'elemento.</summary>
        <value>Cursore da visualizzare. Il valore predefinito è definito come <see langword="null" /> in base a questa proprietà di dipendenza. Tuttavia, l'impostazione predefinita pratica in fase di esecuzione dipenderà da numerosi fattori.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si imposta questa proprietà [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], il [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processore si basa sulla conversione del tipo per il <xref:System.Windows.Input.Cursor> classe per valutare la stringa. La stringa fornita deve restituire un <xref:System.Windows.Input.CursorType> valore. Per informazioni dettagliate, vedere <xref:System.Windows.Input.Cursor>.  
  
 Se il cursore definito da questa proprietà sarà o non venga visualizzato quando il puntatore del mouse è sopra questo elemento dipende anche il valore della <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> proprietà. Inoltre, considerazioni relative a eventi, ad esempio un trascinamento attivo, stato mouse capture, all'interno di controlli e così via, modalità di modifica del testo influirà anche il cursore con priorità più alta rispetto al valore specificato in questa proprietà.  
  
 Per ripristinare il comportamento dell'impostazione di questa proprietà sul valore predefinito finale, impostarla su `null` nuovamente.  
  
 Il `null` predefinito in realtà indica che la definizione del valore del cursore pratico è rinviata qui e deve essere ottenuta da un' posizione. Se viene visualizzata senza valori a livello di codice da qualsiasi origine, il cursore predefinito su un [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] applicazione sarà una freccia.  
  
 Ogni movimento del mouse su un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] applicazione genera un <xref:System.Windows.ContentElement.QueryCursor> evento. Le bolle di eventi e qualsiasi altro elemento lungo la route ha la possibilità di gestire l'evento e di impostare il valore del cursore tramite gli argomenti dell'evento. In tal caso, il fatto che l'evento è gestito e ha un valore modificato negli argomenti di ha la precedenza sul valore della <xref:System.Windows.FrameworkContentElement.Cursor%2A> proprietà in qualsiasi livello, a meno che non <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> è impostata.  
  
 Se non viene creato un cursore personalizzato, in genere impostare questa proprietà su un valore della proprietà statica il <xref:System.Windows.Input.Cursors> classe.  
  
 L'impostazione di <xref:System.Windows.Input.Cursor> su un valore personalizzato non è abilitato in attendibilità parziale. Per altre informazioni sui cursori personalizzati, vedere [Cenni preliminari sull'Input](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente imposta il cursore su un valore personalizzato.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.Cursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il contesto dei dati per un elemento quando partecipa al data binding.</summary>
        <value>Oggetto da usare come contesto dei dati.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Contesto dati* è un concetto che consente agli elementi di ereditare informazioni dagli elementi padre sull'origine del binding che viene usato per associazione, nonché altre caratteristiche dell'associazione, ad esempio il percorso.  
  
 Contesto dei dati può essere impostata direttamente su un [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] oggetto, con le associazioni che restituiscono le proprietà di quell'oggetto. In alternativa, è possibile impostare il contesto dei dati un <xref:System.Windows.Data.DataSourceProvider> oggetto.  
  
 Questa proprietà di dipendenza eredita i valori delle proprietà. Se sono presenti gli elementi figlio con nessun altro valore per <xref:System.Windows.FrameworkContentElement.DataContext%2A> stabilita tramite i valori locali o gli stili, il sistema di proprietà verrà impostato il valore sarà il <xref:System.Windows.FrameworkContentElement.DataContext%2A> valore dell'elemento padre più vicino con questo valore viene assegnato.  
  
 In alternativa, è possibile usare una delle seguenti proprietà del <xref:System.Windows.Data.Binding> classe per specificare l'origine del binding in modo esplicito: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, o <xref:System.Windows.Data.Binding.RelativeSource%2A>. Per altre informazioni, vedere [procedura: specificare l'origine del Binding](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 Nelle [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> è impostato più di frequente come un <xref:System.Windows.Data.Binding> dichiarazione. È possibile usare la sintassi degli elementi di proprietà o la sintassi degli attributi. La sintassi degli attributi è illustrato nell'esempio in questa pagina. È anche possibile impostare <xref:System.Windows.FrameworkContentElement.DataContext%2A> nel codice.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Utilizzo della sintassi XAML per elementi proprietà  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *dataContextObject*  
 Un oggetto direttamente incorporato che viene usato come contesto dei dati per tutti i binding all'interno dell'elemento padre. In genere, questo oggetto è un <xref:System.Windows.Data.Binding> o un altro <xref:System.Windows.Data.BindingBase> sottoclasse. In alternativa, i dati non elaborati di qualsiasi [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] dell'oggetto di tipo designato per l'associazione può essere inserita in questo caso, con le associazioni effettive definite in un secondo momento.  
  
 *bindingUsage*  
 Utilizzo di associazione che restituisce un contesto di dati appropriato. Per informazioni dettagliate, vedere [Estensione di markup Binding](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *ResourceExtension*  
 Uno dei seguenti: `StaticResource`, o `DynamicResource`. Questo utilizzo viene utilizzato quando si fa riferimento ai dati non elaborati, definiti come un oggetto nelle risorse. Visualizzare [risorse XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 L'identificatore di chiave per l'oggetto richiesto dall'interno una <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Nell'esempio seguente imposta un'associazione in un <xref:System.Windows.Documents.Paragraph> elemento, creando un nuovo oggetto di dati personalizzati, stabilire tale oggetto come <xref:System.Windows.FrameworkContentElement.DataContext%2A>e impostare il percorso di associazione a una proprietà all'interno di esso.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando il contesto dati di questo elemento viene modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per una spiegazione dei contesti dei dati e il data binding, vedere [Panoramica sul Data Binding](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Quando un elemento <xref:System.Windows.FrameworkContentElement.DataContext%2A> potenzialmente interessate delle modifiche, tutte le proprietà con associazione a dati sull'elemento. Questo vale per tutti gli elementi che sono gli elementi discendenti dell'elemento corrente, che eredita il contesto di dati, e anche lo stesso elemento corrente. Tali associazioni reinterpretano nuovo <xref:System.Windows.FrameworkContentElement.DataContext%2A> in modo da riflettere il nuovo valore nelle associazioni. Non c'è garanzia sull'ordine di queste modifiche rispetto alla generazione del <xref:System.Windows.FrameworkContentElement.DataContextChanged> evento.  Le modifiche possono verificarsi prima dell'evento, dopo l'evento, o in qualsiasi combinazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la chiave da utilizzare per cercare il modello dello stile per questo controllo nei temi.</summary>
        <value>Chiave di stile. Affinché funzioni correttamente durante la ricerca dello stile del tema, questo valore deve essere l'oggetto <see cref="T:System.Type" /> dell'elemento a cui viene applicato lo stile. <see langword="null" /> è un valore accettato per un determinato caso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà non è in genere impostata tramite uno dei metodi di impostazione diretti. Al contrario, si esegue l'override i metadati specifici del tipo di questa proprietà di dipendenza ogni volta che si crea una nuova sottoclasse. Quando si crea una sottoclasse, chiamare il <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> metodo contro il <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identificatore, all'interno del costruttore statico della sottoclasse del controllo.  
  
 Ad esempio, una classe inline, ad esempio <xref:System.Windows.Documents.Bold> effettivamente ha pochissimo implementazione oltre a eseguire l'override di <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadati nel costruttore statico e l'esposizione di diversi costruttori di istanza. Il fatto che gli elementi racchiusi tra il <xref:System.Windows.Documents.Bold> miglioramento del tag un <xref:System.Windows.Documents.TextElement.FontWeight%2A> proprietà di <xref:System.Windows.FontWeights.Bold%2A> viene implementato nello stile del tema che viene fatto riferimento tramite l'impostazione predefinita pari a <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> a `typeof(Bold)`.  
  
 Se si desidera che l'elemento o controllo deliberatamente non utilizzino gli stili di tema, impostare il <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> proprietà `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiamato immediatamente dopo l'inizializzazione di un elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementare questo metodo per fornire una gestione speciale che deve verificarsi quando l'elemento viene inizializzato durante il processo di caricamento dell'elemento.  
  
 L'implementazione deve chiamare l'implementazione di base, perché l'implementazione di base (valore predefinito) imposta alcuni flag interno per tenere traccia di inizializzazione.  
  
 Se <xref:System.Windows.FrameworkContentElement.BeginInit%2A> è stato precedentemente chiamato, la base implementazione genererà il <xref:System.Windows.FrameworkContentElement.Initialized> evento. In caso contrario, se <xref:System.Windows.FrameworkContentElement.BeginInit%2A> non è stato chiamato o non è stato possibile determinare se <xref:System.Windows.FrameworkContentElement.BeginInit%2A> è stato chiamato, l'evento non viene generato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'elemento di cui eseguire la ricerca.</param>
        <summary>Trova un elemento con il nome dell'identificatore specificato.</summary>
        <returns>Elemento richiesto. Potrebbe essere <see langword="null" /> se non è stato trovato un elemento corrispondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo elemento contiene elementi figlio, tali elementi figlio sono tutti effettuata in modo ricorsivo per il nome di elemento richiesto.  
  
   
  
## Examples  
 L'esempio seguente imposta una proprietà su un elemento è stato trovato in base al nome all'interno di un riferimento <xref:System.Windows.Documents.FlowDocument> in una pagina.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identificatore della chiave della risorsa da trovare.</param>
        <summary>Cerca una risorsa con la chiave specificata e genera un'eccezione se la risorsa richiesta non viene trovata.</summary>
        <returns>La risorsa trovata oppure <see langword="null" /> se non viene trovata una risorsa corrispondente (ma genera anche un'eccezione se <see langword="null" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Se si chiama questo metodo per una chiave che non viene trovata, viene generata un'eccezione. Se non vuoi gestire le eccezioni per questo caso, è necessario chiamare invece <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>. <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> Restituisce `null` quando viene trovata alcuna risorsa e non viene generata un'eccezione.  
  
 Se la risorsa non viene trovata nell'elemento chiamante, la struttura ad albero padre viene eseguita la ricerca usando l'albero logico, nello stesso modo che la struttura ad albero sarebbe effettuata se la risorsa richiesti dalla chiave in fase di esecuzione.  
  
 In genere si esegue immediatamente il cast del valore restituito al tipo della proprietà che si stava tentando di impostare con il valore di risorsa restituita.  
  
   
  
## Examples  
 Nell'esempio seguente viene trovata una risorsa definita nel markup e lo applica a una determinata proprietà di un elemento in risposta a un evento indirizzato.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">La chiave della risorsa richiesta non è stata trovata.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto che consente la personalizzazione dell'aspetto, degli effetti o di altre caratteristiche di stile che si applicheranno a questo elemento quando acquisisce lo stato attivo della tastiera.</summary>
        <value>Stile desiderato da applicare allo stato attivo. Il valore predefinito dichiarato nella proprietà di dipendenza è un oggetto <see cref="T:System.Windows.Style" /> statico vuoto. Tuttavia, il valore effettivo in fase di esecuzione è spesso, ma non sempre, uno stile specificato dal supporto dei temi per i controlli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si imposta questa proprietà [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], gli stili sono quasi sempre definiti come una risorsa, anziché inline come un elemento e che risorse viene in genere indicata come una <xref:System.Windows.StaticResourceExtension>.  
  
 Si noti che questa proprietà influisce sull'aspetto visivo, ma non viene segnalato nei metadati. Infatti, la modifica dell'aspetto visivo è basato sugli eventi e potrebbe non essere applicabile in qualsiasi momento e pertanto non deve in genere segnalare qualsiasi informazione visivo o layout nei metadati.  
  
 Concettualmente, il comportamento visivo dello stato attivo applicati a un controllo deve essere coerente da un elemento per elemento. Il modo più appropriato per imporre la coerenza consiste nel modificare solo lo stile di visualizzazione dello stato attivo se si sta componendo un tema completo. Impostazione di questa proprietà su singoli stili e non come parte di un tema non è l'utilizzo previsto di questa proprietà, perché ciò potrebbe causare confusione nell'esperienza utente relativamente allo stato attivo. Se si stanno prendendo in considerazione il comportamento specifico dell'elemento che viene deliberatamente non coerente all'interno di un tema, un approccio migliore consiste usare trigger negli stili per le proprietà dello stato di input singolo, ad esempio <xref:System.Windows.UIElement.IsFocused%2A> o <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>e per eseguire questa operazione in modo che non sono presenti visivamente interferire con gli stili di visualizzazione dello stato attivo esistente. Per altre informazioni sugli scopi della progettazione del <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> e alternativi concentrare le proprietà, vedere [applicazione di stili per lo stato attivo nei controlli e FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Utilizzo della sintassi XAML per elementi proprietà  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *ResourceExtension*  
 Uno dei seguenti:, o. Visualizzare [risorse XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 La chiave che identifica lo stile della richiesta. La chiave fa riferimento a una risorsa esistente in un <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  La sintassi degli elementi è tecnicamente possibile, ma non è consigliata. Visualizzare [stili Inline e modelli](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Un riferimento dell'associazione usando o <xref:System.Windows.Data.Binding> è anche possibile, ma non comuni.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se l'oggetto <see cref="T:System.Windows.FrameworkContentElement" /> deve forzare l'[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] per il rendering del cursore dichiarato dalla proprietà <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> di questa istanza</summary>
        <value>
          <see langword="true" /> per forzare la presentazione del cursore mentre è posizionato su questo elemento a utilizzare le impostazioni di questa istanza per il cursore (inclusi tutti gli elementi figlio); in caso contrario <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostando questa proprietà su `true` sostituiranno le preferenze di cursore stabilite dagli elementi figlio. Tale operazione pertanto in generale dell'applicazione [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] potrebbe risultare poco chiaro per l'utente, in particolare se gli elementi figlio sono se si specificano i cursori. Impostazione <xref:System.Windows.FrameworkElement.ForceCursor%2A> più appropriato per scenari di creazione di una sottoclasse o la composizione del controllo.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente forza il cursore mentre è posizionato sull'elemento.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Oggetto <see cref="T:System.Windows.DependencyProperty" /> di destinazione dal quale ottenere l'associazione.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Windows.Data.BindingExpression" /> per l'associazione della proprietà specificata.</summary>
        <returns>Restituisce un oggetto <see cref="T:System.Windows.Data.BindingExpression" /> se la destinazione è associata a dati; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente recupera un'associazione eseguendo una query di una proprietà.  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un elemento padre logico alternativo per questo elemento se non esiste un elemento padre visuale. In questo caso, un elemento padre <see cref="T:System.Windows.FrameworkContentElement" /> ha sempre lo stesso valore della proprietà <see cref="P:System.Windows.FrameworkContentElement.Parent" />.</summary>
        <returns>Restituisce un valore diverso da <see langword="null" /> ogni volta che un'implementazione a livello di framework WPF di questo metodo presenta una connessione padre non visuale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implementazione predefinita restituisce l'elemento padre visivo single previsto. Le implementazioni personalizzate potrebbero restituire le relazioni padre / alternativo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene inizializzato l'oggetto <see cref="T:System.Windows.FrameworkContentElement" />. che coincide con i casi in cui il valore della proprietà <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> viene modificato da <see langword="false" /> (o non definito) a <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento verrà generato ogni volta che il <xref:System.Windows.FrameworkContentElement.EndInit%2A> o <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> metodi vengono chiamati. Chiamate a questi metodi è stato reso tramite codice intenzionale. exe o il [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] processo di caricamento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il contesto per l'input utilizzato dall'oggetto <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <value>Ambito di input, che modifica il modo in cui viene interpretato l'input proveniente da metodi di input alternativi. Il valore predefinito è <see langword="null" /> (che comporta la gestione predefinita dei comandi).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà di dipendenza eredita i valori delle proprietà. Se sono presenti gli elementi figlio con nessun altro valore per <xref:System.Windows.FrameworkElement.InputScope%2A> stabilita tramite i valori locali o gli stili, il sistema di proprietà verrà impostato il valore sarà il <xref:System.Windows.FrameworkElement.InputScope%2A> valore dell'elemento padre più vicino con questo valore viene assegnato.  
  
 Anche se un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] utilizzo della sintassi viene elencato e sintatticamente è consentito, l'impostazione di questa proprietà [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] non è comune.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.InputScope" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se questo elemento è stato inizializzato, mediante il caricamento come [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] oppure mediante la chiamata esplicita al metodo <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</summary>
        <value>
          <see langword="true" /> se l'elemento viene inizializzato in base al processo di caricamento descritto in precedenza o con chiamate al metodo; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà può anche essere `true` se questo elemento è stato spostato all'interno dell'albero degli elementi in modo che abbia un nuovo elemento padre e pertanto venga ricaricato nuovamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se questo elemento è stato caricato per la presentazione.</summary>
        <value>
          <see langword="true" /> se l'elemento corrente è associato a una struttura ad albero dell'elemento e ne è stato eseguito il rendering; <see langword="false" /> se l'elemento non è mai stato associato a una struttura ad albero dell'elemento caricata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da un'istanza appena costruita, questa proprietà inizia `false`e rimane `true` dopo che è impostato su `true`, anche se successivamente viene rimossa dal codice.  
  
   
  
## Examples  
 Il codice di esempio seguente usa <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> come controllo condizionale per assicurare che una funzione `displayData` (non mostrato) verranno dispone gli elementi validi caricato nella pagina da utilizzare, come parte di un gestore on demand. Che per la stessa logica viene eseguita come un gestore eventi per <xref:System.Windows.FrameworkContentElement.Loaded>.  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le informazioni relative alla lingua di localizzazione/globalizzazione che si applicano a un singolo elemento.</summary>
        <value>Informazioni relative alle impostazioni cultura per l'elemento. Il valore predefinito è l'istanza di un oggetto <see cref="T:System.Windows.Markup.XmlLanguage" /> con il valore <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> impostato sulla stringa "en-US".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I formati di stringa conforme allo standard RFC 3066. Ad esempio, Stati Uniti Inglese è "en-US". Vedere <xref:System.Windows.Markup.XmlLanguage> per altre informazioni su valori e formato.  
  
 Questa proprietà di dipendenza eredita i valori delle proprietà. Se sono presenti gli elementi figlio con nessun altro valore per <xref:System.Windows.FrameworkElement.Language%2A> stabilita tramite i valori locali o gli stili, il sistema di proprietà verrà impostato il valore sarà il <xref:System.Windows.FrameworkElement.Language%2A> valore dell'elemento padre più vicino con questo valore viene assegnato.  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.Language" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica al termine del layout e del rendering, quando l'elemento è pronto per l'interazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi indirizzati diretti non seguono una route, ma vengono gestiti solo all'interno dell'elemento stesso in cui vengono generati. Indirizzare gli eventi indirizzati supportano altri comportamenti di eventi indirizzati: supportano una raccolta di gestori accessibile e può essere utilizzati come un <xref:System.Windows.EventTrigger> in uno stile.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informazioni evento indirizzato  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|Strategia di routing|Direct|  
|delegato|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.Loaded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un enumeratore per gli elementi figlio logici di questo elemento.</summary>
        <value>Ottiene un enumeratore per gli elementi figlio logici di questo elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni su come usare <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> e <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, vedere [strutture ad albero in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Direzione dello spostamento dello stato attivo, sotto forma di valore dell'enumerazione.</param>
        <summary>Sposta lo stato attivo da questo elemento a un altro elemento.</summary>
        <returns>Restituisce <see langword="true" /> se lo stato attivo viene spostato correttamente; <see langword="false" /> se l'elemento di destinazione nella direzione specificata non esiste.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome identificativo dell'elemento. Il nome fornisce un riferimento a un'istanza che consenta al code-behind a livello di codice, ad esempio il codice del gestore eventi, di fare riferimento a un elemento dopo che questo è stato costruito durante l'analisi della sintassi [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</summary>
        <value>Nome dell'elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'uso più comune di questa proprietà è quando si specifica un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nome elemento nel markup.  
  
 Questa proprietà fornisce essenzialmente una proprietà di praticità a livello di framework WPF per impostare il [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [direttiva X:Name](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Recupero di un <xref:System.Windows.FrameworkContentElement.Name%2A> dal codice non è comune, poiché se si dispone già di riferimento appropriati nel codice, è possibile chiamare solo metodi e proprietà sull'elemento di riferimento e non li supportano in genere è necessario il <xref:System.Windows.FrameworkContentElement.Name%2A>. È un'eccezione se la stringa ha un significato aggiuntivo, ad esempio se è utile visualizzare tale nome nel [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Impostazione di un <xref:System.Windows.FrameworkContentElement.Name%2A> dal codice se originale <xref:System.Windows.FrameworkContentElement.Name%2A> è stato impostato dal markup inoltre non è consigliabile, e la modifica della proprietà non cambia il riferimento all'oggetto. Riferimenti a tali oggetti vengono creati solo quando i NameScope sottostanti vengono creati esplicitamente durante [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] il caricamento.  
  
 È necessario chiamare espressamente <xref:System.Windows.FrameworkContentElement.RegisterName%2A> per rendere effettiva una modifica nel <xref:System.Windows.FrameworkContentElement.Name%2A> proprietà di un elemento già caricato.  
  
 Un rilevanti caso in cui l'impostazione <xref:System.Windows.FrameworkContentElement.Name%2A> dal codice è importante è per la denominazione di elementi che storyboard verranno eseguite. Prima di poter registrare un nome, potrebbe essere necessario anche creare un'istanza e assegnare un <xref:System.Windows.NameScope> istanza. Vedere la sezione di esempio, oppure [Cenni preliminari sugli storyboard](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Impostazione <xref:System.Windows.FrameworkContentElement.Name%2A> dal codice con applicazioni limitate, ma ricerca di un elemento in base al nome è più comune, in particolare se si stanno utilizzando un modello di navigazione in cui le pagine vengono ricaricate all'applicazione e il codice in fase di esecuzione non è necessariamente il code-behind di tale pagina corrispondente. Il metodo di utilità <xref:System.Windows.FrameworkContentElement.FindName%2A>, disponibile da qualsiasi <xref:System.Windows.FrameworkContentElement>, può individuare qualsiasi elemento in base <xref:System.Windows.FrameworkContentElement.Name%2A> in modo ricorsivo albero logico dell'elemento. Oppure è possibile usare la <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> metodo statico dei <xref:System.Windows.LogicalTreeHelper>, che accetta anche il <xref:System.Windows.FrameworkContentElement.Name%2A> stringa come argomento.  
  
 In genere utilizzato elementi radice (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> ad esempio) implementano l'interfaccia <xref:System.Windows.Markup.INameScope>. Le implementazioni di questa interfaccia devono imporre che i nomi di essere non ambigua nel proprio ambito.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.Name" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Fornisce i dati sull'evento.</param>
        <summary>Richiamato ogni qualvolta l'evento indirizzato <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> raggiunge questa classe nella relativa route. Implementare questo metodo per aggiungere la gestione delle classi per questo evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo presenta alcuna implementazione predefinita. È comunque necessario chiamare l'implementazione di base nel caso in cui una classe intermedia nell'ereditarietà ha implementato questo metodo.  
  
 Lo scopo di questo metodo è un po' come [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] schema di eventi in * metodi: fornisce i mezzi per gestire l'evento corrispondente dalle classi derivate con un gestore della classe anziché un gestore di istanze. In questo caso l'evento corrispondente è un evento indirizzato. Il modello di implementazione dei metodi On * è diverso per gli eventi indirizzati, perché l'evento indirizzato può essere generato da un elemento figlio, non necessariamente l'elemento che richiama i gestori. Pertanto, l'implementazione dovrà prendere in considerazione le proprietà dell'origine degli argomenti di evento (e non deve tentare di generare nuovamente l'evento nella maggior parte dei casi). Le sottoclassi di <xref:System.Windows.FrameworkContentElement> può scegliere di chiamare metodi del gestore di classe privata quando viene ricevuto l'evento lungo la route. Uno scenario di potenziale prevede accettano gli argomenti dell'evento e deliberatamente contrassegnare l'evento come gestito per abbreviare la route.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento per l'evento.</param>
        <summary>Richiamato ogni qualvolta l'evento indirizzato <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> raggiunge questa classe nella relativa route. Implementare questo metodo per aggiungere la gestione delle classi per questo evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo presenta alcuna implementazione predefinita. È comunque necessario chiamare base () nel caso in cui una classe intermedia nell'ereditarietà ha implementato questo metodo.  
  
 Lo scopo di questo metodo è un po' come [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] schema di eventi in * metodi: fornisce i mezzi per gestire l'evento corrispondente dalle classi derivate con un gestore della classe anziché un gestore di istanze. In questo caso l'evento corrispondente è un evento indirizzato. Il modello di implementazione dei metodi On * è diverso per gli eventi indirizzati, perché l'evento indirizzato può essere generato da un elemento figlio, non necessariamente l'elemento che richiama i gestori, in modo che l'implementazione dovrà richiedere origine degli argomenti dell'evento le proprietà in considerazione (e non deve tentare di generare nuovamente l'evento nella maggior parte dei casi). Le sottoclassi di <xref:System.Windows.FrameworkContentElement> può scegliere di chiamare metodi del gestore di classe privata quando viene ricevuto l'evento lungo la route. Uno scenario di potenziale prevede accettano gli argomenti dell'evento e deliberatamente contrassegnare l'evento come gestito per abbreviare la route.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento per l'evento.</param>
        <summary>Gestore di classe per l'evento <see cref="E:System.Windows.ContentElement.GotFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo gestore della classe imposta il comportamento dello stato attivo appropriato su questo elemento se l'evento ha avuto origine da questo elemento. Se l'origine dell'evento è stato un altro elemento nell'albero, il gestore non esegue alcuna operazione.  
  
 Eseguire l'override di questo metodo per modificare il valore predefinito se ci fermiamo comportamento dell'elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento per l'evento.</param>
        <summary>Genera l'evento <see cref="E:System.Windows.FrameworkContentElement.Initialized" />. Questo metodo viene richiamato ogni volta che la proprietà <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> è impostata su <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implementazione predefinita di questo metodo virtuale genera l'evento come descritto in precedenza in questo argomento. Gli override devono chiamare base () per mantenere questo comportamento.  
  
 Si noti che il <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> proprietà è di sola lettura. Pertanto, è possibile impostarlo per forzare il comportamento di inizializzazione in questo modo. Impostazione di inizializzazione deve essere eseguita solo dal [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati dell'evento che descrivono la proprietà modificata, inclusi i valori vecchi e nuovi.</param>
        <summary>Richiamato ogni volta che il valore effettivo di una qualsiasi proprietà di dipendenza di questo oggetto <see cref="T:System.Windows.FrameworkContentElement" /> viene aggiornato. La proprietà di dipendenza specifica modificata viene indicata nel parametro degli argomenti. Esegue l'override di <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è in genere rileva le modifiche alle proprietà o le convalide. Invece è destinato alle modifiche del modello generale di invalidamento se sono noto che alcune informazioni sulle classificazioni a livello delle proprietà.  
  
 Questo metodo viene richiamato potenzialmente più volte nel corso della durata di un oggetto. Pertanto, è possibile ottenere prestazioni migliorate se esegue l'override di metadati di proprietà specifiche e quindi collegarli <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funzioni per le singole proprietà. Questo metodo, tuttavia, è consigliabile se un <xref:System.Windows.FrameworkContentElement> include un numero significativo di proprietà di dipendenza correlata al valore, o se ne include la logica, ad esempio il comportamento di rendering, che deve essere ripetuto per molti casi di convalide di proprietà correlati.  
  
 Si noti che vi sia un nome identico `OnPropertyChanged` metodo con una firma diversa (tipo di parametro non <xref:System.ComponentModel.PropertyChangedEventArgs>) che possono essere visualizzati in una serie di classi. Che `OnPropertyChanged` viene usato per le notifiche di oggetti dati e fa parte del contratto per <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Chiamare sempre l'implementazione di base, come prima operazione nell'implementazione. Errore eseguire questa operazione disabiliterà in modo significativo l'intera [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema di proprietà, che fa sì che valori non corretti da segnalare.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Stile precedente.</param>
        <param name="newStyle">Stile nuovo.</param>
        <summary>Richiamato quando lo stile utilizzato per questo elemento viene modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo ha un'implementazione predefinita che consente di impostare un flag interno notare la condizione di stile di visualizzazione modificato.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Chiamare sempre l'implementazione di base, in caso contrario, non è possibile applicare degli stili. Scenari per eseguire l'override di questo metodo potrebbero includere se la classe derivata dispone di un selettore di stile specializzata o memorizza nella cache i valori di stile. Modifiche al tema potenzialmente richiama questo metodo.</para>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Fornisce i dati sull'evento.</param>
        <summary>Richiamato ogni qualvolta l'evento indirizzato <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> raggiunge questa classe nella relativa route. Implementare questo metodo per aggiungere la gestione delle classi per questo evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo presenta alcuna implementazione predefinita. È comunque necessario chiamare base () nel caso in cui una classe intermedia nell'ereditarietà ha implementato questo metodo.  
  
 Lo scopo di questo metodo è un po' come [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] schema di eventi in * metodi: fornisce i mezzi per gestire l'evento corrispondente dalle classi derivate con un gestore della classe anziché un gestore di istanze. In questo caso l'evento corrispondente è un evento indirizzato. Il modello di implementazione dei metodi On * è diverso per gli eventi indirizzati, perché l'evento indirizzato può essere generato da un elemento figlio, non necessariamente l'elemento che richiama i gestori, in modo che l'implementazione dovrà richiedere origine degli argomenti dell'evento le proprietà in considerazione (e non deve tentare di generare nuovamente l'evento nella maggior parte dei casi). Le sottoclassi di <xref:System.Windows.FrameworkContentElement> può scegliere di chiamare metodi del gestore di classe privata quando viene ricevuto l'evento lungo la route. Uno scenario di potenziale prevede accettano gli argomenti dell'evento e deliberatamente contrassegnare l'evento come gestito per abbreviare la route.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Fornisce i dati sull'evento.</param>
        <summary>Richiamato ogni qualvolta l'evento indirizzato <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> raggiunge questa classe nella relativa route. Implementare questo metodo per aggiungere la gestione delle classi per questo evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo presenta alcuna implementazione predefinita. È comunque necessario chiamare base () nel caso in cui una classe intermedia nell'ereditarietà ha implementato questo metodo.  
  
 Lo scopo di questo metodo è un po' come [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] schema di eventi in * metodi: fornisce i mezzi per gestire l'evento corrispondente dalle classi derivate con un gestore della classe anziché un gestore di istanze. In questo caso l'evento corrispondente è un evento indirizzato. Il modello di implementazione dei metodi On * è diverso per gli eventi indirizzati, perché l'evento indirizzato può essere generato da un elemento figlio, non necessariamente l'elemento che richiama i gestori, in modo che l'implementazione dovrà eseguire origine degli argomenti dell'evento le proprietà in considerazione (e non deve tentare di generare nuovamente l'evento nella maggior parte dei casi). Le sottoclassi di <xref:System.Windows.FrameworkContentElement> può scegliere di chiamare metodi del gestore di classe privata quando viene ricevuto l'evento lungo la route. Uno scenario di potenziale prevede accettano gli argomenti dell'evento e deliberatamente contrassegnare l'evento come gestito per abbreviare la route.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se questo elemento incorpora le proprietà di stile dagli stili del tema.</summary>
        <value>
          <see langword="true" /> se questo elemento non utilizza le proprietà di stile del tema; tutte le proprietà che hanno origine dallo stile provengono dagli stili dell'applicazione locale e le proprietà di stile del tema non sono applicabili. <see langword="false" /> se vengono applicati prima gli stili dell'applicazione, quindi gli stili del tema per le proprietà non specificamente impostate negli stili dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'uso più comune di questa proprietà è un indiretto all'interno di setter di uno stile che include uno stile a tema.  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'elemento padre nell'albero logico per questo elemento.</summary>
        <value>Elemento padre logico di questo elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che l'elemento padre logico di un elemento può essere modificato a seconda delle funzionalità dell'applicazione, e mantenere il valore di questa proprietà non rifletterà le modifiche. È in genere deve ottenere il valore immediatamente prima che ti serve.  
  
 Visualizzare [strutture ad albero in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) per altre informazioni sull'attraversamento di strutture ad albero logiche e gli scenari in cui questo approccio nei confronti di individuare l'elemento è appropriato.  
  
 Il sistema di proprietà potrà ricalcolare tutti i valori di proprietà di un elemento quando viene riassociato come padre, perché alcune proprietà ereditano valori attraverso l'albero logico. Il <xref:System.Windows.FrameworkContentElement.DataContext%2A> che applica le associazioni possono essere modificato anche quando gli elementi vengono riassociate come elementi padre.  
  
 Modifica padre di un elemento viene in genere eseguita mediante manipolazione di raccolte, utilizzando dedicato aggiungere o rimuovere metodi, o tramite l'impostazione delle proprietà del contenuto degli elementi.  
  
 Lo scenario più comune per l'uso di <xref:System.Windows.FrameworkContentElement.Parent%2A> proprietà consiste nell'ottenere un riferimento, quindi ottenere varie <xref:System.Windows.FrameworkContentElement> i valori delle proprietà dall'elemento padre. Per i modelli, il <xref:System.Windows.FrameworkContentElement.Parent%2A> del modello alla fine saranno `null`. Per ottenere dopo questo passaggio e passare all'albero logico in cui viene fatto applicato il modello, usare <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.  
  
   
  
## Examples  
 L'esempio seguente controlla per verificare se il <xref:System.Windows.FrameworkContentElement.Parent%2A> di un <xref:System.Windows.Documents.TextPointer> è di un determinato tipo.  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Direzione per la quale deve essere determinata una potenziale modifica dello stato attivo.</param>
        <summary>Determina il successivo elemento che riceverà lo stato attivo in relazione a questo elemento per una direzione dello spostamento dello stato attivo specificata, ma non sposta effettivamente lo stato attivo. Questo metodo è sealed e non può essere sottoposto a override.</summary>
        <returns>Elemento successivo su cui verrebbe spostato lo stato attivo in caso di effettivo attraversamento dello stato attivo. Potrebbe restituire <see langword="null" /> se lo stato attivo non può essere spostato in relazione a questo elemento per la direzione specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> è il metodo correlato che effettivamente spostare lo stato attivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Specificata per una delle seguenti direzioni in <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Queste direzioni non sono valide per <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />, ma lo sono per <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nome da utilizzare per il mapping nome-oggetto specificato.</param>
        <param name="scopedElement">Oggetto per il mapping.</param>
        <summary>Fornisce una funzione di accesso che semplifica l'accesso al metodo di registrazione di <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un metodo pratico per chiamare il metodo <xref:System.Windows.NameScope.RegisterName%2A>. L'implementazione controllerà gli elementi padre successivi fino a individuare applicabile <xref:System.Windows.NameScope> implementazione, che viene calcolata eseguendo la ricerca di un elemento che implementa <xref:System.Windows.Markup.INameScope>. Per altre informazioni su ambiti dei nomi, vedere [NameScope XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 La chiamata a <xref:System.Windows.FrameworkContentElement.RegisterName%2A> laborioso correttamente collegare gli storyboard per animazioni per le applicazioni create nel codice. Infatti, proprietà, una delle principali storyboard <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, utilizza una ricerca in fase di esecuzione anziché essere in grado di accettare un riferimento a un elemento di destinazione. Questo vale anche se tale elemento è accessibile mediante un riferimento dal codice. Per altre informazioni sul motivo per cui è necessario registrare i nomi per le destinazioni di storyboard, vedere [Cenni preliminari sugli storyboard](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md). Le animazioni per gli elementi di contenuto sono meno comuni animazioni su controlli, il [Cenni preliminari sugli storyboard](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) si concentra sugli scenari di controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Elemento da rimuovere.</param>
        <summary>Rimuove l'elemento specificato dall'albero logico per questo elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciò [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] riguarda principalmente per la classe che deriva scenari, quando si aggiunge il supporto per le raccolte figlio.  
  
 La maggior parte delle <xref:System.Windows.FrameworkContentElement> alle classi derivate espongono raccolte dedicate che sono responsabili di contenimento (ad esempio, <xref:System.Windows.Documents.Span.Inlines%2A> nel <xref:System.Windows.Documents.Span> classe; <xref:System.Windows.Documents.Section.Blocks%2A> sul <xref:System.Windows.Documents.Section> classe). Derivazione da tali classi in genere, è possibile evitare qualsiasi esigenza di modificare direttamente l'albero logico.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il dizionario risorse corrente definito localmente.</summary>
        <value>Le risorse correnti definite localmente. Si tratta di un dizionario risorse in cui l'accesso alle risorse all'interno del dizionario viene eseguito tramite chiave.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dizionari risorse che possono essere definiti completamente o parzialmente in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] vengono in genere creati jako prvek vlastnosti e sono in genere per l'elemento radice di qualsiasi pagina singola o per l'applicazione. Posizionando il dizionario risorse a questo livello rende più semplice trovare da singoli elementi figlio nella pagina (o da qualsiasi pagina, nel caso dell'applicazione). Nella maggior parte degli scenari di applicazione, è consigliabile che gli stili viene definita come elementi oggetto all'interno di un dizionario risorse, o essere definiti come risorse esterne in modo che la risorsa di stile intero può essere autonoma (questo approccio consente di progettazione separate le responsabilità di responsabilità degli sviluppatori, separando i file fisici che devono essere modificate).  
  
 Si noti che questa proprietà restituisce solo il dizionario risorse dichiarati direttamente all'interno di tale elemento. Ciò è diverso rispetto al processo di ricerca di risorse effettivi, in cui un elemento figlio può accedere a tutte le risorse definite in ogni elemento padre, la ricerca in modo ricorsivo verso l'alto.  
  
 Può anche essere richiamate dal codice dall'interno dell'insieme di risorse, ma tenere presente che le risorse create [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] indubbiamente non sarà possibile accedere fino a dopo <xref:System.Windows.FrameworkContentElement.Loaded> viene generato dall'elemento che dichiara il dizionario. In effetti, le risorse vengono analizzate in modo asincrono e non anche il <xref:System.Windows.FrameworkContentElement.Loaded> evento è una garanzia che è possibile fare riferimento a un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] risorsa definita. Per questo motivo è consigliabile in genere solo accedere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] risorse definite come parte del codice in fase di esecuzione o tramite altri [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] tecniche, ad esempio stili o i riferimenti all'estensione di risorsa per i valori di attributo. Quando si accede alle risorse tramite codice, è essenzialmente equivalente a un riferimento effettuato da [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Sottostante <xref:System.Windows.ResourceDictionary> supporta i metodi necessari per aggiungere, rimuovere o eseguire una query sulle risorse dall'interno dell'insieme utilizzando il codice. Il <xref:System.Windows.FrameworkContentElement.Resources%2A> è possibile impostare per supportare lo scenario di sostituzione completa la raccolta di risorse di un elemento per ottenere un nuovo o diverso proprietà <xref:System.Windows.ResourceDictionary>.  
  
 Si noti che il [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintassi illustrata include un elemento per il <xref:System.Windows.ResourceDictionary>. Questo è un esempio di sintassi per raccolte implicite; un tag che rappresenta l'elemento della raccolta può essere omessa. Gli elementi che vengono aggiunte come elementi nella raccolta vengono invece specificati. Per altre informazioni sulle raccolte implicite e [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], vedere [XAML descrizione dettagliata della sintassi](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Un caso in cui un <xref:System.Windows.ResourceDictionary> sono ancora specificate in modo esplicito come un elemento è se si inserisce un dizionario unito, nel qual caso sono non presenti in genere elementi figlio per tale <xref:System.Windows.ResourceDictionary>. Per informazioni dettagliate, vedere [dizionari risorse uniti](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Utilizzo della sintassi XAML per elementi proprietà  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *oneOrMoreResourceElements*  
 Uno o più elementi oggetto, ognuno dei quali definisce una risorsa. Ogni elemento di proprietà della risorsa all'interno di ciascun <xref:System.Windows.ResourceDictionary> deve avere un valore univoco per il [direttiva X:Key](~/docs/framework/xaml-services/x-key-directive.md), che funge da chiave univoca quando vengono recuperati valori dal <xref:System.Windows.ResourceDictionary>.  
  
   
  
## Examples  
 L'esempio seguente stabilisce un <xref:System.Windows.FrameworkContentElement.Resources%2A> insieme su un <xref:System.Windows.Documents.FlowDocument> elemento radice. <xref:System.Windows.Documents.FlowDocument> è una scelta tipica perché è una delle poche <xref:System.Windows.FrameworkContentElement> le classi che è possano utilizzare come un elemento radice e le risorse sono in genere archiviate nella radice della pagina o a livelli ancora superiori ad esempio l'applicazione.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aggiunge un'associazione a questo elemento per la proprietà di dipendenza specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Identifica la proprietà associata.</param>
        <param name="path">Nome della proprietà di origine o percorso della proprietà utilizzata per l'associazione.</param>
        <summary>Connette un'associazione a questo elemento in base al nome della proprietà di origine specificata come qualificazione del percorso all'origine dati.</summary>
        <returns>Registra le condizioni dell'associazione. Questo valore restituito può essere utile per il controllo degli errori.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un metodo pratico per la chiamata <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, che consente di passare l'istanza corrente come il <xref:System.Windows.DependencyObject>e crea un nuovo <xref:System.Windows.Data.Binding> base fornito `path` parametro. Questa firma è più pratica, se si stabilisce un binding predefinito semplice. Se è necessario specificare alcuna proprietà di associazione per le condizioni non predefinito, o da usare una <xref:System.Windows.Data.MultiBinding> oppure <xref:System.Windows.Data.PriorityBinding>, è consigliabile usare il <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> firma.  
  
   
  
## Examples  
 Nell'esempio seguente imposta un'associazione in un <xref:System.Windows.Documents.Paragraph> elemento, creando un nuovo oggetto di dati personalizzati, stabilire tale oggetto come <xref:System.Windows.FrameworkContentElement.DataContext%2A>e impostare il percorso di associazione a una proprietà all'interno di esso.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Identifica la proprietà associata.</param>
        <param name="binding">Rappresenta un'associazione dati.</param>
        <summary>Collega un'associazione a questo elemento in base all'oggetto di associazione specificato.</summary>
        <returns>Registra le condizioni dell'associazione. Questo valore restituito può essere utile per il controllo degli errori.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è un metodo pratico per la chiamata <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, che consente di passare l'istanza corrente come il <xref:System.Windows.DependencyObject>.  
  
   
  
## Examples  
 Nell'esempio seguente imposta un'associazione in un <xref:System.Windows.Documents.Paragraph> creando un nuovo elemento <xref:System.Windows.Data.Binding> e impostando l'origine su un'appena compilata `DateTime` oggetto.  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Proprietà a cui è associata la risorsa.</param>
        <param name="name">Nome della risorsa.</param>
        <summary>Cerca una risorsa con il nome specificato e ne configura un riferimento alla risorsa per la proprietà specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un riferimento a una risorsa è simile all'utilizzo di un [estensione di Markup DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) nel markup. Il riferimento di risorsa viene creata un'espressione interna che fornisce il valore della proprietà specificata in fase di esecuzione posticipata. L'espressione verrà riconsiderato ogni volta che il dizionario risorse indica un valore modificato tramite gli eventi interni o ogni volta che viene riassociate come elementi padre dell'elemento corrente (un elemento padre è cambiato modificherebbe il percorso di ricerca di dizionario).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un valore che indica se i processi di serializzazione devono serializzare il contenuto della proprietà <see cref="P:System.Windows.FrameworkContentElement.Resources" /> nelle istanze di questa classe.</summary>
        <returns>
          <see langword="true" /> se il valore della proprietà <see cref="P:System.Windows.FrameworkContentElement.Resources" /> deve essere serializzato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verrà restituito `true` purché vi sia almeno una risorsa con chiave locale <xref:System.Windows.FrameworkContentElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un valore che indica se i processi di serializzazione devono serializzare il contenuto della proprietà <see cref="P:System.Windows.FrameworkContentElement.Style" /> nelle istanze di questa classe.</summary>
        <returns>
          <see langword="true" /> se il valore della proprietà <see cref="P:System.Windows.FrameworkContentElement.Style" /> deve essere serializzato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verrà restituito `true` se il <xref:System.Windows.Style> è impostato localmente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando una qualsiasi origine dati associata che partecipa a un'associazione in questo elemento viene modificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento mostra il <xref:System.Windows.Data.Binding.SourceUpdated> evento generato da qualsiasi <xref:System.Windows.Data.Binding> associato a questo elemento.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo stile che l'elemento deve usare.</summary>
        <value>Stile non predefinito applicato per l'elemento, se presente. In caso contrario, <see langword="null" />. Il valore predefinito per un oggetto <see cref="T:System.Windows.FrameworkContentElement" /> costruito in base all'impostazione predefinita è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo stile corrente viene spesso fornito da uno stile predefinito dall'applicazione di temi, o dagli stili in genere applicati agli oggetti di quel tipo dalle risorse a livello di pagina o un'applicazione (uno stile implicito). Questa proprietà non stili (tema) predefiniti non impostato o restituito, ma restituisce lo stile implicito o uno stile esplicito. Nel caso di stili impliciti o espliciti, non è importante se lo stile è accessibile come una risorsa o definito in locale.  
  
 Impostare gli stili presenta alcune restrizioni. È possibile reimpostare l'intera <xref:System.Windows.FrameworkContentElement.Style%2A> a una nuova proprietà <xref:System.Windows.Style> in qualsiasi momento, che forzerà la ricomposizione un layout. Tuttavia, appena lo stile verrà utilizzato da un elemento caricato, il <xref:System.Windows.Style> deve essere considerato sealed. Tenta di apportare una modifica a una singola proprietà di uno stile in uso (ad esempio qualsiasi elemento all'interno dell'insieme di <xref:System.Windows.Style.Setters%2A>) viene generata un'eccezione. Uno stile che viene definito nel markup viene considerato per essere in uso, non appena viene caricato da un dizionario di risorse (per le risorse) o (per gli stili inline) viene caricata la pagina che è contenuta.  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> è una proprietà di dipendenza con la precedenza speciale. Impostata localmente lo stile in genere ha la precedenza più alta nel sistema di proprietà. Se il <xref:System.Windows.FrameworkContentElement.Style%2A> è null a questo punto, durante il caricamento del sistema di proprietà Cerca stili impliciti come risorse definite che specificano che il tipo. Se lo stile è ancora null dopo questo passaggio, quindi lo stile deriva dallo stile (tema) predefiniti, ma lo stile predefinito non viene restituito nel <xref:System.Windows.FrameworkContentElement.Style%2A> valore della proprietà. Visualizzare [precedenza del valore della proprietà dipendenza](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *ResourceExtension*  
 Uno dei seguenti:, o. Visualizzare [risorse XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 La chiave che identifica lo stile della richiesta. La chiave fa riferimento a una risorsa esistente in un <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  La sintassi degli elementi è tecnicamente possibile, ma non è consigliata. Visualizzare [stili Inline e modelli](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Un riferimento dell'associazione usando o <xref:System.Windows.Data.Binding> è anche possibile, ma non comuni.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|Impostare le proprietà dei metadati `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 L'esempio seguente stabilisce un <xref:System.Windows.FrameworkContentElement.Resources%2A> insieme in una <xref:System.Windows.Documents.FlowDocument> elemento radice e quindi farvi riferimento come una risorsa come uno stile specifico per un <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nome della proprietà di ambiente richiesta.</param>
        <summary>Per una descrizione di questo membro, vedere il metodo <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="propertyName" /> è disponibile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Windows.FrameworkContentElement> a un'interfaccia <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o imposta un valore di oggetto arbitrario utilizzabile per archiviare informazioni personalizzate sull'elemento.</summary>
        <value>Valore previsto. Nessun valore predefinito per questa proprietà.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è analoga alle proprietà di Tag in altri modelli di programmazione di Microsoft, ad esempio Visual Basic, Applications Edition o Windows Form. Consente di fornire una posizione già esistente per archiviare alcune informazioni personalizzate su qualsiasi elemento di base senza imporre agli sviluppatori di applicazioni per creare una sottoclasse.  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>Valori XAML  
 Poiché questa proprietà accetta un oggetto, è necessario usare l'utilizzo dell'elemento di proprietà per impostare il <xref:System.Windows.FrameworkContentElement.Tag%2A> proprietà in XAML su un valore qualsiasi diverso da un oggetto con un convertitore di tipi noti e predefiniti, ad esempio una stringa. Gli oggetti utilizzati in questo modo non sono in genere all'interno di spazi dei nomi standard di WPF e pertanto possono richiedere il mapping dello spazio dei nomi per lo spazio dei nomi esterno per poter essere introdotti come elementi XAML.  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.Tag" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica in seguito alla modifica di qualsiasi proprietà di destinazione associata coinvolta in un'associazione per l'elemento corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento mostra il <xref:System.Windows.Data.Binding.TargetUpdated> evento generato da qualsiasi <xref:System.Windows.Data.Binding> associato a questo elemento. Ciò in genere significa che l'associazione in questione è un'associazione bidirezionale, e che la proprietà di dipendenza associata un invalidamento dei dati del valore della proprietà precedente per qualsiasi schema di convalida o memorizzazione nella cache che supporta la proprietà.  
  
 Gli argomenti dell'evento di questo evento indicherà quale proprietà associata è stata modificata.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un riferimento al modello padre di questo elemento. Questa proprietà non è pertinente se l'elemento non è stato creato con un modello.</summary>
        <value>L'elemento il cui <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> ha causato questo elemento deve essere creato. Questo valore è spesso <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I modelli sono oggetti condivisi in realtà, in cui il contenuto del modello viene creato una sola volta. Pertanto, se si ottiene un riferimento all'oggetto a un elemento che proviene da un modello, è possibile che l'albero logico evidente non raggiunge la radice della pagina. Per connettersi a tale riferimento del modello alla struttura ad albero logica della pagina, è necessario ottenere il <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> valore e continuare a esplorare tale albero degli elementi in base alle esigenze.  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> sarà spesso costituita da `null` per oggetti comuni, perché se è stato ottenuto un riferimento all'oggetto dall'esterno di una pagina nell'applicazione tramite gli strumenti standard, è probabile quell'elemento non sia stato creato da un modello. Casi in cui <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> potrebbe non essere `null` includono operazioni quali eventi hit testing, la gestione di determinati eventi di input a basso livello, o l'utilizzo enumeratori che potrebbero essere restituiti gli elementi creati da modelli.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto della descrizione comandi visualizzato per questo elemento nell'[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Oggetto della descrizione comandi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore di questa proprietà è di tipo <xref:System.Windows.Controls.ToolTip>, quindi è la descrizione che verrà usata nel [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Se il valore è di altro tipo, quindi tale valore verrà utilizzato come il *contenuto* per un <xref:System.Windows.Controls.ToolTip> specificato (costruito) dal sistema. Per altre informazioni, vedere <xref:System.Windows.Controls.ToolTipService>. La classe di servizio fornisce le proprietà associate che possono essere utilizzate per personalizzare ulteriormente una descrizione comandi.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Uso della sintassi XAML per gli attributi  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Utilizzo della sintassi XAML per elementi proprietà  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Valori XAML  
 *toolTipContent*  
 Stringa che entra il testo visualizzato per il <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Un oggetto, specificato nel formato dell'elemento oggetto, che deve essere utilizzato come il contenuto per il <xref:System.Windows.FrameworkContentElement> . In genere il risultato sarà un <xref:System.Windows.FrameworkElement> o un altro elemento che crea la composizione di layout per il <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, alla fine che contiene il contenuto di testo all'interno della composizione. In questo caso, il <xref:System.Windows.Controls.ToolTip> elemento creato in modo implicito da analizzata [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]e il *toolTipObjectContent* content è impostato come relativo <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> proprietà.  
  
 <`ToolTip` .../>  
 Vedere <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informazioni proprietà di dipendenza  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|Impostare le proprietà dei metadati `true`|nessuno|  
  
   
  
## Examples  
 Nell'esempio seguente imposta il valore della <xref:System.Windows.FrameworkElement.ToolTip%2A> proprietà direttamente a una stringa.  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica subito prima che venga chiusa una descrizione comandi relativa all'elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per evitare la chiusura della descrizione comandi, i gestori dell'evento che venga contrassegnato come gestito.  
  
 Questo evento non può essere un <xref:System.Windows.EventTrigger> in uno stile. Questo avviene perché il campo dell'identificatore di questo evento viene nuovamente utilizzata un'implementazione da un servizio che espone i metodi di aggiunta/rimozione dell'evento.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informazioni evento indirizzato  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|Strategia di routing|Direct|  
|delegato|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica all'apertura di qualsiasi descrizione per l'elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per aprire manualmente le descrizioni comandi, i gestori degli eventi devono contrassegnare l'evento rilevante come gestito. In caso contrario, il valore della <xref:System.Windows.FrameworkContentElement.ToolTip%2A> proprietà verrà utilizzata per aprire automaticamente un menu di scelta rapida. Contrassegnare l'evento come gestito in modo efficace annullerà l'azione predefinita e può essere un'opportunità per reimpostare il valore dei <xref:System.Windows.FrameworkContentElement.ToolTip%2A> proprietà e quindi aprire il nuovo <xref:System.Windows.Controls.ContextMenu>. Si noti che questo evento non verrà generato se <xref:System.Windows.FrameworkContentElement.ToolTip%2A> è un riferimento null o in caso contrario, non impostato.  
  
 Questo evento non può essere un <xref:System.Windows.EventTrigger> in uno stile. Questo avviene perché il campo dell'identificatore di questo evento viene nuovamente utilizzata un'implementazione da un servizio che espone i metodi di aggiunta/rimozione dell'evento.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informazioni evento indirizzato  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|Strategia di routing|Direct|  
|delegato|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la proprietà di dipendenza <see cref="P:System.Windows.FrameworkContentElement.ToolTip" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identificatore della chiave della risorsa da trovare.</param>
        <summary>Cerca una risorsa con la chiave specificata e restituisce tale risorsa, se trovata.</summary>
        <returns>Risorsa trovata. Se non viene trovata alcuna risorsa, viene restituito <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la risorsa non viene trovata nell'elemento di chiamata, viene eseguita la ricerca nella struttura ad albero padre usando l'albero logico, nello stesso modo che la struttura ad albero sarebbe cercati se un riferimento di risorsa dinamica sono stati richiesti da chiave in fase di esecuzione.  
  
 In genere si esegue immediatamente il cast del valore restituito al tipo della proprietà che si stava tentando di impostare con il valore di risorsa restituita.  
  
 Il <xref:System.Windows.FrameworkContentElement.FindResource%2A> metodo presenta un comportamento simile, ad eccezione del fatto che verrà generata un'eccezione nel caso non viene trovata una risorsa con la chiave fornita.  
  
   
  
## Examples  
 Nell'esempio seguente viene trovata una risorsa definita nel markup e lo applica a una determinata proprietà di un elemento in risposta a un evento indirizzato.  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'elemento viene rimosso da una struttura ad albero di elementi caricati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli eventi indirizzati diretti non seguono una route, ma vengono gestiti solo all'interno dell'elemento stesso in cui vengono generati. Indirizzare gli eventi indirizzati supportano altri comportamenti di eventi indirizzati: supportano una raccolta di gestori accessibile e può essere utilizzati come un <xref:System.Windows.EventTrigger> in uno stile.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informazioni evento indirizzato  
  
|||  
|-|-|  
|Campo dell'identificatore|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|Strategia di routing|Direct|  
|delegato|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la [panoramica degli eventi indirizzati](~/docs/framework/wpf/advanced/routed-events-overview.md) <see cref="E:System.Windows.FrameworkContentElement.Unloaded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli oggetti identificatore di evento vengono creati quando vengono registrati gli eventi indirizzati (vedere <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) e possono quindi essere usati per aggiungere i gestori di classi (vedere <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Identificatore oggetti contengono un nome che identifichi il tipo di proprietario, tipo di gestore, strategia di routing e un metodo di utilità per l'aggiunta di proprietari per l'evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome della coppia nome-oggetto da rimuovere dall'ambito corrente.</param>
        <summary>Semplifica l'accesso al metodo di annullamento della registrazione <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario solo per i nomi di annullare la registrazione se si prevede di registrare nuovamente un altro elemento con lo stesso nome.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riapplica lo stile predefinito al controllo <see cref="T:System.Windows.FrameworkContentElement" /> corrente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>