<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="346b263b0e22fb800ba4b1fdb296032637c17b7c" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52737238" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Segnala o applica i metadati per una proprietà di dipendenza, aggiungendo specificamente le caratteristiche di sistema delle proprietà specifiche del framework.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa classe deriva da <xref:System.Windows.PropertyMetadata> (tramite <xref:System.Windows.UIPropertyMetadata>). Per la maggior parte degli scopi di sviluppo dell'applicazione a livello di framework WPF, <xref:System.Windows.FrameworkPropertyMetadata> è il tipo utilizzato per i metadati di proprietà di dipendenza, anziché i tipi di metadati di base <xref:System.Windows.PropertyMetadata> o <xref:System.Windows.UIPropertyMetadata>. Questo vale sia per le proprietà di dipendenza esistenti per la maggior parte degli scenari di proprietà di dipendenza personalizzata.  
  
 I membri dichiarati da questa classe tale supplemento di <xref:System.Windows.PropertyMetadata> classe di base includono diverse proprietà booleana che specifica o comportamento di sistema di proprietà a livello di framework WPF, ad esempio ereditarietà della proprietà, associazione dati e layout di report.  
  
 Molte firme del costruttore per la creazione di un <xref:System.Windows.FrameworkPropertyMetadata> istanza accettano un <xref:System.Windows.FrameworkPropertyMetadataOptions> parametro. Il <xref:System.Windows.FrameworkPropertyMetadataOptions> enumerazione viene utilizzata solo per specificare il comportamento iniziale nel costruttore e non viene esposto in caso contrario, dopo aver <xref:System.Windows.FrameworkPropertyMetadata> viene costruito. Da un'istanza costruita, è possibile ottenere o impostare le informazioni corrispondenti attraverso varie proprietà che condividono il nome dei valori di enumerazione utilizzato nella chiamata al costruttore.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Questa classe non viene utilizzata in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Nell'esempio seguente ottiene i metadati per una proprietà di dipendenza su un particolare proprietario come iniziale base <xref:System.Windows.PropertyMetadata> tipo. Viene eseguito il cast dei metadati <xref:System.Windows.FrameworkPropertyMetadata>. Se il cast ha restituito un valore valido <xref:System.Windows.FrameworkPropertyMetadata>, quindi vari <xref:System.Windows.FrameworkPropertyMetadata> i valori delle proprietà vengono segnalati tramite una semplice interfaccia utente (non illustrata).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa firma inizializza tutti i valori di <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> sui valori di proprietà predefiniti. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> saranno `null`e i vari <xref:System.Windows.FrameworkPropertyMetadata> saranno le proprietà booleane `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore predefinito specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo del valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancate corrispondenze tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza per che viene applicato possono essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà alla fase di esecuzione, in modo che il risultato della mancata corrispondenza di tipo tipi/proprietà valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
   
  
## Examples  
 L'esempio seguente chiama questa firma del costruttore:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il callback specificato <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente chiama questa firma del costruttore:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</param>
        <param name="flags">Flag dell’opzione dei metadati (una combinazione dei valori <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> ). Queste opzioni specificano le caratteristiche della proprietà di dipendenza che interagiscono con sistemi come ad esempio layout o associazione dati.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore fornito predefinito e le opzioni dei metadati a livello di framework.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo del valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancate corrispondenze tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza per che viene applicato possono essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà alla fase di esecuzione, in modo che il risultato della mancata corrispondenza di tipo tipi/proprietà valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
 I valori contrassegnati come set di flag nel `flags` parametro verrà impostato il valore booleano della <xref:System.Windows.FrameworkPropertyMetadata> le proprietà che corrisponde a quello <xref:System.Windows.FrameworkPropertyMetadataOptions> il nome del flag per `true`. Successivamente, è possibile modificare i valori delle proprietà nei metadati, purché i metadati non è ancora stato applicato a un'operazione di sistema di proprietà specifici.  
  
   
  
## Examples  
 L'esempio seguente chiama questa firma del costruttore:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />  con il valore fornito predefinito e il callback specificato <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo del valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancate corrispondenze tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza per che viene applicato possono essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà alla fase di esecuzione, in modo che il risultato della mancata corrispondenza di tipo tipi/proprietà valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
   
  
## Examples  
 L'esempio seguente chiama questa firma del costruttore:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <param name="coerceValueCallback">Un riferimento ad un'implementazione del gestore sarà richiesto ogni qualvolta il sistema di proprietà chiamerà <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> per questa proprietà di dipendenza.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con i callback specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione chiama un inizializzatore di base e quindi aggiunge la `coerceValueCallback` impostando la proprietà sull'istanza di base.  
  
   
  
## Examples  
 L'esempio seguente chiama questa firma del costruttore:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</param>
        <param name="flags">Flag dell’opzione dei metadati (una combinazione dei valori <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> ). Queste opzioni specificano le caratteristiche della proprietà di dipendenza che interagiscono con sistemi come ad esempio layout o associazione dati.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore fornito predefinito e le opzioni dei metadati a livello di framework, e il callback specificato <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo del valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancate corrispondenze tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza per che viene applicato possono essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà alla fase di esecuzione, in modo che il risultato della mancata corrispondenza di tipo tipi/proprietà valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
 I valori contrassegnati come set di flag nel `flags` parametro verrà impostato il valore booleano della <xref:System.Windows.FrameworkPropertyMetadata> le proprietà che corrisponde a quello <xref:System.Windows.FrameworkPropertyMetadataOptions> il nome del flag per `true`. È possibile modificare i valori delle proprietà nei metadati, comunque, purché i metadati non è ancora stato applicato a un'operazione di sistema di proprietà specifici.  
  
   
  
## Examples  
 L'esempio seguente chiama questa firma del costruttore:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come tipo specifico.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <param name="coerceValueCallback">Un riferimento ad un'implementazione del gestore che sarà richiesto ogni qualvolta il sistema di proprietà chiamerà <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> per questa proprietà di dipendenza.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />  con il valore fornito predefinito e i callback specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo del valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancate corrispondenze tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza per che viene applicato possono essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà alla fase di esecuzione, in modo che il risultato della mancata corrispondenza di tipo tipi/proprietà valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
   
  
## Examples  
 L'esempio seguente chiama questa firma del costruttore:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come tipo specifico.</param>
        <param name="flags">Flag dell’opzione dei metadati (una combinazione dei valori <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> ). Queste opzioni specificano le caratteristiche della proprietà di dipendenza che interagiscono con sistemi come ad esempio layout o associazione dati.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <param name="coerceValueCallback">Un riferimento ad un'implementazione del gestore che sarà richiesto ogni qualvolta il sistema di proprietà eseguirà chiamate <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> a questa proprietà.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore fornito predefinito e le opzioni dei metadati a livello di framework, e i callback specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo del valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancate corrispondenze tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza per che viene applicato possono essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà alla fase di esecuzione, in modo che il risultato della mancata corrispondenza di tipo tipi/proprietà valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
 I valori contrassegnati come set di flag nel `flags` parametro verrà impostato il valore booleano della <xref:System.Windows.FrameworkPropertyMetadata> le proprietà che corrisponde a quello <xref:System.Windows.FrameworkPropertyMetadataOptions> il nome del flag per `true`. È possibile modificare i valori delle proprietà nei metadati, comunque, purché i metadati non è ancora stato applicato a un'operazione di sistema di proprietà specifici.  
  
   
  
## Examples  
 L'esempio seguente chiama questa firma del costruttore:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come tipo specifico.</param>
        <param name="flags">Flag dell’opzione dei metadati (una combinazione dei valori <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> ). Queste opzioni specificano le caratteristiche della proprietà di dipendenza che interagiscono con sistemi come ad esempio layout o associazione dati.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <param name="coerceValueCallback">Un riferimento ad un'implementazione del gestore che sarà richiesto ogni qualvolta il sistema di proprietà eseguirà una chiamata <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> su questa proprietà di dipendenza.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> per impedire che il sistema di proprietà aggiunga un’animazione alla proprietà alla quale questi metadati sono applicati. Tali proprietà genereranno un'eccezione in fase di esecuzione di origine dal sistema di proprietà se si tenta di aggiungere animazioni. <see langword="false" /> per consentire l'animazione della proprietà. Il valore predefinito è <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore fornito predefinito ed opzioni di metadati di framework, callback specificati ed un Booleano che può essere utilizzato per impedire l’animazione della proprietà.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo del valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancate corrispondenze tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza per che viene applicato possono essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà alla fase di esecuzione, in modo che il risultato della mancata corrispondenza di tipo tipi/proprietà valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
 Il `isAnimationProhibited` parametro consente di impostare il valore iniziale del <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> proprietà dichiarata per la base immediata <xref:System.Windows.UIPropertyMetadata> classe.  
  
 I valori contrassegnati come set di flag nel `flags` parametro verrà impostato il valore booleano della <xref:System.Windows.FrameworkPropertyMetadata> le proprietà che corrisponde a quello <xref:System.Windows.FrameworkPropertyMetadataOptions> il nome del flag per `true`. È possibile modificare i valori delle proprietà nei metadati, comunque, purché i metadati non è ancora stato applicato a un'operazione di sistema di proprietà specifici.  
  
   
  
## Examples  
 L'esempio seguente chiama questa firma del costruttore:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come tipo specifico.</param>
        <param name="flags">Flag dell’opzione dei metadati (una combinazione dei valori <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> ). Queste opzioni specificano le caratteristiche della proprietà di dipendenza che interagiscono con sistemi come ad esempio layout o associazione dati.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <param name="coerceValueCallback">Un riferimento ad un'implementazione del gestore che sarà richiesto ogni qualvolta il sistema di proprietà eseguirà chiamate <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> a questa proprietà.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> per impedire che il sistema di proprietà aggiunga un’animazione alla proprietà alla quale questi metadati sono applicati. Tali proprietà genereranno un'eccezione in fase di esecuzione di origine dal sistema di proprietà se si tenta di aggiungere animazioni. Il valore predefinito è <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger">
          <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> da utilizzare quando le associazioni per questa proprietà sono applicate ed hanno <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> impostato a <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore fornito predefinito ed opzioni di metadati di framework, callback specificati ed un Booleano che può essere utilizzato per impedire l’animazione della proprietà, e un'impostazione predefinita di trigger di aggiornamento di associazione dati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo del valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancate corrispondenze tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza per che viene applicato possono essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà alla fase di esecuzione, in modo che il risultato della mancata corrispondenza di tipo tipi/proprietà valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
 Il `isAnimationProhibited` parametro consente di impostare il valore iniziale del <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> proprietà dichiarata per la base immediata <xref:System.Windows.UIPropertyMetadata> classe.  
  
 Per altre informazioni sul comportamento di origine di aggiornamento per le associazioni, vedere [Panoramica sul Data Binding](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 I valori contrassegnati come set di flag nel `flags` parametro verrà impostato il valore booleano della <xref:System.Windows.FrameworkPropertyMetadata> le proprietà che corrisponde a quello <xref:System.Windows.FrameworkPropertyMetadataOptions> il nome del flag per `true`. È possibile modificare i valori delle proprietà nei metadati, comunque, purché i metadati non è ancora stato applicato a un'operazione di sistema di proprietà specifici.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una proprietà di dipendenza può influire sul passaggio di disposizione durante operazioni del motore di layout.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza in cui si trovano i metadati può influire sul passaggio di disposizione. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> includere un'implementazione di <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> che consente di monitorare le modifiche dei valori effettivo per tutte le proprietà di dipendenza esistenti in un elemento. Come parte di tale logica, le proprietà di dipendenza che cambiano in vigore valore e hanno i metadati con <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> impostata su `true` avvierà una richiesta posticipata per invalidare gli oggetti visivi per quell'elemento (una chiamata a <xref:System.Windows.UIElement.InvalidateArrange%2A>). Questa implementazione a livello di framework WPF è già in posizione, in genere non occorre cercare le proprietà di dipendenza con <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> a meno che non si stia sostituendo o modifica del comportamento di layout a livello di framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementazioni potrebbero scegliere di disporre di un comportamento simile per le modifiche alle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> è `true`.  
  
 Le proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe vengono in genere non utilizzati [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> proprietà ad essa e utilizza le informazioni per popolare una tabella per implementare un visualizzatore"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una proprietà di dipendenza può influire sul passaggio di misurazione durante operazioni del motore di layout.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza in cui si trovano i metadati può influire sul passaggio di misurazione. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> includere un'implementazione di <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> che consente di monitorare le modifiche dei valori effettivo per tutte le proprietà di dipendenza esistenti in un elemento. Come parte di tale logica, le proprietà di dipendenza che cambiano in vigore valore e hanno i metadati con <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> impostato su `true` avvierà una richiesta posticipata per invalidare gli oggetti visivi per quell'elemento. Questa implementazione a livello di framework WPF è già in posizione, in genere non occorre cercare le proprietà di dipendenza con <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> a meno che non si stia sostituendo o modifica del comportamento di layout a livello di framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementazioni potrebbero scegliere di disporre di un comportamento simile per le modifiche alle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> è `true`.  
  
 Le proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> proprietà ad essa e utilizza le informazioni per popolare una tabella per implementare un visualizzatore"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una proprietà di dipendenza può influire sul passaggio di disposizione del layout dell'elemento padre durante le operazioni del motore di layout.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza in cui si trovano i metadati può influire sul passaggio di disposizione in modo specifico nell'elemento padre. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> includere un'implementazione di <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> che consente di monitorare le modifiche dei valori effettivo per tutte le proprietà di dipendenza esistenti in un elemento. Come parte di tale logica, le proprietà di dipendenza che cambiano in vigore valore e hanno i metadati con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> impostato su `true` avvierà una richiesta posticipata per invalidare gli oggetti visivi per l'elemento padre.  
  
 In genere, non è necessario per segnalare le modifiche di una <xref:System.Windows.FrameworkElement> proprietà a un elemento padre usando <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> perché l'elemento stesso ha già un proprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> come `true`. In genere sufficiente, perché le modifiche nell'elemento figlio iniziano in genere un elemento padre Disponi quando appropriato. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> viene a volte usato per un <xref:System.Windows.FrameworkContentElement> classe derivata. In questo caso, il set di elementi figlio che una proprietà, ma un <xref:System.Windows.FrameworkContentElement> classe derivata non controlla il proprio rendering. Il rendering viene gestito da un <xref:System.Windows.FrameworkElement> elemento padre che funge da host del contenuto. Ad esempio, una modifica al valore della <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> invalida una proprietà associata da un elemento figlio disposizione dell'elemento padre, perché è necessario modificare la posizione dell'elemento figlio del padre. Pertanto, il <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> proprietà associata è di metadati in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> è `true`. Un altro esempio è <xref:System.Windows.Controls.Control.Padding%2A>; quando questa proprietà viene modificata, l'elemento padre potrebbe modificare il posizionamento dell'elemento figlio, a seconda dello spazio disponibile.  
  
 Questa implementazione a livello di framework WPF è già in posizione, in genere non occorre cercare le proprietà di dipendenza con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> a meno che non si stia sostituendo o modifica del comportamento di layout a livello di framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementazioni potrebbero scegliere di disporre di un comportamento simile per le modifiche alle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> è `true`.  
  
 Le proprietà per qualsiasi classe derivata di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una proprietà di dipendenza può influire sul passaggio di misurazione del layout dell'elemento padre durante le operazioni del motore di layout.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza in cui si trovano i metadati può influire sul passaggio di misurazione in modo specifico nell'elemento padre. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> includere un'implementazione di <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> che consente di monitorare le modifiche dei valori effettivo per tutte le proprietà di dipendenza esistenti in un elemento. Come parte di tale logica, le proprietà di dipendenza che cambiano in vigore valore e hanno i metadati con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> impostato su `true` avvierà una richiesta posticipata per invalidare gli oggetti visivi per l'elemento padre. Questa implementazione a livello di framework WPF è già in posizione, in genere non occorre cercare le proprietà di dipendenza con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> a meno che non si stia sostituendo o modifica del comportamento di layout a livello di framework WPF.  
  
 In genere, non è necessario per segnalare le modifiche di una <xref:System.Windows.FrameworkElement> proprietà a un elemento padre usando <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> perché l'elemento stesso ha già un proprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> come `true`. Ciò avviene in genere sufficiente, perché le modifiche nell'elemento figlio iniziano in genere un passaggio di misurazione padre quando appropriato. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> viene a volte usato per un <xref:System.Windows.FrameworkContentElement> classe derivata. In questo caso, il set di elementi figlio che una proprietà, ma un <xref:System.Windows.FrameworkContentElement> classe derivata non controlla il proprio rendering. Il rendering viene gestito da un <xref:System.Windows.FrameworkElement> elemento padre che funge da host del contenuto. Ad esempio, una modifica al valore della <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> proprietà da un elemento figlio invalida una misura dell'elemento padre, perché lo spazio relativo dei paragrafi potrebbe modificare e aumentare o ridurre le dimensioni di host del contenuto. Pertanto, il <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> dispone di proprietà dei metadati in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> è `true`.  
  
 Elementi host del contenuto spesso anche cercano le modifiche nelle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> è `true`, come parte della logica di rendering host del contenuto. Ad esempio, il <xref:System.Windows.Controls.TextBox> elemento deve rispondere a determinate modifiche all'interno del testo che potrebbe essere richiesto che il rettangolo di selezione della <xref:System.Windows.Controls.TextBox> stesso essere modificato.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementazioni potrebbero scegliere di disporre di un comportamento simile per le modifiche alle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> è `true`.  
  
 Le proprietà per qualsiasi classe derivata di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una proprietà di dipendenza può avere potenzialmente effetto sul layout generale, in un modo che non influenza in modo specifico la disposizione o la misurazione, ma che richiederebbe un nuovo disegno.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza in cui si trovano questi metadati può influire sul rendering. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> includere un'implementazione di <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> che consente di monitorare le modifiche dei valori effettivo per tutte le proprietà di dipendenza esistenti in un elemento. Come parte di tale logica, le proprietà di dipendenza che cambiano in vigore valore e hanno i metadati con <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> impostato su `true` avvierà una richiesta posticipata per invalidare gli oggetti visivi per quell'elemento. Questa implementazione a livello di framework WPF è già in posizione, in genere non occorre cercare le proprietà di dipendenza con <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> a meno che non si stia sostituendo o modifica del comportamento di layout a livello di framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementazioni potrebbero scegliere di disporre di un comportamento simile per le modifiche alle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> è `true`.  
  
 Le proprietà per qualsiasi classe derivata di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> proprietà ad essa e utilizza le informazioni per popolare una tabella per implementare un visualizzatore"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la proprietà esegue l'associazione bidirezionale per impostazione predefinita.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza in cui si trovano questi metadati esegue l'associazione bidirezionale per impostazione predefinita. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In assenza di questa proprietà in corso `true`, gli aggiornamenti di binding sono unidirezionali per impostazione predefinita, in base al comportamento predefinito del <xref:System.Windows.Data.Binding> costruttori o equivalente [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintassi.  
  
 Negli elementi esistenti, si troverà in genere questa proprietà è impostata su `true` nei metadati per le proprietà di dipendenza che segnalano lo stato e che sono modificabili dall'utente, ad esempio <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 Questa proprietà indica solo le caratteristiche di aggiornamento di associazione predefinito della proprietà di dipendenza in generale. Qualsiasi associazione impostato su questa proprietà su un'istanza in locale è possibile impostare il <xref:System.Windows.Data.Binding.Mode%2A> proprietà dell'associazione e modificare il valore predefinito.  
  
 Le proprietà per qualsiasi classe derivata di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> proprietà ad essa e utilizza le informazioni per popolare una tabella per implementare un visualizzatore"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'impostazione predefinita per <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> da utilizzare quando le associazioni per la proprietà con questi metadati sono applicate, che hanno <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> impostato in <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Un valore dell'enumerazione, diverso da <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Questa proprietà è impostata su <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; si suppone che il valore impostato divenga un’impostazione predefinita, quando richiesto dalle associazioni.</exception>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il valore della proprietà di dipendenza è ereditabile.</summary>
        <value>
          <see langword="true" /> se il valore della proprietà è ereditabile. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereditarietà del valore della proprietà è una funzionalità dei [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema di proprietà a livello di framework WPF, in base al quale determinate proprietà di dipendenza può essere in locale impostata su un elemento uguale o vicino alla base di un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] elemento della struttura ad albero e quindi chiedere il loro valore ereditato da tutti gli elementi all'interno dell'albero logico degli elementi figlio che possiedono anche tale proprietà. Ereditarietà del valore della proprietà non è abilitato per impostazione predefinita e abilitarla avere alcune implicazioni sulle prestazioni. Per informazioni dettagliate, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Anche se può sembrare ereditarietà del valore della proprietà per le proprietà di dipendenza non associata, il comportamento di ereditarietà per una proprietà non associata tramite determinati reparti di oggetto nell'albero della fase di esecuzione è definito. Usare sempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> per registrare le proprietà in cui si specificano <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nei metadati.  
  
 Le proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> proprietà ad essa e utilizza le informazioni per popolare una tabella per implementare un visualizzatore"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il data binding è supportato per la proprietà di dipendenza.</summary>
        <value>
          <see langword="true" /> se il data binding è supportato nella proprietà di dipendenza a cui si applicano questi metadati. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà indica `false` per una delle due condizioni: l'associazione dati per una proprietà di dipendenza non è consentita perché la proprietà di dipendenza è di sola lettura (come indicato nell'identificatore della proprietà di dipendenza, non i metadati), o il valore di un'altra proprietà dei metadati <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, è impostato su `true` nei metadati. Questa proprietà viene esposta per praticità, in modo che i chiamanti non sono necessario controllare entrambi <xref:System.Windows.DependencyProperty.ReadOnly%2A> e <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Se si sta tentando di creare i metadati che specifica che una proprietà di lettura/scrittura in caso contrario, non deve supportare l'associazione dati, specificare il flag <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (si noti la leggera differenza di convenzione di denominazione invece <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> proprietà ad essa e utilizza le informazioni per popolare una tabella per implementare un visualizzatore"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la proprietà di dipendenza supporta il data binding.</summary>
        <value>
          <see langword="true" /> se la proprietà non supporta il data binding. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che questa proprietà di metadati è impostata su `true` in modo specifico per le proprietà che non devono supportare l'associazione di dati, nonostante sia le proprietà di lettura / scrittura. L'aspettativa è che nella maggior parte dei casi in cui viene dichiarata una proprietà di dipendenza, si desidera l'associazione dati, poiché l'associazione dati è uno degli scenari chiave in cui è utile una proprietà di dipendenza. A differenza di <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, ciò non modifica semplicemente un valore predefinito che può essere modificato successivamente in un'associazione specifica. Impostazione di questa proprietà `true` nei metadati per una proprietà di dipendenza dei metadati disabiliterà tutte le associazioni dell'applicazione i valori mediante espressioni a quella proprietà di dipendenza.  
  
 Le proprietà di dipendenza di sola lettura non supportano i dati di associazione (perché non hanno alcuna funzione set che è possibile applicare i valori modificati), ma comunque riporteranno `false` per <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. Infatti, le proprietà che corrispondono a un <xref:System.Windows.FrameworkPropertyMetadataOptions> valori segnalerà la parità con i metadati come è stata effettivamente stabilito, invece di riportare sempre il comportamento del risultato finale che potrebbe implicare la denominazione della proprietà. Per determinare se una proprietà di dipendenza specificata consente l'associazione dati, è consigliabile controllare <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> invece. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> è utile per la verifica entrambe <xref:System.Windows.DependencyProperty.ReadOnly%2A> e <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> come un'unica operazione, restituendo il risultato previsto.  
  
 Le proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la proprietà contiene informazioni di inserimento nel journal che le applicazioni possono o devono archiviare come parte di un'implementazione di inserimento nel journal.</summary>
        <value>
          <see langword="true" /> se l'inserimento nel journal deve essere eseguito nella proprietà di dipendenza a cui sono applicati i metadati. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Metadati di base da unire.</param>
        <param name="dp">Proprietà di dipendenza a cui vengono applicati i metadati.</param>
        <summary>Abilita un merge dei metadati di origine con i metadati di base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene usato internamente quando sono in corso l'override dei metadati.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Le classi che derivano da <see cref="T:System.Windows.PropertyMetadata" /> (o da questa classe particolarmente) deve eseguire l'override di questo metodo per conto di qualsiasi proprietà di metadati che sono aggiunti nelle rispettive implementazioni. Ad esempio, l'implementazione potrebbe avere aggiunto un nuovo valore di enumerazione flag per flag e il <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementazione dovrebbe quindi essere in grado di combinare correttamente i flag.  
  
Chiamare sempre l'implementazione di base prima dell'implementazione, poiché l'implementazione di base si occupa di unione di tutte le proprietà già definite nei tipi precedenti nella gerarchia.  
  
Il comportamento aggiunto dal <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementazione nei <see cref="T:System.Windows.FrameworkPropertyMetadata" /> è di proprietà a livello di framework WPF specifiche nei metadati, ad esempio <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> vengono combinati in un bit per bit o operazione.  
  
Il <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> comportamento implementa anche il comportamento quando si esegue l'override dei metadati della proprietà su una proprietà di dipendenza esistente chiamando <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />, usando i metadati di sostituzione che è <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Proprietà di dipendenza alla quale sono stati applicati i metadati.</param>
        <param name="targetType">Il tipo associato a questi metadati se questi sono metadati di tipo specifico. Se si tratta di metadati predefiniti, questo valore può essere <see langword="null" />.</param>
        <summary>Chiamata effettuata quando questi metadati sono stati applicati ad una proprietà che indica che i metadati sono sealed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualsiasi modificabilità della struttura dei dati di un <xref:System.Windows.FrameworkPropertyMetadata> istanza deve essere contrassegnata come non modificabile quando questo metodo viene richiamato.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Il <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implementazione di questo metodo non esegue alcuna operazione oltre a chiamare l'implementazione di base.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la valutazione dell'ereditarietà del valore della proprietà deve estendersi attraverso determinati limiti di contenuto nell'albero logico degli elementi.</summary>
        <value>
          <see langword="true" /> se l'ereditarietà del valore di proprietà deve estendersi attraverso certi limiti di contenuto. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questi metadati segnala una modifica applicata raramente al comportamento di ereditarietà del valore proprietà attraverso i limiti di elemento figlio dell'elemento padre speciale. L'esempio canonico di tale limite è il contenuto di un <xref:System.Windows.Controls.Frame>, dove il <xref:System.Windows.Controls.Frame> contenuto potrebbe essere ricaricato indipendentemente dall'esistenza del <xref:System.Windows.Controls.Frame>. Il comportamento del sistema di proprietà desiderata è che ereditarietà del valore della proprietà non deve attraversare il contenuto del <xref:System.Windows.Controls.Frame>, in quanto questi contenuti potrebbero essere gli elementi che l'applicazione che ospita il frame non possiede o controlla. Specificare i metadati con <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> impostata su `true`, specificando anche <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> come `true`, provocherà la proprietà in cui viene applicato ai metadati per essere ereditabili anche attraverso il <xref:System.Windows.Controls.Frame> limite o limiti simili.  
  
 Le proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se le sottoproprietà della proprietà di dipendenza non influiscono sul rendering dell'oggetto contenitore.</summary>
        <value>
          <see langword="true" /> se le modifiche ai valori delle sottoproprietà non influiscono sul rendering. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa opzione dei metadati è pertinente per le proprietà di dipendenza che sono tipi riferimento, in cui quel tipo dispone di valori di proprietà proprie. In genere, la logica di sistema di layout è presupporre che qualsiasi proprietà di dipendenza con proprietà secondarie verranno potenzialmente influire sul layout, perché il controllo di tutte le sottoproprietà per le modifiche richiede più tempo rispetto a effettivamente in esecuzione un'altra passaggio di rendering. Impostando questa opzione su `true` è utile per ottimizzare le prestazioni dell'implementazione del sistema di layout a livello di framework WPF.  
  
 Le proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> vengono in genere definite nel modello a oggetti in lettura e scrittura. Si tratta pertanto possono essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati vengono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà contenenti le specifiche dei metadati sono ora considerate immutabili. Tentativo di impostare questa proprietà dopo aver <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` su questi metadati istanza genererà un'eccezione.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 I membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>