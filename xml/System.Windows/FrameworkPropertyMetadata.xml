<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c70304d7b52b8f4e76c37fd1e35de0928f9619c7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680545" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Segnala o applica i metadati per una proprietà di dipendenza, aggiungendo specificamente le caratteristiche di sistema delle proprietà specifiche del framework.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa classe deriva da <xref:System.Windows.PropertyMetadata> (tramite <xref:System.Windows.UIPropertyMetadata>). Per la maggior parte degli scopi di sviluppo a livello di framework applicazione WPF, <xref:System.Windows.FrameworkPropertyMetadata> è il tipo utilizzato per i metadati di proprietà di dipendenza, anziché i tipi di metadati di base <xref:System.Windows.PropertyMetadata> o <xref:System.Windows.UIPropertyMetadata>. Questo vale sia per le proprietà di dipendenza esistenti e per la maggior parte degli scenari di proprietà di dipendenza personalizzata.  
  
 I membri dichiarati da questa classe che integrano la <xref:System.Windows.PropertyMetadata> classe di base includono diverse proprietà booleane che specificano o comportamento del sistema di proprietà a livello di framework WPF, ad esempio l'ereditarietà delle proprietà, l'associazione dati e layout di report.  
  
 Molte firme del costruttore per la creazione di un <xref:System.Windows.FrameworkPropertyMetadata> istanza accettano un <xref:System.Windows.FrameworkPropertyMetadataOptions> parametro. Il <xref:System.Windows.FrameworkPropertyMetadataOptions> enumerazione viene utilizzata solo per specificare il comportamento iniziale nel costruttore e non è esposta dopo <xref:System.Windows.FrameworkPropertyMetadata> viene costruito. Da un'istanza costruita, è possibile ottenere o impostare le informazioni corrispondenti tramite varie proprietà che condividono il nome dei valori di enumerazione utilizzato nella chiamata al costruttore.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Questa classe non è in genere utilizzata in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Nell'esempio seguente ottiene i metadati per una proprietà di dipendenza su un particolare proprietario come iniziale base <xref:System.Windows.PropertyMetadata> tipo. Viene eseguito il cast dei metadati <xref:System.Windows.FrameworkPropertyMetadata>. Se il cast ha restituito un valore valido <xref:System.Windows.FrameworkPropertyMetadata>, quindi varie <xref:System.Windows.FrameworkPropertyMetadata> i valori delle proprietà sono segnalati tramite un'interfaccia utente semplice (non illustrata).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa firma inizializza tutti i valori di <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> i valori di proprietà predefiniti. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> sarà `null`e i vari <xref:System.Windows.FrameworkPropertyMetadata> le proprietà booleane sarà `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore predefinito specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancata corrispondenza tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza applicata a può essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà in fase di esecuzione, pertanto il risultato della mancata corrispondenza di tipo o la proprietà tipo di valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
   
  
## Examples  
 Questa firma del costruttore viene chiamato nell'esempio seguente:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il callback specificato <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Questa firma del costruttore viene chiamato nell'esempio seguente:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</param>
        <param name="flags">Flag dell’opzione dei metadati (una combinazione dei valori <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> ). Queste opzioni specificano le caratteristiche della proprietà di dipendenza che interagiscono con sistemi come ad esempio layout o associazione dati.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore fornito predefinito e le opzioni dei metadati a livello di framework.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancata corrispondenza tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza applicata a può essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà in fase di esecuzione, pertanto il risultato della mancata corrispondenza di tipo o la proprietà tipo di valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
 I valori contrassegnati come flag impostati nel `flags` parametro verrà impostato il valore booleano di <xref:System.Windows.FrameworkPropertyMetadata> le proprietà corrispondenti che <xref:System.Windows.FrameworkPropertyMetadataOptions> nome flag a `true`. Successivamente, è possibile modificare i valori delle proprietà nei metadati, purché i metadati non sono ancora applicato a un'operazione di sistema di proprietà specifici.  
  
   
  
## Examples  
 Questa firma del costruttore viene chiamato nell'esempio seguente:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />  con il valore fornito predefinito e il callback specificato <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancata corrispondenza tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza applicata a può essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà in fase di esecuzione, pertanto il risultato della mancata corrispondenza di tipo o la proprietà tipo di valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
   
  
## Examples  
 Questa firma del costruttore viene chiamato nell'esempio seguente:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <param name="coerceValueCallback">Un riferimento ad un'implementazione del gestore sarà richiesto ogni qualvolta il sistema di proprietà chiamerà <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> per questa proprietà di dipendenza.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con i callback specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa implementazione chiama un inizializzatore di base e quindi aggiunge la `coerceValueCallback` impostando la proprietà sull'istanza di base.  
  
   
  
## Examples  
 Questa firma del costruttore viene chiamato nell'esempio seguente:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come valore di un tipo specifico.</param>
        <param name="flags">Flag dell’opzione dei metadati (una combinazione dei valori <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> ). Queste opzioni specificano le caratteristiche della proprietà di dipendenza che interagiscono con sistemi come ad esempio layout o associazione dati.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore fornito predefinito e le opzioni dei metadati a livello di framework, e il callback specificato <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancata corrispondenza tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza applicata a può essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà in fase di esecuzione, pertanto il risultato della mancata corrispondenza di tipo o la proprietà tipo di valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
 I valori contrassegnati come flag impostati nel `flags` parametro verrà impostato il valore booleano di <xref:System.Windows.FrameworkPropertyMetadata> le proprietà corrispondenti che <xref:System.Windows.FrameworkPropertyMetadataOptions> nome flag a `true`. È comunque possibile modificare i valori delle proprietà nei metadati, purché i metadati non sono ancora applicato a un'operazione di sistema di proprietà specifici.  
  
   
  
## Examples  
 Questa firma del costruttore viene chiamato nell'esempio seguente:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come tipo specifico.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <param name="coerceValueCallback">Un riferimento ad un'implementazione del gestore che sarà richiesto ogni qualvolta il sistema di proprietà chiamerà <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> per questa proprietà di dipendenza.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />  con il valore fornito predefinito e i callback specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancata corrispondenza tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza applicata a può essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà in fase di esecuzione, pertanto il risultato della mancata corrispondenza di tipo o la proprietà tipo di valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
   
  
## Examples  
 Questa firma del costruttore viene chiamato nell'esempio seguente:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come tipo specifico.</param>
        <param name="flags">Flag dell’opzione dei metadati (una combinazione dei valori <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> ). Queste opzioni specificano le caratteristiche della proprietà di dipendenza che interagiscono con sistemi come ad esempio layout o associazione dati.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <param name="coerceValueCallback">Un riferimento ad un'implementazione del gestore che sarà richiesto ogni qualvolta il sistema di proprietà eseguirà chiamate <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> a questa proprietà.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore fornito predefinito e le opzioni dei metadati a livello di framework, e i callback specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancata corrispondenza tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza applicata a può essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà in fase di esecuzione, pertanto il risultato della mancata corrispondenza di tipo o la proprietà tipo di valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
 I valori contrassegnati come flag impostati nel `flags` parametro verrà impostato il valore booleano di <xref:System.Windows.FrameworkPropertyMetadata> le proprietà corrispondenti che <xref:System.Windows.FrameworkPropertyMetadataOptions> nome flag a `true`. È comunque possibile modificare i valori delle proprietà nei metadati, purché i metadati non sono ancora applicato a un'operazione di sistema di proprietà specifici.  
  
   
  
## Examples  
 Questa firma del costruttore viene chiamato nell'esempio seguente:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come tipo specifico.</param>
        <param name="flags">Flag dell’opzione dei metadati (una combinazione dei valori <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> ). Queste opzioni specificano le caratteristiche della proprietà di dipendenza che interagiscono con sistemi come ad esempio layout o associazione dati.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <param name="coerceValueCallback">Un riferimento ad un'implementazione del gestore che sarà richiesto ogni qualvolta il sistema di proprietà eseguirà una chiamata <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> su questa proprietà di dipendenza.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> per impedire che il sistema di proprietà aggiunga un’animazione alla proprietà alla quale questi metadati sono applicati. Tali proprietà genereranno un'eccezione in fase di esecuzione di origine dal sistema di proprietà se si tenta di aggiungere animazioni. <see langword="false" /> per consentire l'animazione della proprietà. Il valore predefinito è <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore fornito predefinito ed opzioni di metadati di framework, callback specificati ed un Booleano che può essere utilizzato per impedire l’animazione della proprietà.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancata corrispondenza tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza applicata a può essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà in fase di esecuzione, pertanto il risultato della mancata corrispondenza di tipo o la proprietà tipo di valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
 Il `isAnimationProhibited` parametro imposta il valore iniziale del <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> proprietà dichiarata dal tipo di base immediata <xref:System.Windows.UIPropertyMetadata> classe.  
  
 I valori contrassegnati come flag impostati nel `flags` parametro verrà impostato il valore booleano di <xref:System.Windows.FrameworkPropertyMetadata> le proprietà corrispondenti che <xref:System.Windows.FrameworkPropertyMetadataOptions> nome flag a `true`. È comunque possibile modificare i valori delle proprietà nei metadati, purché i metadati non sono ancora applicato a un'operazione di sistema di proprietà specifici.  
  
   
  
## Examples  
 Questa firma del costruttore viene chiamato nell'esempio seguente:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valore predefinito della proprietà di dipendenza, in genere fornito come tipo specifico.</param>
        <param name="flags">Flag dell’opzione dei metadati (una combinazione dei valori <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> ). Queste opzioni specificano le caratteristiche della proprietà di dipendenza che interagiscono con sistemi come ad esempio layout o associazione dati.</param>
        <param name="propertyChangedCallback">Un riferimento ad un'implementazione del gestore che il sistema di proprietà chiamerà ogni volta che il valore effettivo della proprietà si modifica.</param>
        <param name="coerceValueCallback">Un riferimento ad un'implementazione del gestore che sarà richiesto ogni qualvolta il sistema di proprietà eseguirà chiamate <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> a questa proprietà.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> per impedire che il sistema di proprietà aggiunga un’animazione alla proprietà alla quale questi metadati sono applicati. Tali proprietà genereranno un'eccezione in fase di esecuzione di origine dal sistema di proprietà se si tenta di aggiungere animazioni. Il valore predefinito è <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger">
          <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> da utilizzare quando le associazioni per questa proprietà sono applicate ed hanno <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> impostato a <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con il valore fornito predefinito ed opzioni di metadati di framework, callback specificati ed un Booleano che può essere utilizzato per impedire l’animazione della proprietà, e un'impostazione predefinita di trigger di aggiornamento di associazione dati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di valore fornito per `defaultValue` deve corrispondere o essere correlato al tipo specificato nella registrazione originale della proprietà di dipendenza che verranno applicati i metadati. Mancata corrispondenza tra il tipo di valore di metadati predefinito e il tipo della proprietà di dipendenza applicata a può essere difficile eseguire il debug, in quanto la mancata corrispondenza non è rilevabile durante la compilazione. Il sistema di proprietà non valuta il valore effettivo di una proprietà in fase di esecuzione, pertanto il risultato della mancata corrispondenza di tipo o la proprietà tipo di valore predefinito è un errore di run-time.  
  
 Il valore <xref:System.Windows.DependencyProperty.UnsetValue> ha un significato speciale nel sistema di proprietà e non può essere utilizzato come un valore predefinito di proprietà di dipendenza.  
  
 Il `isAnimationProhibited` parametro imposta il valore iniziale del <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> proprietà dichiarata dal tipo di base immediata <xref:System.Windows.UIPropertyMetadata> classe.  
  
 Per ulteriori informazioni sul comportamento di origine di aggiornamento per i binding, vedere [Panoramica del Data Binding](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 I valori contrassegnati come flag impostati nel `flags` parametro verrà impostato il valore booleano di <xref:System.Windows.FrameworkPropertyMetadata> le proprietà corrispondenti che <xref:System.Windows.FrameworkPropertyMetadataOptions> nome flag a `true`. È comunque possibile modificare i valori delle proprietà nei metadati, purché i metadati non sono ancora applicato a un'operazione di sistema di proprietà specifici.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> è impostato su <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una proprietà di dipendenza può influire sul passaggio di disposizione durante operazioni del motore di layout.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza sulla quale esistono potenzialmente questi metadati influisce sul passaggio della disposizione; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> includono un'implementazione di <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> che esegue il monitoraggio delle modifiche del valore effettivo di tutte le proprietà di dipendenza esistenti su un elemento. Come parte di quella logica, le proprietà di dipendenza che modificano l'effettivo valore e hanno metadati con <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> impostato su `true` verrà avviata una richiesta differita per invalidare gli oggetti visivi per quell'elemento (una chiamata a <xref:System.Windows.UIElement.InvalidateArrange%2A>). Poiché questa implementazione a livello di framework WPF è già attiva, in genere non è necessaria cercare le proprietà di dipendenza con <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> a meno che non si stia sostituendo o modificando il comportamento di layout a livello di framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementazioni è potrebbero scegliere di disporre di un comportamento simile per le modifiche alle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> è `true`.  
  
 Proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe vengono in genere non viene utilizzati [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> , proprietà e utilizza le informazioni per popolare una tabella per implementare un browser"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una proprietà di dipendenza può influire sul passaggio di misurazione durante operazioni del motore di layout.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza in cui si trovano i metadati può influire sul passaggio di misurazione. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> includono un'implementazione di <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> che esegue il monitoraggio delle modifiche del valore effettivo di tutte le proprietà di dipendenza esistenti su un elemento. Come parte di quella logica, le proprietà di dipendenza che modificano l'effettivo valore e hanno metadati con <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> impostato su `true` verrà avviata una richiesta differita per invalidare gli oggetti visivi per quell'elemento. Poiché questa implementazione a livello di framework WPF è già attiva, in genere non è necessaria cercare le proprietà di dipendenza con <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> a meno che non si stia sostituendo o modificando il comportamento di layout a livello di framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementazioni è potrebbero scegliere di disporre di un comportamento simile per le modifiche alle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> è `true`.  
  
 Proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> , proprietà e utilizza le informazioni per popolare una tabella per implementare un browser"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una proprietà di dipendenza può influire sul passaggio di disposizione del layout dell'elemento padre durante le operazioni del motore di layout.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza sulla quale esistono potenzialmente questi metadati influisce specificamente sul passaggio della disposizione sull'elemento padre; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> includono un'implementazione di <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> che esegue il monitoraggio delle modifiche del valore effettivo di tutte le proprietà di dipendenza esistenti su un elemento. Come parte di quella logica, le proprietà di dipendenza che modificano l'effettivo valore e hanno metadati con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> impostato su `true` verrà avviata una richiesta differita per invalidare gli oggetti visivi per l'elemento padre.  
  
 In genere, non è necessaria per segnalare le modifiche di un <xref:System.Windows.FrameworkElement> proprietà a un elemento padre utilizzando <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> perché l'elemento stesso ha già un proprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> come `true`. In genere sufficiente, perché le modifiche nell'elemento figlio iniziano in genere un elemento padre disposizione quando appropriato. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> a volte viene utilizzato per un <xref:System.Windows.FrameworkContentElement> classe derivata. In questo caso, l'elemento figlio imposta una proprietà, ma un <xref:System.Windows.FrameworkContentElement> classe derivata non controlla il rendering. Il rendering è gestito da un <xref:System.Windows.FrameworkElement> elemento padre che funge da host del contenuto. Ad esempio, una modifica al valore del <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> proprietà associata da un elemento figlio invalida disposizione del padre, perché la posizione dell'elemento figlio dell'elemento padre deve essere modificata. Pertanto, il <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> proprietà associata ha metadati dove <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> è `true`. Un altro esempio è <xref:System.Windows.Controls.Control.Padding%2A>; quando questa proprietà viene modificata, l'elemento padre potrebbe modificare il posizionamento dell'elemento figlio, a seconda dello spazio disponibile.  
  
 Poiché questa implementazione a livello di framework WPF è già attiva, in genere non è necessaria cercare le proprietà di dipendenza con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> a meno che non si stia sostituendo o modificando il comportamento di layout a livello di framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementazioni è potrebbero scegliere di disporre di un comportamento simile per le modifiche alle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> è `true`.  
  
 Le proprietà per qualsiasi classe derivata di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una proprietà di dipendenza può influire sul passaggio di misurazione del layout dell'elemento padre durante le operazioni del motore di layout.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza sulla quale esistono potenzialmente questi metadati influisce specificamente sul passaggio della disposizione sull'elemento padre; in caso contrario, <see langword="false" />. L’impostazione predefinita è <see langword="false" /> . </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> includono un'implementazione di <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> che esegue il monitoraggio delle modifiche del valore effettivo di tutte le proprietà di dipendenza esistenti su un elemento. Come parte di quella logica, le proprietà di dipendenza che modificano l'effettivo valore e hanno metadati con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> impostato su `true` verrà avviata una richiesta differita per invalidare gli oggetti visivi per l'elemento padre. Poiché questa implementazione a livello di framework WPF è già attiva, in genere non è necessaria cercare le proprietà di dipendenza con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> a meno che non si stia sostituendo o modificando il comportamento di layout a livello di framework WPF.  
  
 In genere, non è necessaria per segnalare le modifiche di un <xref:System.Windows.FrameworkElement> proprietà a un elemento padre utilizzando <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> perché l'elemento stesso ha già un proprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> come `true`. Che è in genere sufficiente, perché le modifiche nell'elemento figlio iniziano in genere un passaggio di misurazione padre quando appropriato. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> a volte viene utilizzato per un <xref:System.Windows.FrameworkContentElement> classe derivata. In questo caso, l'elemento figlio imposta una proprietà, ma un <xref:System.Windows.FrameworkContentElement> classe derivata non controlla il rendering. Il rendering è gestito da un <xref:System.Windows.FrameworkElement> elemento padre che funge da host del contenuto. Ad esempio, una modifica al valore del <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> proprietà da un elemento figlio invalida misura dell'elemento padre, perché lo spazio relativo di paragrafi potrebbe modificare e aumentare o diminuire le dimensioni dell'host del contenuto. Pertanto, il <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> è di proprietà di metadati in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> è `true`.  
  
 Elementi host del contenuto consente di cercare spesso anche le modifiche nelle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> è `true`, come parte della logica di rendering di host del contenuto. Ad esempio, il <xref:System.Windows.Controls.TextBox> elemento deve rispondere a determinate modifiche all'interno del testo che potrebbero richiedere che il rettangolo di selezione del <xref:System.Windows.Controls.TextBox> stesso essere modificato.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementazioni è potrebbero scegliere di disporre di un comportamento simile per le modifiche alle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> è `true`.  
  
 Le proprietà per qualsiasi classe derivata di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se una proprietà di dipendenza può avere potenzialmente effetto sul layout generale, in un modo che non influenza in modo specifico la disposizione o la misurazione, ma che richiederebbe un nuovo disegno.</summary>
        <value>
          <see langword="true" /> se la proprietà di dipendenza sulla quale esistono questi metadati influisce sul rendering; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> includono un'implementazione di <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> che esegue il monitoraggio delle modifiche del valore effettivo di tutte le proprietà di dipendenza esistenti su un elemento. Come parte di quella logica, le proprietà di dipendenza che modificano l'effettivo valore e hanno metadati con <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> impostato su `true` verrà avviata una richiesta differita per invalidare gli oggetti visivi per quell'elemento. Poiché questa implementazione a livello di framework WPF è già attiva, in genere non è necessaria cercare le proprietà di dipendenza con <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> a meno che non si stia sostituendo o modificando il comportamento di layout a livello di framework WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementazioni è potrebbero scegliere di disporre di un comportamento simile per le modifiche alle proprietà di dipendenza in cui <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> è `true`.  
  
 Le proprietà per qualsiasi classe derivata di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> , proprietà e utilizza le informazioni per popolare una tabella per implementare un browser"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la proprietà esegue l'associazione bidirezionale per impostazione predefinita.</summary>
        <value>
          <see langword="true" /> Se la proprietà di dipendenza per cui esistono il questi metadati esegue l'associazione bidirezionale per impostazione predefinita. in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In assenza di questa proprietà sia `true`, gli aggiornamenti dell'associazione sono unidirezionali per impostazione predefinita, in base al comportamento predefinito del <xref:System.Windows.Data.Binding> costruttori o equivalente [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintassi.  
  
 Negli elementi esistenti, si troverà in genere questa proprietà è impostata su `true` nei metadati per le proprietà di dipendenza che segnalano lo stato e che sono modificabili dall'utente, ad esempio <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 Questa proprietà restituisce solo le caratteristiche di aggiornamento di associazione predefinito della proprietà di dipendenza in generale. Qualsiasi associazione impostata su questa proprietà su un'istanza locale è possibile impostare il <xref:System.Windows.Data.Binding.Mode%2A> proprietà dell'associazione e modificare il valore predefinito.  
  
 Le proprietà per qualsiasi classe derivata di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> , proprietà e utilizza le informazioni per popolare una tabella per implementare un browser"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'impostazione predefinita per <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> da utilizzare quando le associazioni per la proprietà con questi metadati sono applicate, che hanno <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> impostato in <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Un valore dell'enumerazione, diverso da <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Questa proprietà è impostata su <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; si suppone che il valore impostato divenga un’impostazione predefinita, quando richiesto dalle associazioni.</exception>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il valore della proprietà di dipendenza è ereditabile.</summary>
        <value>
          <see langword="true" /> se il valore della proprietà è ereditabile; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ereditarietà del valore di proprietà è una funzionalità del [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] il sistema di proprietà a livello di framework WPF, in base al quale alcune proprietà di dipendenza può essere locale impostato su un elemento in prossimità della radice di un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] elemento della struttura ad albero e quindi chiedere loro valore ereditato dalle tutti gli elementi all'interno dell'albero logico degli elementi figlio che dispone anche di tale proprietà. Ereditarietà del valore di proprietà non è abilitato per impostazione predefinita e abilitarlo hanno alcune implicazioni sulle prestazioni. Per informazioni dettagliate, vedere [Ereditarietà del valore della proprietà](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Anche se potrebbe sembrare che ereditarietà del valore di proprietà funziona per le proprietà di dipendenza non associata, non è definito il comportamento di ereditarietà per una proprietà non associata tramite determinati reparti oggetto nell'albero della fase di esecuzione. Utilizzare sempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> per registrare le proprietà in cui si specifica <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nei metadati.  
  
 Proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> , proprietà e utilizza le informazioni per popolare una tabella per implementare un browser"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il data binding è supportato per la proprietà di dipendenza.</summary>
        <value>
          <see langword="true" /> se l'associazione dati è supportata sulla proprietà di dipendenza alla quale si applicano questi metadati; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà riporta `false` per una delle due condizioni possibili: l'associazione dati per una proprietà di dipendenza non è consentita perché la proprietà di dipendenza è di sola lettura (come indicato nell'identificatore della proprietà di dipendenza, non nei metadati), o il valore di un'altra proprietà di metadati, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, è impostato su `true` nei metadati. Questa proprietà viene esposta per praticità, in modo che i chiamanti non è necessario verificare entrambi <xref:System.Windows.DependencyProperty.ReadOnly%2A> e <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Se si sta tentando di creare i metadati che specifica che una proprietà di lettura/scrittura in caso contrario non deve supportare l'associazione dati, specificare il flag <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (si noti la leggera differenza di convenzione di denominazione invece <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 L'esempio seguente ottiene i metadati predefiniti dalla dipendenza vari campi delle proprietà, il valore di varie query <xref:System.Windows.FrameworkPropertyMetadata> , proprietà e utilizza le informazioni per popolare una tabella per implementare un browser"metadati".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la proprietà di dipendenza supporta il data binding.</summary>
        <value>
          <see langword="true" /> se la proprietà non supporta l’associazione dati; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che questa proprietà di metadati è impostata su `true` in particolare per le proprietà che non devono supportare l'associazione di dati, nonostante siano di proprietà di lettura / scrittura. È previsto che nella maggior parte dei casi in cui viene dichiarata una proprietà di dipendenza, associazione dati viene considerata, perché l'associazione dati è uno degli scenari chiave in cui una proprietà di dipendenza è utile. A differenza di <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, questo non modifica soltanto un valore predefinito che può essere modificato successivamente in un'associazione specifica. Impostazione di questa proprietà `true` nei metadati per una proprietà di dipendenza dei metadati disabiliterà tutte le associazioni dell'applicazione i valori tramite espressioni a tale proprietà di dipendenza.  
  
 Le proprietà di dipendenza di sola lettura non supportano l'associazione dati (perché non hanno alcuna funzione set che è possibile applicare i valori modificati), ma vengono comunque report `false` per <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. In questo modo le proprietà che corrispondono a un <xref:System.Windows.FrameworkPropertyMetadataOptions> valori riporteranno con i metadati come è stata effettivamente stabilito, anziché reporting sempre il comportamento del risultato finale che potrebbe implicare la denominazione della proprietà. Per determinare se una proprietà di dipendenza consente l'associazione di dati, è consigliabile controllare <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> invece. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> è utile per la verifica di <xref:System.Windows.DependencyProperty.ReadOnly%2A> e <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> come una singola operazione, producendo il risultato previsto.  
  
 Proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la proprietà contiene informazioni di inserimento nel journal che le applicazioni possono o devono archiviare come parte di un'implementazione di inserimento nel journal.</summary>
        <value>
          <see langword="true" /> se l'inserimento nel journal deve essere eseguito nella proprietà di dipendenza a cui sono applicati i metadati. In caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Metadati di base da unire.</param>
        <param name="dp">Proprietà di dipendenza a cui vengono applicati i metadati.</param>
        <summary>Abilita un merge dei metadati di origine con i metadati di base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato internamente durante l'override di metadati.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Le classi che derivano da <see cref="T:System.Windows.PropertyMetadata" /> (o da questa classe particolarmente) deve eseguire l'override di questo metodo per l'account per tutte le proprietà dei metadati che hanno aggiunto nelle rispettive implementazioni. Ad esempio, l'implementazione potrebbe essere aggiunto un nuovo valore di enumerazione flag per flag e <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementazione deve quindi essere in grado di combinare correttamente tali flag.  
  
 Chiamare sempre l'implementazione di base prima dell'implementazione, perché l'implementazione di base si occupa dell'unione di tutte le proprietà già definite sui tipi precedenti nella gerarchia.  
  
 Il comportamento aggiunto dal <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementazione in <see cref="T:System.Windows.FrameworkPropertyMetadata" /> è che specifiche proprietà a livello di framework WPF nei metadati, ad esempio <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> vengono combinati in un bit per bit o operazione.  
  
 Il <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> comportamento implementa anche il comportamento quando si sostituiscono i metadati della proprietà su una proprietà di dipendenza esistente chiamando <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />., usando i metadati di sostituzione sono <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Proprietà di dipendenza alla quale sono stati applicati i metadati.</param>
        <param name="targetType">Il tipo associato a questi metadati se questi sono metadati di tipo specifico. Se si tratta di metadati predefiniti, questo valore può essere <see langword="null" />.</param>
        <summary>Chiamata effettuata quando questi metadati sono stati applicati ad una proprietà che indica che i metadati sono sealed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualsiasi mutabilità della struttura di dati di un <xref:System.Windows.FrameworkPropertyMetadata> istanza deve essere contrassegnata come non modificabile quando questo metodo viene richiamato.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Il <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implementazione di questo metodo non esegue alcuna operazione, oltre a chiamare l'implementazione di base.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la valutazione dell'ereditarietà del valore della proprietà deve estendersi attraverso determinati limiti di contenuto nell'albero logico degli elementi.</summary>
        <value>
          <see langword="true" /> se l'ereditarietà del valore di proprietà deve estendersi attraverso certi limiti di contenuto; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questi metadati indica una modifica raramente applicata al comportamento di ereditarietà di proprietà valore attraverso i limiti degli elementi figlio dell'elemento padre speciale. L'esempio canonico di tale limite è il contenuto di un <xref:System.Windows.Controls.Frame>, dove il <xref:System.Windows.Controls.Frame> contenuto potrebbe essere ricaricato indipendentemente dall'esistenza del <xref:System.Windows.Controls.Frame>. Il comportamento del sistema di proprietà desiderato è che ereditarietà del valore di proprietà non deve attraversare il contenuto del <xref:System.Windows.Controls.Frame>, perché questi contenuti potrebbero essere elementi che l'applicazione che ospita il frame non possiede o controlla. Specificare i metadati con <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> impostato su `true`, specificando anche <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> come `true`, causerà la proprietà in cui i metadati sono applicati sarà ereditabile anche attraverso il <xref:System.Windows.Controls.Frame> limite o limiti simili.  
  
 Proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati sono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se le sottoproprietà della proprietà di dipendenza non influiscono sul rendering dell'oggetto contenitore.</summary>
        <value>
          <see langword="true" /> se le modifiche ai valori della sub-proprietà non influiscono su rendering modificato; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa opzione di metadati è pertinente per le proprietà di dipendenza che sono tipi di riferimento, in cui tale tipo ha i valori delle proprietà di un proprio. In genere, la logica del sistema di layout è presupporre che qualsiasi proprietà di dipendenza con sottoproprietà potenzialmente avranno effetto su layout, perché il controllo di tutte le sottoproprietà per le modifiche è più tempo rispetto al effettivamente in esecuzione un'altra passaggio di rendering. Impostazione dell'opzione `true` è utile per ottimizzare le prestazioni dell'implementazione di sistema di layout a livello di framework WPF.  
  
 Proprietà nelle classi derivate di <xref:System.Windows.PropertyMetadata> sono in genere definiti nel modello a oggetti di lettura e scrittura. Si tratta pertanto può essere modificate dopo l'inizializzazione dell'istanza. Tuttavia, dopo che i metadati vengono utilizzati come parte di una chiamata a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, il sistema di proprietà eseguirà il sealing dell'istanza di metadati e proprietà che trasmettono le specifiche dei metadati ora sono considerate immutabili. Il tentativo di impostare questa proprietà dopo <xref:System.Windows.PropertyMetadata.IsSealed%2A> è `true` i metadati di questa istanza verrà generata un'eccezione.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Utilizzo di testo XAML  
 Membri di questa classe non vengono utilizzati in genere [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Poiché sono già stati applicati a un'operazione della proprietà di dipendenza, questi metadati sono sealed e non è possibile impostarne le proprietà.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>