<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="31e3a9db18b7cba85d5901fe816b3124d2f065ba" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30550475" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Personalizza il rendering per il controllo derivato al quale è collegato l'adattatore, per modificare il markup predefinito o il comportamento di browser specifici, ed è la classe base dalla quale ereditano tutti gli adattatori dei controlli.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli adattatori di controllo sono componenti che eseguono l'override di determinati <xref:System.Web.UI.Control> classe metodi ed eventi nella durata di esecuzione per consentire la gestione di markup specifico o browser. .NET Framework esegue il mapping di una scheda di controllo derivato singola di un <xref:System.Web.UI.Control> oggetto per ogni richiesta client.  
  
 Un adattatore di modifica di un controllo per un browser specifico o una classe di browser o funge da filtro arbitrario su alcune funzionalità. L'adapter è in genere definito dal linguaggio di markup che utilizza il browser (ad esempio, XHTML o HTML 3.2). Possibile incapsulare gran parte dell'adattabilità comportamento di rendering nelle classi specializzate che derivano dalla <xref:System.Web.UI.HtmlTextWriter> classe. Pertanto, è probabile che una scheda possa essere utilizzata per il numero di comportamenti delle classi del browser o che l'inclusione dell'adattabilità nel <xref:System.Web.UI.HtmlTextWriter> classi può evitare l'utilizzo di una scheda di controllo.  
  
 Un adattatore per una classe del controllo si applica a tutti i controlli che ereditano da tale classe, a meno che non è presente più specializzato di schede. Ad esempio, un adattatore per il <xref:System.Web.UI.WebControls.BaseValidator> classe può essere utilizzata per tutti i `Validator` oggetti.  
  
 In genere gli adattatori non ereditano direttamente dal <xref:System.Web.UI.Adapters.ControlAdapter> (classe), ma da una dell'adapter specifico della destinazione di base le classi che forniscono funzionalità aggiuntive specifiche del browser di destinazione e di tipo di controllo o il rendering specifico richiesto.  
  
 Controlli stessi non richiedono necessariamente un adapter. Se i controlli vengono estesi attraverso la composizione, in genere gli adattatori di controllo figlio sono sufficienti.  
  
 Ogni controllo presenta mapping espliciti agli adattatori attraverso i file di definizione del browser. Pertanto, qualsiasi accesso al <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> proprietà Usa il <xref:System.Web.HttpBrowserCapabilities> oggetto estratto dal file di definizione del browser per eseguire la ricerca per il mapping della scheda di controllo.  
  
 Durante l'elaborazione, .NET Framework intercetta le chiamate ai metodi sottoponibili a override di un controllo che può essere specifico della destinazione. Se è collegata una scheda di controllo, .NET Framework chiama i metodi di adattatore associato.  
  
 L'adapter esegue il rendering del controllo mediante il <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metodo. Se sottoposto a override, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potenzialmente non deve chiamare l'implementazione della classe base poiché che non esegue una chiamata di nuovo il <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metodo. Ciò potrebbe causare il verificarsi due volte, una volta dall'adapter e una volta dal controllo del rendering.  
  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> in chiamate al metodo di base di <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metodo del controllo. Pertanto, se esegue l'override <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, non chiamare l'implementazione della classe base, a meno che il rendering da implementare è inoltre necessario che viene fornito da <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> del controllo.  
  
 È necessario assicurarsi che .NET Framework esegue intercettazione per le schede dei controlli figlio. Ciò si realizza tramite la chiamata di <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> base metodo che chiama il <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> metodo del controllo, dal <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> eseguire l'override.  
  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metodi vengono chiamati dal controllo immediatamente prima e dopo, rispettivamente, le chiamate di controllo di <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metodo. Se prima e dopo il rendering sono specifici dei browser solo attività di elaborazione necessaria utilizzando <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> potrebbe rendere necessaria eseguire l'override <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>. Il comportamento predefinito del <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metodi consiste nel chiamare i metodi corrispondenti del <xref:System.Web.UI.HtmlTextWriter>.  
  
 Per mantenere le proprie informazioni di stato, è possibile eseguire l'override di una scheda di controllo di <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, e <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> metodi. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, e <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> vengono chiamati quando gli stati di controllo e di visualizzazione privati vengono salvati e caricati, rispettivamente.  
  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, e <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> chiamata di metodi di base sul corrispondente <xref:System.Web.UI.Control> metodi della classe. Di conseguenza, nessuno di questi <xref:System.Web.UI.Adapters.ControlAdapter> metodi sottoposti a override devono chiamare i metodi di base; in caso contrario, l'evento associato il <xref:System.Web.UI.Control> metodo della classe non verrà generato.  
  
 Controlli e gli adattatori implementano facoltativamente il <xref:System.Web.UI.IPostBackDataHandler> e <xref:System.Web.UI.IPostBackEventHandler> interfacce. .NET Framework determina se un adattatore esiste e se l'adapter implementa queste interfacce. In caso affermativo, l'adapter deve eseguire l'override di <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, e <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> metodi, in base alle esigenze. Se i dati di postback non sono riconosciuti nell'adapter, deve chiamare nuovamente sul controllo per elaborarlo. Gestori di eventi successivi anche necessario richiamare il controllo.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Quando si eredita dal <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), un controllo che richiede funzionalità di adattatore generale deve avere un adattatore corrispondente classe base, denominata nel modello <paramref name="ControlType" /><see langword="Adapter" /> (ad esempio, <see langword="TextBoxAdapter" />). L'adapter deve restituire almeno un'istanza fortemente tipizzata del controllo tramite il relativo <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> proprietà.  
  
1.  Controllare le schede per un determinato controllo tipo e linguaggio di markup deve essere denominato nel criterio di <paramref name="MarkupControlType" /><see langword="Adapter" /> (ad esempio, <see langword="XhtmlTextBoxAdapter" />). Gli adattatori per un controllo devono essere implementati in un <see langword="Adapters" /> sottospazio dei nomi.  
  
 Adattatori del controllo devono ereditare dalla classe di base appropriata e seguire lo stesso modello di ereditarietà del controllo. Ad esempio, un adattatore per un controllo che eredita dal <see cref="T:System.Web.UI.Control" /> classe di base deve ereditare da una di <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe o pertinente <paramref name="ControlType" /><see langword="Adapter" /> classe.  
  
 Tutti gli adattatori specializzati devono essere definiti per il controllo specializzato in tutti i nodi di dispositivo nei file di configurazione browser.  
  
 Un controllo implementato correttamente non deve presupporre che un adapter è collegato o che l'adattatore collegato implementa un'interfaccia specifica. In alternativa, è necessario verificare questi prodotti prima di chiamare il metodo.  
  
 È possibile simulare l'override dei metodi di evento protetto nel controllo, ad esempio il <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> metodo il <see cref="T:System.Web.UI.WebControls.LinkButton" />. Innanzitutto, creare una classe dell'adattatore con un <c>OnClick</c> metodo. Quindi creare un nuovo controllo derivato da <see cref="T:System.Web.UI.WebControls.LinkButton" /> ed eseguire l'override di <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> metodo. Sottoposta a override <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> chiamate al metodo di <c>OnClick</c> metodo dell'adattatore. L'oggetto scheda è disponibile tramite il metodo protetto <see cref="P:System.Web.UI.Control.Adapter" /> proprietà la <see cref="T:System.Web.UI.Control" /> classe. Il <see cref="P:System.Web.UI.Control.Adapter" /> è di proprietà del controllo <see langword="null" /> quando è presente alcun adattatore associato, pertanto qualsiasi codice deve verificare di tale condizione prima di chiamare i metodi dell'adattatore.</para>
    </block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Web.UI.Adapters.ControlAdapter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework crea questa scheda internamente durante la creazione della corrispondente <xref:System.Web.UI.Control> oggetto.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Web.UI.HtmlTextWriter" /> contenente i metodi per eseguire il rendering dell'output specifico della destinazione.</param>
        <summary>Questo metodo viene chiamato prima di effettuare il rendering di un controllo. In una classe di adattatore derivata, genera i tag di apertura richiesti da una destinazione specifica ma non necessari per i browser HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> metodo viene chiamato appena prima di <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> (metodo) e viene utilizzato per eseguire specifico della destinazione di pre-elaborazione prima del rendering del controllo.  
  
 Utilizzare il <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> metodo in combinazione con il <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metodo per assicurarsi di apertura e chiusura uniformità dei tag.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si eredita dal <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), il <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> chiamate al metodo di base di <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> metodo. Pertanto, esegue l'override del <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> metodo deve chiamare il <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> metodo di base solo se l'elaborazione è in aggiunta a non invece del <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> (metodo).</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un riferimento alle funzionalità del browser del client che effettua la richiesta HTTP corrente.</summary>
        <value>Oggetto <see cref="T:System.Web.HttpBrowserCapabilities" /> che specifica le funzionalità del browser client e del linguaggio markup.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Web.UI.Adapters.ControlAdapter> oggetto determina le funzionalità del browser client dal <xref:System.Web.HttpBrowserCapabilities> oggetto restituito dal <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> proprietà. In questo modo il <xref:System.Web.UI.Adapters.ControlAdapter> oggetto per il rendering del markup specifico del browser oppure per modificare il comportamento del <xref:System.Web.UI.Control>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> proprietà per accedere ai dettagli del browser richiedente. In questo esempio, il codice di verifica per determinare se il browser è compatibile con JavaScript e quindi consente allo sviluppatore di eseguire il rendering di output personalizzato in questo caso.  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un riferimento al controllo a cui è collegato questo adattatore di controllo.</summary>
        <value>Oggetto <see cref="T:System.Web.UI.Control" /> a cui è associato <see cref="T:System.Web.UI.Adapters.ControlAdapter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando una scheda di controllo derivato è collegata a un controllo, .NET Framework chiama determinati membri dell'adattatore anziché i membri del controllo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come derivare un controllo personalizzato dal <xref:System.Web.UI.Control> classe e quindi creare un adattatore corrispondente da cui eredita il <xref:System.Web.UI.Adapters.ControlAdapter> classe. L'adapter esegue l'override di <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> proprietà e restituisce un riferimento fortemente tipizzato per il controllo.  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si eredita dal <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), come minimo, è necessario implementare un <see langword="Control" /> proprietà per restituire un'istanza fortemente tipizzata del controllo, come illustrato nella sezione esempio.</para>
        </block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea i controlli figlio specifici della destinazione per un controllo composito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è presente una scheda di controllo derivato collegato a un <xref:System.Web.UI.Control> oggetto e <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> viene eseguito l'override di metodo, viene chiamato l'override anziché il <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> metodo. Di conseguenza, <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> può essere utilizzato per creare un insieme di controlli figlio specifico della destinazione.  
  
 Per ulteriori informazioni sulla combinazione di controlli per creare un nuovo controllo, vedere [controlli compositi](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se si crea una classe che eredita e si esegue l'override di <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> (metodo), non chiamare il metodo di base, a meno che non si desidera aggiungere controlli a quelli creato dal metodo base. In caso contrario è possibile creare due set di figlio controlli.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Web.UI.HtmlTextWriter" /> contenente i metodi per eseguire il rendering dell'output specifico della destinazione.</param>
        <summary>Questo metodo viene chiamato dopo il rendering di un controllo. In una classe di adattatore derivata, genera i tag di chiusura richiesti da una destinazione specifica ma non necessari per i browser HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metodo viene chiamato subito dopo il <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> (metodo) e viene utilizzato per eseguire destinazione post-elaborazione specifica dopo il rendering del controllo.  
  
 Utilizzare il <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> metodo in combinazione con il <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> metodo per assicurarsi di apertura e chiusura uniformità dei tag.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si eredita dal <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), il <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> chiamate al metodo di base di <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> metodo. Pertanto, esegue l'override del <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> metodo deve chiamare il <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> metodo di base solo se l'elaborazione è in aggiunta a non invece del <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> (metodo).</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> contenente le informazioni sullo stato del controllo dell'adattatore come <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Carica le informazioni sullo stato di controllo dell'adattatore salvate dal metodo <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> durante una precedente richiesta alla pagina in cui si trova il controllo associato a questo adattatore di controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo stato del controllo è l'informazione essenziale necessaria anche se lo stato di visualizzazione è disabilitato. Quando un adapter deve gestire le proprie informazioni di stato di controllo, è possibile eseguire l'override di <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> metodi.  
  
 Un adapter potrebbe essere necessario mantenere le informazioni sullo stato di controllo quando sono presenti funzionalità che è necessario disporre di stato mantenuto su tutte le richieste, indipendentemente dallo stato del controllo associato. Ad esempio, un controllo composito costituito da una visualizzazione di testo di grandi dimensioni e un gruppo di <xref:System.Web.UI.WebControls.RadioButton> potrebbero eseguire il rendering di controlli come una singola visualizzazione nel browser per computer desktop. In altri browser, è possibile suddividerlo il rendering, ovvero una visualizzazione per la visualizzazione di testo e l'altro per il gruppo di pulsanti di opzione. L'adapter devono mantenere il proprio specifico della destinazione di informazioni sulla visualizzazione attualmente attiva.  
  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> metodo viene chiamato immediatamente dopo il <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> (metodo), nel `LoadState` fase del ciclo di vita. Lo stato del controllo scheda è separata e oltre che dello stato di controllo del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Oggetto <see cref="T:System.Object" /> che contiene le informazioni sullo stato di visualizzazione dell'adattatore come <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Carica le informazioni sullo stato di visualizzazione dell'adattatore salvate dal metodo <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> durante una precedente richiesta alla pagina in cui si trova il controllo associato a questo adattatore di controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un adapter deve gestire le proprie informazioni di stato di visualizzazione, è possibile eseguire l'override di <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> metodi.  
  
 Un adapter deve gestire le informazioni sullo stato di visualizzazione quando sono presenti dati che devono essere mantenuti in tutte le richieste, indipendentemente dallo stato di visualizzazione del controllo associato. Ad esempio, un controllo griglia nel browser per computer desktop può eseguire il rendering come una singola visualizzazione delle righe e colonne di valori. In altri browser, potrebbe separare il rendering in visualizzazioni multiple separate, ad esempio un elenco di righe e dettagli di una singola riga. L'adapter dovrà gestire i dati per le viste che non sono attualmente attive in stato di visualizzazione.  
  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> metodo viene chiamato immediatamente prima di <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> metodo il `LoadState` fase del ciclo di vita. Lo stato di visualizzazione di adapter è separata e oltre che dello stato di visualizzazione del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Esegue l'override del metodo <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> per il controllo associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è presente un adattatore collegato a un <xref:System.Web.UI.Control> oggetto e <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> viene eseguito l'override di metodo, viene chiamato il metodo di override anziché il <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> metodo.  
  
 Eseguire l'override <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> per eseguire l'elaborazione di destinazione specifico nel `Initialize` fase del ciclo di vita di controllo. In genere, queste sono funzioni che vengono eseguite quando viene creato un controllo.  
  
   
  
## Examples  
 Esempio di codice seguente deriva da una scheda di controllo personalizzato di <xref:System.Web.UI.Adapters.ControlAdapter> classe. Viene quindi eseguito l'override di <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> metodo per impostare una proprietà del controllo associato e chiamare il metodo di base per completare l'inizializzazione del controllo.  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si eredita dal <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe e l'adattatore esegue l'override di <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> (metodo), l'adapter deve chiamare il metodo di classe di base corrispondente, che a sua volta chiama il <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> (metodo). Se il <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> non viene chiamato, il <see cref="E:System.Web.UI.Control.Init" /> non verrà generato l'evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Esegue l'override del metodo <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> per il controllo associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è presente un adattatore collegato a un <xref:System.Web.UI.Control> oggetto e <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> viene eseguito l'override di metodo, viene chiamato il metodo di override anziché il <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> metodo.  
  
 Eseguire l'override di <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> metodo per eseguire l'elaborazione di destinazione specifico nel `Load` fase del ciclo di vita di controllo. In genere, queste sono funzioni che devono essere eseguite per ogni richiesta client.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si eredita dal <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe e l'adattatore esegue l'override di <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> (metodo), l'adapter deve chiamare il metodo di classe di base corrispondente, che a sua volta chiama il <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> (metodo). Se <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> non viene chiamato, il <see cref="E:System.Web.UI.Control.Load" /> non verrà generato l'evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Esegue l'override del metodo <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> per il controllo associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è presente un adattatore collegato a un <xref:System.Web.UI.Control> oggetto e <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> viene eseguito l'override di metodo, viene chiamato il metodo di override anziché il <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> metodo.  
  
 Eseguire l'override di <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> metodo per eseguire l'elaborazione di destinazione specifico nel `PreRender` fase del ciclo di vita di controllo. In genere, queste sono funzioni che precedono immediatamente il rendering dell'output del controllo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si eredita dal <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe e l'adattatore esegue l'override di <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> (metodo), l'adapter deve chiamare il metodo di classe di base corrispondente, che a sua volta chiama il <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> (metodo). Se il <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> non viene chiamato, il <see cref="E:System.Web.UI.Control.PreRender" /> non verrà generato l'evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Oggetto <see cref="T:System.EventArgs" /> che contiene i dati dell'evento.</param>
        <summary>Esegue l'override del metodo <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> per il controllo associato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se è presente un adattatore collegato a un <xref:System.Web.UI.Control> oggetto e <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> viene eseguito l'override di metodo, viene chiamato il metodo di override anziché il <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> metodo.  
  
 Eseguire l'override di <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> metodo per eseguire l'operazione di elaborazione specifica di destinazione nel `Unload` fase del ciclo di vita di controllo. In genere, queste sono funzioni di pulizia che precedono la disposizione del controllo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si eredita dal <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe e l'adattatore esegue l'override di <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> (metodo), l'adapter deve chiamare il metodo di classe di base corrispondente, che a sua volta chiama il <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> (metodo). Se <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> non viene chiamato, il <see cref="E:System.Web.UI.Control.Unload" /> non verrà generato l'evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un riferimento alla pagina in cui si trova il controllo associato a questo adattatore.</summary>
        <value>Oggetto <see cref="T:System.Web.UI.Page" /> che fornisce accesso all'istanza della pagina in cui si trova il controllo associato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> fornisce l'accesso a proprietà di <xref:System.Web.UI.Page?displayProperty=nameWithType> oggetto in cui si trova il controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un riferimento all'adattatore di pagina per la pagina in cui si trova il controllo associato.</summary>
        <value>Oggetto <see cref="T:System.Web.UI.Adapters.PageAdapter" /> per la pagina in cui si trova il controllo associato all'oggetto <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> fornisce l'accesso al <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> dell'oggetto per il <xref:System.Web.UI.Page> oggetto in cui il <xref:System.Web.UI.Control> oggetto associato all'oggetto corrente <xref:System.Web.UI.Adapters.ControlAdapter> si trova l'oggetto.  
  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> proprietà può essere utilizzata per accedere ad altri elementi a livello di adattatore di pagina, ad esempio funzioni specifico della destinazione comuni che è possibile applicare a vari tipi di controlli della pagina.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Web.UI.HtmlTextWriter" /> da utilizzare per eseguire il rendering dell'output specifico della destinazione.</param>
        <summary>Genera il markup specifico della destinazione per il controllo a cui è associato l'adattatore del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eseguire l'override di <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metodo per generare il markup specifico della destinazione da inviare al browser client. Il <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> metodo viene chiamato al posto di <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> metodo se un <xref:System.Web.UI.Adapters.ControlAdapter> oggetto è associato a un <xref:System.Web.UI.Control> oggetto.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si eredita dal <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), il <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> chiamate al metodo di base di <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> metodo. Pertanto, esegue l'override del <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metodo deve chiamare il <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metodo di base solo se l'elaborazione è in aggiunta a non invece del <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> (metodo).  
  
 Per un controllo composito, lo sviluppatore dell'adattatore deve garantire che i controlli figlio vengano eseguito il rendering. Se il <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> cause metodo rendering dei controlli figlio, ma non genera markup, potrebbe essere appropriata per il <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metodo da chiamare il metodo di base. Se specifico della destinazione di rendering dei controlli figlio è necessario, l'adapter deve implementare il <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metodo e chiamare il <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metodo il <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metodo.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Oggetto <see cref="T:System.Web.UI.HtmlTextWriter" /> da utilizzare per eseguire il rendering dell'output specifico della destinazione.</param>
        <summary>Genera il markup specifico della destinazione per i controlli figlio in un controllo composito al quale è collegato l'adattatore del controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eseguire l'override di <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> metodo quando è necessario generare il markup specifico della destinazione per l'insieme di controlli figlio di un controllo composito, inoltre, per il markup per i singoli controlli figlio.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si eredita dal <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), per un controllo composito, lo sviluppatore dell'adattatore deve garantire che i controlli figlio vengano eseguito il rendering. Se l'adapter esegue l'override di <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> , il metodo deve chiamare il <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> un override del metodo di <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> (metodo).  
  
 Se il <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> cause metodo rendering dei controlli figlio, ma non genera markup, potrebbe essere appropriata per il <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> metodo da chiamare il metodo di base, che chiama il <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> (metodo), anziché implementare un override per il <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> metodo.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva le informazioni sullo stato del controllo per l'adattatore del controllo.</summary>
        <returns>
          <see cref="T:System.Object" /> contenente le informazioni sullo stato del controllo dell'adattatore come <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo stato del controllo è l'informazione essenziale necessaria anche se lo stato di visualizzazione è disabilitato. Quando un adapter deve gestire le proprie informazioni di stato di controllo, è possibile eseguire l'override di <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> metodi.  
  
 Un adapter potrebbe essere necessario mantenere le informazioni sullo stato di controllo quando sono presenti funzionalità che è necessario disporre di stato mantenuto su tutte le richieste, indipendentemente dallo stato del controllo associato. Ad esempio, un controllo composito costituito da una visualizzazione di testo di grandi dimensioni e un gruppo di <xref:System.Web.UI.WebControls.RadioButton> potrebbero eseguire il rendering di controlli come una singola visualizzazione nel browser per computer desktop. In altri browser, è possibile suddividerlo il rendering, ovvero una visualizzazione per la visualizzazione di testo e l'altro per il gruppo di pulsanti di opzione. L'adapter devono mantenere il proprio specifico della destinazione di informazioni sulla visualizzazione attualmente attiva.  
  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> metodo viene chiamato immediatamente dopo il <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> metodo il `SaveState` fase del ciclo di vita. Lo stato del controllo scheda è separata e oltre che dello stato di controllo del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva le informazioni sullo stato di visualizzazione per l'adattatore del controllo.</summary>
        <returns>Oggetto <see cref="T:System.Object" /> che contiene le informazioni sullo stato di visualizzazione dell'adattatore come <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando un adapter deve gestire le proprie informazioni di stato di visualizzazione, è possibile eseguire l'override di <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> e <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> metodi.  
  
 Un adapter deve gestire le informazioni sullo stato di visualizzazione quando sono presenti dati che devono essere mantenuti in tutte le richieste, indipendentemente dallo stato di visualizzazione associato del controllo. Ad esempio, un controllo griglia nel browser per computer desktop può eseguire il rendering come una singola visualizzazione delle righe e colonne di valori. In altri browser, potrebbe separare il rendering in visualizzazioni multiple separate, ad esempio un elenco di righe e dettagli di una singola riga. L'adapter dovrà gestire i dati per le viste che non sono attualmente attive in stato di visualizzazione.  
  
 Il <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> metodo viene chiamato immediatamente prima di <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> metodo il `SaveState` fase del ciclo di vita. Lo stato di visualizzazione di adapter è separata e oltre che dello stato di visualizzazione del controllo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>