<Type Name="EntityCollection&lt;TEntity&gt;" FullName="System.Data.Objects.DataClasses.EntityCollection&lt;TEntity&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="45b9bfc40b016ca73dee531ab7fda4bba501d89f" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="it-IT" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53231755" /></Metadata><TypeSignature Language="C#" Value="public sealed class EntityCollection&lt;TEntity&gt; : System.Data.Objects.DataClasses.RelatedEnd, System.Collections.Generic.ICollection&lt;TEntity&gt;, System.Collections.Generic.IEnumerable&lt;TEntity&gt;, System.ComponentModel.IListSource where TEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityCollection`1&lt;class TEntity&gt; extends System.Data.Objects.DataClasses.RelatedEnd implements class System.Collections.Generic.ICollection`1&lt;!TEntity&gt;, class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt;, class System.Collections.IEnumerable, class System.ComponentModel.IListSource" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.DataClasses.EntityCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityCollection(Of TEntity)&#xA;Inherits RelatedEnd&#xA;Implements ICollection(Of TEntity), IEnumerable(Of TEntity), IListSource" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TEntity&gt;&#xA; where TEntity : classpublic ref class EntityCollection sealed : System::Data::Objects::DataClasses::RelatedEnd, System::Collections::Generic::ICollection&lt;TEntity&gt;, System::Collections::Generic::IEnumerable&lt;TEntity&gt;, System::ComponentModel::IListSource" />
  <TypeSignature Language="F#" Value="type EntityCollection&lt;'Entity (requires 'Entity : null)&gt; = class&#xA;    inherit RelatedEnd&#xA;    interface ICollection&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface seq&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface IEnumerable&#xA;    interface IListSource" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Data.Objects.DataClasses.RelatedEnd</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TEntity">Tipo di entità della raccolta.</typeparam>
    <summary>Rappresenta una raccolta di oggetti nel lato "molti" di una relazione.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601> è una raccolta di oggetti di un determinato tipo di entità che rappresenta il lato "molti" di una relazione uno-a-molti o molti-a-molti.  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601> viene restituito da una proprietà di navigazione. Utilizzare il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> per caricare oggetti correlati in <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Per archiviare una raccolta di oggetti non correlato di un tipo di entità specifico, ad esempio il risultato di un oggetto <xref:System.Data.Objects.ObjectQuery%601>, utilizzare un'istanza della classe <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601> può contenere un oggetto <xref:System.Data.Objects.DataClasses.EntityReference%601> corrispondente. Quando <xref:System.Data.Objects.DataClasses.EntityCollection%601> e <xref:System.Data.Objects.DataClasses.EntityReference%601> modellano le entità finali opposte della stessa relazione, l'integrità della relazione viene mantenuta a livello di oggetto. Le due classi sono sincronizzate automaticamente.  
  
 Questa classe non può essere ereditata.  
  
   
  
## Examples  
 Questo esempio è basato il. Per eseguire il codice incluso in questo esempio, è necessario avere già aggiunto il modello Sales di Adventure Works al progetto e avere configurato il progetto per l'utilizzo di Entity Framework. A tale scopo, completare le procedure in [come: Configurare manualmente un progetto Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [come: File di Mapping e definire il modello manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 In questo esempio vengono effettuate le operazioni seguenti:  
  
1.  Vengono create due nuove entità `SalesOrderHeader` che vengono aggiunte all'entità `Contact`.  
  
2.  Vengono ottenute tutte le entità finali correlate dall'oggetto <xref:System.Data.Objects.DataClasses.RelationshipManager> associato all'entità `Contact`.  
  
3.  Viene scorsa la raccolta di oggetti <xref:System.Data.Objects.DataClasses.IRelatedEnd>.  
  
4.  Viene ottenuto l'oggetto <xref:System.Data.Objects.DataClasses.EntityCollection%601> per ogni entità finale correlata.  
  
5.  Viene utilizzato il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> per rimuovere un'entità dalla raccolta.  
  
6.  Viene chiamato il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> per determinare se l'oggetto è stato rimosso dalla raccolta.  
  
7.  Viene utilizzato il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> per aggiungere nuovamente l'entità.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore pubblico per <xref:System.Data.Objects.DataClasses.EntityCollection%601> deve essere utilizzato da Object Services durante la deserializzazione degli oggetti grafici. È necessario accedere a un'istanza di <xref:System.Data.Objects.DataClasses.EntityCollection%601> da una proprietà di navigazione anziché utilizzare questo costruttore.  
  
 Per archiviare una raccolta di oggetti non correlata di un tipo di entità specifico, ad esempio il risultato di un oggetto <xref:System.Data.Objects.ObjectQuery%601>, utilizzare un'istanza di <xref:System.Collections.Generic.List%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Add : 'Entity -&gt; unit" Usage="entityCollection.Add entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Oggetto da aggiungere alla raccolta. L'oggetto <paramref name="entity" /> deve implementare <see cref="T:System.Data.Objects.DataClasses.IEntityWithRelationships" />.</param>
        <summary>Aggiunge un oggetto alla raccolta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> aggiunge un oggetto a <xref:System.Data.Objects.DataClasses.EntityCollection%601> e crea una relazione tra i due oggetti. Quando l'oggetto di origine viene connesso a un'istanza di <xref:System.Data.Objects.ObjectContext>, il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> aggiunge inoltre l'oggetto a <xref:System.Data.Objects.ObjectContext>. Questa operazione viene tradotta in un'operazione di inserimento nell'origine dati quando viene chiamato il metodo <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Per altre informazioni, vedere [creazione, aggiunta, modifica e l'eliminazione di oggetti](https://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 Il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> può essere chiamato più volte sulla stessa istanza dell'oggetto.  
  
   
  
## Examples  
 Questo esempio è basato il. Per eseguire il codice incluso in questo esempio, è necessario avere già aggiunto il modello Sales di Adventure Works al progetto e avere configurato il progetto per l'utilizzo di Entity Framework. A tale scopo, completare le procedure in [come: Configurare manualmente un progetto Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [come: File di Mapping e definire il modello manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 In questo esempio vengono create due nuove entità `SalesOrderHeader` che vengono aggiunte all'entità `Contact` e, dopo avere rimosso un oggetto, viene utilizzato il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> per aggiungere nuovamente l'oggetto alla raccolta.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Attach">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definisce una relazione tra due oggetti connessi in un contesto dell'oggetto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Collections.Generic.IEnumerable&lt;TEntity&gt; entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Attach(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entities As IEnumerable(Of TEntity))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Collections::Generic::IEnumerable&lt;TEntity&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="override this.Attach : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit" Usage="entityCollection.Attach entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TEntity&gt;" />
      </Parameters>
      <Docs>
        <param name="entities">Raccolta di oggetti nel contesto dell'oggetto correlati all'oggetto di origine.</param>
        <summary>Definisce le relazioni tra un oggetto e una raccolta di oggetti correlati in un contesto dell'oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.Data.Objects.ObjectContext.Attach%2A> viene utilizzato per definire le relazioni tra un oggetto e una raccolta di oggetti correlati quando sia l'oggetto di origine che la raccolta di oggetti correlati sono già presenti nel contesto dell'oggetto. Per connettere un oggetto o un oggetto grafico in cui le relazioni sono già definite, chiamare il metodo <xref:System.Data.Objects.ObjectContext.Attach%2A> su <xref:System.Data.Objects.ObjectContext>. Per creare un nuovo oggetto correlato all'oggetto di origine, chiamare il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> su <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Per altre informazioni, vedere [collegamento e scollegamento di oggetti](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Se la raccolta è stata già riempita o parzialmente riempita, il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> unisce le entità esistenti con le entità specificate. Le entità specificate non vengono considerate come il set completo di entità correlate.  
  
 Tutte le entità passate devono trovarsi nello stato <xref:System.Data.EntityState.Unchanged> o <xref:System.Data.EntityState.Modified>. Gli oggetti nello stato <xref:System.Data.EntityState.Deleted> sono consentiti solo quando è in corso la registrazione dell'istanza della relazione da parte del gestore degli stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'insieme <paramref name="entities" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto di origine o un oggetto nell'insieme <paramref name="entities" /> è <see langword="null" /> o non si trova nello stato <see cref="F:System.Data.EntityState.Unchanged" /> o <see cref="F:System.Data.EntityState.Modified" />.  
  
oppure 
Non è possibile definire la relazione in base ai metadati EDM. Questa condizione può verificarsi quando l'associazione nello schema concettuale non supporta una relazione tra i due tipi.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Attach(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Attach : 'Entity -&gt; unit" Usage="entityCollection.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Oggetto da connettere.</param>
        <summary>Definisce una relazione tra due oggetti connessi in un contesto dell'oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> viene utilizzato per definire le relazioni tra due oggetti quando entrambi gli oggetti sono già presenti nel contesto dell'oggetto. Per connettere un oggetto o un oggetto grafico in cui le relazioni sono già definite, chiamare il metodo <xref:System.Data.Objects.ObjectContext.Attach%2A> su <xref:System.Data.Objects.ObjectContext>. Per creare un nuovo oggetto correlato all'oggetto di origine, chiamare il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> su <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Per altre informazioni, vedere [collegamento e scollegamento di oggetti](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Se <xref:System.Data.Objects.DataClasses.EntityCollection%601> ha già caricato gli oggetti, il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> unisce insieme l'oggetto agli oggetti esistenti in <xref:System.Data.Objects.DataClasses.EntityCollection%601>.  
  
 L'oggetto connesso non viene considerato come set completo di oggetti entità correlati.  
  
 L'oggetto associato a <xref:System.Data.Objects.DataClasses.EntityCollection%601> e tutti gli oggetti ad esso connessi devono trovarsi nello stato <xref:System.Data.EntityState.Unchanged> o <xref:System.Data.EntityState.Modified>.  
  
 Gli oggetti nello stato <xref:System.Data.EntityState.Deleted> possono essere connessi solo quando è in corso la registrazione dell'istanza della relazione da parte di <xref:System.Data.Objects.ObjectStateManager>.  
  
   
  
## Examples  
 Questo esempio è basato il. Per eseguire il codice incluso in questo esempio, è necessario avere già aggiunto il modello Sales di Adventure Works al progetto e avere configurato il progetto per l'utilizzo di Entity Framework. A tale scopo, completare le procedure in [come: Configurare manualmente un progetto Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [come: File di Mapping e definire il modello manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Questo esempio associa una raccolta di scollegata `SalesOrderDetail` oggetti disconnessi e un `SalesOrderHeader` dell'oggetto a un contesto dell'oggetto e di definire le relazioni tra le `SalesOrderHeader` oggetto e ogni `SalesOrderDetail` oggetto.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Quando l'oggetto <paramref name="entity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Quando <paramref name="entity" /> non può essere correlato all'oggetto di origine. Questa condizione può verificarsi quando l'associazione nello schema concettuale non supporta una relazione tra i due tipi.  
  
-oppure- 
Quando uno qualsiasi degli oggetti è <see langword="null" /> o non si trova nello stato <see cref="F:System.Data.EntityState.Unchanged" /> o <see cref="F:System.Data.EntityState.Modified" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="override this.Clear : unit -&gt; unit" Usage="entityCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutte le entità dalla raccolta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.Clear%2A> effettua le operazioni seguenti:  
  
-   Imposta il <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> flag `false`.  
  
-   Rimuove tutte le entità dalla raccolta.  
  
-   Disconnette le relazioni tra le entità rimosse e il proprietario di <xref:System.Data.Objects.DataClasses.EntityCollection%601> da <xref:System.Data.Objects.ObjectStateManager>.  
  
-   Rimuove il proprietario di <xref:System.Data.Objects.DataClasses.EntityCollection%601> dalle entità correlate.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (entity As TEntity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(TEntity entity);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'Entity -&gt; bool&#xA;override this.Contains : 'Entity -&gt; bool" Usage="entityCollection.Contains entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Oggetto da individuare nella raccolta <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</param>
        <summary>Determina se nella raccolta è presente un oggetto specifico.</summary>
        <returns><see langword="true" /> se l'oggetto si trova in <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizza il metodo <xref:System.Object.Equals%2A?displayProperty=nameWithType> per confrontare l'oggetto specificato con gli oggetti già presenti nella raccolta.  
  
   
  
## Examples  
 Questo esempio è basato il. Per eseguire il codice incluso in questo esempio, è necessario avere già aggiunto il modello Sales di Adventure Works al progetto e avere configurato il progetto per l'utilizzo di Entity Framework. A tale scopo, completare le procedure in [come: Configurare manualmente un progetto Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [come: File di Mapping e definire il modello manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 In questo esempio vengono effettuate le operazioni seguenti:  
  
1.  Vengono create due nuove entità `SalesOrderHeader` che vengono aggiunte all'entità `Contact`.  
  
2.  Vengono ottenute tutte le entità finali correlate dall'oggetto <xref:System.Data.Objects.DataClasses.RelationshipManager> associato all'entità Contact.  
  
3.  Viene scorsa la raccolta di oggetti <xref:System.Data.Objects.DataClasses.IRelatedEnd>.  
  
4.  Viene ottenuto l'oggetto <xref:System.Data.Objects.DataClasses.EntityCollection%601> per ogni entità finale correlata.  
  
5.  Viene utilizzato il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> per rimuovere un'entità dalla raccolta.  
  
6.  Viene chiamato il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> per determinare se l'oggetto è stato rimosso dalla raccolta.  
  
7.  Viene utilizzato il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> per aggiungere nuovamente l'entità.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (TEntity[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!TEntity[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As TEntity(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;TEntity&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'Entity[] * int -&gt; unit&#xA;override this.CopyTo : 'Entity[] * int -&gt; unit" Usage="entityCollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="TEntity[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice in cui effettuare la copia.</param>
        <param name="arrayIndex">Indice in base zero nella matrice in corrispondenza del quale ha inizio la copia.</param>
        <summary>Copia tutto il contenuto della raccolta in una matrice, iniziando dall'indice specificato della matrice di destinazione.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Data.Objects.DataClasses.EntityCollection&lt;'Entity (requires 'Entity : null)&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di oggetti contenuti nella raccolta.</summary>
        <value>Numero di elementi contenuti in <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La proprietà <xref:System.Data.Objects.DataClasses.EntityCollection%601.Count%2A> ottiene il numero di entità attualmente presente nella raccolta locale e non riflette le dimensioni della raccolta nell'origine dati. Un conteggio di zero non indica necessariamente che la raccolta correlata sia vuota. Per determinare le dimensioni della raccolta nell'origine dati, chiamare il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> o includere l'oggetto correlato nel percorso della query. Per altre informazioni, vedere [caricamento di oggetti correlati](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSourceQuery">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;TEntity&gt; CreateSourceQuery ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!TEntity&gt; CreateSourceQuery() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.CreateSourceQuery" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSourceQuery () As ObjectQuery(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;TEntity&gt; ^ CreateSourceQuery();" />
      <MemberSignature Language="F#" Value="override this.CreateSourceQuery : unit -&gt; System.Data.Objects.ObjectQuery&lt;'Entity (requires 'Entity : null)&gt;" Usage="entityCollection.CreateSourceQuery " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una query di oggetto che, quando eseguita, restituisce lo stesso set di oggetti presente nella raccolta corrente.</summary>
        <returns><see cref="T:System.Data.Objects.ObjectQuery`1" /> che rappresenta la raccolta di entità.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene utilizzata per ottenere una nuova istanza di <xref:System.Data.Objects.ObjectQuery%601> che restituisce lo stesso set di oggetti. Ciò si rivela utile come punto di partenza per join più complessi, unioni o query filtrate o per restituire gli stessi oggetti in un stato Detached utilizzando l'opzione <xref:System.Data.Objects.MergeOption.NoTracking>.  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.CreateSourceQuery%2A> viene usato per filtrare gli oggetti in un <xref:System.Data.Objects.DataClasses.EntityCollection%601> che consentono di associare solo gli oggetti di un tipo specifico. Per altre informazioni, vedere [associazione di oggetti ai controlli](https://msdn.microsoft.com/library/2fd34855-929b-4303-a91e-4bb69d958f2b).  
  
   
  
## Examples  
 Questo esempio è basato su una versione modificata di. Questa versione supporta l'ereditarietà tabella per tipo con `Course` come tipo astratto. Completare la procedura dettagliata per modificare il modello School per supportare l'esempio di ereditarietà tabella per tipo usato in questo argomento.  
  
 In questo esempio viene illustrato come utilizzare <xref:System.Data.Objects.DataClasses.EntityCollection%601.CreateSourceQuery%2A> per filtrare gli oggetti in un <xref:System.Data.Objects.DataClasses.EntityCollection%601> ed eseguire l'associazione solo agli oggetti di un tipo specifico. Per una versione completa di questo esempio, vedere [come: Associare controlli a tipi derivati](https://msdn.microsoft.com/library/09730c14-3b7b-4563-af4a-7ecfa4e34bd5).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Quando l'oggetto si trova nello stato <see cref="F:System.Data.EntityState.Added" />.  
  
-oppure- 
Quando l'oggetto si trova nello stato <see cref="F:System.Data.EntityState.Detached" /> con <see cref="T:System.Data.Objects.MergeOption" /> diverso da <see cref="F:System.Data.Objects.MergeOption.NoTracking" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;TEntity&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!TEntity&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;TEntity&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'Entity (requires 'Entity : null)&gt;" Usage="entityCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore utilizzato per scorrere gli oggetti della raccolta.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> che scorre il set di valori memorizzati nella cache da <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Data.Objects.DataClasses.EntityCollection&lt;'Entity (requires 'Entity : null)&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> è di sola lettura.</summary>
        <value>Restituisce sempre <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Load(System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="override this.Load : System.Data.Objects.MergeOption -&gt; unit" Usage="entityCollection.Load mergeOption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="mergeOption">Specifica il modo in cui gli oggetti della raccolta devono essere uniti con gli eventuali oggetti restituiti dalle query precedenti sullo stesso oggetto <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Carica gli oggetti correlati nella raccolta utilizzando l'opzione di merge specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Questo metodo chiama interna `RelatedEnd.ValidateLoad` prima di caricare la raccolta, che verifica che una chiamata al metodo <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> ha le condizioni corrette. Il `RelatedEnd.ValidateLoad` metodo controlla che:

* Un valore valido <xref:System.Data.Objects.ObjectContext> esiste.
* L'entità non si trova in un <xref:System.Data.EntityState.Deleted> dello stato.
* <xref:System.Data.Objects.MergeOption> per la <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> deve essere <xref:System.Data.Objects.MergeOption.NoTracking> solo se l'entità di origine è stata <xref:System.Data.Objects.MergeOption.NoTracking>. Se l'entità di origine è stata recuperata con qualsiasi altro <xref:System.Data.Objects.MergeOption>, il <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> <xref:System.Data.Objects.MergeOption> può essere qualsiasi valore diverso <xref:System.Data.Objects.MergeOption.NoTracking> (ad esempio, l'entità è stato possibile sono stato caricato con <xref:System.Data.Objects.MergeOption.OverwriteChanges> e il <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> opzione può essere <xref:System.Data.Objects.MergeOption.AppendOnly>).
* Se `mergeOption` viene <xref:System.Data.Objects.MergeOption.NoTracking>, <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> non viene chiamato su un'entità già caricata e <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> non viene chiamato su una non vuota, non con rilevamento <xref:System.Data.Objects.DataClasses.RelatedEnd>.
  
 Quando gli oggetti nella raccolta sono già caricati nel <xref:System.Data.Objects.ObjectContext>, il <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> metodo impone la <xref:System.Data.Objects.MergeOption> specificato da di `mergeOption` parametro. Per altre informazioni, vedere [risoluzione di identità, gestione dello stato e rilevamento modifiche](https://msdn.microsoft.com/library/3bd49311-0e72-4ea4-8355-38fe57036ba0).  
  
 Per caricare esplicitamente oggetti correlati, è necessario chiamare il `Load` metodo sull'entità finale correlata restituita dalla proprietà di navigazione. Per una relazione uno-a-molti, chiamare il <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Per una relazione uno a uno, chiamare il <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> su <xref:System.Data.Objects.DataClasses.EntityReference%601>. In questo modo, i dati degli oggetti correlati verranno caricati nel contesto dell'oggetto. È possibile enumerare la raccolta di risultati restituiti tramite un `foreach` ciclo (`For Each...Next` in Visual Basic) e richiedere condizionatamente il `Load` metodo sul <xref:System.Data.Objects.DataClasses.EntityReference%601> e <xref:System.Data.Objects.DataClasses.EntityCollection%601> proprietà per ogni entità nei risultati.  
  
 Il <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> metodo carica gli oggetti correlati dall'origine dati o meno <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> è `true`.  
  
> [!NOTE]
>  Quando si chiama il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> durante un'enumerazione `foreach` (C#) o `For Each` (Visual Basic), Object Services tenta di aprire un nuovo lettore dati. Questa operazione non verrà eseguita correttamente a meno che non sia stata abilitata la funzionalità MARS (Multiple Active Result Set) specificando `multipleactiveresultsets=true` nella stringa di connessione. È inoltre possibile caricare il risultato della query in una raccolta <xref:System.Collections.Generic.List%601>. In questo modo viene chiuso il lettore dati ed è possibile enumerare la raccolta per caricare gli oggetti a cui viene fatto riferimento.  
  
 Il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A?displayProperty=nameWithType> viene sincronizzato con il metodo <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Questo esempio è basato il. Per eseguire il codice incluso in questo esempio, è necessario avere già aggiunto il modello Sales di Adventure Works al progetto e avere configurato il progetto per l'utilizzo di Entity Framework. A tale scopo, completare le procedure in [come: Configurare manualmente un progetto Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [come: File di Mapping e definire il modello manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 In questo esempio vengono caricati gli oggetti `SalesOrderHeader` correlati per l'entità `Contact`.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryWithLoad](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querywithload)]
 [!code-vb[DP ObjectServices Concepts#QueryWithLoad](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querywithload)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCollectionDeserialized">
      <MemberSignature Language="C#" Value="public void OnCollectionDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnCollectionDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.OnCollectionDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnCollectionDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnCollectionDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnCollectionDeserialized : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityCollection.OnCollectionDeserialized context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Contesto di flusso.</param>
        <summary>Utilizzato internamente per deserializzare oggetti entità.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSerializing">
      <MemberSignature Language="C#" Value="public void OnSerializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnSerializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.OnSerializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnSerializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnSerializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnSerializing : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityCollection.OnSerializing context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OnSerializing</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Contesto di flusso.</param>
        <summary>Utilizzato internamente per serializzare oggetti entità.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (entity As TEntity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Entity -&gt; bool" Usage="entityCollection.Remove entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Oggetto da rimuovere dalla raccolta.</param>
        <summary>Rimuove un oggetto dalla raccolta e contrassegna la relazione per l'eliminazione.</summary>
        <returns><see langword="true" /> se l'elemento è stato rimosso correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> elimina anche la relazione tra l'oggetto di origine e l'oggetto rimosso dalla raccolta. Se la relazione ha un vincolo di integrità referenziale, la chiamata al metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> su un oggetto dipendente contrassegna per eliminazione sia la relazione che l'oggetto dipendente. Questo si verifica perché il vincolo indica che l'oggetto dipendente non può esistere senza una relazione con il padre. Per altre informazioni, vedere [elemento ReferentialConstraint (CSDL)](https://msdn.microsoft.com/library/24f96a80-85b5-4f2e-a14c-0e3eb6796fa0).  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> Restituisce `false` quando l'oggetto specificato non è nella raccolta.  
  
   
  
## Examples  
 Questo esempio è basato il. Per eseguire il codice incluso in questo esempio, è necessario avere già aggiunto il modello Sales di Adventure Works al progetto e avere configurato il progetto per l'utilizzo di Entity Framework. A tale scopo, completare le procedure in [come: Configurare manualmente un progetto Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [come: File di Mapping e definire il modello manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 In questo esempio viene utilizzato il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> per rimuovere una delle entità dalla raccolta, quindi viene chiamato il metodo <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> per determinare se l'oggetto è stato rimosso dalla raccolta.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'oggetto <paramref name="entity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <paramref name="entity" /> non è collegato allo stesso contesto dell'oggetto.  
  
-oppure- 
L'oggetto <paramref name="entity" /> non contiene un gestore delle relazioni valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore utilizzato per scorrere il set di valori memorizzati nella cache da <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> che scorre il set di valori memorizzati nella cache da <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la raccolta di entità correlate è costituita da oggetti raccolta.</summary>
        <value>Tale proprietà restituisce sempre <see langword="false" /> perché <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> contiene oggetti e non insiemi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.Objects.DataClasses.EntityCollection%601> a un'interfaccia <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce la raccolta come <see cref="T:System.Collections.IList" /> utilizzato per il data binding.</summary>
        <returns>Oggetto <see cref="T:System.Collections.IList" /> di oggetti entità.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Data.Objects.DataClasses.EntityCollection%601> a un'interfaccia <xref:System.ComponentModel.IListSource>.  
  
 Questo metodo consente il data binding a un oggetto <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Viene chiamato dal controllo associato alla raccolta. Per altre informazioni, vedere [associazione di oggetti ai controlli](https://msdn.microsoft.com/library/2fd34855-929b-4303-a91e-4bb69d958f2b).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>