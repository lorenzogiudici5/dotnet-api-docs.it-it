<Type Name="ParallelLoopState" FullName="System.Threading.Tasks.ParallelLoopState">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e4244160069333f5d930b81c7b54173c2ad6d6a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530215" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ParallelLoopState" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ParallelLoopState extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.ParallelLoopState" />
  <TypeSignature Language="VB.NET" Value="Public Class ParallelLoopState" />
  <TypeSignature Language="C++ CLI" Value="public ref class ParallelLoopState" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ShouldExitCurrentIteration = {ShouldExitCurrentIteration}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Consente alle iterazioni dei cicli paralleli di interagire con altre iterazioni. Un'istanza di questa classe viene fornita dalla classe <see cref="T:System.Threading.Tasks.Parallel" /> a ogni ciclo. Non è possibile creare istanze nel codice utente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che è possibile creare un'istanza di questa classe. Viene generato automaticamente dal compilatore come argomento in una chiamata al <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo. Nell'esempio viene illustrata una situazione di questo tipo.  
  
 Ad esempio costruisce `for` e `foreach` (in c#) e `For` e `For Each` (in Visual Basic) eseguire in sequenza dall'indice più basso al più alto o dal primo oggetto in un set e l'ultimo. Al contrario, il <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> e <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> non metodi. Poiché le iterazioni del ciclo singole eseguite in parallelo, possono iniziare e terminare in qualsiasi ordine. La <xref:System.Threading.Tasks.ParallelLoopState> classe consente a singole iterazioni dei cicli paralleli di interagire tra loro. La <xref:System.Threading.Tasks.ParallelLoopState> classe consente di:  
  
-   Chiudere l'iterazione corrente e impedire qualsiasi iterazioni aggiuntive avvio chiamando il <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo. Questa operazione non influenza le iterazioni che abbia già avviato l'esecuzione.  
  
-   Impedire l'esecuzione chiamando le iterazioni con un indice maggiore dell'indice corrente di <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo. Questa operazione non influenza le iterazioni che abbia già avviato l'esecuzione.  
  
-   Determinare se un'eccezione in qualsiasi iterazione del ciclo, tramite il recupero del valore del <xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A> proprietà.  
  
-   Determinare se un'iterazione del ciclo ha chiamato la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo recuperando il valore di <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> proprietà. È possibile utilizzare questa proprietà per restituire dalle iterazioni del ciclo che ha avviato prima della chiamata al <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo ma sono ancora in esecuzione.  
  
-   Determinare se un'iterazione del ciclo ha chiamato la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo oppure ha generato un'eccezione per il recupero del valore del <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> proprietà.  
  
-   Uscita da un'iterazione con esecuzione prolungata il cui indice è maggiore dell'indice di un'iterazione in cui è stata chiamata interruzione recuperando il valore di <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita fino a 100 iterazioni di un ciclo in parallelo. Consente di sospendere ogni iterazione per un intervallo casuale compreso tra 1 e 1.000 millisecondi. Un valore generato casualmente determina a quali iterazione del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo viene chiamato. Come illustrato nell'esempio, nessuna iterazione il cui indice è maggiore di output di <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> inizio del valore proprietà dopo la chiamata al <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Perché sono ancora soggetti a essere in esecuzione al termine delle iterazioni del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo viene chiamato, le chiamate di ogni iterazione il <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> proprietà per verificare se un'altra iterazione è chiamato il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo. Se il valore della proprietà `true`, l'iterazione controlla il valore del <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> proprietà e, se è maggiore del valore di indice dell'iterazione corrente, termina immediatamente.  
  
 ]]></format>
    </remarks>
    <threadsafe>Oggetto <see cref="T:System.Threading.Tasks.ParallelLoopState" /> istanza deve essere utilizzata solo all'interno del corpo del ciclo a cui è stata fornita un'istanza.  Non è possibile utilizzare un oggetto fornito <see cref="T:System.Threading.Tasks.ParallelLoopState" /> istanza dopo il ciclo associato viene terminato, né distribuirla in modo esplicito da altri thread in modo che tali thread accedervi in qualsiasi momento.  Un altro <see cref="T:System.Threading.Tasks.ParallelLoopState" /> verrà fornita l'istanza per ogni thread coinvolto in un ciclo.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public void Break ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Break() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Break" />
      <MemberSignature Language="VB.NET" Value="Public Sub Break ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Break();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comunica che il ciclo <see cref="T:System.Threading.Tasks.Parallel" /> deve interrompere l'esecuzione non appena è stato raggiunto il numero di iterazioni oltre l'iterazione corrente desiderato dal sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> indica che nessuna iterazione dopo l'iterazione corrente devono essere eseguita. Cancella in modo efficace le iterazioni aggiuntive del ciclo. Tuttavia, non arresta tutte le iterazioni che abbia già avviato l'esecuzione. Ad esempio, se <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> viene chiamato da 100 iterazione di un ciclo parallelo l'iterazione da 0 a 1000, tutte le iterazioni minore di 100 devono ancora essere esecuzione, ma le iterazioni tra 101 e 1000 che non sono ancora stati avviato non sono eseguiti.  
  
 Per le iterazioni di lunga durata che potrebbero essere già in esecuzione, <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> imposta il <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> proprietà all'indice dell'iterazione corrente se l'indice corrente è minore del valore corrente di <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>. Per interrompere le iterazioni, il cui indice è maggiore di iterazione minimo interruzione dall'esecuzione concorrenti, è necessario eseguire le operazioni seguenti:  
  
1.  Controllare se il <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> proprietà `true`.  
  
2.  Uscire dall'iterazione se l'indice è maggiore di <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valore della proprietà.  
  
 Nell'esempio viene illustrata una situazione di questo tipo.  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> è in genere utilizzato negli algoritmi basati sulla ricerca di un ordinamento in cui è presente nell'origine dati.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita fino a 100 iterazioni di un ciclo in parallelo. Consente di sospendere ogni iterazione per un intervallo casuale compreso tra 1 e 1.000 millisecondi. Un valore generato casualmente determina a quali iterazione del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo viene chiamato. Come illustrato nell'esempio, nessuna iterazione il cui indice è maggiore di output di <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> inizio del valore proprietà dopo la chiamata al <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Perché sono ancora soggetti a essere in esecuzione al termine delle iterazioni del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo viene chiamato, le chiamate di ogni iterazione il <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> proprietà per verificare se un'altra iterazione è chiamato il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo. Se il valore della proprietà `true`, l'iterazione controlla il valore del <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> proprietà e, se è maggiore del valore di indice dell'iterazione corrente, termina immediatamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> è stato chiamato precedentemente. <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> e <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> non possono essere utilizzati in combinazione da iterazioni dello stesso ciclo.</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      </Docs>
    </Member>
    <Member MemberName="IsExceptional">
      <MemberSignature Language="C#" Value="public bool IsExceptional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExceptional" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsExceptional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExceptional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExceptional { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se un'iterazione del ciclo ha generato un'eccezione che non è stata gestita da tale iterazione.</summary>
        <value>
          <see langword="true" /> se è stata generata un'eccezione non gestita; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStopped">
      <MemberSignature Language="C#" Value="public bool IsStopped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStopped" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStopped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStopped { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se un'iterazione del ciclo ha chiamato il metodo <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />.</summary>
        <value>
          <see langword="true" /> se un'iterazione ha arrestato il ciclo chiamando il metodo <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le iterazioni del ciclo con esecuzione prolungata, è possibile recuperare il valore della <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> proprietà per determinare se tutte le iterazioni del ciclo di inizio dell'esecuzione prima della chiamata al <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo sono ancora in esecuzione. È quindi possibile utilizzare il valore di <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> proprietà per determinare se deve restituire immediatamente o eseguire normalmente.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita fino a 10.000 iterazioni di un ciclo in parallelo. Consente di sospendere ogni iterazione per un intervallo casuale compreso tra 1 e 1.000 millisecondi. Un valore generato casualmente determina a quali iterazione del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo viene chiamato. Perché sono ancora soggetti a essere in esecuzione al termine delle iterazioni del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo viene chiamato, l'espressione lambda chiama il <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> metodo per verificare se un'altra iterazione è chiamato il <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo. Se restituisce `true`, viene restituito immediatamente all'iterazione.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LowestBreakIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;long&gt; LowestBreakIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int64&gt; LowestBreakIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LowestBreakIteration As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;long&gt; LowestBreakIteration { Nullable&lt;long&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di iterazione minimo del ciclo da cui è stato chiamato l'oggetto <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" />.</summary>
        <value>Numero di iterazione minimo del ciclo da cui è stato chiamato l'oggetto <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" />. Nel caso di un ciclo <see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />, il valore è basato su un indice generato internamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile che più iterazioni di un ciclo parallelo per chiamare il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo. In caso affermativo, questo valore è l'indice minimo di un'iterazione che ha chiamato <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Se nessuna iterazione del ciclo chiamato <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, questa proprietà restituisce `null`. Si noti che il valore della proprietà non è interessato dalle chiamate al <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo.  
  
 Nelle iterazioni di lunga durata in cui tutte le iterazioni dopo l'iterazione che chiama il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> (metodo) non è necessario eseguire, il <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> proprietà viene utilizzata per terminare le iterazioni inizio dell'esecuzione prima della chiamata al <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo. Per interrompere le iterazioni, il cui indice è maggiore di iterazione minimo interruzione dall'esecuzione concorrenti, è necessario eseguire le operazioni seguenti:  
  
1.  Controllare se il <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> proprietà `true`.  
  
2.  Uscire dall'iterazione se l'indice è maggiore di <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valore della proprietà.  
  
 Nell'esempio viene illustrata una situazione di questo tipo.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita fino a 100 iterazioni di un ciclo in parallelo. Consente di sospendere ogni iterazione per un intervallo casuale compreso tra 1 e 1.000 millisecondi. Un valore generato casualmente determina a quali iterazione del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo viene chiamato. In questo modo il cui indice è maggiore di iterazioni il <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valore della proprietà dopo la chiamata per Impossibile avviare il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> (metodo), ma non influisce sulla tutte le iterazioni che abbia già avviato l'esecuzione. Per evitare questi completamento, chiama ogni iterazione il <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> metodo per verificare se un'altra iterazione è chiamato il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo. Se in tal caso, l'iterazione controlla il valore del <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> proprietà e, se è maggiore del valore di indice dell'iterazione corrente, termina immediatamente.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Si noti che, in quanto il <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valore esula dall'ambito all'esterno del ciclo parallelo, è necessario assegnarlo a una variabile che è visibile all'esterno del ciclo, se si desidera mantenere il valore.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
      </Docs>
    </Member>
    <Member MemberName="ShouldExitCurrentIteration">
      <MemberSignature Language="C#" Value="public bool ShouldExitCurrentIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldExitCurrentIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShouldExitCurrentIteration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldExitCurrentIteration { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se terminare l'iterazione corrente del ciclo in base alle richieste fatte da questa o da altre iterazioni.</summary>
        <value>
          <see langword="true" /> se l'iterazione corrente deve essere terminata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> è impostata su `true` in presenza delle condizioni seguenti:  
  
-   Un'iterazione del ciclo chiama <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>.  
  
-   Un'iterazione del ciclo genera un'eccezione.  
  
-   Il ciclo viene annullato.  
  
 Quando questa proprietà è `true`, <xref:System.Threading.Tasks.Parallel> classe in modo proattivo tenterà di impedire l'avvio dell'esecuzione di iterazioni aggiuntive del ciclo. Tuttavia, potrebbe essere casi in cui è possibile impedire l'avvio di altre iterazioni.  
  
 È possibile anche il caso che un'iterazione con esecuzione prolungata ha già avviato l'esecuzione. In questi casi, le iterazioni possono controllare in modo esplicito il <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> proprietà e interrompere l'esecuzione se la proprietà restituisce `true`.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita fino a 100 iterazioni di un ciclo in parallelo. Consente di sospendere ogni iterazione per un intervallo casuale compreso tra 1 e 1.000 millisecondi. Un valore generato casualmente determina a quali iterazione del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo viene chiamato. In questo modo il cui indice è maggiore di iterazioni il <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valore della proprietà dopo la chiamata per Impossibile avviare il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> (metodo), ma non influisce sulla tutte le iterazioni che abbia già avviato l'esecuzione. Per evitare questi completamento, chiama ogni iterazione il <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> metodo per verificare se un'altra iterazione è chiamato il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo. Se in tal caso, l'iterazione controlla il valore del <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> proprietà e, se è maggiore del valore di indice dell'iterazione corrente, termina immediatamente.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comunica che il ciclo <see cref="T:System.Threading.Tasks.Parallel" /> deve interrompere l'esecuzione non appena il sistema lo richieda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata di <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo indica che è necessario eseguire le iterazioni del ciclo che non sono ancora avviate. Cancella in modo efficace le iterazioni aggiuntive del ciclo. Tuttavia, non arresta tutte le iterazioni che abbia già avviato l'esecuzione.  
  
 La chiamata di <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo provoca il <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> proprietà da restituire `true` per un'iterazione del ciclo che è ancora in esecuzione. Questo è particolarmente utile per le iterazioni con esecuzione prolungata, che è possono controllare il <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> proprietà e uscire in anticipo se il valore è `true`.  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> è in genere utilizzato negli algoritmi basati sulla ricerca, in cui dopo un risultato è presente, nessun altra iterazioni necessitano eseguire.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita fino a 10.000 iterazioni di un ciclo in parallelo. Consente di sospendere ogni iterazione per un intervallo casuale compreso tra 1 e 1.000 millisecondi. Un valore generato casualmente determina a quali iterazione del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo viene chiamato. Come illustrato nell'output dell'esempio, nessun iterazioni eseguite dopo la chiamata al <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 Perché sono ancora soggetti a essere in esecuzione al termine delle iterazioni del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo viene chiamato, le chiamate di ogni iterazione il <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> metodo per verificare se un'altra iterazione è chiamato il <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo. Se restituisce `true`, viene restituito immediatamente all'iterazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il metodo <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> è stato chiamato in precedenza. <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> e <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> non possono essere utilizzati in combinazione da iterazioni dello stesso ciclo.</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      </Docs>
    </Member>
  </Members>
</Type>