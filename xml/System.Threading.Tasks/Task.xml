<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d920b17ab80db20fab0e3101b745858eade81dd1" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531695" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un'operazione asincrona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 La <xref:System.Threading.Tasks.Task> classe rappresenta una singola operazione che non restituisce un valore e che in genere esegue in modo asincrono. <xref:System.Threading.Tasks.Task> gli oggetti sono uno dei componenti di centrale di [modello asincrono basato su attività](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) introdotta in .NET Framework 4. Poiché il lavoro eseguito da un <xref:System.Threading.Tasks.Task> in genere viene eseguito l'oggetto in modo asincrono in un pool di thread anziché in modo sincrono sul thread principale dell'applicazione, è possibile utilizzare il <xref:System.Threading.Tasks.Task.Status%2A> , proprietà, nonché <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, e <xref:System.Threading.Tasks.Task.IsFaulted%2A> proprietà per determinare lo stato di un'attività. In genere, un'espressione lambda viene utilizzata per specificare il lavoro per eseguire l'attività.  
  
 Per le operazioni che restituiscono valori, utilizzare la <xref:System.Threading.Tasks.Task%601> classe.  
  
 Contenuto della sezione:  
  
 [Esempi di creazione di un'istanza di attività](#Instant)   
 [Creazione ed esecuzione di un'attività](#Creating)   
 [Separazione di esecuzione e creazione di attività](#Separating)   
 [In attesa del completamento di uno o più attività](#WaitingForOne)   
 [Attività e le impostazioni cultura](#Culture)   
 [Per gli sviluppatori del debugger](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a>Creazione di istanze di attività  
 Nell'esempio seguente crea ed esegue quattro attività. Eseguire tre attività un <xref:System.Action%601> delegato denominato `action`, che accetta un argomento di tipo <xref:System.Object>. Un quarto di attività viene eseguita un'espressione lambda (un <xref:System.Action> delegato) che è definito inline nella chiamata al metodo di creazione di attività. Ogni attività vengano creata un'istanza ed eseguire in modo diverso:  
  
-   Attività `t1` viene creata un'istanza chiamando un costruttore di classe di attività, ma viene avviata chiamando il relativo <xref:System.Threading.Tasks.Task.Start> metodo solo dopo l'attività `t2` è stata avviata.  
  
-   Attività `t2` viene creata un'istanza e avviato in una singola chiamata al metodo chiamando il <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> metodo.  
  
-   Attività `t3` viene creata un'istanza e avviato in una singola chiamata al metodo chiamando il <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metodo.  
  
-   Attività `t4` viene eseguita in modo sincrono sul thread principale chiamando il <xref:System.Threading.Tasks.Task.RunSynchronously> metodo.  
  
 Poiché attività `t4` esegue in modo sincrono, viene eseguita sul thread principale dell'applicazione. Le attività rimanenti in genere eseguite in modo asincrono in uno o più thread del pool.  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>Creazione ed esecuzione di un'attività  
 <xref:System.Threading.Tasks.Task> è possibile creare istanze in diversi modi. L'approccio più comune, che è disponibile a partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], consiste nel chiamare il metodo statico <xref:System.Threading.Tasks.Task.Run%2A> metodo. Il <xref:System.Threading.Tasks.Task.Run%2A> metodo fornisce un modo semplice per avviare un'attività utilizzando i valori predefiniti e senza parametri aggiuntivi. L'esempio seguente usa il <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metodo per avviare un'attività che esegue il ciclo e quindi Visualizza il numero di iterazioni del ciclo:  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 In alternativa e il metodo più comune per avviare un'attività in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], è statica <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodo. Il <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> proprietà restituisce un <xref:System.Threading.Tasks.TaskFactory> oggetto. Esegue l'overload di <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodo consentono di specificare i parametri da passare per le opzioni di creazione di attività e un'utilità di pianificazione. L'esempio seguente usa il <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodo per avviare un'attività. È funzionalmente equivalente al codice nell'esempio precedente.  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 Per esempi più completi, vedere [basato su attività di programmazione asincrona](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>Separazione di esecuzione e creazione di attività  
 La <xref:System.Threading.Tasks.Task> classe fornisce anche costruttori che inizializzano l'attività, ma che non pianificarne l'esecuzione. Per motivi di prestazioni di <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodo è il meccanismo preferito per creare e pianificare le attività di calcolo, ma per gli scenari in cui devono essere separati creazione e la pianificazione, è possibile utilizzare i costruttori e quindi chiamare il <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> metodo per la pianificazione per l'esecuzione in un secondo momento.  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>In attesa del completamento di uno o più attività  
 Poiché le attività in genere eseguite in modo asincrono in un pool di thread, il thread che crea e avvia l'attività continua l'esecuzione non appena l'attività è stata creata un'istanza. In alcuni casi, quando il thread chiamante è il thread principale dell'applicazione, l'applicazione può terminare prima di qualsiasi attività effettivamente inizia l'esecuzione. In altri, la logica dell'applicazione potrebbe richiedere il thread chiamante di continuare l'esecuzione solo quando una o più attività ha completato l'esecuzione. È possibile sincronizzare l'esecuzione del thread chiamante e asincrona le attività viene avviata chiamando un `Wait` metodo per attendere il completamento di uno o più attività.  
  
 Per attendere il completamento di un'attività singola, è possibile chiamare il relativo <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodo. Una chiamata al <xref:System.Threading.Tasks.Task.Wait%2A> metodo blocca il thread chiamante fino al completamento dell'istanza di classe singola esecuzione.  
  
 Nell'esempio seguente viene chiamata senza parametri <xref:System.Threading.Tasks.Task.Wait> metodo per attendere in modo non condizionale fino al completamento di un'attività. L'attività simula lavoro chiamando il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per due secondi.  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 Anche in modo condizionale è possibile attendere un'attività da completare. Il <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> e <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> metodi bloccano il thread chiamante fino al completamento dell'attività o un intervallo di timeout scade, verifica per primo. Poiché nell'esempio seguente viene avviata un'attività che rimane inattivo per due secondi, ma definisce un valore di timeout di un secondo, il thread chiamante si blocca fino a quando il timeout scade e prima dell'attività completata l'esecuzione.  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 È inoltre possibile fornire un token di annullamento chiamando il <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> e <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metodi. Se il token <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> proprietà `true`, il tempo di attesa è stata annullata; se è true quando il <xref:System.Threading.Tasks.Task.Wait%2A> metodo termina.  
  
 In alcuni casi, si consiglia di attendere per il primo di una serie di attività eseguite completare, ma non è l'attenzione quale attività è.  A tale scopo, è possibile chiamare uno degli overload di <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodo.  L'esempio seguente crea tre attività, ognuna delle quali rimane inattiva per un intervallo per determinare da un generatore di numeri casuali. Il <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> metodo attende la prima attività da completare. Nell'esempio vengono quindi visualizzate informazioni sullo stato di tutte le tre attività.  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 È anche possibile attendere tutta una serie di attività da completare tramite la chiamata di <xref:System.Threading.Tasks.Task.WaitAll%2A> metodo. L'esempio seguente crea dieci attività, è in attesa di dieci tutte completate e quindi Visualizza il relativo stato.  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 Si noti che, durante l'attesa del completamento di uno o più attività, tutte le eccezioni generate nelle attività in esecuzione vengono propagate nel thread che chiama il `Wait` metodo, come illustrato nell'esempio seguente. Avvia 12 attività, tre dei quali completare normalmente e tre dei quali genera un'eccezione. Tre viene annullato prima dell'inizio delle sei attività rimanenti, e tre sono annullato mentre sono in esecuzione. Cui vengono generate eccezioni di <xref:System.Threading.Tasks.Task.WaitAll%2A> chiamata al metodo e sono gestite da un `try` / `catch` blocco.  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 Per ulteriori informazioni sulla gestione delle eccezioni nelle operazioni asincrone basate su attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>Attività e le impostazioni cultura  
 A partire dalle App desktop destinate il [!INCLUDE[net_v46](~/includes/net-v46-md.md)], le impostazioni cultura del thread che crea e richiama un'attività diventano parte del contesto del thread. Indipendentemente dalle impostazioni cultura correnti del thread in cui l'attività viene eseguita, le impostazioni cultura correnti dell'attività sono le impostazioni cultura del thread chiamante. Per le app destinate alle versioni di .NET Framework precedenti al [!INCLUDE[net_v46](~/includes/net-v46-md.md)], le impostazioni cultura dell'attività sono le impostazioni cultura del thread in cui viene eseguita l'attività. Per ulteriori informazioni, vedere la sezione "Operazioni asincrone basate su attività e delle impostazioni cultura" nel <xref:System.Globalization.CultureInfo> argomento.  
  
> [!NOTE]
>  App di Store seguono di Windows Runtime in impostazione e recupero delle impostazioni cultura predefinite.  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>Per gli sviluppatori del debugger  
 Per gli sviluppatori implementano debugger personalizzati, più i membri interni e privati di attività possono essere utili (possono cambiare a ogni versione). Il `m_taskId` campo viene utilizzato come archivio di backup per il <xref:System.Threading.Tasks.Task.Id%2A> proprietà, tuttavia l'accesso in questo campo direttamente da un debugger può essere più efficiente dell'accesso lo stesso valore tramite il metodo di richiamo della proprietà (il `s_taskIdCounter` contatore Consente di recuperare il successivo ID disponibile per un'attività). Analogamente, il `m_stateFlags` campo Archivia le informazioni sulla fase corrente del ciclo di vita dell'attività, informazioni accessibili anche tramite il <xref:System.Threading.Tasks.Task.Status%2A> proprietà. Il `m_action` campo Archivia un riferimento al delegato dell'attività e `m_stateObject` campo Archivia lo stato asincrono passato all'attività dallo sviluppatore. Infine, per i debugger che analizzano stack frame, la `InternalWait` metodo funge da indicatore potenziale per quando un'attività sta entrando in un'operazione di attesa.   
  
 ]]></format>
    </remarks>
    <threadsafe>Tutti i membri di <see cref="T:System.Threading.Tasks.Task" />, ad eccezione di <see cref="M:System.Threading.Tasks.Task.Dispose" />, sono thread-safe e possono essere utilizzati da più thread contemporaneamente.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anziché chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetto e avviare un'attività è tramite la chiamata al metodo statico <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> o <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> metodo. L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati dalla chiamata di attività.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> costruttore per creare le attività che recuperano i nomi dei file nelle directory specificate. Tutte le attività di scrivono i nomi dei file in un singolo <xref:System.Collections.Concurrent.ConcurrentBag%601> oggetto. Nell'esempio viene quindi chiamato il <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> metodo per assicurarsi che tutte le attività completate e quindi visualizza un conteggio del numero totale di nomi di file scritti il <xref:System.Collections.Concurrent.ConcurrentBag%601> oggetto.  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 Nell'esempio seguente è identico, ad eccezione del fatto che utilizzato il <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metodo per creare un'istanza ed eseguire l'attività in un'unica operazione. Il metodo restituisce il <xref:System.Threading.Tasks.Task> oggetto che rappresenta l'attività.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="action" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> che verrà considerato dalla nuova attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione specificata e <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anziché chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetto e avviare un'attività è tramite la chiamata al metodo statico <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> e <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> metodi. L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati dalla chiamata di attività.  
  
 Per ulteriori informazioni, vedere [parallelismo delle attività (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) e [annullamento in thread gestiti](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> costruttore per creare un'attività che consente di scorrere i file nella directory C:\Windows\System32. L'espressione lambda chiama il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo per aggiungere informazioni su ogni file da un <xref:System.Collections.Generic.List%601> oggetto. Ogni scollegato attività annidata richiamato dal <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> ciclo controlla lo stato del token di annullamento e, se la richiesta di annullamento, chiama il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodo. Il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodo genera un <xref:System.OperationCanceledException> eccezione gestita in un `catch` blocco quando il thread chiamante chiama il <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodo.  Il <xref:System.Threading.Tasks.Task.Start%2A> viene quindi chiamato il metodo per avviare l'attività.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'istanza <see cref="T:System.Threading.CancellationToken" /> fornita è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="creationOptions">Oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per personalizzare il comportamento dell'attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione e le opzioni di creazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anziché chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetto e avviare un'attività è tramite la chiamata al metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> metodo. L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati dalla chiamata di attività.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="creationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione e lo stato specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anziché chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetto e avviare un'attività è tramite la chiamata al metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> metodo. L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati dalla chiamata di attività.  
  
   
  
## Examples  
 Nell'esempio seguente definisce una matrice di parole 6 lettera. Ogni parola viene quindi passato come argomento per il <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> costruttore, il cui <xref:System.Action%601> delegato codificata i caratteri nella parola, quindi Visualizza la parola originale e la relativa versione codificata.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà considerato dalla nuova attività.</param>
        <param name="creationOptions">Oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per personalizzare il comportamento dell'attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione e le opzioni di creazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anziché chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetto e avviare un'attività è tramite la chiamata al metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> metodo. L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati dalla chiamata di attività.  
  
 Per ulteriori informazioni, vedere [parallelismo delle attività (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) e [annullamento delle attività](~/docs/standard/parallel-programming/task-cancellation.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="creationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà osservato dalla nuova attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione, lo stato e le opzioni specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anziché chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetto e avviare un'attività è tramite la chiamata al metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> metodo. L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati dalla chiamata di attività.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione.</param>
        <param name="creationOptions">Oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per personalizzare il comportamento dell'attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione, lo stato e le opzioni specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anziché chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetto e avviare un'attività è tramite la chiamata al metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> metodo. L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati dalla chiamata di attività.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="creationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà osservato dalla nuova attività.</param>
        <param name="creationOptions">Oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per personalizzare il comportamento dell'attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione, lo stato e le opzioni specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anziché chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetto e avviare un'attività è tramite la chiamata al metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> metodo. L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati dalla chiamata di attività.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="creationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto stato fornito quando è stato creato <see cref="T:System.Threading.Tasks.Task" /> oppure null se non ne è stato fornito alcuno.</summary>
        <value>Oggetto <see cref="T:System.Object" /> che rappresenta i dati relativi allo stato passati all'attività al momento della creazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il cast dell'oggetto al tipo originale per recuperare i dati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un'attività già completata correttamente.</summary>
        <value>Attività completata correttamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce un'attività il cui <xref:System.Threading.Tasks.Task.Status%2A> è impostata su <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Per creare l'attività restituisce un valore che viene eseguito fino al completamento, chiamare il <xref:System.Threading.Tasks.Task.FromResult%2A> metodo.  
  
 I tentativi ripetuti di recuperare il valore della proprietà potrebbero non restituire sempre la stessa istanza.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">
          <see langword="true" /> per provare a effettuare il marshalling della continuazione nel contesto originale acquisito; in caso contrario, <see langword="false" />.</param>
        <summary>Configura un elemento awaiter usato per attendere questo oggetto <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Oggetto usato per attendere questa attività.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta in modo prematuro perché annullata.  
  
   
  
## Examples  
 L'esempio seguente definisce un'attività che popola una matrice con 100 casuale valori data e ora. Usa il <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> metodo per selezionare più recente e i valori di data più recenti dopo che la matrice è completamente popolata.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Perché un'applicazione console può terminare prima che l'attività di continuazione viene eseguita, il <xref:System.Threading.Tasks.Task.Wait> metodo viene chiamato per verificare che la continuazione al termine dell'esecuzione prima dell'esempio.  
  
 Per un altro esempio, vedere [concatenamento di attività tramite attività di continuazione](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationAction" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento dell'attività. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante vengono passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione di continuazione.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e viene eseguita al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita oppure uscire in anticipo a causa dell'annullamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationAction" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea una continuazione che riceve un token di annullamento e viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta in modo prematuro perché annullata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato il token è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationAction" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire in base all'oggetto <c>continuationOptions</c> specificato. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuazione che viene eseguita al completamento dell'attività di destinazione in base all'oggetto <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> specificato.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente. Se i criteri di continuazione specificato tramite il `continuationOptions` parametro non vengono soddisfatte, verrà annullata l'attività di continuazione anziché pianificata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare <xref:System.Threading.Tasks.TaskContinuationOptions> per specificare che un'attività di continuazione deve essere eseguito in modo sincrono al completamento dell'attività precedente. (Se l'attività specificata è già stata completata l'ora <xref:System.Threading.Tasks.Task.ContinueWith%2A> viene chiamato, sincroni continuazione verrà eseguita nel chiamante thread <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationAction" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta in modo prematuro perché annullata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationAction" /> è <see langword="null" />.  
  
 oppure  
  
 L'argomento <paramref name="scheduler" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione di continuazione.</param>
        <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e un token di annullamento e che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta in modo prematuro perché annullata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationAction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'istanza <see cref="T:System.Threading.CancellationToken" /> fornita è già stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e viene eseguita al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione viene eseguita in base a un set di condizioni specificate.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente. Se i criteri di continuazione specificato tramite il `continuationOptions` parametro non vengono soddisfatte, verrà annullata l'attività di continuazione anziché pianificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationAction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />.  Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione di continuazione.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta in modo prematuro perché annullata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire in base all'oggetto <c>continuationOptions</c> specificato. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita al completamento dell'attività di destinazione in base all'oggetto <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> specificato. La continuazione riceve un token di annullamento e usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente. Se i criteri specificati tramite il `continuationOptions` parametro non vengono soddisfatte, verrà annullata l'attività di continuazione anziché pianificata.  
  
   
  
## Examples  
 Di seguito è riportato un esempio di uso di ContinueWith per l'esecuzione di lavoro in background e nell'utente del thread di interfaccia.  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato il token è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationAction" /> è Null.  
  
 oppure  
  
 L'argomento <paramref name="scheduler" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione di continuazione.</param>
        <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e un token di annullamento e che viene eseguita al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione viene eseguita in base a un set di condizioni specificate e usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente. Se i criteri specificati tramite il `continuationOptions` parametro non vengono soddisfatte, verrà annullata l'attività di continuazione anziché pianificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'istanza <see cref="T:System.Threading.CancellationToken" /> fornita è già stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task`1" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di destinazione e restituisce un valore.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta in modo prematuro perché annullata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il metodo ContinueWith:  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationFunction" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dalla funzione di continuazione.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione, quindi restituisce un valore.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta in modo prematuro perché annullata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione e restituisce un valore. La continuazione riceve un token di annullamento.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta in modo prematuro perché annullata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato il token è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationFunction" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire in base alla condizione specificata in <c>continuationOptions</c>. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuazione che viene eseguita in base alle opzioni di continuazione specificate e restituisce un valore.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente. Se i criteri di continuazione specificato tramite il `continuationOptions` parametro non vengono soddisfatte, verrà annullata l'attività di continuazione anziché pianificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationFunction" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione e restituisce un valore. La continuazione usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta in modo prematuro perché annullata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationFunction" /> è Null.  
  
 oppure  
  
 L'argomento <paramref name="scheduler" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dalla funzione di continuazione.</param>
        <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione e restituisce un valore. La continuazione riceve informazioni sullo stato fornite dal chiamante e un token di annullamento.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta in modo prematuro perché annullata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'istanza <see cref="T:System.Threading.CancellationToken" /> fornita è già stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dalla funzione di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuazione che viene eseguita in base alle opzioni specificate per la continuazione delle attività al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione riceve informazioni sullo stato fornite dal chiamante.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente. Se i criteri di continuazione specificato tramite il `continuationOptions` parametro non vengono soddisfatte, verrà annullata l'attività di continuazione anziché pianificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />.  Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dalla funzione di continuazione.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione riceve informazioni sullo stato fornite dal chiamante e usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente, se viene completato a causa di completamento dell'esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta in modo prematuro perché annullata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire in base all'oggetto <c>continuationOptions</c> specificato Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita in base alle opzioni di continuazione specificate e restituisce un valore. La continuazione riceve un token di annullamento e usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente. Se i criteri specificati tramite il `continuationOptions` parametro non vengono soddisfatte, verrà annullata l'attività di continuazione anziché pianificata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il metodo ContinueWith con opzioni di continuazione:  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato il token è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationFunction" /> è Null.  
  
 oppure  
  
 L'argomento <paramref name="scheduler" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dalla funzione di continuazione.</param>
        <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita in base alle opzioni specificate per la continuazione delle attività al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione, quindi restituisce un valore. La continuazione riceve informazioni sullo stato fornite dal chiamante e un token di annullamento, quindi usa l'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> non verrà pianificato per l'esecuzione finché non viene completata l'attività corrente. Se i criteri specificati tramite il `continuationOptions` parametro non vengono soddisfatte, verrà annullata l'attività di continuazione anziché pianificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'istanza <see cref="T:System.Threading.CancellationToken" /> fornita è già stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per creare questa attività.</summary>
        <value>Oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per creare questa attività.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce l'ID dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> attualmente in esecuzione.</summary>
        <value>Intero assegnato dal sistema all'attività attualmente in esecuzione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A> è un `static` (`Shared` in Visual Basic) proprietà utilizzata per ottenere l'identificatore dell'attività attualmente in esecuzione dal codice che viene eseguita l'attività. Si differenzia dal <xref:System.Threading.Tasks.Task.Id%2A> proprietà, che restituisce l'identificatore di un determinato <xref:System.Threading.Tasks.Task> istanza. Se si tenta di recuperare il <xref:System.Threading.Tasks.Task.CurrentId%2A> valore all'esterno del codice che esegue un'attività, la proprietà restituisce `null`.  
  
 Si noti che anche se i conflitti sono molto rari, gli identificatori di attività non sono necessariamente essere univoco.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'attività che verrà completata dopo un ritardo di tempo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Numero di millisecondi prima del completamento dell'attività restituita oppure -1 per un'attesa indefinita.</param>
        <summary>Crea un'attività che viene completata dopo un ritardo di tempo.</summary>
        <returns>Attività che rappresenta il ritardo di tempo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task.Delay%2A> metodo viene in genere utilizzato per ritardare l'operazione di tutte o parte di un'attività per un intervallo di tempo specificato. In genere, è stato introdotto il ritardo di tempo:  
  
-   AT Mostra l'inizio dell'attività, come nell'esempio seguente.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   Qualche minuto mentre l'attività è in esecuzione. In questo caso, la chiamata al <xref:System.Threading.Tasks.Task.Delay%2A> metodo viene eseguito come attività figlio all'interno di un'attività, come illustrato nell'esempio seguente. Si noti che dopo l'attività che chiama il <xref:System.Threading.Tasks.Task.Delay%2A> metodo viene eseguito in modo asincrono, l'attività padre deve attendere il completamento tramite la `await` (parola chiave).  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 Dopo il ritardo di tempo specificato, l'attività è stata completata nel <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  
  
 Il metodo dipende dall'orologio di sistema. Ciò significa che la risoluzione del clock di sistema di circa sarà uguale all'intervallo di tempo se il `millisecondsDelay` argomento è minore rispetto alla risoluzione del clock di sistema, è di circa 15 millisecondi nei sistemi Windows.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo semplice del <xref:System.Threading.Tasks.Task.Delay%2A> metodo.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="millisecondsDelay" /> è minore di -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">Intervallo di tempo da attendere prima del completamento dell'attività restituita oppure <see langword="TimeSpan.FromMilliseconds(-1)" /> per un'attesa indefinita.</param>
        <summary>Crea un'attività che viene completata dopo un intervallo di tempo specificato.</summary>
        <returns>Attività che rappresenta il ritardo di tempo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il ritardo di tempo specificato, l'attività è stata completata <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato.  
  
 Per gli scenari di utilizzo ed esempi aggiuntivi, vedere la documentazione per il <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> rapporto di overload.  
  
 Il metodo dipende dall'orologio di sistema. Ciò significa che la risoluzione del clock di sistema di circa sarà uguale all'intervallo di tempo se il `delay` argomento è minore rispetto alla risoluzione del clock di sistema, è di circa 15 millisecondi nei sistemi Windows.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo semplice del <xref:System.Threading.Tasks.Task.Delay%2A> metodo.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> rappresenta un intervallo di tempo negativo diverso da <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
 oppure  
  
 La proprietà <see cref="P:System.TimeSpan.TotalMilliseconds" /> dell'argomento <paramref name="delay" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Numero di millisecondi prima del completamento dell'attività restituita oppure -1 per un'attesa indefinita.</param>
        <param name="cancellationToken">Token di annullamento che verrà controllato prima del completamento dell'attività restituita.</param>
        <summary>Crea un'attività annullabile che viene completata dopo un ritardo di tempo.</summary>
        <returns>Attività che rappresenta il ritardo di tempo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il token di annullamento viene segnalato prima che il ritardo di tempo specificato, un <xref:System.Threading.Tasks.TaskCanceledException> risultati dell'eccezione e l'attività viene completata nel <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  In caso contrario, l'attività è stata completata nel <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato una volta trascorso l'intervallo di tempo specificato.  
  
 Per gli scenari di utilizzo ed esempi aggiuntivi, vedere la documentazione per il <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> rapporto di overload.  
  
 Il metodo dipende dall'orologio di sistema. Ciò significa che la risoluzione del clock di sistema di circa sarà uguale all'intervallo di tempo se il `millisecondsDelay` argomento è minore rispetto alla risoluzione del clock di sistema, è di circa 15 millisecondi nei sistemi Windows.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'attività che include una chiamata al <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> metodo con un ritardo di un secondo. Prima dell'intervallo di ritardo, il token viene annullato. L'output dell'esempio mostra che, di conseguenza, un <xref:System.Threading.Tasks.TaskCanceledException> viene generata e le attività <xref:System.Threading.Tasks.Task.Status%2A> è impostata su <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="millisecondsDelay" /> è minore di -1.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">L'istanza <paramref name="cancellationToken" /> fornita è già stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">Intervallo di tempo da attendere prima del completamento dell'attività restituita oppure <see langword="TimeSpan.FromMilliseconds(-1)" /> per un'attesa indefinita.</param>
        <param name="cancellationToken">Token di annullamento che verrà controllato prima del completamento dell'attività restituita.</param>
        <summary>Crea un'attività annullabile che viene completata dopo un intervallo di tempo specificato.</summary>
        <returns>Attività che rappresenta il ritardo di tempo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il token di annullamento viene segnalato prima che il ritardo di tempo specificato, un <xref:System.Threading.Tasks.TaskCanceledException> risultati dell'eccezione e l'attività viene completata nel <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  In caso contrario, l'attività è stata completata nel <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato una volta trascorso l'intervallo di tempo specificato.  
  
 Per gli scenari di utilizzo ed esempi aggiuntivi, vedere la documentazione per il <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> rapporto di overload.  
  
 Il metodo dipende dall'orologio di sistema. Ciò significa che la risoluzione del clock di sistema di circa sarà uguale all'intervallo di tempo se il `delay` argomento è minore rispetto alla risoluzione del clock di sistema, è di circa 15 millisecondi nei sistemi Windows.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'attività che include una chiamata al <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metodo con un ritardo di uno e-mezzo secondo. Prima dell'intervallo di ritardo, il token viene annullato. L'output dell'esempio mostra che, di conseguenza, un <xref:System.Threading.Tasks.TaskCanceledException> viene generata e le attività <xref:System.Threading.Tasks.Task.Status%2A> è impostata su <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Si noti che in questo esempio include una condizione di competizione: dipende l'attività in esecuzione in modo asincrono il ritardo quando il token viene annullato. Anche se il secondo 1,5 ritardare la chiamata al <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metodo presume che probabilmente, tuttavia è possibile che la chiamata al <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metodo potrebbe restituire prima che il token viene annullato. In tal caso, l'esempio produce il seguente output:  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> rappresenta un intervallo di tempo negativo diverso da <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
 oppure  
  
 La proprietà <see cref="P:System.TimeSpan.TotalMilliseconds" /> dell'argomento <paramref name="delay" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">L'istanza <paramref name="cancellationToken" /> fornita è già stata eliminata.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task> classe implementa il <xref:System.IDisposable> interfaccia perché utilizza internamente le risorse che implementano <xref:System.IDisposable>. Tuttavia, in particolare se app è destinato il [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o versione successiva, è necessario chiamare <xref:System.Threading.Tasks.Task.Dispose%2A> , a meno che le prestazioni o scalabilità indica che, in base ai modelli di utilizzo, le prestazioni dell'app risulta migliorata per l'eliminazione di attività. Per ulteriori informazioni, vedere [necessario per l'eliminazione di attività?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) in parallelo blog sulla programmazione con .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'attività non è in uno degli stati finali: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> o <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Valore booleano che indica se questo metodo viene chiamato a causa di una chiamata a <see cref="M:System.Threading.Tasks.Task.Dispose" />.</param>
        <summary>Elimina <see cref="T:System.Threading.Tasks.Task" />, rilasciandone tutte le risorse non gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task> classe implementa il <xref:System.IDisposable> interfaccia perché utilizza internamente le risorse che implementano <xref:System.IDisposable>. Tuttavia, in particolare se app è destinato il [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o versione successiva, è necessario chiamare <xref:System.Threading.Tasks.Task.Dispose%2A> , a meno che le prestazioni o scalabilità indica che, in base ai modelli di utilizzo, le prestazioni dell'app risulta migliorata per l'eliminazione di attività. Per ulteriori informazioni, vedere [necessario per l'eliminazione di attività?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) in parallelo blog sulla programmazione con .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'attività non è in uno degli stati finali: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> o <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <threadsafe>A differenza la maggior parte dei membri del <see cref="T:System.Threading.Tasks.Task" /> (classe), questo metodo non è thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.AggregateException" /> che ha causato l'interruzione anomala di <see cref="T:System.Threading.Tasks.Task" />. Se l'oggetto <see cref="T:System.Threading.Tasks.Task" /> è stato completato correttamente o non ha ancora generato alcuna eccezione, verrà restituito <see langword="null" />.</summary>
        <value>Oggetto <see cref="T:System.AggregateException" /> che ha causato l'interruzione anomala di <see cref="T:System.Threading.Tasks.Task" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le attività che generano eccezioni non gestite archiviano l'eccezione risultante e propaga il wrapping in un <xref:System.AggregateException> nelle chiamate a <xref:System.Threading.Tasks.Task.Wait%2A> o negli accessi al <xref:System.Threading.Tasks.Task.Exception%2A> proprietà. Qualsiasi eccezione non osservata nel momento in cui che l'istanza dell'attività è sottoposto a garbage collection verranno propagate nel thread finalizzatore. Per ulteriori informazioni e un esempio, vedere [gestione delle eccezioni (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fornisce l'accesso ai metodi factory per la creazione e la configurazione delle istanze di <see cref="T:System.Threading.Tasks.Task" /> e <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <value>Oggetto factory in grado di creare una vasta gamma di oggetti <see cref="T:System.Threading.Tasks.Task" /> e <see cref="T:System.Threading.Tasks.Task`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce un'istanza predefinita del <xref:System.Threading.Tasks.TaskFactory> classe che è identico a quello creato mediante la chiamata senza parametri <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> costruttore. Contiene i valori delle proprietà seguenti:  
  
|Proprietà|Valore|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`, o <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 L'utilizzo più comune di questa proprietà consiste nel creare e avviare una nuova attività in una singola chiamata al <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodo.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> metodo fornisce il modo più semplice per creare un <xref:System.Threading.Tasks.Task> oggetto con valori di configurazione predefiniti.  
  
 L'esempio seguente usa il metodo statico <xref:System.Threading.Tasks.Task.Factory%2A> due chiamate a proprietà di <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodo. Il primo popola una matrice con i nomi dei file nella directory di documenti dell'utente, mentre il secondo popola una matrice con i nomi delle sottodirectory della directory documenti dell'utente. Chiama quindi il <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> metodo, che visualizza informazioni sul numero di file e directory in due matrici dopo le prime due attività ha completato l'esecuzione.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token di annullamento con cui completare l'attività.</param>
        <summary>Crea un oggetto <see cref="T:System.Threading.Tasks.Task" /> che risulta completato a causa dell'annullamento con un token di annullamento specificato.</summary>
        <returns>Attività annullata.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Non è stato richiesto l'annullamento per <paramref name="cancellationToken" />. La proprietà <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato restituito dall'attività.</typeparam>
        <param name="cancellationToken">Token di annullamento con cui completare l'attività.</param>
        <summary>Crea un oggetto <see cref="T:System.Threading.Tasks.Task`1" /> che risulta completato a causa dell'annullamento con un token di annullamento specificato.</summary>
        <returns>Attività annullata.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Non è stato richiesto l'annullamento per <paramref name="cancellationToken" />. La proprietà <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Eccezione con cui completare l'attività.</param>
        <summary>Crea un oggetto <see cref="T:System.Threading.Tasks.Task" /> che risulta completato con un'eccezione specificata.</summary>
        <returns>Attività in errore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea un <xref:System.Threading.Tasks.Task> i cui <xref:System.Threading.Tasks.Task.Status%2A> proprietà <xref:System.Threading.Tasks.TaskStatus.Faulted> e il cui <xref:System.Threading.Tasks.Task.Exception%2A> contiene proprietà `exception`. Il metodo viene in genere utilizzato quando si conosce immediatamente che il lavoro che esegue un'attività verrà generata un'eccezione prima dell'esecuzione di un percorso più lungo di codice. Per un esempio, vedere il <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> rapporto di overload.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato restituito dall'attività.</typeparam>
        <param name="exception">Eccezione con cui completare l'attività.</param>
        <summary>Crea un oggetto <see cref="T:System.Threading.Tasks.Task`1" /> che risulta completato con un'eccezione specificata.</summary>
        <returns>Attività in errore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea un <xref:System.Threading.Tasks.Task%601> i cui <xref:System.Threading.Tasks.Task.Status%2A> proprietà <xref:System.Threading.Tasks.TaskStatus.Faulted> e il cui <xref:System.Threading.Tasks.Task.Exception%2A> contiene proprietà `exception`. Il metodo viene in genere utilizzato quando si conosce immediatamente che il lavoro che esegue un'attività verrà generata un'eccezione prima dell'esecuzione di un percorso più lungo di codice. Nell'esempio viene illustrata una situazione di questo tipo.  
  
   
  
## Examples  
 Nell'esempio seguente è un'utilità della riga di comando che calcola il numero di byte nei file in ogni directory il cui nome è passato come argomento della riga di comando. Anziché un percorso più lungo di codice che crea un'istanza in esecuzione un <xref:System.IO.FileInfo> dell'oggetto e recupera il valore del relativo <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> proprietà per ogni file nella directory, l'esempio chiama semplicemente il <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> metodo per creare un'attività in errore se un particolare sottodirectory non esiste.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato restituito dall'attività.</typeparam>
        <param name="result">Risultato da archiviare nell'attività completata.</param>
        <summary>Crea un oggetto <see cref="T:System.Threading.Tasks.Task`1" /> completato correttamente con il risultato specificato.</summary>
        <returns>Attività completata correttamente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea un <xref:System.Threading.Tasks.Task%601> i cui <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> proprietà `result` e il cui <xref:System.Threading.Tasks.Task.Status%2A> proprietà <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Il metodo viene comunemente utilizzato quando il valore restituito di un'attività è noto immediatamente senza un percorso più lungo di codice in esecuzione. Nell'esempio viene illustrata una situazione di questo tipo.  
  
 Per creare un oggetto attività che non restituisce un valore, recuperare l'oggetto attività di <xref:System.Threading.Tasks.Task.CompletedTask%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente è un'utilità della riga di comando che calcola il numero di byte nei file in ogni directory il cui nome è passato come argomento della riga di comando. Anziché un percorso più lungo di codice che crea un'istanza in esecuzione un <xref:System.IO.FileStream> dell'oggetto e recupera il valore del relativo <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> proprietà per ogni file nella directory, l'esempio chiama semplicemente il <xref:System.Threading.Tasks.Task.FromResult%2A> metodo per creare un'attività il cui <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> proprietà è zero (0) se una directory non è presenti file.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un elemento awaiter usato per attendere questo oggetto <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Istanza di awaiter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è destinato per l'utilizzo del compilatore piuttosto che per l'utilizzo nel codice dell'applicazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un ID per questa istanza di <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <value>Identificatore assegnato dal sistema a questa istanza di <see cref="T:System.Threading.Tasks.Task" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ID attività vengono assegnati su richiesta e non rappresentano necessariamente l'ordine delle attività vengono create istanze. Si noti che anche se i conflitti sono molto rari, gli identificatori di attività non sono necessariamente essere univoco.  
  
 Per ottenere l'ID attività dell'attività attualmente in esecuzione da all'interno di codice che tale attività è in esecuzione, utilizzare il <xref:System.Threading.Tasks.Task.CurrentId%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'esecuzione di questa istanza di <see cref="T:System.Threading.Tasks.Task" /> è stata completata perché annullata.</summary>
        <value>
          <see langword="true" /> se l'attività è stata completata perché annullata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Threading.Tasks.Task> verrà completata il <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato in presenza delle condizioni seguenti:  
  
-   Il relativo <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> è stato contrassegnato per l'annullamento prima dell'inizio dell'attività in esecuzione,  
  
-   L'attività ha confermato la richiesta di annullamento nel relativo già segnalato <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> generando un <xref:System.OperationCanceledException> che contiene lo stesso <xref:System.Threading.CancellationToken>.  
  
-   L'attività ha confermato la richiesta di annullamento nel relativo già segnalato <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> chiamando il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> metodo il <xref:System.Threading.CancellationToken>.  
  
> [!IMPORTANT]
>  Il recupero del valore del <xref:System.Threading.Tasks.Task.IsCanceled%2A> proprietà non blocca il thread chiamante finché non viene completata l'attività.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se questo oggetto <see cref="T:System.Threading.Tasks.Task" /> è stato completato.</summary>
        <value>
          <see langword="true" /> se l'attività è stata completata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.IsCompleted%2A> restituirà `true` quando l'attività è in uno dei tre stati finali: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
> [!IMPORTANT]
>  Il recupero del valore del <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> proprietà non blocca il thread chiamante finché non viene completata l'attività.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Threading.Tasks.Task" /> è stato completato a causa di un'eccezione non gestita.</summary>
        <value>
          <see langword="true" /> se l'attività ha generato un'eccezione non gestita; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Threading.Tasks.Task.IsFaulted%2A> è `true`, l'attività <xref:System.Threading.Tasks.Task.Status%2A> è uguale a <xref:System.Threading.Tasks.TaskStatus.Faulted>e il relativo <xref:System.Threading.Tasks.Task.Exception%2A> proprietà è non null.  
  
> [!IMPORTANT]
>  Il recupero del valore del <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> proprietà non blocca il thread chiamante finché non viene completata l'attività.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accoda il lavoro specificato da eseguire in ThreadPool e restituisce un'attività o un handle di <see cref="T:System.Threading.Tasks.Task`1" /> per tale lavoro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task.Run%2A> metodo fornisce un set di overload che rendono più semplice avviare un'attività con i valori predefiniti. È un'alternativa semplificata al <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> overload.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Lavoro da eseguire in modo asincrono.</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un oggetto <see cref="T:System.Threading.Tasks.Task" /> che rappresenta tale lavoro.</summary>
        <returns>Attività che rappresenta il lavoro in coda da eseguire in ThreadPool.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task.Run%2A> metodo consente di creare ed eseguire un'attività in una singola chiamata al metodo, un'alternativa più semplice per il <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> metodo. Crea un'attività con i valori predefiniti seguenti:  
  
-   Il token di annullamento è <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Il relativo <xref:System.Threading.Tasks.Task.CreationOptions%2A> valore della proprietà è <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa l'utilità di pianificazione predefinita.  
  
 Per informazioni sulla gestione delle eccezioni generate dalle operazioni di attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L'esempio seguente definisce un `ShowThreadInfo` metodo che visualizza il <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> del thread corrente. Viene chiamato direttamente dal thread dell'applicazione e viene chiamato dal <xref:System.Action> delegato passato al <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metodo.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 Nell'esempio seguente è simile a quello precedente, ad eccezione del fatto che viene utilizzata un'espressione lambda per definire il codice che l'attività da eseguire.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 Negli esempi viene illustrato che l'attività asincrona viene eseguita su un thread diverso da quello del thread principale dell'applicazione.  
  
 La chiamata al <xref:System.Threading.Tasks.Task.Wait%2A> metodo assicura che l'attività viene completata e visualizza il relativo output prima della chiusura dell'applicazione. In caso contrario, è possibile che il `Main` metodo verrà completato prima del completamento dell'attività.  
  
 Nell'esempio seguente viene illustrato il <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metodo. Definisce una matrice di nomi di directory e avvia un'attività separata per recuperare i nomi di file in ogni directory. Tutte le attività di scrivono i nomi dei file in un singolo <xref:System.Collections.Concurrent.ConcurrentBag%601> oggetto. Nell'esempio viene quindi chiamato il <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> metodo per assicurarsi che tutte le attività completate e quindi visualizza un conteggio del numero totale di nomi di file scritti il <xref:System.Collections.Concurrent.ConcurrentBag%601> oggetto.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="action" /> era <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <summary>Accoda il lavoro specificato da eseguire sul pool di thread e restituisce un proxy per l'attività restituita da <paramref name="function" />.</summary>
        <returns>Attività che rappresenta un proxy per l'attività restituita da <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sulla gestione delle eccezioni generate dalle operazioni di attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> era <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Lavoro da eseguire in modo asincrono.</param>
        <param name="cancellationToken">Token di annullamento che è possibile usare per annullare il lavoro</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un oggetto <see cref="T:System.Threading.Tasks.Task" /> che rappresenta tale lavoro. Un token di annullamento consente di annullare il lavoro.</summary>
        <returns>Attività che rappresenta il lavoro in coda da eseguire nel pool di thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la richiesta di annullamento prima che l'attività inizia l'esecuzione, l'attività non viene eseguito. Invece di impostare il <xref:System.Threading.Tasks.TaskStatus.Canceled> lo stato e genera un <xref:System.Threading.Tasks.TaskCanceledException> eccezione.  
  
 Il <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> metodo è un'alternativa più semplice per il <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> metodo. Crea un'attività con i valori predefiniti seguenti:  
  
-   Il relativo <xref:System.Threading.Tasks.Task.CreationOptions%2A> valore della proprietà è <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa l'utilità di pianificazione predefinita.  
  
 Per informazioni sulla gestione delle eccezioni generate dalle operazioni di attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> metodo per creare un'attività che consente di scorrere i file nella directory C:\Windows\System32. L'espressione lambda chiama il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo per aggiungere informazioni su ogni file da un <xref:System.Collections.Generic.List%601> oggetto. Ogni scollegato attività annidata richiamato dal <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> ciclo controlla lo stato del token di annullamento e, se la richiesta di annullamento, chiama il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodo. Il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodo genera un <xref:System.OperationCanceledException> eccezione gestita in un `catch` blocco quando il thread chiamante chiama il <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodo.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="action" /> era <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">La classe <see cref="T:System.Threading.CancellationTokenSource" /> associata all'oggetto <paramref name="cancellationToken" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <param name="cancellationToken">Token di annullamento da usare per annullare il lavoro.</param>
        <summary>Accoda il lavoro specificato da eseguire sul pool di thread e restituisce un proxy per l'attività restituita da <paramref name="function" />.</summary>
        <returns>Attività che rappresenta un proxy per l'attività restituita da <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sulla gestione delle eccezioni generate dalle operazioni di attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> era <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">La classe <see cref="T:System.Threading.CancellationTokenSource" /> associata all'oggetto <paramref name="cancellationToken" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato restituito dall'attività proxy.</typeparam>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un proxy per l'oggetto <see langword="Task(TResult)" /> restituito da <paramref name="function" />.</summary>
        <returns>Oggetto <see langword="Task(TResult)" /> che rappresenta un proxy per l'oggetto <see langword="Task(TResult)" /> restituito da <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sulla gestione delle eccezioni generate dalle operazioni di attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> era <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo restituito dell'attività.</typeparam>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un oggetto <see cref="T:System.Threading.Tasks.Task`1" /> che rappresenta tale lavoro.</summary>
        <returns>Oggetto attività che rappresenta il lavoro in coda da eseguire nel pool di thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task.Run%2A> metodo è un'alternativa più semplice per il <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> metodo. Crea un'attività con i valori predefiniti seguenti:  
  
-   Il token di annullamento è <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Il relativo <xref:System.Threading.Tasks.Task.CreationOptions%2A> valore della proprietà è <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa l'utilità di pianificazione predefinita.  
  
 Per informazioni sulla gestione delle eccezioni generate dalle operazioni di attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Nell'esempio seguente conta il numero approssimativo di parole nei file di testo che rappresentano una documentazione pubblicate. Ogni attività è responsabile dell'apertura di un file, leggere l'intero contenuto in modo asincrono e calcolare il conteggio di word utilizzando un'espressione regolare. Il <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> metodo viene chiamato per garantire che tutte le attività vengano completate prima di visualizzare il numero di parole di ogni libro nella console.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 L'espressione regolare `\p{P}*\s+` corrisponde a zero, uno o più caratteri di punteggiatura, seguiti da uno o più caratteri spazio vuoto. Si presuppone che il numero complessivo di corrispondenze uguale al conteggio di word approssimativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato restituito dall'attività proxy.</typeparam>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <param name="cancellationToken">Token di annullamento da usare per annullare il lavoro.</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un proxy per l'oggetto <see langword="Task(TResult)" /> restituito da <paramref name="function" />.</summary>
        <returns>Oggetto <see langword="Task(TResult)" /> che rappresenta un proxy per l'oggetto <see langword="Task(TResult)" /> restituito da <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sulla gestione delle eccezioni generate dalle operazioni di attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> era <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">La classe <see cref="T:System.Threading.CancellationTokenSource" /> associata all'oggetto <paramref name="cancellationToken" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo di risultato dell'attività.</typeparam>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <param name="cancellationToken">Token di annullamento da usare per annullare il lavoro.</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un oggetto <see langword="Task(TResult)" /> che rappresenta tale lavoro. Un token di annullamento consente di annullare il lavoro.</summary>
        <returns>Oggetto <see langword="Task(TResult)" /> che rappresenta il lavoro in coda da eseguire nel pool di thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la richiesta di annullamento prima che l'attività inizia l'esecuzione, l'attività non viene eseguito. Invece di impostare il <xref:System.Threading.Tasks.TaskStatus.Canceled> lo stato e genera un <xref:System.Threading.Tasks.TaskCanceledException> eccezione.  
  
 Il <xref:System.Threading.Tasks.Task.Run%2A> metodo è un'alternativa più semplice per il <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> metodo. Crea un'attività con i valori predefiniti seguenti:  
  
-   Il relativo <xref:System.Threading.Tasks.Task.CreationOptions%2A> valore della proprietà è <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa l'utilità di pianificazione predefinita.  
  
 Per informazioni sulla gestione delle eccezioni generate dalle operazioni di attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L'esempio seguente crea 20 attività che eseguirà un ciclo fino a quando non viene incrementato un contatore per un valore pari a 2 milioni. Quando le prime 10 attività raggiungono 2 milioni, il token di annullamento viene annullato e vengono annullate tutte le attività il cui contatori non hanno raggiunto 2 milioni. Nell'esempio viene illustrato l'output possibili.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 Anziché utilizzare il <xref:System.AggregateException.InnerExceptions%2A> proprietà per esaminare le eccezioni, l'esempio scorre tutte le attività per determinare che sono stati completati correttamente e che sono state annullate. Per coloro che sono state completate, ma visualizza il valore restituito dall'attività.  
  
 Poiché l'annullamento è cooperativo, ogni attività possono decidere come rispondere all'annullamento. L'esempio seguente è simile alla prima, ad eccezione del fatto che, quando il token viene annullato, l'attività di restituire il numero di iterazioni di essere completati anziché generare un'eccezione.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 Nell'esempio viene comunque necessario gestire il <xref:System.AggregateException> eccezione, poiché tutte le attività che non hanno avviato quando viene richiesto l'annullamento comunque un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">La classe <see cref="T:System.Threading.CancellationTokenSource" /> associata all'oggetto <paramref name="cancellationToken" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue <see cref="T:System.Threading.Tasks.Task" /> in modo sincrono nell'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esegue <see cref="T:System.Threading.Tasks.Task" /> in modo sincrono nell'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, le attività vengono eseguite in modo asincrono in un pool di thread e non blocca il thread chiamante. Le attività eseguite chiamando il <xref:System.Threading.Tasks.Task.RunSynchronously> metodo associati corrente <xref:System.Threading.Tasks.TaskScheduler> e vengono eseguiti nel thread chiamante. Se l'utilità di pianificazione di destinazione non supporta l'esecuzione di questa attività nel thread chiamante, l'attività verrà pianificato per l'esecuzione nell'utilità di pianificazione e il thread chiamante verrà bloccata fino a quando l'attività ha completato l'esecuzione. Anche se l'attività viene eseguita in modo sincrono, il thread chiamante deve ancora chiamare <xref:System.Threading.Tasks.Task.Wait%2A> per gestire le eccezioni che potrebbe generare l'attività.  Per ulteriori informazioni sulla gestione delle eccezioni, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 Le attività eseguite chiamando il <xref:System.Threading.Tasks.Task.RunSynchronously%2A> viene creata un'istanza di metodo chiamando un <xref:System.Threading.Tasks.Task> o <xref:System.Threading.Tasks.Task%601> costruttore della classe. Deve essere l'attività da eseguire in modo sincrono il <xref:System.Threading.Tasks.TaskStatus.Created> dello stato. Un'attività può essere avviata ed eseguire una sola volta. Qualsiasi tentativo di pianificare un'attività di risultati di un secondo tempo generano un'eccezione.  
  
   
  
## Examples  
 L'esempio seguente confronta un'attività eseguita chiamando il <xref:System.Threading.Tasks.Task.RunSynchronously%2A> (metodo) con uno eseguita in modo asincrono. In entrambi i casi, le attività eseguite le espressioni lambda identici che consentono di visualizzare l'ID attività e l'ID del thread in cui viene eseguita l'attività. L'attività calcola la somma dei valori interi compresi tra 1 e 1.000.000. Come illustrato nell'output dell'esempio, l'attività eseguita chiamando il <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metodo viene eseguito nel thread dell'applicazione, mentre l'attività asincrona non.  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> non è in uno stato valido per essere avviato. Potrebbe essere già stato avviato, eseguito o annullato oppure potrebbe essere stato creato in un modo che non supporta la pianificazione diretta.</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Utilità di pianificazione in cui provare a eseguire questa attività inline.</param>
        <summary>Esegue <see cref="T:System.Threading.Tasks.Task" /> in modo sincrono nell'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le attività eseguite chiamando il <xref:System.Threading.Tasks.Task.RunSynchronously%2A> viene creata un'istanza di metodo chiamando un <xref:System.Threading.Tasks.Task> o <xref:System.Threading.Tasks.Task%601> costruttore della classe. Deve essere l'attività da eseguire in modo sincrono il <xref:System.Threading.Tasks.TaskStatus.Created> dello stato. Un'attività può essere avviata ed eseguire una sola volta. Qualsiasi tentativo di pianificare un'attività di risultati di un secondo tempo generano un'eccezione.  
  
 Se l'utilità di pianificazione di destinazione non supporta l'esecuzione di questa attività nel thread corrente, verrà pianificata l'attività per l'esecuzione nell'utilità di pianificazione e il thread corrente verrà bloccata fino a quando l'attività ha completato l'esecuzione. Per questo motivo, il thread chiamante non è necessario chiamare un metodo, ad esempio <xref:System.Threading.Tasks.Task.Wait%2A> per garantire che l'attività ha completato l'esecuzione. Per ulteriori informazioni sulla gestione delle eccezioni per le operazioni di attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> non è in uno stato valido per essere avviato. Potrebbe essere già stato avviato, eseguito o annullato oppure potrebbe essere stato creato in un modo che non supporta la pianificazione diretta.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia <see cref="T:System.Threading.Tasks.Task" />, pianificandone l'esecuzione nell'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'attività può essere avviata ed eseguire una sola volta. Qualsiasi tentativo di pianificare un'attività di una seconda volta genererà un'eccezione.  
  
 Il <xref:System.Threading.Tasks.Task.Start%2A> viene utilizzato per eseguire un'attività che è stata creata chiamando uno del <xref:System.Threading.Tasks.Task> costruttori. In genere, questo caso quando è necessario separare la creazione dell'attività dalla relativa esecuzione, ad esempio quando si esegue in modo condizionale le attività che è stato creato. Nel caso più comune in cui non è necessario separare la creazione di istanze di attività di esecuzione, si consiglia di chiamare un overload di <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodo.  
  
 Per informazioni sulla gestione delle eccezioni generate dalle operazioni di attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> costruttore per creare un'istanza di un nuovo <xref:System.Threading.Tasks.Task> oggetto che consente di visualizzare l'attività ID e l'ID thread gestito, quindi esegue un ciclo. Chiama quindi il <xref:System.Threading.Tasks.Task.Start%2A> metodo per eseguire l'attività.  Poiché si tratta di un'applicazione console, la chiamata al <xref:System.Threading.Tasks.Task.Wait%2A> metodo è necessario impedire l'applicazione di terminare prima che l'attività termina l'esecuzione.  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> non è in uno stato valido per essere avviato. Potrebbe essere già stato avviato, eseguito o annullato oppure potrebbe essere stato creato in un modo che non supporta la pianificazione diretta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> a cui associare e con cui eseguire questa attività.</param>
        <summary>Avvia <see cref="T:System.Threading.Tasks.Task" />, pianificandone l'esecuzione nell'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'attività può essere avviata ed eseguire una sola volta. Qualsiasi tentativo di pianificare un'attività di una seconda volta genererà un'eccezione.  
  
 Per informazioni sulla gestione delle eccezioni generate dalle operazioni di attività, vedere [eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> non è in uno stato valido per essere avviato. Potrebbe essere già stato avviato, eseguito o annullato oppure potrebbe essere stato creato in un modo che non supporta la pianificazione diretta.</exception>
        <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">L'utilità di pianificazione non è riuscita a inserire in coda questa attività.</exception>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Threading.Tasks.TaskStatus" /> di questa attività.</summary>
        <value>Oggetto <see cref="T:System.Threading.Tasks.TaskStatus" /> corrente di questa istanza dell'attività.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il recupero del valore del <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> proprietà non blocca il thread chiamante finché non viene completata l'attività.  
  
 Per ulteriori informazioni e un esempio, vedere [concatenamento di attività tramite attività di continuazione](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) e [procedura: annullare un'attività e i relativi figli](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).  
  
   
  
## Examples  
 L'esempio seguente crea 20 attività che eseguirà un ciclo fino a quando non viene incrementato un contatore per un valore pari a 2 milioni. Quando le prime 10 attività raggiungono 2 milioni, il token di annullamento viene annullato e vengono annullate tutte le attività il cui contatori non hanno raggiunto 2 milioni. Nell'esempio viene quindi esamina il <xref:System.Threading.Tasks.Task.Status%2A> proprietà di ogni attività per indicare se è stata completata o è stata annullata. Per quelle che è stata completata, ma visualizza il valore restituito dall'attività.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System.IAsyncResult.AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Threading.WaitHandle" /> che può essere usato per attendere il completamento dell'attività.</summary>
        <value>Oggetto <see cref="T:System.Threading.WaitHandle" /> che può essere usato per attendere il completamento dell'attività.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzando la funzionalità di attesa fornita da <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> è preferibile usare <xref:System.IAsyncResult.AsyncWaitHandle%2A> per una funzionalità simile. Per ulteriori informazioni, vedere la sezione "In attesa su attività" in [basato su attività di programmazione asincrona](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) e [utilizzando TPL con altri modelli asincroni](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System.IAsyncResult.CompletedSynchronously { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'operazione è stata completata in modo sincrono.</summary>
        <value>
          <see langword="true" /> se l'operazione è stata completata in modo sincrono; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A> è un metodo di sincronizzazione che causa il thread chiamante attenda il completamento dell'attività corrente. Se l'attività corrente non è stata avviata esecuzione, il metodo di attesa tenta di rimuovere l'attività dall'utilità di pianificazione ed eseguirlo in linea sul thread corrente. Se non è in grado di eseguire tale operazione, o se l'attività corrente è già stata avviata esecuzione, blocca il thread chiamante fino al completamento dell'attività. Per ulteriori informazioni, vedere [Task.Wait e "Inline"](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) in parallelo blog sulla programmazione con .NET.  
  
 Per ulteriori informazioni e un esempio, vedere [come: attendere una o più attività di completamento](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374).  
  
   
  
## Examples  
 Nell'esempio seguente avvia un'attività che genera un milione di integer casuale compreso tra 0 e 100 e calcola la Media. Nell'esempio viene utilizzato il <xref:System.Threading.Tasks.Task.Wait%2A> metodo per assicurarsi che l'attività venga completata prima della chiusura dell'applicazione. In caso contrario, poiché si tratta di un'applicazione console, l'esempio verrebbe chiuso prima che l'attività è possibile calcolare e visualizzare la Media.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.AggregateException">L'attività è stata annullata. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene un oggetto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
 oppure  
  
 È stata generata un'eccezione durante l'esecuzione dell'attività. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene informazioni su una o più eccezioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" /> entro un numero specificato di millisecondi.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Threading.Tasks.Task" /> ha completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> è un metodo di sincronizzazione che provoca il thread chiamante di attesa per l'istanza corrente di attività completare fino a quando non si verifica una delle operazioni seguenti:  
  
-   L'attività viene completata correttamente.  
  
-   L'attività stessa viene annullata o genera un'eccezione. In questo caso, si gestisce un <xref:System.AggregateException> eccezione. Il <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> proprietà contiene i dettagli sull'eccezione o le eccezioni.  
  
-   L'intervallo definito da `millisecondsTimeout` scade. In questo caso, il thread corrente viene ripresa l'esecuzione e il metodo restituisce `false`.  
  
   
  
## Examples  
 Nell'esempio seguente avvia un'attività che genera l'errore 5 milioni di integer casuale compreso tra 0 e 100 e calcola la Media. Nell'esempio viene utilizzato il <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> metodo per attendere che l'applicazione è completata entro 150 millisecondi. Se l'applicazione viene completata, l'attività consente di visualizzare la somma e Media dei numeri casuali che è generato. Se è trascorso l'intervallo di timeout, verrà visualizzato un messaggio prima che venga terminato.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.AggregateException">L'attività è stata annullata. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene un oggetto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
 oppure  
  
 È stata generata un'eccezione durante l'esecuzione dell'attività. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene informazioni su una o più eccezioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token di annullamento da osservare durante l'attesa del completamento dell'attività.</param>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" />. L'attesa termina se un token di annullamento viene annullato prima del completamento dell'attività.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> metodo crea un periodo di attesa annullabile; vale a dire provoca il thread corrente in attesa fino a quando non si verifica una delle operazioni seguenti:  
  
-   Il completamento dell'attività.  
  
-   Il token di annullamento viene annullato. In questo caso, la chiamata al <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> metodo genera un <xref:System.OperationCanceledException>.  
  
> [!NOTE]
>  L'annullamento di `cancellationToken` token di annullamento non ha alcun effetto sull'attività in esecuzione a meno che non è inoltre è stato passato il token di annullamento ed è predisposta gestire l'annullamento. Il passaggio di `cancellationToken` oggetto a questo metodo consente semplicemente l'attesa di essere annullata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo semplice di un token di annullamento per annullare l'attesa del completamento dell'attività. Viene avviata un'attività, le chiamate di <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metodo per annullare una qualsiasi di token di annullamento dell'origine del token, quindi ritardi per cinque secondi. Si noti che l'attività stessa non è stato passato il token di annullamento e non è annullabile. Il thread dell'applicazione chiama l'attività <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodo per attendere il completamento dell'attività, ma il tempo di attesa viene annullata quando viene annullato il token di annullamento e un <xref:System.OperationCanceledException> viene generata un'eccezione. Il gestore di eccezioni segnala l'eccezione e quindi viene sospesa per sei secondi. Come illustrato nell'output dell'esempio, questo ritardo consente all'attività completare il <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'attività è stata eliminata.</exception>
        <exception cref="T:System.AggregateException">L'attività è stata annullata. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene un oggetto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
 oppure  
  
 È stata generata un'eccezione durante l'esecuzione dell'attività. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene informazioni su una o più eccezioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" /> entro un intervallo di tempo specificato.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Threading.Tasks.Task" /> ha completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> è un metodo di sincronizzazione che provoca il thread chiamante di attesa per l'istanza corrente di attività completare fino a quando non si verifica una delle operazioni seguenti:  
  
-   L'attività viene completata correttamente.  
  
-   L'attività stessa viene annullata o genera un'eccezione. In questo caso, si gestisce un <xref:System.AggregateException> eccezione. Il <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> proprietà contiene i dettagli sull'eccezione o le eccezioni.  
  
-   L'intervallo definito da `timeout` scade. In questo caso, il thread corrente viene ripresa l'esecuzione e il metodo restituisce `false`.  
  
   
  
## Examples  
 Nell'esempio seguente avvia un'attività che genera l'errore 5 milioni di integer casuale compreso tra 0 e 100 e calcola la Media. Nell'esempio viene utilizzato il <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> metodo per attendere che l'applicazione è completata entro 150 millisecondi. Se l'applicazione viene completata, l'attività consente di visualizzare la somma e Media dei numeri casuali che è generato. Se è trascorso l'intervallo di timeout, verrà visualizzato un messaggio prima che venga terminato.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.  
  
 oppure  
  
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">L'attività è stata annullata. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene un oggetto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
 oppure  
  
 È stata generata un'eccezione durante l'esecuzione dell'attività. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene informazioni su una o più eccezioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="cancellationToken">Token di annullamento da osservare durante l'attesa del completamento dell'attività.</param>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" />. L'attesa termina se si esaurisce l'intervallo di timeout o se un token di annullamento viene annullato prima del completamento dell'attività.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Threading.Tasks.Task" /> ha completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> è un metodo di sincronizzazione che provoca il thread chiamante di attesa per l'istanza corrente di attività completare fino a quando non si verifica una delle operazioni seguenti:  
  
-   L'attività viene completata correttamente.  
  
-   L'attività stessa viene annullata o genera un'eccezione. In questo caso, si gestisce un <xref:System.AggregateException> eccezione. Il <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> proprietà contiene i dettagli sull'eccezione o le eccezioni.  
  
-   Il `cancellationToken` token di annullamento. In questo caso, la chiamata al <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metodo genera un <xref:System.OperationCanceledException>.  
  
-   L'intervallo definito da `millisecondsTimeout` scade. In questo caso, il thread corrente viene ripresa l'esecuzione e il metodo restituisce `false`.  
  
> [!NOTE]
>  L'annullamento di `cancellationToken` token di annullamento non ha alcun effetto sull'attività in esecuzione a meno che non è inoltre è stato passato il token di annullamento ed è predisposta gestire l'annullamento. Il passaggio di `cancellationToken` oggetto al metodo semplicemente consente l'attesa di essere annullata in base una condizione.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metodo per fornire un valore di timeout sia un annullamento del token che può terminare l'attesa di completamento dell'attività. Un nuovo thread viene avviato e viene eseguito il `CancelToken` (metodo), che sospende e quindi chiama il <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metodo per annullare il token di annullamento. Un'attività viene quindi avviata e ritarda per 5 secondi. Il <xref:System.Threading.Tasks.Task.Wait%2A> metodo viene chiamato per attendere il completamento dell'attività e viene fornito un valore di timeout breve sia un token di annullamento.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Si noti che l'output dell'esempio preciso varia a seconda se il tempo di attesa è stata annullata a causa del token di annullamento o perché è trascorso l'intervallo di timeout.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.AggregateException">L'attività è stata annullata. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene un oggetto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
 oppure  
  
 È stata generata un'eccezione durante l'esecuzione dell'attività. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene informazioni su una o più eccezioni.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente avvia 10 attività, ognuna delle quali viene passato un indice come un oggetto di stato. Attività con un indice da due a cinque generare eccezioni. La chiamata al <xref:System.Threading.Tasks.Task.WaitAll%2A> metodo esegue il wrapping di tutte le eccezioni in un <xref:System.AggregateException> dell'oggetto e che venga ripropagata al thread chiamante.  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno o più degli oggetti <see cref="T:System.Threading.Tasks.Task" /> in <paramref name="tasks" /> sono stati eliminati.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.  
  
 oppure  
  
 L'argomento <paramref name="tasks" /> è una matrice vuota.</exception>
        <exception cref="T:System.AggregateException">Almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" /> è stata annullata. Se un'attività è stata annullata, l'eccezione <see cref="T:System.AggregateException" /> contiene un'eccezione <see cref="T:System.OperationCanceledException" /> nella raccolta <see cref="P:System.AggregateException.InnerExceptions" />.  
  
 oppure  
  
 È stata generata un'eccezione durante l'esecuzione di almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti entro un numero specificato di millisecondi.</summary>
        <returns>
          <see langword="true" /> se tutte le istanze di <see cref="T:System.Threading.Tasks.Task" /> hanno completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Uno o più degli oggetti <see cref="T:System.Threading.Tasks.Task" /> in <paramref name="tasks" /> sono stati eliminati.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" /> è stata annullata. Se un'attività è stata annullata, <see cref="T:System.AggregateException" /> contiene un oggetto <see cref="T:System.OperationCanceledException" /> nella relativa raccolta <see cref="P:System.AggregateException.InnerExceptions" />.  
  
 oppure  
  
 È stata generata un'eccezione durante l'esecuzione di almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.  
  
 oppure  
  
 L'argomento <paramref name="tasks" /> è una matrice vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> da osservare durante l'attesa del completamento delle attività.</param>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti a meno che l'attesa non venga annullata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `cancellationToken` argomento viene utilizzato per annullare l'operazione di attesa. Annullamento delle attività è un'operazione distinta e viene segnalato dal <xref:System.AggregateException> come indicato in precedenza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" /> è stata annullata. Se un'attività è stata annullata, <see cref="T:System.AggregateException" /> contiene un oggetto <see cref="T:System.OperationCanceledException" /> nella relativa raccolta <see cref="P:System.AggregateException.InnerExceptions" />.  
  
 oppure  
  
 È stata generata un'eccezione durante l'esecuzione di almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.  
  
 oppure  
  
 L'argomento <paramref name="tasks" /> è una matrice vuota.</exception>
        <exception cref="T:System.ObjectDisposedException">Uno o più degli oggetti <see cref="T:System.Threading.Tasks.Task" /> in <paramref name="tasks" /> sono stati eliminati.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti annullabili entro un intervallo di tempo specificato.</summary>
        <returns>
          <see langword="true" /> se tutte le istanze di <see cref="T:System.Threading.Tasks.Task" /> hanno completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Uno o più degli oggetti <see cref="T:System.Threading.Tasks.Task" /> in <paramref name="tasks" /> sono stati eliminati.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" /> è stata annullata. Se un'attività è stata annullata, <see cref="T:System.AggregateException" /> contiene un oggetto <see cref="T:System.OperationCanceledException" /> nella relativa raccolta <see cref="P:System.AggregateException.InnerExceptions" />.  
  
 oppure  
  
 È stata generata un'eccezione durante l'esecuzione di almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.  
  
 oppure  
  
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.  
  
 oppure  
  
 L'argomento <paramref name="tasks" /> è una matrice vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> da osservare durante l'attesa del completamento delle attività.</param>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti entro un numero specificato di millisecondi o finché l'attesa non viene annullata.</summary>
        <returns>
          <see langword="true" /> se tutte le istanze di <see cref="T:System.Threading.Tasks.Task" /> hanno completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `cancellationToken` argomento viene utilizzato per annullare l'operazione di attesa. Annullamento delle attività è un'operazione distinta e viene segnalato dal <xref:System.AggregateException> indicato in precedenza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno o più degli oggetti <see cref="T:System.Threading.Tasks.Task" /> in <paramref name="tasks" /> sono stati eliminati.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" /> è stata annullata. Se un'attività è stata annullata, <see cref="T:System.AggregateException" /> contiene un oggetto <see cref="T:System.OperationCanceledException" /> nella relativa raccolta <see cref="P:System.AggregateException.InnerExceptions" />.  
  
 oppure  
  
 È stata generata un'eccezione durante l'esecuzione di almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.  
  
 oppure  
  
 L'argomento <paramref name="tasks" /> è una matrice vuota.</exception>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti.</summary>
        <returns>Indice dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> completato nella matrice di <paramref name="tasks" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente avvia cinque attività, ognuna delle quali rimane inattivo per un massimo di 1.050 millisecondi o di un minimo di 50 millisecondi. Il <xref:System.Threading.Tasks.Task.WaitAny%2A> metodo quindi attende che uno di attività da completare. Nell'esempio viene visualizzato l'ID attività dell'attività che è terminata l'attesa, nonché lo stato corrente di tutte le attività.  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti entro un numero specificato di millisecondi.</summary>
        <returns>Indice dell'attività completata nell'argomento di matrice di <paramref name="tasks" />, oppure -1 in caso di timeout.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> da osservare durante l'attesa del completamento di un'attività.</param>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti a meno che l'attesa non venga annullata.</summary>
        <returns>Indice dell'attività completata nell'argomento di matrice di <paramref name="tasks" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.</exception>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti entro un intervallo di tempo specificato.</summary>
        <returns>Indice dell'attività completata nell'argomento di matrice di <paramref name="tasks" />, oppure -1 in caso di timeout.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.  
  
 oppure  
  
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> da osservare durante l'attesa del completamento di un'attività.</param>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti entro un numero specificato di millisecondi o finché un token di annullamento non viene annullato.</summary>
        <returns>Indice dell'attività completata nell'argomento di matrice di <paramref name="tasks" />, oppure -1 in caso di timeout.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.</exception>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'attività che verrà completata quando tutte le attività fornite saranno completate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata in seguito al completamento di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> di una raccolta enumerabile.</summary>
        <returns>Attività che rappresenta il completamento di tutte le attività fornite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload di <xref:System.Threading.Tasks.Task.WhenAll%2A> metodo che restituisce un <xref:System.Threading.Tasks.Task> oggetto sono in genere chiamato quando si è interessati, lo stato di un set di attività o le eccezioni generate da un set di attività.  
  
> [!NOTE]
>  La chiamata a <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> metodo non blocca il thread chiamante.  
  
 Se una delle attività specificata viene completato in uno stato di errore, l'attività restituita verrà completata anche un <xref:System.Threading.Tasks.TaskStatus.Faulted> stato, in cui le eccezioni conterrà l'aggregazione del set di eccezioni annullato il wrapping da ognuna delle attività fornite.  
  
 Se nessuna delle attività fornite con errori, ma almeno uno di essi è stato annullato, l'attività restituita terminerà tra il <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  
  
 Se nessuna delle attività non riuscite e nessuna delle attività sono stata annullata, l'attività risultante terminerà tra il <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  
  
 Se fornito array/enumerabile non contiene attività, l'attività restituita immediatamente passerà a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato prima che venga restituito al chiamante.  
  
   
  
## Examples  
 L'esempio seguente crea un set di attività che gli URL in una matrice di effettuare il ping. Le attività vengono archiviate in un `List<Task>` insieme che viene passato per il <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> metodo. Dopo la chiamata al <xref:System.Threading.Tasks.Task.Wait%2A> metodo assicura che tutti i thread è sono completata, l'esempio esamina la <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> proprietà per determinare se tutte le attività sono con errori.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La raccolta <paramref name="tasks" /> conteneva un'attività <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata in seguito al completamento di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> di una matrice.</summary>
        <returns>Attività che rappresenta il completamento di tutte le attività fornite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload di <xref:System.Threading.Tasks.Task.WhenAll%2A> metodo che restituisce un <xref:System.Threading.Tasks.Task> oggetto sono in genere chiamato quando si è interessati, lo stato di un set di attività o le eccezioni generate da un set di attività.  
  
> [!NOTE]
>  La chiamata a <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> metodo non blocca il thread chiamante.  
  
 Se una delle attività specificata viene completato in uno stato di errore, l'attività restituita verrà completata anche un <xref:System.Threading.Tasks.TaskStatus.Faulted> stato, in cui le eccezioni conterrà l'aggregazione del set di eccezioni annullato il wrapping da ognuna delle attività fornite.  
  
 Se nessuna delle attività fornite con errori, ma almeno uno di essi è stato annullato, l'attività restituita terminerà tra il <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  
  
 Se nessuna delle attività non riuscite e nessuna delle attività sono stata annullata, l'attività risultante terminerà tra il <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  
  
 Se fornito array/enumerabile non contiene attività, l'attività restituita immediatamente passerà a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato prima che venga restituito al chiamante.  
  
   
  
## Examples  
 L'esempio seguente crea un set di attività che gli URL in una matrice di effettuare il ping. Le attività vengono archiviate in un `List<Task>` raccolta che viene convertito in una matrice e passato per il <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> metodo. Dopo la chiamata al <xref:System.Threading.Tasks.Task.Wait%2A> metodo assicura che tutti i thread è sono completata, l'esempio esamina la <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> proprietà per determinare se tutte le attività sono con errori.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice<paramref name="tasks" /> conteneva un'attività <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo dell'attività completata.</typeparam>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata in seguito al completamento di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task`1" /> di una raccolta enumerabile.</summary>
        <returns>Attività che rappresenta il completamento di tutte le attività fornite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata a <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> metodo non blocca il thread chiamante. Tuttavia, una chiamata all'oggetto restituito <xref:System.Threading.Tasks.Task%601.Result%2A> proprietà blocca il thread chiamante.  
  
 Se una delle attività specificata viene completato in uno stato di errore, l'attività restituita verrà completata anche un <xref:System.Threading.Tasks.TaskStatus.Faulted> stato, in cui le eccezioni conterrà l'aggregazione del set di eccezioni annullato il wrapping da ognuna delle attività fornite.  
  
 Se nessuna delle attività fornite con errori, ma almeno uno di essi è stato annullato, l'attività restituita terminerà tra il <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  
  
 Se nessuna delle attività non riuscite e nessuna delle attività sono stata annullata, l'attività risultante terminerà tra il <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  Il <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> dell'attività restituita verrà impostata per una matrice contenente tutti i risultati delle attività fornite nello stesso ordine, così come sono stati forniti (ad esempio, se l'input dell'attività di matrice inclusa t1, t2, t3, l'attività di output <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> restituirà un `TResult[]` in `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Se il `tasks` argomento non contiene attività, l'attività restituita immediatamente passerà a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato prima che venga restituito al chiamante. L'oggetto restituito `TResult[]` sarà una matrice di elementi di 0.  
  
   
  
## Examples  
 L'esempio seguente crea dieci attività, ognuna delle quali viene creata un'istanza di un generatore di numeri casuali che crea i numeri casuali 1.000 compreso tra 1 e 1.000 e calcola la Media. Il <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> metodo viene utilizzato per posticipare la creazione di istanze di generatori di numeri casuali in modo che non vengono create con valori di inizializzazione identici. La chiamata al <xref:System.Threading.Tasks.Task.WhenAll%2A> metodo quindi restituisce un <xref:System.Int64> matrice che contiene il valore medio calcolato da ogni attività. Questi vengono quindi utilizzati per calcolare la media globale.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 In questo caso, le dieci attività singole vengono archiviate un <xref:System.Collections.Generic.List%601> oggetto. L'oggetto <xref:System.Collections.Generic.List%601> implementa l'interfaccia <xref:System.Collections.Generic.IEnumerable%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La raccolta <paramref name="tasks" /> conteneva un'attività <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo dell'attività completata.</typeparam>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata in seguito al completamento di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task`1" /> di una matrice.</summary>
        <returns>Attività che rappresenta il completamento di tutte le attività fornite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata a <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> metodo non blocca il thread chiamante. Tuttavia, una chiamata all'oggetto restituito <xref:System.Threading.Tasks.Task%601.Result%2A> proprietà blocca il thread chiamante.  
  
 Se una delle attività specificata viene completato in uno stato di errore, l'attività restituita verrà completata anche un <xref:System.Threading.Tasks.TaskStatus.Faulted> stato, in cui le eccezioni conterrà l'aggregazione del set di eccezioni annullato il wrapping da ognuna delle attività fornite.  
  
 Se nessuna delle attività fornite con errori, ma almeno uno di essi è stato annullato, l'attività restituita terminerà tra il <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  
  
 Se nessuna delle attività non riuscite e nessuna delle attività sono stata annullata, l'attività risultante terminerà tra il <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  Il <xref:System.Threading.Tasks.Task%601.Result%2A> dell'attività restituita verrà impostato su una matrice contenente tutti i risultati delle attività fornite nello stesso ordine, così come sono stati forniti (ad esempio, se l'input dell'attività di matrice inclusa t1, t2, t3, l'attività di output <xref:System.Threading.Tasks.Task%601.Result%2A> restituirà un `TResult[]` dove `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Se fornito array/enumerabile non contiene attività, l'attività restituita immediatamente passerà a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato prima che venga restituito al chiamante.  L'oggetto restituito `TResult[]` sarà una matrice di elementi di 0.  
  
   
  
## Examples  
 L'esempio seguente crea dieci attività, ognuna delle quali viene creata un'istanza di un generatore di numeri casuali che crea i numeri casuali 1.000 compreso tra 1 e 1.000 e calcola la Media. In questo caso, le dieci attività singole vengono archiviate un `Task<Int64>` matrice.  Il <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> metodo viene utilizzato per posticipare la creazione di istanze di generatori di numeri casuali in modo che non vengono create con valori di inizializzazione identici. La chiamata al <xref:System.Threading.Tasks.Task.WhenAll%2A> metodo quindi restituisce un <xref:System.Int64> matrice che contiene il valore medio calcolato da ogni attività. Questi vengono quindi utilizzati per calcolare la media globale.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice<paramref name="tasks" /> conteneva un'attività <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'attività che verrà completata quando una delle attività fornite sarà completata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata quando una delle attività fornite sarà completata.</summary>
        <returns>Attività che rappresenta il completamento di una delle attività fornite.  Il risultato dell'attività restituita è l'attività completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività restituita verrà completata quando una delle attività specificata è stata completata.  L'attività restituita sempre terminerà tra il `RanToCompletion` dello stato con il set di risultati per la prima attività per completare.  Questo vale anche se la prima attività da completare è terminata con il `Canceled` o `Faulted` stato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> conteneva un'attività null o era vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata quando una delle attività fornite sarà completata.</summary>
        <returns>Attività che rappresenta il completamento di una delle attività fornite.  Il risultato dell'attività restituita è l'attività completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività restituita verrà completata quando una delle attività specificata è stata completata.  Sempre terminerà l'attività restituita nel `RanToCompletion` stato relativo `Result` impostato per la prima attività su completo.  Questo vale anche se la prima attività da completare è terminata con il `Canceled` o `Faulted` stato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="tasks" /> era null.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> conteneva un'attività null o era vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo dell'attività completata.</typeparam>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata quando una delle attività fornite sarà completata.</summary>
        <returns>Attività che rappresenta il completamento di una delle attività fornite.  Il risultato dell'attività restituita è l'attività completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività restituita verrà completata quando una delle attività specificata è stata completata.  L'attività restituita verrà sempre terminare nello stato RanToCompletion con il set di risultati per la prima attività per completare. Questo vale anche se la prima attività da completare è terminata nello stato annullato o Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> conteneva un'attività null o era vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo dell'attività completata.</typeparam>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata quando una delle attività fornite sarà completata.</summary>
        <returns>Attività che rappresenta il completamento di una delle attività fornite.  Il risultato dell'attività restituita è l'attività completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività restituita verrà completata quando una delle attività specificata è stata completata.  L'attività restituita verrà sempre terminare nello stato RanToCompletion con il set di risultati per la prima attività per completare. Questo vale anche se la prima attività da completare è terminata nello stato annullato o Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="tasks" /> era null.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> conteneva un'attività null o era vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un'attività awaitable che consente il passaggio in modo asincrono al contesto corrente, quando atteso.</summary>
        <returns>Contesto che, quando atteso, eseguirà una transizione in modo asincrono al contesto corrente al momento dell'attesa. Se l'oggetto <see cref="T:System.Threading.SynchronizationContext" /> corrente è diverso da Null, verrà considerato come contesto corrente. In caso contrario, sarà l'utilità di pianificazione associata all'attività in esecuzione a essere considerata come contesto corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare `await Task.Yield();` in un metodo asincrono per forzare il metodo venga completato in modo asincrono. Se è presente un contesto di sincronizzazione corrente (<xref:System.Threading.SynchronizationContext> oggetto), questo verrà registrato il resto dell'esecuzione del metodo tale contesto. Tuttavia, il contesto a decidere come classificare il lavoro relativo altro lavoro che può essere sospeso. Il contesto di sincronizzazione è presente in un thread dell'interfaccia utente nella maggior parte degli ambienti di interfaccia utente spesso verrà data priorità lavoro registrato per il contesto di maggiore di input e di lavoro per il rendering. Per questo motivo, non fare affidamento su `await Task.Yield();` per mantenere reattiva l'interfaccia utente.  Per ulteriori informazioni, vedere la voce [utile astrazioni abilitato con ContinueWith](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) in parallelo blog sulla programmazione con .NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>