<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c16340e471c95a0473b0f16f55090f971e888200" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51308311" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un'operazione asincrona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 Il <xref:System.Threading.Tasks.Task> classe rappresenta una singola operazione che non restituisce un valore e che in genere esegue in modo asincrono. <xref:System.Threading.Tasks.Task> gli oggetti sono uno dei componenti centrali del [modello asincrono basato su attività](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) introdotte inizialmente in .NET Framework 4. Poiché il lavoro eseguito da un <xref:System.Threading.Tasks.Task> in genere viene eseguito l'oggetto in modo asincrono in un pool di thread anziché in modo sincrono sul thread principale dell'applicazione, è possibile usare il <xref:System.Threading.Tasks.Task.Status%2A> proprietà, nonché il <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, e <xref:System.Threading.Tasks.Task.IsFaulted%2A> alle proprietà per determinare lo stato di un'attività. In genere, un'espressione lambda viene utilizzata per specificare il lavoro che l'attività deve eseguire.  
  
 Per le operazioni che restituiscono valori, si utilizza il <xref:System.Threading.Tasks.Task%601> classe.  
  
 Contenuto della sezione:  
  
 [Esempi di creazione di un'istanza di attività](#Instant)   
 [Creazione ed esecuzione di un'attività](#Creating)   
 [La separazione tra l'esecuzione e la creazione di attività](#Separating)   
 [In attesa di uno o più attività da completare](#WaitingForOne)   
 [Le attività e le impostazioni cultura](#Culture)   
 [Per gli sviluppatori di debugger](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a>Creazione di istanze di attività  
 Nell'esempio seguente crea ed esegue quattro attività. Le tre attività vengono eseguite un' <xref:System.Action%601> delegato denominato `action`, che accetta un argomento di tipo <xref:System.Object>. Un'espressione lambda viene eseguita un'attività quarta (un <xref:System.Action> delegare) vale a dire definito inline nella chiamata al metodo di creazione di attività. Ogni attività vengano creata un'istanza ed eseguire in modo diverso:  
  
-   Task `t1` viene creata un'istanza chiamando un costruttore di classe di attività, ma viene avviata chiamando relativi <xref:System.Threading.Tasks.Task.Start> metodo solo dopo l'attività `t2` è stata avviata.  
  
-   Task `t2` viene creata e avviata in una singola chiamata al metodo chiamando il <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> (metodo).  
  
-   Task `t3` viene creata e avviata in una singola chiamata al metodo chiamando il <xref:System.Threading.Tasks.Task.Run%28System.Action%29> (metodo).  
  
-   Task `t4` viene eseguita in modo sincrono sul thread principale, chiamare il <xref:System.Threading.Tasks.Task.RunSynchronously> (metodo).  
  
 In quanto attività `t4` esegue in modo sincrono, viene eseguito sul thread principale dell'applicazione. Le rimanenti attività eseguire in modo asincrono in genere in uno o più pool di thread.  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>Creazione ed esecuzione di un'attività  
 <xref:System.Threading.Tasks.Task> è possibile creare istanze in diversi modi. L'approccio più comune, che sarà disponibile a partire con il [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile chiamare il metodo statico <xref:System.Threading.Tasks.Task.Run%2A> (metodo). Il <xref:System.Threading.Tasks.Task.Run%2A> metodo fornisce un modo semplice per avviare un'attività usando i valori predefiniti e senza richiedere parametri aggiuntivi. L'esempio seguente usa il <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metodo per avviare un'attività che esegue il ciclo e quindi Visualizza il numero di iterazioni del ciclo:  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 In alternativa e il metodo più comune per avviare un'attività in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], è il metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> (metodo). Il <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> proprietà restituisce un <xref:System.Threading.Tasks.TaskFactory> oggetto. Esegue l'overload del <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodo consentono di specificare i parametri da passare a un'utilità di pianificazione e le opzioni di creazione di attività. L'esempio seguente usa il <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodo per avviare un'attività. È funzionalmente equivalente al codice nell'esempio precedente.  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 Per esempi più completi, vedere [programmazione asincrona basata su attività](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>La separazione tra l'esecuzione e la creazione di attività  
 Il <xref:System.Threading.Tasks.Task> classe fornisce anche i costruttori che inizializzano l'attività, ma che non si pianifica l'esecuzione. Per motivi di prestazioni, la <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodo è il meccanismo preferito per creare e pianificare le attività di calcolo, ma per gli scenari in cui la creazione e la pianificazione devono essere separati, è possibile usare i costruttori e quindi chiamare il <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> metodo per pianificare l'attività per l'esecuzione in un secondo momento.  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>In attesa di uno o più attività da completare  
 Poiché le attività in genere vengono eseguiti in modo asincrono in un pool di thread, il thread che crea e avvia l'attività continua l'esecuzione, non appena l'attività è stata creata l'istanza. In alcuni casi, quando il thread chiamante è il thread principale dell'applicazione, l'app può terminare prima di qualsiasi attività effettivamente inizia l'esecuzione. In altri casi, la logica dell'applicazione può richiedere che il thread chiamante continua l'esecuzione solo quando una o più attività è stata completata l'esecuzione. È possibile sincronizzare l'esecuzione del thread chiamante e asincrona le attività consente di avviare chiamando un `Wait` metodo per attendere uno o più attività da completare.  
  
 Per attendere il completamento di un'attività singola, è possibile chiamare relativo <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> (metodo). Una chiamata al <xref:System.Threading.Tasks.Task.Wait%2A> metodo si blocca il thread chiamante finché l'istanza della classe singola è stata completata l'esecuzione.  
  
 L'esempio seguente viene chiamata senza parametri <xref:System.Threading.Tasks.Task.Wait> metodo per attendere in modo incondizionato fino al completamento di un'attività. L'attività simula lavoro chiamando il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo allo stato di sospensione per due secondi.  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 È inoltre in modo condizionale può attendere un'attività da completare. Il <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> e <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> metodi bloccano il thread chiamante finché non viene completata l'attività o un intervallo di timeout scade, a seconda del valore raggiunto per primo. Poiché nell'esempio seguente viene avviata un'attività che rimane inattivo per due secondi, ma definisce un valore di timeout di un secondo, il thread chiamante si blocca fino a quando non scade il timeout e prima dell'attività è stata completata l'esecuzione.  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 È anche possibile fornire un token di annullamento chiamando il <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> e <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metodi. Se il token <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> proprietà è `true` o diventa `true` mentre il <xref:System.Threading.Tasks.Task.Wait%2A> metodo è in esecuzione, il metodo genera un <xref:System.OperationCanceledException>.  
  
 In alcuni casi, si vuole attendere per il primo di una serie di esecuzione dell'attività completata, ma è care quale attività è.  A tale scopo, è possibile chiamare uno degli overload del <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> (metodo).  L'esempio seguente crea tre attività, ognuna delle quali rimane inattivo per un intervallo di determinare dal generatore di numeri casuali. Il <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> metodo attende il completamento dell'attività prima. Nell'esempio vengono quindi visualizzate informazioni sullo stato di tutte le tre attività.  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 È anche possibile attendere tutti di una serie di attività da completare tramite la chiamata di <xref:System.Threading.Tasks.Task.WaitAll%2A> (metodo). L'esempio seguente crea dieci attività, attende che tutti e dieci completamento e quindi Visualizza il relativo stato.  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 Si noti che quando in attesa di uno o più attività da completare, tutte le eccezioni generate nelle attività in esecuzione vengono propagate nel thread che chiama il `Wait` metodo, come illustrato nell'esempio seguente. Avvia le attività di 12, tre dei quali completata normalmente e tre dei quali generano un'eccezione. Delle sei attività rimanenti, tre vengono annullati prima dell'avvio, e tre annullati durante cui l'esecuzione. Vengono generate eccezioni nel <xref:System.Threading.Tasks.Task.WaitAll%2A> chiamata al metodo e sono gestite da un `try` / `catch` blocco.  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 Per altre informazioni sulla gestione delle eccezioni in operazioni asincrone basate su attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>Le attività e le impostazioni cultura  
 Inizia con le app desktop che hanno come destinazione il [!INCLUDE[net_v46](~/includes/net-v46-md.md)], le impostazioni cultura del thread che crea e richiama un'attività entra a far parte del contesto del thread. Indipendentemente dalle impostazioni cultura correnti del thread in cui l'attività viene eseguita, le impostazioni cultura correnti dell'attività sono la cultura del thread chiamante. Per le app destinate a versioni di .NET Framework precedenti al [!INCLUDE[net_v46](~/includes/net-v46-md.md)], le impostazioni cultura dell'attività sono le impostazioni cultura del thread in cui viene eseguita l'attività. Per altre informazioni, vedere la sezione "Impostazioni cultura e operazioni asincrone basate su attività" nel <xref:System.Globalization.CultureInfo> argomento.  
  
> [!NOTE]
>  Le app di Store seguono il Runtime di Windows nell'impostazione e recupero delle impostazioni cultura predefinite.  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>Per gli sviluppatori di debugger  
 Per gli sviluppatori implementano debugger personalizzati, membri interni e privati diverse dell'attività possono essere utili (tali può cambiare nelle diverse versioni). Il `m_taskId` campo funge da archivio di backup per il <xref:System.Threading.Tasks.Task.Id%2A> proprietà, tuttavia l'accesso a questo campo direttamente da un debugger può essere più efficiente rispetto all'accesso allo stesso valore tramite il metodo di richiamo della proprietà (il `s_taskIdCounter` contatore Consente di recuperare il successivo ID disponibile per un'attività). Analogamente, il `m_stateFlags` campo Archivia le informazioni relative alla fase del ciclo di vita corrente dell'attività, informazioni accessibili anche tramite il <xref:System.Threading.Tasks.Task.Status%2A> proprietà. Il `m_action` campo Archivia un riferimento al delegato dell'attività e il `m_stateObject` campo Archivia lo stato asincrono passato all'attività dallo sviluppatore. Infine, per debugger che analizzano gli stack frame, la `InternalWait` metodo viene utilizzato un marcatore potenziali per quando un'attività sta entrando in un'operazione di attesa.   
  
 ]]></format>
    </remarks>
    <threadsafe>Tutti i membri del <see cref="T:System.Threading.Tasks.Task" />, ad eccezione di <see cref="M:System.Threading.Tasks.Task.Dispose" />, sono thread-safe e possono essere utilizzati da più thread contemporaneamente.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmazione asincrona basata su attività</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Esempi di programmazione parallela con .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invece di chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetti e avviare un'attività consiste nel chiamare il metodo statico <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> o <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> (metodo). L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati da una chiamata di attività.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> costruttore per creare le attività che recuperano i nomi di file nelle directory specificate. Tutte le attività di scrivono i nomi dei file in un singolo <xref:System.Collections.Concurrent.ConcurrentBag%601> oggetto. Nell'esempio viene quindi chiamato il <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> metodo per assicurarsi che tutte le attività completate e quindi visualizza un conteggio del numero totale di nomi di file scritti i <xref:System.Collections.Concurrent.ConcurrentBag%601> oggetto.  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 Nell'esempio seguente è identico, ad eccezione del fatto che usato il <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metodo per creare un'istanza ed eseguire l'attività in un'unica operazione. Il metodo restituisce il <xref:System.Threading.Tasks.Task> oggetto che rappresenta l'attività.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="action" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> che verrà considerato dalla nuova attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione specificata e <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invece di chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetti e avviare un'attività consiste nel chiamare il metodo statico <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> e <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> metodi. L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati da una chiamata di attività.  
  
 Per altre informazioni, vedere [parallelismo fra attività (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) e [annullamento in thread gestiti](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> costruttore per creare un'attività che esegue l'iterazione di file nella directory C:\Windows\System32. L'espressione lambda chiama il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo per aggiungere informazioni su ogni file a un <xref:System.Collections.Generic.List%601> oggetto. Ogni scollegato attività annidata richiamato dal <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> ciclo controlla lo stato del token di annullamento e, se viene richiesto l'annullamento, chiama il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> (metodo). Il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodo genera un' <xref:System.OperationCanceledException> eccezione gestita in un `catch` bloccare quando il thread chiama chiama il <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> (metodo).  Il <xref:System.Threading.Tasks.Task.Start%2A> viene quindi chiamato il metodo per avviare l'attività.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Provider <see cref="T:System.Threading.CancellationToken" /> già eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="creationOptions">Oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per personalizzare il comportamento dell'attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione e le opzioni di creazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invece di chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetti e avviare un'attività consiste nel chiamare il metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> (metodo). L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati da una chiamata di attività.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="creationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione e lo stato specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invece di chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetti e avviare un'attività consiste nel chiamare il metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> (metodo). L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati da una chiamata di attività.  
  
   
  
## Examples  
 L'esempio seguente definisce una matrice di parole 6-letter. Ogni parola viene quindi passato come argomento per il <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> costruttore, il cui <xref:System.Action%601> delegato codificata i caratteri della parola, quindi Visualizza il termine originale e la relativa versione codificata.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà considerato dalla nuova attività.</param>
        <param name="creationOptions">Oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per personalizzare il comportamento dell'attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione e le opzioni di creazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invece di chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetti e avviare un'attività consiste nel chiamare il metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> (metodo). L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati da una chiamata di attività.  
  
 Per altre informazioni, vedere [parallelismo fra attività (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) e [annullamento delle attività](~/docs/standard/parallel-programming/task-cancellation.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="creationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà osservato dalla nuova attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione, lo stato e le opzioni specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invece di chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetti e avviare un'attività consiste nel chiamare il metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> (metodo). L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati da una chiamata di attività.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione.</param>
        <param name="creationOptions">Oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per personalizzare il comportamento dell'attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione, lo stato e le opzioni specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invece di chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetti e avviare un'attività consiste nel chiamare il metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> (metodo). L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati da una chiamata di attività.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="creationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegato che rappresenta il codice da eseguire nell'attività.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà osservato dalla nuova attività.</param>
        <param name="creationOptions">Oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per personalizzare il comportamento dell'attività.</param>
        <summary>Inizializza un nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> con l'azione, lo stato e le opzioni specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invece di chiamare questo costruttore, il modo più comune per creare un'istanza di un <xref:System.Threading.Tasks.Task> oggetti e avviare un'attività consiste nel chiamare il metodo statico <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> (metodo). L'unico vantaggio offerto da questo costruttore è che consente la creazione di istanze di oggetto essere separati da una chiamata di attività.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="action" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="creationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto stato fornito quando è stato creato <see cref="T:System.Threading.Tasks.Task" /> oppure null se non ne è stato fornito alcuno.</summary>
        <value>Oggetto <see cref="T:System.Object" /> che rappresenta i dati relativi allo stato passati all'attività al momento della creazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il cast dell'oggetto nel tipo originale per recuperare i dati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un'attività già completata correttamente.</summary>
        <value>Attività completata correttamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce un'attività il cui <xref:System.Threading.Tasks.Task.Status%2A> è impostata su <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Per creare attività che restituisce un valore e viene eseguito fino al completamento, chiamare il <xref:System.Threading.Tasks.Task.FromResult%2A> (metodo).  
  
 Tentativi ripetuti di recuperare il valore della proprietà potrebbero non restituire sempre la stessa istanza.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">
          <see langword="true" /> per provare a effettuare il marshalling della continuazione nel contesto originale acquisito; in caso contrario, <see langword="false" />.</param>
        <summary>Configura un elemento awaiter usato per attendere questo oggetto <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Oggetto usato per attendere questa attività.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta a causa dell'annullamento in modo prematuro.  
  
   
  
## Examples  
 L'esempio seguente definisce un'attività che popola una matrice con 100 casuale valori data e ora. Usa il <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> metodo selezionare meno recente e i valori di data più recenti dopo che la matrice è completamente popolata.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Perché un'applicazione console potrebbe terminare prima che l'attività di continuazione viene eseguita, il <xref:System.Threading.Tasks.Task.Wait> metodo viene chiamato per verificare che la continuazione al termine dell'esecuzione prima della scadenza di esempio.  
  
 Per un altro esempio, vedere [concatenamento di attività tramite attività di continuazione](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationAction" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento dell'attività. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante vengono passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione di continuazione.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e viene eseguita al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o uscire dalla fase iniziale a causa dell'annullamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationAction" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea una continuazione che riceve un token di annullamento e viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta a causa dell'annullamento in modo prematuro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato il token è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationAction" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire in base all'oggetto <c>continuationOptions</c> specificato. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuazione che viene eseguita al completamento dell'attività di destinazione in base all'oggetto <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> specificato.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente. Se i criteri di continuazione specificato tramite la `continuationOptions` parametro non vengono soddisfatti, verrà annullata l'attività di continuazione anziché pianificata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare <xref:System.Threading.Tasks.TaskContinuationOptions> per specificare che un'attività di continuazione deve essere eseguita in modo sincrono al completamento dell'attività antecedente. (Se l'attività specificata è già stata completata entro l'ora di <xref:System.Threading.Tasks.Task.ContinueWith%2A> viene chiamato, sincrono continuazione verrà eseguita nel chiamante thread <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationAction" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta a causa dell'annullamento in modo prematuro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationAction" /> è <see langword="null" />.  
  
oppure 
L'argomento <paramref name="scheduler" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione di continuazione.</param>
        <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e un token di annullamento e che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta a causa dell'annullamento in modo prematuro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationAction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Provider <see cref="T:System.Threading.CancellationToken" /> già eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e viene eseguita al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione viene eseguita in base a un set di condizioni specificate.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente. Se i criteri di continuazione specificato tramite la `continuationOptions` parametro non vengono soddisfatti, verrà annullata l'attività di continuazione anziché pianificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationAction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />.  Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione di continuazione.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta a causa dell'annullamento in modo prematuro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire in base all'oggetto <c>continuationOptions</c> specificato. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita al completamento dell'attività di destinazione in base all'oggetto <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> specificato. La continuazione riceve un token di annullamento e usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente. Se i criteri specificati tramite il `continuationOptions` parametro non vengono soddisfatti, verrà annullata l'attività di continuazione anziché pianificata.  
  
   
  
## Examples  
 Di seguito è riportato un esempio dell'uso di ContinueWith per eseguire le attività in background e nell'utente del thread dell'interfaccia.  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato il token è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationAction" /> è Null.  
  
oppure 
L'argomento <paramref name="scheduler" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Azione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dall'azione di continuazione.</param>
        <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e un token di annullamento e che viene eseguita al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione viene eseguita in base a un set di condizioni specificate e usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente. Se i criteri specificati tramite il `continuationOptions` parametro non vengono soddisfatti, verrà annullata l'attività di continuazione anziché pianificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Provider <see cref="T:System.Threading.CancellationToken" /> già eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task`1" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di destinazione e restituisce un valore.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta a causa dell'annullamento in modo prematuro.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il metodo ContinueWith:  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationFunction" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dalla funzione di continuazione.</param>
        <summary>Crea una continuazione che riceve informazioni sullo stato fornite dal chiamante e viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione, quindi restituisce un valore.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta a causa dell'annullamento in modo prematuro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione e restituisce un valore. La continuazione riceve un token di annullamento.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta a causa dell'annullamento in modo prematuro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.  
  
oppure 
L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato il token è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationFunction" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire in base alla condizione specificata in <c>continuationOptions</c>. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuazione che viene eseguita in base alle opzioni di continuazione specificate e restituisce un valore.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente. Se i criteri di continuazione specificato tramite la `continuationOptions` parametro non vengono soddisfatti, verrà annullata l'attività di continuazione anziché pianificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationFunction" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione e restituisce un valore. La continuazione usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta a causa dell'annullamento in modo prematuro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationFunction" /> è Null.  
  
oppure 
L'argomento <paramref name="scheduler" /> è Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dalla funzione di continuazione.</param>
        <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione e restituisce un valore. La continuazione riceve informazioni sullo stato fornite dal chiamante e un token di annullamento.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta a causa dell'annullamento in modo prematuro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Provider <see cref="T:System.Threading.CancellationToken" /> già eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dalla funzione di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuazione che viene eseguita in base alle opzioni specificate per la continuazione delle attività al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione riceve informazioni sullo stato fornite dal chiamante.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente. Se i criteri di continuazione specificato tramite la `continuationOptions` parametro non vengono soddisfatti, verrà annullata l'attività di continuazione anziché pianificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />.  Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dalla funzione di continuazione.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita in modo asincrono al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione. La continuazione riceve informazioni sullo stato fornite dal chiamante e usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente, se viene completato correttamente in esecuzione fino al completamento, generare un errore a causa di un'eccezione non gestita o interrotta a causa dell'annullamento in modo prematuro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire in base all'oggetto <c>continuationOptions</c> specificato Durante l'esecuzione, l'attività completata verrà passata come argomento al delegato.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita in base alle opzioni di continuazione specificate e restituisce un valore. La continuazione riceve un token di annullamento e usa un'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente. Se i criteri specificati tramite il `continuationOptions` parametro non vengono soddisfatti, verrà annullata l'attività di continuazione anziché pianificata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come usare il metodo ContinueWith con opzioni di continuazione:  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.  
  
oppure 
L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato il token è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="continuationFunction" /> è Null.  
  
oppure 
L'argomento <paramref name="scheduler" /> è Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato prodotto dalla continuazione.</typeparam>
        <param name="continuationFunction">Funzione da eseguire al completamento di <see cref="T:System.Threading.Tasks.Task" />. Durante l'esecuzione, l'attività completata e l'oggetto stato fornito dal chiamante verranno passati come argomenti al delegato.</param>
        <param name="state">Oggetto che rappresenta i dati che devono essere usati dalla funzione di continuazione.</param>
        <param name="cancellationToken">Oggetto <see cref="T:System.Threading.CancellationToken" /> che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Opzioni relative alla pianificazione e al comportamento della continuazione. Ciò comprende criteri, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, nonché opzioni di esecuzione, ad esempio <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> da associare all'attività di continuazione e da usare per l'esecuzione.</param>
        <summary>Crea una continuazione che viene eseguita in base alle opzioni specificate per la continuazione delle attività al completamento dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> di destinazione, quindi restituisce un valore. La continuazione riceve informazioni sullo stato fornite dal chiamante e un token di annullamento, quindi usa l'utilità di pianificazione specificata.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto restituito <xref:System.Threading.Tasks.Task%601> sarà pianificata per l'esecuzione fino a quando non è stata completata l'attività corrente. Se i criteri specificati tramite il `continuationOptions` parametro non vengono soddisfatti, verrà annullata l'attività di continuazione anziché pianificata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido per <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Provider <see cref="T:System.Threading.CancellationToken" /> già eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per creare questa attività.</summary>
        <value>Oggetto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usato per creare questa attività.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce l'ID dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> attualmente in esecuzione.</summary>
        <value>Intero assegnato dal sistema all'attività attualmente in esecuzione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A> è un `static` (`Shared` in Visual Basic) proprietà utilizzata per ottenere l'identificatore dell'attività attualmente in esecuzione dal codice che l'attività è in esecuzione. Si differenzia dal <xref:System.Threading.Tasks.Task.Id%2A> proprietà, che restituisce l'identificatore di un determinato <xref:System.Threading.Tasks.Task> istanza. Se si prova a recuperare il <xref:System.Threading.Tasks.Task.CurrentId%2A> valore all'esterno del codice che un'attività è in esecuzione, la proprietà restituisce `null`.  
  
 Si noti che anche se le collisioni sono molto rare, gli identificatori di attività non sono necessariamente essere univoci.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'attività che verrà completata dopo un ritardo di tempo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Numero di millisecondi prima del completamento dell'attività restituita oppure -1 per un'attesa indefinita.</param>
        <summary>Crea un'attività che viene completata dopo un numero di millisecondi specificato.</summary>
        <returns>Attività che rappresenta il ritardo di tempo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task.Delay%2A> metodo viene in genere utilizzato per ritardare l'operazione di tutti o parte di un'attività per un intervallo di tempo specificato. In genere, è stato introdotto il ritardo di tempo:  
  
-   AT Mostra l'inizio dell'attività, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   Minuto mentre l'attività è in esecuzione. In questo caso, la chiamata al <xref:System.Threading.Tasks.Task.Delay%2A> metodo viene eseguito come attività figlio all'interno di un'attività, come illustrato nell'esempio seguente. Si noti che poiché l'attività che chiama il <xref:System.Threading.Tasks.Task.Delay%2A> metodo viene eseguito in modo asincrono, l'attività padre deve attendere il completamento tramite la `await` (parola chiave).  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 Dopo il ritardo di tempo specificato, l'attività viene completata nel <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  
  
 Questo metodo dipende dall'orologio di sistema. Ciò significa che l'intervallo di tempo sarà pari circa la risoluzione del clock di sistema se la `millisecondsDelay` argomento è minore rispetto alla risoluzione dell'orologio di sistema, è di circa 15 millisecondi nei sistemi Windows.  
  
   
  
## Examples  
 L'esempio seguente illustra un semplice utilizzo di <xref:System.Threading.Tasks.Task.Delay%2A> (metodo).  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="millisecondsDelay" /> è minore di -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">Intervallo di tempo da attendere prima del completamento dell'attività restituita oppure <see langword="TimeSpan.FromMilliseconds(-1)" /> per un'attesa indefinita.</param>
        <summary>Crea un'attività che viene completata dopo un intervallo di tempo specificato.</summary>
        <returns>Attività che rappresenta il ritardo di tempo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il ritardo di tempo specificato, l'attività viene completata <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  
  
 Per gli scenari di utilizzo ed esempi aggiuntivi, vedere la documentazione per il <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> rapporto di overload.  
  
 Questo metodo dipende dall'orologio di sistema. Ciò significa che l'intervallo di tempo sarà pari circa la risoluzione del clock di sistema se la `delay` argomento è minore rispetto alla risoluzione dell'orologio di sistema, è di circa 15 millisecondi nei sistemi Windows.  
  
   
  
## Examples  
 L'esempio seguente illustra un semplice utilizzo di <xref:System.Threading.Tasks.Task.Delay%2A> (metodo).  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> rappresenta un intervallo di tempo negativo diverso da <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
oppure 
La proprietà <see cref="P:System.TimeSpan.TotalMilliseconds" /> dell'argomento <paramref name="delay" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Numero di millisecondi prima del completamento dell'attività restituita oppure -1 per un'attesa indefinita.</param>
        <param name="cancellationToken">Token di annullamento da osservare durante l'attesa del completamento dell'attività.</param>
        <summary>Crea un'attività annullabile che viene completata dopo un numero di millisecondi specificato.</summary>
        <returns>Attività che rappresenta il ritardo di tempo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il token di annullamento viene segnalato prima che il ritardo di tempo specificato, un <xref:System.Threading.Tasks.TaskCanceledException> dei risultati dell'eccezione e l'attività viene completato nei <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  In caso contrario, l'attività viene completato nei <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato una volta trascorso l'intervallo di tempo specificato.  
  
 Per gli scenari di utilizzo ed esempi aggiuntivi, vedere la documentazione per il <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> rapporto di overload.  
  
 Questo metodo dipende dall'orologio di sistema. Ciò significa che l'intervallo di tempo sarà pari circa la risoluzione del clock di sistema se la `millisecondsDelay` argomento è minore rispetto alla risoluzione dell'orologio di sistema, è di circa 15 millisecondi nei sistemi Windows.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'attività che include una chiamata al <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> metodo con un secondo di ritardo. Prima che è trascorso l'intervallo di ritardo, il token viene annullato. L'output dell'esempio mostra che, di conseguenza, un <xref:System.Threading.Tasks.TaskCanceledException> viene generata un'eccezione, nonché delle attività <xref:System.Threading.Tasks.Task.Status%2A> è impostata su <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="millisecondsDelay" /> è minore di -1.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">Provider <paramref name="cancellationToken" /> già eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">Intervallo di tempo da attendere prima del completamento dell'attività restituita oppure <see langword="TimeSpan.FromMilliseconds(-1)" /> per un'attesa indefinita.</param>
        <param name="cancellationToken">Token di annullamento da osservare durante l'attesa del completamento dell'attività.</param>
        <summary>Crea un'attività annullabile che viene completata dopo un intervallo di tempo specificato.</summary>
        <returns>Attività che rappresenta il ritardo di tempo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il token di annullamento viene segnalato prima che il ritardo di tempo specificato, un <xref:System.Threading.Tasks.TaskCanceledException> dei risultati dell'eccezione e l'attività viene completato nei <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  In caso contrario, l'attività viene completato nei <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato una volta trascorso l'intervallo di tempo specificato.  
  
 Per gli scenari di utilizzo ed esempi aggiuntivi, vedere la documentazione per il <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> rapporto di overload.  
  
 Questo metodo dipende dall'orologio di sistema. Ciò significa che l'intervallo di tempo sarà pari circa la risoluzione del clock di sistema se la `delay` argomento è minore rispetto alla risoluzione dell'orologio di sistema, è di circa 15 millisecondi nei sistemi Windows.  
  
   
  
## Examples  
 Nell'esempio seguente viene avviata un'attività che include una chiamata al <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metodo con un ritardo di 1,5 secondi. Prima che è trascorso l'intervallo di ritardo, il token viene annullato. L'output dell'esempio mostra che, di conseguenza, un <xref:System.Threading.Tasks.TaskCanceledException> viene generata un'eccezione, nonché delle attività <xref:System.Threading.Tasks.Task.Status%2A> è impostata su <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Si noti che questo esempio include una possibile race condition: dipende l'attività in esecuzione in modo asincrono il ritardo quando viene annullato il token. Sebbene il secondo 1,5 ritardare la chiamata ai <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metodo effettua questo presupposto probabilmente, tuttavia è possibile che la chiamata al <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metodo può restituire prima che il token viene annullato. In tal caso, l'esempio produce l'output seguente:  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> rappresenta un intervallo di tempo negativo diverso da <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
oppure 
La proprietà <see cref="P:System.TimeSpan.TotalMilliseconds" /> dell'argomento <paramref name="delay" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">Provider <paramref name="cancellationToken" /> già eliminato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task> classe implementa le <xref:System.IDisposable> interfaccia perché internamente Usa le risorse che implementano anche <xref:System.IDisposable>. Tuttavia, in particolare se destinazione dell'app il [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o in un secondo momento, non è necessario chiamare <xref:System.Threading.Tasks.Task.Dispose%2A> , a meno che le prestazioni o scalabilità test indica che, in base i modelli di utilizzo, le prestazioni dell'app risulta migliorata eliminando le attività. Per altre informazioni, vedere [necessario per l'eliminazione di attività?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) nella programmazione parallela con .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'attività non è in uno degli stati finali: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> o <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Valore booleano che indica se questo metodo viene chiamato a causa di una chiamata a <see cref="M:System.Threading.Tasks.Task.Dispose" />.</param>
        <summary>Elimina <see cref="T:System.Threading.Tasks.Task" />, rilasciandone tutte le risorse non gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task> classe implementa le <xref:System.IDisposable> interfaccia perché internamente Usa le risorse che implementano anche <xref:System.IDisposable>. Tuttavia, in particolare se destinazione dell'app il [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o in un secondo momento, non è necessario chiamare <xref:System.Threading.Tasks.Task.Dispose%2A> , a meno che le prestazioni o scalabilità test indica che, in base i modelli di utilizzo, le prestazioni dell'app risulta migliorata eliminando le attività. Per altre informazioni, vedere [necessario per l'eliminazione di attività?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) nella programmazione parallela con .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'attività non è in uno degli stati finali: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> o <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <threadsafe>A differenza della maggior parte dei membri del <see cref="T:System.Threading.Tasks.Task" /> (classe), questo metodo non è thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.AggregateException" /> che ha causato l'interruzione anomala di <see cref="T:System.Threading.Tasks.Task" />. Se l'oggetto <see cref="T:System.Threading.Tasks.Task" /> è stato completato correttamente o non ha ancora generato alcuna eccezione, verrà restituito <see langword="null" />.</summary>
        <value>Oggetto <see cref="T:System.AggregateException" /> che ha causato l'interruzione anomala di <see cref="T:System.Threading.Tasks.Task" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le attività che generano eccezioni non gestite archiviare l'eccezione risulta e propagarlo sottoposta a wrapping in un <xref:System.AggregateException> nelle chiamate a <xref:System.Threading.Tasks.Task.Wait%2A> o in accessi per il <xref:System.Threading.Tasks.Task.Exception%2A> proprietà. Tutte le eccezioni non osservate nel momento in cui che l'istanza dell'attività viene raccolto nel garbage collector verranno propagate nel thread finalizzatore. Per altre informazioni e un esempio, vedere [gestione delle eccezioni (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fornisce l'accesso ai metodi factory per la creazione e la configurazione delle istanze di <see cref="T:System.Threading.Tasks.Task" /> e <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <value>Oggetto factory in grado di creare una vasta gamma di oggetti <see cref="T:System.Threading.Tasks.Task" /> e <see cref="T:System.Threading.Tasks.Task`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce un'istanza predefinita di <xref:System.Threading.Tasks.TaskFactory> class identica a quella creata tramite la chiamata senza parametri <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> costruttore. Include i valori delle proprietà seguenti:  
  
|Proprietà|Valore|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`, o <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 L'uso più comune di questa proprietà consiste nel creare e avviare una nuova attività in una singola chiamata al <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> (metodo).  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], il <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> metodo fornisce il modo più semplice per creare un <xref:System.Threading.Tasks.Task> oggetto con valori di configurazione predefiniti.  
  
 L'esempio seguente usa il metodo statico <xref:System.Threading.Tasks.Task.Factory%2A> proprietà effettuare due chiamate al <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> (metodo). Il primo popola una matrice con i nomi dei file nella directory di documenti dell'utente, mentre il secondo popola una matrice con i nomi delle sottodirectory della directory documenti dell'utente. Chiama quindi il <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> (metodo), che visualizza informazioni sul numero di file e directory in due matrici dopo le prime due attività ha completato l'esecuzione.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token di annullamento con cui completare l'attività.</param>
        <summary>Crea un oggetto <see cref="T:System.Threading.Tasks.Task" /> che risulta completato a causa dell'annullamento con un token di annullamento specificato.</summary>
        <returns>Attività annullata.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Non è stato richiesto l'annullamento per <paramref name="cancellationToken" />. La proprietà <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato restituito dall'attività.</typeparam>
        <param name="cancellationToken">Token di annullamento con cui completare l'attività.</param>
        <summary>Crea un oggetto <see cref="T:System.Threading.Tasks.Task`1" /> che risulta completato a causa dell'annullamento con un token di annullamento specificato.</summary>
        <returns>Attività annullata.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Non è stato richiesto l'annullamento per <paramref name="cancellationToken" />. La proprietà <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Eccezione con cui completare l'attività.</param>
        <summary>Crea un oggetto <see cref="T:System.Threading.Tasks.Task" /> che risulta completato con un'eccezione specificata.</summary>
        <returns>Attività in errore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea un' <xref:System.Threading.Tasks.Task> dell'oggetto la cui proprietà <xref:System.Threading.Tasks.Task.Status%2A> è di proprietà <xref:System.Threading.Tasks.TaskStatus.Faulted> e il cui <xref:System.Threading.Tasks.Task.Exception%2A> contiene proprietà `exception`. Il metodo viene usato comunemente quando è possibile sapere immediatamente che il lavoro che esegue un'attività genera un'eccezione prima dell'esecuzione di un percorso più lungo di codice. Per un esempio, vedere il <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> rapporto di overload.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato restituito dall'attività.</typeparam>
        <param name="exception">Eccezione con cui completare l'attività.</param>
        <summary>Crea un oggetto <see cref="T:System.Threading.Tasks.Task`1" /> che risulta completato con un'eccezione specificata.</summary>
        <returns>Attività in errore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea un' <xref:System.Threading.Tasks.Task%601> dell'oggetto la cui proprietà <xref:System.Threading.Tasks.Task.Status%2A> è di proprietà <xref:System.Threading.Tasks.TaskStatus.Faulted> e il cui <xref:System.Threading.Tasks.Task.Exception%2A> contiene proprietà `exception`. Il metodo viene usato comunemente quando è possibile sapere immediatamente che il lavoro che esegue un'attività genera un'eccezione prima dell'esecuzione di un percorso più lungo di codice. Nell'esempio viene illustrata una situazione di questo tipo.  
  
   
  
## Examples  
 Nell'esempio seguente è un'utilità della riga di comando che consente di calcolare il numero di byte nei file in ogni directory il cui nome viene passato come argomento della riga di comando. Anziché l'esecuzione di un percorso più lungo di codice che crea un'istanza di un <xref:System.IO.FileInfo> dell'oggetto e recupera il valore della relativa <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> proprietà per ogni file nella directory, l'esempio chiama semplicemente il <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> metodo per creare un'attività con errori se un particolare sottodirectory non esiste.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato restituito dall'attività.</typeparam>
        <param name="result">Risultato da archiviare nell'attività completata.</param>
        <summary>Crea un oggetto <see cref="T:System.Threading.Tasks.Task`1" /> completato correttamente con il risultato specificato.</summary>
        <returns>Attività completata correttamente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea un <xref:System.Threading.Tasks.Task%601> dell'oggetto la cui proprietà <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> è di proprietà `result` e il cui <xref:System.Threading.Tasks.Task.Status%2A> è di proprietà <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Il metodo è comunemente utilizzato quando il valore restituito di un'attività è noto immediatamente senza eseguire un percorso più lungo di codice. Nell'esempio viene illustrata una situazione di questo tipo.  
  
 Per creare un oggetto attività che non restituisce un valore, recuperare l'oggetto attività dal <xref:System.Threading.Tasks.Task.CompletedTask%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente è un'utilità della riga di comando che consente di calcolare il numero di byte nei file in ogni directory il cui nome viene passato come argomento della riga di comando. Piuttosto che l'esecuzione di un percorso più lungo di codice che crea un'istanza di un <xref:System.IO.FileStream> dell'oggetto e recupera il valore del relativo <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> proprietà per ogni file nella directory, l'esempio chiama semplicemente la <xref:System.Threading.Tasks.Task.FromResult%2A> metodo per creare un'attività il cui <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> proprietà è zero (0) se una directory non è presenti file.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un elemento awaiter usato per attendere questo oggetto <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Istanza di awaiter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è destinato per l'uso del compilatore piuttosto che per l'uso nel codice dell'applicazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un ID per questa istanza di <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <value>Identificatore assegnato dal sistema a questa istanza di <see cref="T:System.Threading.Tasks.Task" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ID attività vengono assegnati on demand e non rappresentano necessariamente l'ordine delle attività vengono create istanze. Si noti che anche se le collisioni sono molto rare, gli identificatori di attività non sono necessariamente essere univoci.  
  
 Per ottenere l'ID attività dell'attività attualmente in esecuzione all'interno del codice che tale attività è in esecuzione, usare il <xref:System.Threading.Tasks.Task.CurrentId%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'esecuzione di questa istanza di <see cref="T:System.Threading.Tasks.Task" /> è stata completata perché annullata.</summary>
        <value>
          <see langword="true" /> se l'attività è stata completata perché annullata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Threading.Tasks.Task> verrà completato nei <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato in presenza delle condizioni seguenti:  
  
-   Relativo <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> è stato contrassegnato per l'annullamento prima che l'attività ha iniziato l'esecuzione,  
  
-   L'attività ha confermato la richiesta di annullamento nel relativo già segnalato <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> generando un' <xref:System.OperationCanceledException> che contiene lo stesso <xref:System.Threading.CancellationToken>.  
  
-   L'attività ha confermato la richiesta di annullamento nel relativo già segnalato <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> chiamando il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> metodo su di <xref:System.Threading.CancellationToken>.  
  
> [!IMPORTANT]
>  Il recupero del valore della <xref:System.Threading.Tasks.Task.IsCanceled%2A> proprietà non blocca il thread chiamante finché l'attività è stata completata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se questo oggetto <see cref="T:System.Threading.Tasks.Task" /> è stato completato.</summary>
        <value>
          <see langword="true" /> se l'attività è stata completata; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.IsCompleted%2A> restituirà `true` quando l'attività è in uno dei tre stati finali: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
> [!IMPORTANT]
>  Il recupero del valore della <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> proprietà non blocca il thread chiamante finché l'attività è stata completata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Threading.Tasks.Task" /> è stato completato a causa di un'eccezione non gestita.</summary>
        <value>
          <see langword="true" /> se l'attività ha generato un'eccezione non gestita; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Threading.Tasks.Task.IsFaulted%2A> viene `true`, l'attività <xref:System.Threading.Tasks.Task.Status%2A> è uguale a <xref:System.Threading.Tasks.TaskStatus.Faulted>e il relativo <xref:System.Threading.Tasks.Task.Exception%2A> proprietà sarà non null.  
  
> [!IMPORTANT]
>  Il recupero del valore della <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> proprietà non blocca il thread chiamante finché l'attività è stata completata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accoda il lavoro specificato da eseguire in ThreadPool e restituisce un'attività o un handle di <see cref="T:System.Threading.Tasks.Task`1" /> per tale lavoro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task.Run%2A> metodo fornisce un set di overload che rendono più semplice avviare un'attività usando i valori predefiniti. È un'alternativa semplificata al <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> overload.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Lavoro da eseguire in modo asincrono.</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un oggetto <see cref="T:System.Threading.Tasks.Task" /> che rappresenta tale lavoro.</summary>
        <returns>Attività che rappresenta il lavoro in coda da eseguire in ThreadPool.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task.Run%2A> metodo consente di creare ed eseguire un'attività in una singola chiamata al metodo e offre un'alternativa più semplice per la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> (metodo). Viene creata un'attività con i valori predefiniti seguenti:  
  
-   Il token di annullamento è <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Relativi <xref:System.Threading.Tasks.Task.CreationOptions%2A> valore della proprietà è <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa l'utilità di pianificazione predefinita.  
  
 Per informazioni sulla gestione delle eccezioni generate da operazioni di attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L'esempio seguente definisce una `ShowThreadInfo` metodo che visualizza il <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> del thread corrente. Viene chiamato direttamente dal thread dell'applicazione e viene chiamato dal <xref:System.Action> delegato passato al <xref:System.Threading.Tasks.Task.Run%28System.Action%29> (metodo).  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 Nell'esempio seguente è simile a quello precedente, ad eccezione del fatto che usa un'espressione lambda per definire il codice che l'attività da eseguire.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 Gli esempi mostrano che l'attività asincrona viene eseguita su un thread diverso rispetto al thread principale dell'applicazione.  
  
 La chiamata al <xref:System.Threading.Tasks.Task.Wait%2A> metodo assicura che l'attività viene completata e viene visualizzato l'output prima della chiusura dell'applicazione. In caso contrario, è possibile che il `Main` metodo verrà completato prima del completamento dell'attività.  
  
 Nell'esempio seguente viene illustrato il <xref:System.Threading.Tasks.Task.Run%28System.Action%29> (metodo). Definisce una matrice di nomi di directory e avvia un'attività separata per recuperare i nomi dei file in ogni directory. Tutte le attività di scrivono i nomi dei file in un singolo <xref:System.Collections.Concurrent.ConcurrentBag%601> oggetto. Nell'esempio viene quindi chiamato il <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> metodo per assicurarsi che tutte le attività completate e quindi visualizza un conteggio del numero totale di nomi di file scritti i <xref:System.Collections.Concurrent.ConcurrentBag%601> oggetto.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="action" /> era <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <summary>Accoda il lavoro specificato da eseguire sul pool di thread e restituisce un proxy per l'attività restituita da <paramref name="function" />.</summary>
        <returns>Attività che rappresenta un proxy per l'attività restituita da <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sulla gestione delle eccezioni generate da operazioni di attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> era <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Lavoro da eseguire in modo asincrono.</param>
        <param name="cancellationToken">Token di annullamento che è possibile usare per annullare il lavoro</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un oggetto <see cref="T:System.Threading.Tasks.Task" /> che rappresenta tale lavoro. Un token di annullamento consente di annullare il lavoro.</summary>
        <returns>Attività che rappresenta il lavoro in coda da eseguire nel pool di thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se viene richiesto l'annullamento prima che l'attività inizia l'esecuzione, l'attività non viene eseguito. Invece è impostata il <xref:System.Threading.Tasks.TaskStatus.Canceled> lo stato e genera un <xref:System.Threading.Tasks.TaskCanceledException> eccezione.  
  
 Il <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> metodo è un'alternativa più semplice per la <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> (metodo). Viene creata un'attività con i valori predefiniti seguenti:  
  
-   Relativi <xref:System.Threading.Tasks.Task.CreationOptions%2A> valore della proprietà è <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa l'utilità di pianificazione predefinita.  
  
 Per informazioni sulla gestione delle eccezioni generate da operazioni di attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> metodo per creare un'attività che esegue l'iterazione di file nella directory C:\Windows\System32. L'espressione lambda chiama il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo per aggiungere informazioni su ogni file a un <xref:System.Collections.Generic.List%601> oggetto. Ogni scollegato attività annidata richiamato dal <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> ciclo controlla lo stato del token di annullamento e, se viene richiesto l'annullamento, chiama il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> (metodo). Il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodo genera un' <xref:System.OperationCanceledException> eccezione gestita in un `catch` bloccare quando il thread chiama chiama il <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> (metodo).  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="action" /> era <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">La classe <see cref="T:System.Threading.CancellationTokenSource" /> associata all'oggetto <paramref name="cancellationToken" /> è stata eliminata.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <param name="cancellationToken">Token di annullamento da usare per annullare il lavoro.</param>
        <summary>Accoda il lavoro specificato da eseguire sul pool di thread e restituisce un proxy per l'attività restituita da <paramref name="function" />.</summary>
        <returns>Attività che rappresenta un proxy per l'attività restituita da <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sulla gestione delle eccezioni generate da operazioni di attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> era <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">La classe <see cref="T:System.Threading.CancellationTokenSource" /> associata all'oggetto <paramref name="cancellationToken" /> è stata eliminata.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annullamento delle attività</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato restituito dall'attività proxy.</typeparam>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un proxy per l'oggetto <see langword="Task(TResult)" /> restituito da <paramref name="function" />.</summary>
        <returns>Oggetto <see langword="Task(TResult)" /> che rappresenta un proxy per l'oggetto <see langword="Task(TResult)" /> restituito da <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sulla gestione delle eccezioni generate da operazioni di attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> era <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo restituito dell'attività.</typeparam>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un oggetto <see cref="T:System.Threading.Tasks.Task`1" /> che rappresenta tale lavoro.</summary>
        <returns>Oggetto attività che rappresenta il lavoro in coda da eseguire nel pool di thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task.Run%2A> metodo è un'alternativa più semplice per la <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> (metodo). Viene creata un'attività con i valori predefiniti seguenti:  
  
-   Il token di annullamento è <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Relativi <xref:System.Threading.Tasks.Task.CreationOptions%2A> valore della proprietà è <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa l'utilità di pianificazione predefinita.  
  
 Per informazioni sulla gestione delle eccezioni generate da operazioni di attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Nell'esempio seguente conta il numero approssimativo di parole nei file di testo che rappresentano libri pubblicati. Ogni attività è responsabile dell'apertura di un file, la lettura di tutto il contenuto in modo asincrono e calcolare il conteggio delle parole usando un'espressione regolare. Il <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> viene chiamato per garantire che tutte le attività completate prima di visualizzare il conteggio delle parole di ogni libro nella console.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 L'espressione regolare `\p{P}*\s+` corrisponde a zero, uno o più caratteri di punteggiatura seguiti da uno o più caratteri spazio vuoto. Si presuppone che il numero complessivo di corrispondenze uguale al conteggio parole approssimativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> è <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del risultato restituito dall'attività proxy.</typeparam>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <param name="cancellationToken">Token di annullamento da usare per annullare il lavoro.</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un proxy per l'oggetto <see langword="Task(TResult)" /> restituito da <paramref name="function" />.</summary>
        <returns>Oggetto <see langword="Task(TResult)" /> che rappresenta un proxy per l'oggetto <see langword="Task(TResult)" /> restituito da <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sulla gestione delle eccezioni generate da operazioni di attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> era <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">La classe <see cref="T:System.Threading.CancellationTokenSource" /> associata all'oggetto <paramref name="cancellationToken" /> è stata eliminata.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annullamento delle attività</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo di risultato dell'attività.</typeparam>
        <param name="function">Lavoro da eseguire in modo asincrono.</param>
        <param name="cancellationToken">Token di annullamento da usare per annullare il lavoro.</param>
        <summary>Accoda il lavoro specificato da eseguire nel pool di thread e restituisce un oggetto <see langword="Task(TResult)" /> che rappresenta tale lavoro. Un token di annullamento consente di annullare il lavoro.</summary>
        <returns>Oggetto <see langword="Task(TResult)" /> che rappresenta il lavoro in coda da eseguire nel pool di thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se viene richiesto l'annullamento prima che l'attività inizia l'esecuzione, l'attività non viene eseguito. Invece è impostata il <xref:System.Threading.Tasks.TaskStatus.Canceled> lo stato e genera un <xref:System.Threading.Tasks.TaskCanceledException> eccezione.  
  
 Il <xref:System.Threading.Tasks.Task.Run%2A> metodo è un'alternativa più semplice per la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> (metodo). Viene creata un'attività con i valori predefiniti seguenti:  
  
-   Relativi <xref:System.Threading.Tasks.Task.CreationOptions%2A> valore della proprietà è <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa l'utilità di pianificazione predefinita.  
  
 Per informazioni sulla gestione delle eccezioni generate da operazioni di attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L'esempio seguente crea 20 attività che avvierà un loop fino a quando non viene incrementato un contatore in un valore di 2 milioni. Quando le prime 10 attività raggiungono 2 milioni, il token di annullamento viene annullato e vengono annullate tutte le attività il cui contatori non hanno raggiunto 2 milioni. Nell'esempio viene possibile output.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 Invece di usare il <xref:System.AggregateException.InnerExceptions%2A> proprietà per esaminare le eccezioni, l'esempio esegue l'iterazione di tutte le attività per determinare quali sono stati completati correttamente e che sono state annullate. Per coloro che sono state completate, viene visualizzato il valore restituito dall'attività.  
  
 Poiché l'annullamento è cooperativo, ogni attività possono decidere come rispondere all'annullamento. L'esempio seguente è simile alla prima, ad eccezione del fatto che, dopo che il token viene annullato, attività di restituire il numero di iterazioni che aver completato anziché generare un'eccezione.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 Nell'esempio viene comunque necessario gestire il <xref:System.AggregateException> eccezione, poiché le attività non avviate quando viene richiesto l'annullamento ancora generano un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="function" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">L'attività è stata annullata.</exception>
        <exception cref="T:System.ObjectDisposedException">La classe <see cref="T:System.Threading.CancellationTokenSource" /> associata all'oggetto <paramref name="cancellationToken" /> è stata eliminata.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annullamento delle attività</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue <see cref="T:System.Threading.Tasks.Task" /> in modo sincrono nell'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esegue <see cref="T:System.Threading.Tasks.Task" /> in modo sincrono nell'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, le attività vengono eseguite in modo asincrono in un pool di thread e non bloccano il thread chiamante. Attività eseguita chiamando il <xref:System.Threading.Tasks.Task.RunSynchronously> metodo associati corrente <xref:System.Threading.Tasks.TaskScheduler> e vengono eseguiti nel thread chiamante. Se l'utilità di pianificazione di destinazione non supporta l'esecuzione di questa attività nel thread chiamante, l'attività verrà pianificata per l'esecuzione nell'utilità di pianificazione e il thread chiama si bloccherà fino a quando l'attività ha completato l'esecuzione. Anche se l'attività viene eseguita in modo sincrono, il thread chiamante deve chiamare comunque <xref:System.Threading.Tasks.Task.Wait%2A> per gestire le eccezioni che potrebbe generare l'attività.  Per altre informazioni sulla gestione delle eccezioni, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 Attività eseguita chiamando il <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metodo istanze vengono create chiamando un <xref:System.Threading.Tasks.Task> o <xref:System.Threading.Tasks.Task%601> costruttore della classe. Deve essere l'attività da eseguire in modo sincrono il <xref:System.Threading.Tasks.TaskStatus.Created> dello stato. Un'attività può essere avviata ed eseguire una sola volta. Qualsiasi tentativo di pianificare un'attività una seconda esecuzione, viene generato un'eccezione.  
  
   
  
## Examples  
 L'esempio seguente confronta un'attività eseguita chiamando il <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metodo con uno eseguita in modo asincrono. In entrambi i casi, le attività eseguite le espressioni lambda identici che visualizzano l'ID attività e l'ID del thread in cui viene eseguita l'attività. L'attività calcola la somma dei numeri interi compresi tra 1 e 1.000.000. Come illustrato nell'output dell'esempio, l'attività eseguita chiamando il <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metodo viene eseguito nel thread dell'applicazione, mentre l'attività asincrona non.  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> non è in uno stato valido per essere avviato. Potrebbe essere già stato avviato, eseguito o annullato oppure potrebbe essere stato creato in un modo che non supporta la pianificazione diretta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Utilità di pianificazione in cui provare a eseguire questa attività inline.</param>
        <summary>Esegue <see cref="T:System.Threading.Tasks.Task" /> in modo sincrono nell'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attività eseguita chiamando il <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metodo istanze vengono create chiamando un <xref:System.Threading.Tasks.Task> o <xref:System.Threading.Tasks.Task%601> costruttore della classe. Deve essere l'attività da eseguire in modo sincrono il <xref:System.Threading.Tasks.TaskStatus.Created> dello stato. Un'attività può essere avviata ed eseguire una sola volta. Qualsiasi tentativo di pianificare un'attività una seconda esecuzione, viene generato un'eccezione.  
  
 Se l'utilità di pianificazione di destinazione non supporta l'esecuzione di questa attività nel thread corrente, l'attività verrà pianificata per l'esecuzione nell'utilità di pianificazione e il thread corrente si bloccherà fino a quando l'attività ha completato l'esecuzione. Per questo motivo, il thread chiamante non è necessario chiamare un metodo, ad esempio <xref:System.Threading.Tasks.Task.Wait%2A> per assicurarsi che l'attività ha completato l'esecuzione. Per altre informazioni sulla gestione delle eccezioni per le operazioni di attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> non è in uno stato valido per essere avviato. Potrebbe essere già stato avviato, eseguito o annullato oppure potrebbe essere stato creato in un modo che non supporta la pianificazione diretta.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Avvia <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avvia <see cref="T:System.Threading.Tasks.Task" />, pianificandone l'esecuzione nell'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'attività può essere avviata ed eseguire una sola volta. Qualsiasi tentativo di pianificare un'attività una seconda volta comporterà un'eccezione.  
  
 Il <xref:System.Threading.Tasks.Task.Start%2A> viene usato per eseguire un'attività che è stata creata chiamando uno del <xref:System.Threading.Tasks.Task> costruttori. In genere, eseguire questa operazione quando è necessario separare la creazione dell'attività dalla relativa esecuzione, ad esempio quando si esegue in modo condizionale le attività che è stata creata. Nel caso più comune in cui non occorre separare la creazione di istanze di attività di esecuzione, è consigliabile chiamare un overload del <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> (metodo).  
  
 Per informazioni sulla gestione delle eccezioni generate da operazioni di attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> costruttore per creare un'istanza di un nuovo <xref:System.Threading.Tasks.Task> oggetto che consente di visualizzare la propria attività ID e l'ID thread gestito, quindi esegue un ciclo. Chiama quindi il <xref:System.Threading.Tasks.Task.Start%2A> metodo per eseguire l'attività.  Poiché si tratta di un'app console, la chiamata al <xref:System.Threading.Tasks.Task.Wait%2A> metodo è necessario per impedire l'interruzione prima che l'attività viene completata l'esecuzione dell'app.  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> non è in uno stato valido per essere avviato. Potrebbe essere già stato avviato, eseguito o annullato oppure potrebbe essere stato creato in un modo che non supporta la pianificazione diretta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> a cui associare e con cui eseguire questa attività.</param>
        <summary>Avvia <see cref="T:System.Threading.Tasks.Task" />, pianificandone l'esecuzione nell'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'attività può essere avviata ed eseguita una sola volta. Qualsiasi tentativo di pianificare un'attività una seconda volta comporterà un'eccezione.  
  
 Per informazioni sulla gestione delle eccezioni generate da operazioni di attività, vedere [gestione delle eccezioni](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> non è in uno stato valido per essere avviato. Potrebbe essere già stato avviato, eseguito o annullato oppure potrebbe essere stato creato in un modo che non supporta la pianificazione diretta.</exception>
        <exception cref="T:System.ObjectDisposedException">L’istanza di <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">L'utilità di pianificazione non è riuscita a inserire in coda questa attività.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestione delle eccezioni (Task Parallel Library)</related>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Threading.Tasks.TaskStatus" /> di questa attività.</summary>
        <value>Oggetto <see cref="T:System.Threading.Tasks.TaskStatus" /> corrente di questa istanza dell'attività.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il recupero del valore della <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> proprietà non blocca il thread chiamante finché l'attività è stata completata.  
  
 Per altre informazioni e un esempio, vedere [concatenamento di attività tramite attività di continuazione](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) e [procedura: annullare un'attività e i relativi figli](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).  
  
   
  
## Examples  
 L'esempio seguente crea 20 attività che avvierà un loop fino a quando non viene incrementato un contatore in un valore di 2 milioni. Quando le prime 10 attività raggiungono 2 milioni, il token di annullamento viene annullato e vengono annullate tutte le attività il cui contatori non hanno raggiunto 2 milioni. Nell'esempio viene quindi esamina il <xref:System.Threading.Tasks.Task.Status%2A> proprietà di ogni attività per indicare se è stata completata o è stato annullato. Per coloro che è stata completata, viene visualizzato il valore restituito dall'attività.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Threading.WaitHandle" /> che può essere usato per attendere il completamento dell'attività.</summary>
        <value>Oggetto <see cref="T:System.Threading.WaitHandle" /> che può essere usato per attendere il completamento dell'attività.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzo della funzionalità di attesa fornita da <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> è preferibile all'uso <xref:System.IAsyncResult.AsyncWaitHandle%2A> per funzionalità analoghe. Per altre informazioni, vedere la sezione "In attesa su attività" nella [programmazione asincrona basata su attività](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) e [utilizzo di TPL con altri modelli asincroni](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'operazione è stata completata in modo sincrono.</summary>
        <value>
          <see langword="true" /> se l'operazione è stata completata in modo sincrono; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A> è un metodo di sincronizzazione che fa sì che il thread chiamante attendere il completamento dell'attività corrente. Se l'attività corrente non ha avviato l'esecuzione, il metodo Wait tenta di rimuovere l'attività dall'utilità di pianificazione ed eseguirlo inline nel thread corrente. Se non è possibile eseguire questa operazione, oppure se l'attività corrente è già avviato l'esecuzione, si blocca il thread chiamante fino al completamento dell'attività. Per altre informazioni, vedere [Task.Wait e "Inline"](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) nella programmazione parallela con .NET blog.   
  
## Examples  
 Nell'esempio seguente avvia un'attività che genera un milione di integer casuale compreso tra 0 e 100 e calcola la Media. Nell'esempio viene usato il <xref:System.Threading.Tasks.Task.Wait%2A> metodo per assicurarsi che l'attività venga completata prima che l'applicazione viene terminata. In caso contrario, poiché si tratta di un'applicazione console, l'esempio interrompe prima che l'attività può calcolare e visualizzare il valore medio.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.AggregateException">L'attività è stata annullata. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene un oggetto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
oppure 
È stata generata un'eccezione durante l'esecuzione dell'attività. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene informazioni su una o più eccezioni.</exception>
        <related type="ExternalDocumentation" href="http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx">Task.Wait e "Inline"</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" /> entro un numero specificato di millisecondi.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Threading.Tasks.Task" /> ha completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> è un metodo di sincronizzazione che fa sì che il thread chiamante di attesa per l'istanza corrente di attività da completare fino a quando non si verifica una delle operazioni seguenti:  
  
-   L'attività viene completata correttamente.  
  
-   L'attività viene annullata o genera un'eccezione. In questo caso, si gestisce un <xref:System.AggregateException> eccezione. Il <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> proprietà contiene informazioni dettagliate su una o più eccezioni.  
  
-   L'intervallo definito da `millisecondsTimeout` scade. In questo caso, il thread corrente viene ripresa l'esecuzione e il metodo restituisce `false`.  
  
   
  
## Examples  
 Nell'esempio seguente avvia un'attività che genera numeri interi casuali di cinque milioni compreso tra 0 e 100 e calcola la Media. Nell'esempio viene usato il <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> metodo per attendere che l'applicazione viene completata entro 150 millisecondi. Se l'applicazione viene in genere, l'attività Visualizza la somma e Media dei numeri casuali che lo ha generato. Se è trascorso l'intervallo di timeout, l'esempio visualizza un messaggio prima che venga terminato.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.AggregateException">L'attività è stata annullata. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene un oggetto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
oppure 
È stata generata un'eccezione durante l'esecuzione dell'attività. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene informazioni su una o più eccezioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token di annullamento da osservare durante l'attesa del completamento dell'attività.</param>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" />. L'attesa termina se un token di annullamento viene annullato prima del completamento dell'attività.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> metodo crea un'attesa annullabile; vale a dire, il thread corrente di attesa fino a quando non si verifica una delle operazioni seguenti:  
  
-   Al completamento dell'attività.  
  
-   Il token di annullamento viene annullato. In questo caso, la chiamata per il <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> metodo genera un <xref:System.OperationCanceledException>.  
  
> [!NOTE]
>  Annullamento di `cancellationToken` token di annullamento non ha alcun effetto sull'attività in esecuzione a meno che non lo è anche stato passato il token di annullamento e si è preparato a gestire l'annullamento. Passando il `cancellationToken` oggetti a questo metodo consente semplicemente l'attesa deve essere annullata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo semplice dei token di annullamento per annullare l'attesa del completamento dell'attività. Un'attività viene avviata, le chiamate di <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metodo per annullare una qualsiasi di token di annullamento dell'origine del token, quindi ritardi per cinque secondi. Si noti che l'attività stessa non è stato passato il token di annullamento e non può essere annullata. Il thread dell'applicazione chiama l'attività <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodo per attendere il completamento dell'attività, ma il tempo di attesa viene annullato quando il token di annullamento viene annullato e un <xref:System.OperationCanceledException> viene generata un'eccezione. Il gestore di eccezioni segnala l'eccezione e quindi rimane inattivo per sei secondi. Come illustrato nell'output dell'esempio, questo ritardo consente all'attività da completare nella <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'attività è stata eliminata.</exception>
        <exception cref="T:System.AggregateException">L'attività è stata annullata. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene un oggetto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
oppure 
È stata generata un'eccezione durante l'esecuzione dell'attività. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene informazioni su una o più eccezioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" /> entro un intervallo di tempo specificato.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Threading.Tasks.Task" /> ha completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> è un metodo di sincronizzazione che fa sì che il thread chiamante di attesa per l'istanza corrente di attività da completare fino a quando non si verifica una delle operazioni seguenti:  
  
-   L'attività viene completata correttamente.  
  
-   L'attività viene annullata o genera un'eccezione. In questo caso, si gestisce un <xref:System.AggregateException> eccezione. Il <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> proprietà contiene informazioni dettagliate su una o più eccezioni.  
  
-   L'intervallo definito da `timeout` scade. In questo caso, il thread corrente viene ripresa l'esecuzione e il metodo restituisce `false`.  
  
   
  
## Examples  
 Nell'esempio seguente avvia un'attività che genera numeri interi casuali di cinque milioni compreso tra 0 e 100 e calcola la Media. Nell'esempio viene usato il <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> metodo per attendere che l'applicazione viene completata entro 150 millisecondi. Se l'applicazione viene in genere, l'attività Visualizza la somma e Media dei numeri casuali che lo ha generato. Se è trascorso l'intervallo di timeout, l'esempio visualizza un messaggio prima che venga terminato.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito. 
oppure 
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">L'attività è stata annullata. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene un oggetto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
oppure 
È stata generata un'eccezione durante l'esecuzione dell'attività. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene informazioni su una o più eccezioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="cancellationToken">Token di annullamento da osservare durante l'attesa del completamento dell'attività.</param>
        <summary>Attende il completamento dell'esecuzione di <see cref="T:System.Threading.Tasks.Task" />. L'attesa termina se si esaurisce l'intervallo di timeout o se un token di annullamento viene annullato prima del completamento dell'attività.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Threading.Tasks.Task" /> ha completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> è un metodo di sincronizzazione che fa sì che il thread chiamante di attesa per l'istanza corrente di attività da completare fino a quando non si verifica una delle operazioni seguenti:  
  
-   L'attività viene completata correttamente.  
  
-   L'attività viene annullata o genera un'eccezione. In questo caso, si gestisce un <xref:System.AggregateException> eccezione. Il <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> proprietà contiene informazioni dettagliate su una o più eccezioni.  
  
-   Il `cancellationToken` token di annullamento. In questo caso, la chiamata per il <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metodo genera un <xref:System.OperationCanceledException>.  
  
-   L'intervallo definito da `millisecondsTimeout` scade. In questo caso, il thread corrente viene ripresa l'esecuzione e il metodo restituisce `false`.  
  
> [!NOTE]
>  Annullamento di `cancellationToken` token di annullamento non ha alcun effetto sull'attività in esecuzione a meno che non lo è anche stato passato il token di annullamento e si è preparato a gestire l'annullamento. Passando il `cancellationToken` oggetto al metodo semplicemente consente l'attesa deve essere annullata in base una condizione.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metodo per fornire un valore di timeout sia un annullamento dei token che può terminare il completamento dell'attività attesa. Un nuovo thread viene avviato ed esegue la `CancelToken` metodo, che sospende e quindi chiama il <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metodo per annullare il token di annullamento. Un'attività viene quindi avviata e ritarda per 5 secondi. Il <xref:System.Threading.Tasks.Task.Wait%2A> metodo per attendere il completamento dell'attività viene quindi chiamato e viene fornito un valore di timeout breve sia un token di annullamento.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Si noti che l'output dell'esempio preciso dipende se l'attesa è stata annullata a causa di token di annullamento o perché l'intervallo di timeout è scaduto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.AggregateException">L'attività è stata annullata. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene un oggetto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
oppure 
È stata generata un'eccezione durante l'esecuzione dell'attività. La raccolta <see cref="P:System.AggregateException.InnerExceptions" /> contiene informazioni su una o più eccezioni.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente avvia le 10 attività, ognuna delle quali viene passato un indice come un oggetto di stato. Le attività con un indice dalle due alle cinque generano eccezioni. La chiamata per il <xref:System.Threading.Tasks.Task.WaitAll%2A> metodo esegue il wrapping di tutte le eccezioni in un <xref:System.AggregateException> dell'oggetto e che venga ripropagata al thread chiamante.  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno o più degli oggetti <see cref="T:System.Threading.Tasks.Task" /> in <paramref name="tasks" /> sono stati eliminati.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.  
  
oppure 
L'argomento <paramref name="tasks" /> è una matrice vuota.</exception>
        <exception cref="T:System.AggregateException">Almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" /> è stata annullata. Se un'attività è stata annullata, l'eccezione <see cref="T:System.AggregateException" /> contiene un'eccezione <see cref="T:System.OperationCanceledException" /> nella raccolta <see cref="P:System.AggregateException.InnerExceptions" />.  
  
oppure 
È stata generata un'eccezione durante l'esecuzione di almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti entro un numero specificato di millisecondi.</summary>
        <returns>
          <see langword="true" /> se tutte le istanze di <see cref="T:System.Threading.Tasks.Task" /> hanno completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Uno o più degli oggetti <see cref="T:System.Threading.Tasks.Task" /> in <paramref name="tasks" /> sono stati eliminati.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" /> è stata annullata. Se un'attività è stata annullata, <see cref="T:System.AggregateException" /> contiene un oggetto <see cref="T:System.OperationCanceledException" /> nella relativa raccolta <see cref="P:System.AggregateException.InnerExceptions" />.  
  
oppure 
È stata generata un'eccezione durante l'esecuzione di almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.  
  
oppure 
L'argomento <paramref name="tasks" /> è una matrice vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> da osservare durante l'attesa del completamento delle attività.</param>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti a meno che l'attesa non venga annullata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `cancellationToken` argomento viene utilizzato per annullare l'operazione di attesa. Annullamento delle attività è un'operazione distinta e viene segnalato dal <xref:System.AggregateException> come indicato in precedenza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" /> è stata annullata. Se un'attività è stata annullata, <see cref="T:System.AggregateException" /> contiene un oggetto <see cref="T:System.OperationCanceledException" /> nella relativa raccolta <see cref="P:System.AggregateException.InnerExceptions" />.  
  
oppure 
È stata generata un'eccezione durante l'esecuzione di almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.  
  
oppure 
L'argomento <paramref name="tasks" /> è una matrice vuota.</exception>
        <exception cref="T:System.ObjectDisposedException">Uno o più degli oggetti <see cref="T:System.Threading.Tasks.Task" /> in <paramref name="tasks" /> sono stati eliminati.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti annullabili entro un intervallo di tempo specificato.</summary>
        <returns>
          <see langword="true" /> se tutte le istanze di <see cref="T:System.Threading.Tasks.Task" /> hanno completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Uno o più degli oggetti <see cref="T:System.Threading.Tasks.Task" /> in <paramref name="tasks" /> sono stati eliminati.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" /> è stata annullata. Se un'attività è stata annullata, <see cref="T:System.AggregateException" /> contiene un oggetto <see cref="T:System.OperationCanceledException" /> nella relativa raccolta <see cref="P:System.AggregateException.InnerExceptions" />.  
  
oppure 
È stata generata un'eccezione durante l'esecuzione di almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito. 
oppure 
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.  
  
oppure 
L'argomento <paramref name="tasks" /> è una matrice vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> da osservare durante l'attesa del completamento delle attività.</param>
        <summary>Attende il completamento dell'esecuzione di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti entro un numero specificato di millisecondi o finché l'attesa non viene annullata.</summary>
        <returns>
          <see langword="true" /> se tutte le istanze di <see cref="T:System.Threading.Tasks.Task" /> hanno completato l'esecuzione nel tempo consentito; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `cancellationToken` argomento viene utilizzato per annullare l'operazione di attesa. Annullamento delle attività è un'operazione distinta e viene segnalato dal <xref:System.AggregateException> indicato in precedenza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno o più degli oggetti <see cref="T:System.Threading.Tasks.Task" /> in <paramref name="tasks" /> sono stati eliminati.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" /> è stata annullata. Se un'attività è stata annullata, <see cref="T:System.AggregateException" /> contiene un oggetto <see cref="T:System.OperationCanceledException" /> nella relativa raccolta <see cref="P:System.AggregateException.InnerExceptions" />.  
  
oppure 
È stata generata un'eccezione durante l'esecuzione di almeno una delle istanze di <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.  
  
oppure 
L'argomento <paramref name="tasks" /> è una matrice vuota.</exception>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti.</summary>
        <returns>Indice dell'oggetto <see cref="T:System.Threading.Tasks.Task" /> completato nella matrice di <paramref name="tasks" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente avvia cinque attività, ognuna delle quali rimane inattivo per un massimo di 1.050 millisecondi o almeno 50 millisecondi. Il <xref:System.Threading.Tasks.Task.WaitAny%2A> metodo quindi attende che uno delle attività da completare. L'esempio mostra l'ID attività dell'attività che è terminata l'attesa, nonché lo stato corrente di tutte le attività.  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti entro un numero specificato di millisecondi.</summary>
        <returns>Indice dell'attività completata nell'argomento di matrice di <paramref name="tasks" />, oppure -1 in caso di timeout.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> da osservare durante l'attesa del completamento di un'attività.</param>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti a meno che l'attesa non venga annullata.</summary>
        <returns>Indice dell'attività completata nell'argomento di matrice di <paramref name="tasks" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.</exception>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti entro un intervallo di tempo specificato.</summary>
        <returns>Indice dell'attività completata nell'argomento di matrice di <paramref name="tasks" />, oppure -1 in caso di timeout.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito. 
oppure 
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice delle istanze di <see cref="T:System.Threading.Tasks.Task" /> per cui attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="cancellationToken">Oggetto <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> da osservare durante l'attesa del completamento di un'attività.</param>
        <summary>Attende il completamento dell'esecuzione di uno qualsiasi degli oggetti <see cref="T:System.Threading.Tasks.Task" /> forniti entro un numero specificato di millisecondi o finché un token di annullamento non viene annullato.</summary>
        <returns>Indice dell'attività completata nell'argomento di matrice di <paramref name="tasks" />, oppure -1 in caso di timeout.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'interfaccia <see cref="T:System.Threading.Tasks.Task" /> è stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.ArgumentException">L'argomento <paramref name="tasks" /> contiene un elemento null.</exception>
        <exception cref="T:System.OperationCanceledException">Il parametro <paramref name="cancellationToken" /> è stato annullato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'attività che verrà completata quando tutte le attività fornite saranno completate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata in seguito al completamento di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> di una raccolta enumerabile.</summary>
        <returns>Attività che rappresenta il completamento di tutte le attività fornite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Threading.Tasks.Task.WhenAll%2A> metodo che restituisce un <xref:System.Threading.Tasks.Task> oggetto vengono in genere chiamati quando si è interessati nello stato di un set di attività o le eccezioni generate da un set di attività.  
  
> [!NOTE]
>  La chiamata a <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> metodo non blocca il thread chiamante.  
  
 Se nessuna delle attività specificata viene completata in uno stato di errore, l'attività restituita verrà completata anche un <xref:System.Threading.Tasks.TaskStatus.Faulted> stato, in cui le eccezioni conterrà l'aggregazione del set di eccezioni non incapsulati da ognuna delle attività fornite.  
  
 Se nessuna delle attività fornite con errori, ma almeno uno di essi è stato annullato, l'attività restituita terminerà entro i <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  
  
 Se nessuna delle attività non riuscite e nessuna attività sono stata annullata, l'attività risultante terminerà entro i <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  
  
 Se fornito array/enumerabile non contiene attività, l'attività restituita immediatamente passerà a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato prima che venga restituito al chiamante.  
  
   
  
## Examples  
 L'esempio seguente crea un set di attività che esegue il ping gli URL in una matrice. Le attività vengono memorizzate un `List<Task>` raccolta che viene passato per il <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> (metodo). Dopo la chiamata ai <xref:System.Threading.Tasks.Task.Wait%2A> metodo assicura che tutti i thread sono stati completati, l'esempio esamina la <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> proprietà per determinare se tutte le attività sono con errori.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La raccolta <paramref name="tasks" /> contiene un'attività <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata in seguito al completamento di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task" /> di una matrice.</summary>
        <returns>Attività che rappresenta il completamento di tutte le attività fornite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli overload del <xref:System.Threading.Tasks.Task.WhenAll%2A> metodo che restituisce un <xref:System.Threading.Tasks.Task> oggetto vengono in genere chiamati quando si è interessati nello stato di un set di attività o le eccezioni generate da un set di attività.  
  
> [!NOTE]
>  La chiamata a <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> metodo non blocca il thread chiamante.  
  
 Se nessuna delle attività specificata viene completata in uno stato di errore, l'attività restituita verrà completata anche un <xref:System.Threading.Tasks.TaskStatus.Faulted> stato, in cui le eccezioni conterrà l'aggregazione del set di eccezioni non incapsulati da ognuna delle attività fornite.  
  
 Se nessuna delle attività fornite con errori, ma almeno uno di essi è stato annullato, l'attività restituita terminerà entro i <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  
  
 Se nessuna delle attività non riuscite e nessuna attività sono stata annullata, l'attività risultante terminerà entro i <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  
  
 Se fornito array/enumerabile non contiene attività, l'attività restituita immediatamente passerà a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato prima che venga restituito al chiamante.  
  
   
  
## Examples  
 L'esempio seguente crea un set di attività che esegue il ping gli URL in una matrice. Le attività vengono memorizzate un `List<Task>` raccolta che viene convertito in una matrice e passato al <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> (metodo). Dopo la chiamata ai <xref:System.Threading.Tasks.Task.Wait%2A> metodo assicura che tutti i thread sono stati completati, l'esempio esamina la <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> proprietà per determinare se tutte le attività sono con errori.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> include un'attività <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo dell'attività completata.</typeparam>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata in seguito al completamento di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task`1" /> di una raccolta enumerabile.</summary>
        <returns>Attività che rappresenta il completamento di tutte le attività fornite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata a <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> metodo non blocca il thread chiamante. Tuttavia, una chiamata all'oggetto restituito <xref:System.Threading.Tasks.Task%601.Result%2A> proprietà blocca il thread chiamante.  
  
 Se nessuna delle attività specificata viene completata in uno stato di errore, l'attività restituita verrà completata anche un <xref:System.Threading.Tasks.TaskStatus.Faulted> stato, in cui le eccezioni conterrà l'aggregazione del set di eccezioni non incapsulati da ognuna delle attività fornite.  
  
 Se nessuna delle attività fornite con errori, ma almeno uno di essi è stato annullato, l'attività restituita terminerà entro i <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  
  
 Se nessuna delle attività non riuscite e nessuna attività sono stata annullata, l'attività risultante terminerà entro i <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  Il <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> dell'attività restituita verrà impostata in una matrice contenente tutti i risultati delle attività fornite nello stesso ordine come sono stati forniti (ad esempio, se l'input attività matrice contenuta t1, t2, t3, l'attività di output <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> proprietà restituirà un' `TResult[]` in cui `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Se il `tasks` argomento non contiene attività, l'attività restituita immediatamente passerà a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato prima che venga restituito al chiamante. L'oggetto restituito `TResult[]` sarà una matrice di elementi 0.  
  
   
  
## Examples  
 L'esempio seguente crea dieci attività, ognuno dei quali crea un'istanza di un generatore di numeri casuali che consente di creare 1.000 numeri casuali compresi tra 1 e 1.000 e calcola la Media. Il <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> metodo viene utilizzato per ritardare la creazione di istanze di generatori di numeri casuali in modo che non vengono creati con valori di inizializzazione identici. La chiamata per il <xref:System.Threading.Tasks.Task.WhenAll%2A> metodo quindi restituisce un <xref:System.Int64> matrice che contiene il valore medio calcolato per ogni attività. Questi vengono quindi usati per calcolare la media complessiva.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 In questo caso, le singole dieci attività sono archiviate in un <xref:System.Collections.Generic.List%601> oggetto. L'oggetto <xref:System.Collections.Generic.List%601> implementa l'interfaccia <xref:System.Collections.Generic.IEnumerable%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La raccolta <paramref name="tasks" /> contiene un'attività <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo dell'attività completata.</typeparam>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata in seguito al completamento di tutti gli oggetti <see cref="T:System.Threading.Tasks.Task`1" /> di una matrice.</summary>
        <returns>Attività che rappresenta il completamento di tutte le attività fornite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata a <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> metodo non blocca il thread chiamante. Tuttavia, una chiamata all'oggetto restituito <xref:System.Threading.Tasks.Task%601.Result%2A> proprietà blocca il thread chiamante.  
  
 Se nessuna delle attività specificata viene completata in uno stato di errore, l'attività restituita verrà completata anche un <xref:System.Threading.Tasks.TaskStatus.Faulted> stato, in cui le eccezioni conterrà l'aggregazione del set di eccezioni non incapsulati da ognuna delle attività fornite.  
  
 Se nessuna delle attività fornite con errori, ma almeno uno di essi è stato annullato, l'attività restituita terminerà entro i <xref:System.Threading.Tasks.TaskStatus.Canceled> dello stato.  
  
 Se nessuna delle attività non riuscite e nessuna attività sono stata annullata, l'attività risultante terminerà entro i <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> dello stato.  Il <xref:System.Threading.Tasks.Task%601.Result%2A> dell'attività restituita verrà impostato su una matrice contenente tutti i risultati delle attività fornite nello stesso ordine come sono stati forniti (ad esempio, se l'input attività matrice contenuta t1, t2, t3, l'attività di output <xref:System.Threading.Tasks.Task%601.Result%2A> restituirà un `TResult[]` in cui `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Se fornito array/enumerabile non contiene attività, l'attività restituita immediatamente passerà a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stato prima che venga restituito al chiamante.  L'oggetto restituito `TResult[]` sarà una matrice di elementi 0.  
  
   
  
## Examples  
 L'esempio seguente crea dieci attività, ognuno dei quali crea un'istanza di un generatore di numeri casuali che consente di creare 1.000 numeri casuali compresi tra 1 e 1.000 e calcola la Media. In questo caso, le singole dieci attività sono archiviate in un `Task<Int64>` matrice.  Il <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> metodo viene utilizzato per ritardare la creazione di istanze di generatori di numeri casuali in modo che non vengono creati con valori di inizializzazione identici. La chiamata per il <xref:System.Threading.Tasks.Task.WhenAll%2A> metodo quindi restituisce un <xref:System.Int64> matrice che contiene il valore medio calcolato per ogni attività. Questi vengono quindi usati per calcolare la media complessiva.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> include un'attività <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'attività che verrà completata quando una delle attività fornite sarà completata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata quando una delle attività fornite sarà completata.</summary>
        <returns>Attività che rappresenta il completamento di una delle attività fornite.  Il risultato dell'attività restituita è l'attività completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività restituita verrà completata quando una delle attività specificata è stata completata.  L'attività restituita terminerà sempre nel `RanToCompletion` dello stato con il set di risultati per la prima attività per il completamento.  Questo vale anche se è terminata con la prima attività per completare la `Canceled` o `Faulted` dello stato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> conteneva un'attività null o era vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata quando una delle attività fornite sarà completata.</summary>
        <returns>Attività che rappresenta il completamento di una delle attività fornite.  Il risultato dell'attività restituita è l'attività completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività restituita verrà completata quando una delle attività specificata è stata completata.  L'attività restituita terminerà sempre nel `RanToCompletion` dello stato con relativo `Result` impostato per la prima attività da completare.  Questo vale anche se è terminata con la prima attività per completare la `Canceled` o `Faulted` dello stato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="tasks" /> era null.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> conteneva un'attività null o era vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo dell'attività completata.</typeparam>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata quando una delle attività fornite sarà completata.</summary>
        <returns>Attività che rappresenta il completamento di una delle attività fornite.  Il risultato dell'attività restituita è l'attività completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività restituita verrà completata quando una delle attività specificata è stata completata.  L'attività restituita terminerà sempre nello stato RanToCompletion con relativo set di risultati per la prima attività per il completamento. Questo vale anche se la prima attività da completare termina nello stato Canceled o Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="tasks" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> conteneva un'attività null o era vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo dell'attività completata.</typeparam>
        <param name="tasks">Attività in attesa del completamento.</param>
        <summary>Crea un'attività che verrà completata quando una delle attività fornite sarà completata.</summary>
        <returns>Attività che rappresenta il completamento di una delle attività fornite.  Il risultato dell'attività restituita è l'attività completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'attività restituita verrà completata quando una delle attività specificata è stata completata.  L'attività restituita terminerà sempre nello stato RanToCompletion con relativo set di risultati per la prima attività per il completamento. Questo vale anche se la prima attività da completare termina nello stato Canceled o Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="tasks" /> era null.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> conteneva un'attività null o era vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un'attività awaitable che consente il passaggio in modo asincrono al contesto corrente, quando atteso.</summary>
        <returns>Contesto che, quando atteso, eseguirà una transizione in modo asincrono al contesto corrente al momento dell'attesa. Se l'oggetto <see cref="T:System.Threading.SynchronizationContext" /> corrente è diverso da Null, verrà considerato come contesto corrente. In caso contrario, sarà l'utilità di pianificazione associata all'attività in esecuzione a essere considerata come contesto corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare `await Task.Yield();` in un metodo asincrono per forzare il metodo venga completato in modo asincrono. Se esiste un contesto di sincronizzazione corrente (<xref:System.Threading.SynchronizationContext> oggetto), questo verrà registrato il resto dell'esecuzione del metodo tornare a tale contesto. Tuttavia, il contesto deciderà come definire le priorità di questo tipo di lavoro rispetto a altro lavoro che potrebbe essere in sospeso. Il contesto di sincronizzazione che è presente in un thread dell'interfaccia utente nella maggior parte degli ambienti dell'interfaccia utente avrà la priorità spesso lavoro registrato per il contesto di maggiore di input e di lavoro di rendering. Per questo motivo, non fare affidamento su `await Task.Yield();` per mantenere un'interfaccia utente reattiva.  Per altre informazioni, vedere l'intervento [astrazioni utili abilitata con ContinueWith](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) nella programmazione parallela con .NET blog.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>