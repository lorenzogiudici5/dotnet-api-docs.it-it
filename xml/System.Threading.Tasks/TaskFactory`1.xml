<Type Name="TaskFactory&lt;TResult&gt;" FullName="System.Threading.Tasks.TaskFactory&lt;TResult&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ac256f08add3803f1dba5244ff8fa5e37774f807" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531665" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TaskFactory&lt;TResult&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskFactory`1&lt;TResult&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskFactory`1" />
  <TypeSignature Language="VB.NET" Value="Public Class TaskFactory(Of TResult)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA;public ref class TaskFactory" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TResult" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TResult">Valore restituito degli oggetti <see cref="T:System.Threading.Tasks.Task`1" /> creati dai metodi di questa classe.</typeparam>
    <summary>Fornisce supporto per la creazione e la pianificazione di oggetti <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework fornisce due factory per la creazione e la pianificazione di attività:  
  
-   Il <xref:System.Threading.Tasks.TaskFactory> (classe), che consente di creare <xref:System.Threading.Tasks.Task> e <xref:System.Threading.Tasks.Task%601> oggetti.  
  
-   Il <xref:System.Threading.Tasks.TaskFactory%601> (classe), che consente di creare <xref:System.Threading.Tasks.Task%601> oggetti.  
  
 La <xref:System.Threading.Tasks.TaskFactory%601> classe consente di eseguire le operazioni seguenti:  
  
-   Creare un'attività e vengono avviati immediatamente chiamando il <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> metodo. È possibile chiamare l'overload di questo metodo per creare ed eseguire un'attività che richiede argomenti non predefiniti.  
  
    > [!WARNING]
    >  A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> metodo fornisce il modo più semplice per creare un'attività con l'impostazione predefinita, i valori di configurazione e avviarla immediatamente.  
  
-   Creare un'attività che viene avviata quando una qualsiasi delle attività in una matrice è stata completata chiamando il <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> metodo.  
  
-   Creare un'attività che viene avviata quando completamento di tutte le attività in una matrice chiamando il <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> metodo.  
  
 Il metodo statico <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> proprietà restituisce un valore predefinito <xref:System.Threading.Tasks.TaskFactory%601> oggetto. È inoltre possibile chiamare uno del <xref:System.Threading.Tasks.TaskFactory%601> classe costruttori per configurare il <xref:System.Threading.Tasks.Task%601> gli oggetti che il <xref:System.Threading.Tasks.TaskFactory%601> Crea classe. Nell'esempio seguente consente di configurare un nuovo <xref:System.Threading.Tasks.TaskFactory%601> oggetto per creare le attività che dispongono di un token di annullamento specificato, le opzioni di creazione di attività, opzioni di continuazione e un'utilità di pianificazione personalizzata.  
  
 [!code-csharp[TPL_Factories#2](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_factories/cs/factoriestresult.cs#2)]
 [!code-vb[TPL_Factories#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_factories/vb/factoriestresult.vb#2)]  
  
 Nella maggior parte dei casi, non è necessario creare un'istanza di un nuovo <xref:System.Threading.Tasks.TaskFactory%601> istanza. Utilizzare invece il metodo statico <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> proprietà, che restituisce un oggetto factory che utilizza valori predefiniti. È quindi possibile chiamare i metodi per avviare nuove attività o definire le continuazioni di attività. Per un'illustrazione, vedere l'esempio.  
  
   
  
## Examples  
 L'esempio seguente usa il metodo statico <xref:System.Threading.Tasks.Task%601.Factory%2A> due chiamate a proprietà di <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> metodo. La prima attività restituisce una matrice di stringhe che viene popolata con i nomi dei file nella directory di documenti dell'utente, mentre la seconda restituisce una matrice di stringhe che viene popolata con i nomi delle sottodirectory della directory documenti dell'utente. Chiama quindi il <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> (metodo), che visualizza informazioni sul numero di file e directory in matrici restituite dalle due attività dopo che ha completato l'esecuzione.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Factory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tutti i membri pubblici e protetti di <see cref="T:System.Threading.Tasks.TaskFactory`1" /> sono thread-safe e possono essere utilizzate contemporaneamente da più thread.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza un'istanza di <see cref="T:System.Threading.Tasks.TaskFactory`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza un'istanza di <see cref="T:System.Threading.Tasks.TaskFactory`1" /> con la configurazione predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un <xref:System.Threading.Tasks.TaskFactory%601> istanza con una configurazione predefinita. Il <xref:System.Threading.Tasks.TaskCreationOptions> proprietà viene inizializzata su <xref:System.Threading.Tasks.TaskCreationOptions.None>, <xref:System.Threading.Tasks.TaskContinuationOptions> proprietà viene inizializzata su <xref:System.Threading.Tasks.TaskContinuationOptions.None>e <xref:System.Threading.Tasks.TaskScheduler> proprietà viene inizializzata all'utilità di pianificazione corrente (vedere <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token di annullamento predefinito che verrà assegnato alle attività create da questo oggetto <see cref="T:System.Threading.Tasks.TaskFactory" />, a meno che durante la chiamata dei metodi factory non venga specificato in modo esplicito un altro token di annullamento.</param>
        <summary>Inizializza un'istanza di <see cref="T:System.Threading.Tasks.TaskFactory`1" /> con la configurazione predefinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un <xref:System.Threading.Tasks.TaskFactory%601> istanza con una configurazione predefinita. Il <xref:System.Threading.Tasks.TaskCreationOptions> proprietà viene inizializzata su <xref:System.Threading.Tasks.TaskCreationOptions.None>, <xref:System.Threading.Tasks.TaskContinuationOptions> proprietà viene inizializzata su <xref:System.Threading.Tasks.TaskContinuationOptions.None>e <xref:System.Threading.Tasks.TaskScheduler> proprietà viene inizializzata all'utilità di pianificazione corrente (vedere <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Utilità di pianificazione da usare per pianificare le attività create con questo oggetto <see cref="T:System.Threading.Tasks.TaskFactory`1" />. Un valore Null indica che è necessario usare l'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> corrente.</param>
        <summary>Inizializza un'istanza di <see cref="T:System.Threading.Tasks.TaskFactory`1" /> con la configurazione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con questo costruttore, il <xref:System.Threading.Tasks.TaskCreationOptions> proprietà viene inizializzata su <xref:System.Threading.Tasks.TaskCreationOptions.None>, <xref:System.Threading.Tasks.TaskContinuationOptions> proprietà viene inizializzata su <xref:System.Threading.Tasks.TaskContinuationOptions.None>e <xref:System.Threading.Tasks.TaskScheduler> proprietà viene inizializzata su `scheduler`, a meno che non dispone di `null`, in qual caso la proprietà viene inizializzata su Utilità di pianificazione corrente (vedere <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (creationOptions As TaskCreationOptions, continuationOptions As TaskContinuationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions">Opzioni predefinite da usare quando si creano attività con questo oggetto <see cref="T:System.Threading.Tasks.TaskFactory`1" />.</param>
        <param name="continuationOptions">Opzioni predefinite da usare quando si creano attività di continuazione con questo oggetto <see cref="T:System.Threading.Tasks.TaskFactory`1" />.</param>
        <summary>Inizializza un'istanza di <see cref="T:System.Threading.Tasks.TaskFactory`1" /> con la configurazione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con questo costruttore, il <xref:System.Threading.Tasks.TaskCreationOptions> proprietà viene inizializzata su `creationOptions`, <xref:System.Threading.Tasks.TaskContinuationOptions> proprietà viene inizializzata su `continuationOptions`e <xref:System.Threading.Tasks.TaskScheduler> proprietà viene inizializzata all'utilità di pianificazione corrente (vedere <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> o <paramref name="continuationOptions" /> specifica un valore non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token di annullamento predefinito che verrà assegnato alle attività create da questo oggetto <see cref="T:System.Threading.Tasks.TaskFactory" />, a meno che durante la chiamata dei metodi factory non venga specificato in modo esplicito un altro token di annullamento.</param>
        <param name="creationOptions">Opzioni predefinite da usare quando si creano attività con questo oggetto <see cref="T:System.Threading.Tasks.TaskFactory`1" />.</param>
        <param name="continuationOptions">Opzioni predefinite da usare quando si creano attività di continuazione con questo oggetto <see cref="T:System.Threading.Tasks.TaskFactory`1" />.</param>
        <param name="scheduler">Utilità di pianificazione predefinita da usare per pianificare le attività create con questo oggetto <see cref="T:System.Threading.Tasks.TaskFactory`1" />. Un valore Null indica che è necessario usare l'oggetto <see cref="P:System.Threading.Tasks.TaskScheduler.Current" />.</param>
        <summary>Inizializza un'istanza di <see cref="T:System.Threading.Tasks.TaskFactory`1" /> con la configurazione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con questo costruttore, il <xref:System.Threading.Tasks.TaskCreationOptions> proprietà viene inizializzata su `creationOptions`, <xref:System.Threading.Tasks.TaskContinuationOptions> proprietà viene inizializzata su `continuationOptions`e <xref:System.Threading.Tasks.TaskScheduler> proprietà viene inizializzata su `scheduler`, a meno che non dispone di `null`, in qual caso la proprietà viene inizializzata su Utilità di pianificazione corrente (vedere <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> o <paramref name="continuationOptions" /> specifica un valore non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken CancellationToken" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory`1.CancellationToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken CancellationToken { System::Threading::CancellationToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il token di annullamento predefinito per questa factory delle attività.</summary>
        <value>Token di annullamento predefinito per questa factory delle attività.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce il token di annullamento predefinito che verrà assegnato a tutte le attività create da questa factory, a meno che non è specificato in modo esplicito un altro valore del token di annullamento durante la chiamata ai metodi factory attività.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinuationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskContinuationOptions ContinuationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory`1.ContinuationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContinuationOptions As TaskContinuationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskContinuationOptions ContinuationOptions { System::Threading::Tasks::TaskContinuationOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore di enumerazione <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> per questa factory delle attività.</summary>
        <value>Uno dei valori di enumerazione che specifica le opzioni di continuazione predefinite per questa factory delle attività.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce il valore predefinito di opzioni di continuazione per questa factory. Verranno utilizzati per creare tutte le attività di continuazione, a meno che altre opzioni vengono specificate in modo esplicito durante le chiamate ai metodi di questa factory.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di un set di attività fornite.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationFunction As Func(Of Task(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice di attività da cui continuare.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando tutte le attività nella matrice <c>tasks</c> sono state completate.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di un set di attività fornite.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">
          La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 L'elemento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null o è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice di attività da cui continuare.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando tutte le attività nella matrice <c>tasks</c> sono state completate.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di un set di attività fornite.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null o è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationFunction As Func(Of Task(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice di attività da cui continuare.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando tutte le attività nella matrice <c>tasks</c> sono state completate.</param>
        <param name="continuationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività di continuazione creata. I valori NotOn* o OnlyOn* non sono validi.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di un set di attività fornite.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null o è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice di attività da cui continuare.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando tutte le attività nella matrice <c>tasks</c> sono state completate.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività di continuazione creata. I valori NotOn* o OnlyOn* non sono validi.</param>
        <param name="scheduler">Utilità di pianificazione usata per pianificare l'attività di continuazione creata.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di un set di attività fornite.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null o è vuota.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Il tipo del risultato dell'attività precedente <c>attività</c>.</typeparam>
        <param name="tasks">Matrice di attività da cui continuare.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando tutte le attività nella matrice <c>tasks</c> sono state completate.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di un set di attività fornite.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null o è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Il tipo del risultato dell'attività precedente <c>attività</c>.</typeparam>
        <param name="tasks">Matrice di attività da cui continuare.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando tutte le attività nella matrice <c>tasks</c> sono state completate.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di un set di attività fornite.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null o è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Il tipo del risultato dell'attività precedente <c>attività</c>.</typeparam>
        <param name="tasks">Matrice di attività da cui continuare.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando tutte le attività nella matrice <c>tasks</c> sono state completate.</param>
        <param name="continuationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività di continuazione creata. I valori NotOn* o OnlyOn* non sono validi.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di un set di attività fornite.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null o è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Il tipo del risultato dell'attività precedente <c>attività</c>.</typeparam>
        <param name="tasks">Matrice di attività da cui continuare.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando tutte le attività nella matrice <c>tasks</c> sono state completate.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività di continuazione creata. I valori NotOn* o OnlyOn* non sono validi.</param>
        <param name="scheduler">Utilità di pianificazione usata per pianificare l'attività di continuazione creata.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di un set di attività fornite.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null o è vuota.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore non valido.</exception>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di una delle attività nel set fornito.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice di attività da cui continuare al completamento di un'attività.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando una delle attività nella matrice <c>tasks</c> viene completata.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di una delle attività nel set fornito.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null o è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice di attività da cui continuare al completamento di un'attività.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando una delle attività nella matrice <c>tasks</c> viene completata.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di una delle attività nel set fornito.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è Null.  
  
 oppure  
  
 L'argomento <paramref name="continuationFunction" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null.  
  
 oppure  
  
 La matrice <paramref name="tasks" /> è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice di attività da cui continuare al completamento di un'attività.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando una delle attività nella matrice <c>tasks</c> viene completata.</param>
        <param name="continuationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività di continuazione creata. I valori <see langword="NotOn*" /> o <see langword="OnlyOn*" /> non sono validi.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di una delle attività nel set fornito.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nell'argomento <paramref name="continuationOptions" /> viene specificato un valore di enumerazione non valido.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null.  
  
 oppure  
  
 La matrice <paramref name="tasks" /> è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Matrice di attività da cui continuare al completamento di un'attività.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando una delle attività nella matrice <c>tasks</c> viene completata.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività di continuazione creata. I valori <see langword="NotOn*" /> o <see langword="OnlyOn*" /> non sono validi.</param>
        <param name="scheduler">Utilità di pianificazione usata per pianificare l'attività di continuazione creata.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di una delle attività nel set fornito.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null.  
  
 oppure  
  
 La matrice <paramref name="tasks" /> è vuota.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> non valido.</exception>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Il tipo del risultato dell'attività precedente <c>attività</c>.</typeparam>
        <param name="tasks">Matrice di attività da cui continuare al completamento di un'attività.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando una delle attività nella matrice <c>tasks</c> viene completata.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di una delle attività nel set fornito.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null.  
  
 oppure  
  
 La matrice <paramref name="tasks" /> è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Il tipo del risultato dell'attività precedente <c>attività</c>.</typeparam>
        <param name="tasks">Matrice di attività da cui continuare al completamento di un'attività.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando una delle attività nella matrice <c>tasks</c> viene completata.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività di continuazione.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di una delle attività nel set fornito.</summary>
        <returns>Nuova attività di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null.  
  
 oppure  
  
 La matrice <paramref name="tasks" /> è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Il tipo del risultato dell'attività precedente <c>attività</c>.</typeparam>
        <param name="tasks">Matrice di attività da cui continuare al completamento di un'attività.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando una delle attività nella matrice <c>tasks</c> viene completata.</param>
        <param name="continuationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività di continuazione creata. I valori <see langword="NotOn*" /> o <see langword="OnlyOn*" /> non sono validi.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di una delle attività nel set fornito.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nell'argomento <paramref name="continuationOptions" /> viene specificato un valore di enumerazione non valido.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null.  
  
 oppure  
  
 La matrice <paramref name="tasks" /> è vuota.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Il tipo del risultato dell'attività precedente <c>attività</c>.</typeparam>
        <param name="tasks">Matrice di attività da cui continuare al completamento di un'attività.</param>
        <param name="continuationFunction">Delegato della funzione da eseguire in modo asincrono quando una delle attività nella matrice <c>tasks</c> viene completata.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività di continuazione.</param>
        <param name="continuationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività di continuazione creata. I valori <see langword="NotOn*" /> o <see langword="OnlyOn*" /> non sono validi.</param>
        <param name="scheduler">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> usato per pianificare l'oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione creato.</param>
        <summary>Crea un'attività di continuazione che verrà avviata al completamento di una delle attività nel set fornito.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Threading.Tasks.Task`1" /> di continuazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo il completamento, un'attività è in uno dei seguenti stati: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> stati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La matrice <paramref name="tasks" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="continuationFunction" /> è <see langword="null" />.  
  
 oppure  
  
 L'argomento <paramref name="scheduler" /> è Null.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contiene un valore null.  
  
 oppure  
  
 La matrice <paramref name="tasks" /> è vuota.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="continuationOptions" /> specifica un valore TaskContinuationOptions non valido.</exception>
        <exception cref="T:System.ObjectDisposedException">Uno degli elementi nella matrice <paramref name="tasks" /> è stato eliminato.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> che ha creato <paramref name="cancellationToken" /> è già stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory`1.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore di enumerazione <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> per questa factory delle attività.</summary>
        <value>Uno dei valori di enumerazione che specifica le opzioni di creazione predefinite per questa factory delle attività.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce il valore predefinito di opzioni di creazione per questa factory. Verranno utilizzati per creare tutte le attività, a meno che altre opzioni vengono specificate in modo esplicito durante le chiamate ai metodi di questa factory.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un'istanza della classe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> il cui completamento deve attivare l'elaborazione del metodo <c>endMethod</c>.</param>
        <param name="endMethod">Delegato della funzione che elabora l'oggetto <c>asyncResult</c> completato.</param>
        <summary>Crea un'attività che esegue una funzione del metodo End al completamento di un oggetto <see cref="T:System.IAsyncResult" /> specificato.</summary>
        <returns>Oggetto <see cref="T:System.Threading.Tasks.Task`1" /> che rappresenta l'operazione asincrona.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="asyncResult" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="endMethod" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Delegato che inizia l'operazione asincrona.</param>
        <param name="endMethod">Delegato che termina l'operazione asincrona.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>beginMethod</c>.</param>
        <summary>Crea un'attività che rappresenta una coppia di metodi Begin ed End conformi al modello di programmazione asincrona.</summary>
        <returns>Attività creata che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo genera qualsiasi eccezione generata dal `beginMethod`. Le eccezioni per `endmethod` vengono generate quando si attende l'attività restituita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="beginMethod" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="endMethod" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> il cui completamento deve attivare l'elaborazione del metodo <c>endMethod</c>.</param>
        <param name="endMethod">Delegato della funzione che elabora l'oggetto <c>asyncResult</c> completato.</param>
        <param name="creationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività creata.</param>
        <summary>Crea un'attività che esegue una funzione del metodo End al completamento di un oggetto <see cref="T:System.IAsyncResult" /> specificato.</summary>
        <returns>Attività che rappresenta l'operazione asincrona.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="asyncResult" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="endMethod" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="creationOptions" /> specifica un valore non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Delegato che inizia l'operazione asincrona.</param>
        <param name="endMethod">Delegato che termina l'operazione asincrona.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>beginMethod</c>.</param>
        <param name="creationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività creata.</param>
        <summary>Crea un'attività che rappresenta una coppia di metodi Begin ed End conformi al modello di programmazione asincrona.</summary>
        <returns>Oggetto <see cref="T:System.Threading.Tasks.Task`1" /> creato che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo genera qualsiasi eccezione generata dal `beginMethod`. Le eccezioni per `endmethod` vengono generate quando si attende l'attività restituita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="beginMethod" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="endMethod" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argomento <paramref name="creationOptions" /> specifica un valore non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oggetto <see cref="T:System.IAsyncResult" /> il cui completamento deve attivare l'elaborazione del metodo <c>endMethod</c>.</param>
        <param name="endMethod">Delegato della funzione che elabora l'oggetto <c>asyncResult</c> completato.</param>
        <param name="creationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività creata.</param>
        <param name="scheduler">Utilità di pianificazione usata per pianificare l'attività che esegue il metodo End.</param>
        <summary>Crea un'attività che esegue una funzione del metodo End al completamento di un oggetto <see cref="T:System.IAsyncResult" /> specificato.</summary>
        <returns>Attività creata che rappresenta l'operazione asincrona.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="asyncResult" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="endMethod" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nel parametro <paramref name="creationOptions" /> è stato specificato un valore non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Il tipo del primo argomento passato al <c>beginMethod</c> delegato.</typeparam>
        <param name="beginMethod">Delegato che inizia l'operazione asincrona.</param>
        <param name="endMethod">Delegato che termina l'operazione asincrona.</param>
        <param name="arg1">Primo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>beginMethod</c>.</param>
        <summary>Crea un'attività che rappresenta una coppia di metodi Begin ed End conformi al modello di programmazione asincrona.</summary>
        <returns>Attività creata che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo genera qualsiasi eccezione generata dal `beginMethod`. Le eccezioni per `endmethod` vengono generate quando si attende l'attività restituita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="beginMethod" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="endMethod" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Il tipo del primo argomento passato al <c>beginMethod</c> delegato.</typeparam>
        <param name="beginMethod">Delegato che inizia l'operazione asincrona.</param>
        <param name="endMethod">Delegato che termina l'operazione asincrona.</param>
        <param name="arg1">Primo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>beginMethod</c>.</param>
        <param name="creationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività creata.</param>
        <summary>Crea un'attività che rappresenta una coppia di metodi Begin ed End conformi al modello di programmazione asincrona.</summary>
        <returns>Attività creata che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo genera qualsiasi eccezione generata dal `beginMethod`. Le eccezioni per `endmethod` vengono generate quando si attende l'attività restituita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="beginMethod" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="endMethod" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nel parametro <paramref name="creationOptions" /> è stato specificato un valore non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Il tipo del secondo argomento passato a <c>beginMethod</c> delegato.</typeparam>
        <typeparam name="TArg2">Il tipo del primo argomento passato al <c>beginMethod</c> delegato.</typeparam>
        <param name="beginMethod">Delegato che inizia l'operazione asincrona.</param>
        <param name="endMethod">Delegato che termina l'operazione asincrona.</param>
        <param name="arg1">Primo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="arg2">Secondo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>beginMethod</c>.</param>
        <summary>Crea un'attività che rappresenta una coppia di metodi Begin ed End conformi al modello di programmazione asincrona.</summary>
        <returns>Attività creata che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo genera qualsiasi eccezione generata dal `beginMethod`. Le eccezioni per `endmethod` vengono generate quando si attende l'attività restituita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="beginMethod" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="endMethod" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Il tipo del secondo argomento passato a <c>beginMethod</c> delegato.</typeparam>
        <typeparam name="TArg2">Il tipo del primo argomento passato al <c>beginMethod</c> delegato.</typeparam>
        <param name="beginMethod">Delegato che inizia l'operazione asincrona.</param>
        <param name="endMethod">Delegato che termina l'operazione asincrona.</param>
        <param name="arg1">Primo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="arg2">Secondo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>beginMethod</c>.</param>
        <param name="creationOptions">Oggetto che controlla il comportamento dell'oggetto <see cref="T:System.Threading.Tasks.Task`1" /> creato.</param>
        <summary>Crea un'attività che rappresenta una coppia di metodi Begin ed End conformi al modello di programmazione asincrona.</summary>
        <returns>Attività creata che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo genera qualsiasi eccezione generata dal `beginMethod`. Le eccezioni per `endmethod` vengono generate quando si attende l'attività restituita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="beginMethod" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="endMethod" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nel parametro <paramref name="creationOptions" /> è stato specificato un valore non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Il tipo del secondo argomento passato a <c>beginMethod</c> delegato.</typeparam>
        <typeparam name="TArg2">Il tipo del terzo argomento passato a <c>beginMethod</c> delegato.</typeparam>
        <typeparam name="TArg3">Il tipo del primo argomento passato al <c>beginMethod</c> delegato.</typeparam>
        <param name="beginMethod">Delegato che inizia l'operazione asincrona.</param>
        <param name="endMethod">Delegato che termina l'operazione asincrona.</param>
        <param name="arg1">Primo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="arg2">Secondo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="arg3">Terzo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>beginMethod</c>.</param>
        <summary>Crea un'attività che rappresenta una coppia di metodi Begin ed End conformi al modello di programmazione asincrona.</summary>
        <returns>Attività creata che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo genera qualsiasi eccezione generata dal `beginMethod`. Le eccezioni per `endmethod` vengono generate quando si attende l'attività restituita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="beginMethod" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="endMethod" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Il tipo del secondo argomento passato a <c>beginMethod</c> delegato.</typeparam>
        <typeparam name="TArg2">Il tipo del terzo argomento passato a <c>beginMethod</c> delegato.</typeparam>
        <typeparam name="TArg3">Il tipo del primo argomento passato al <c>beginMethod</c> delegato.</typeparam>
        <param name="beginMethod">Delegato che inizia l'operazione asincrona.</param>
        <param name="endMethod">Delegato che termina l'operazione asincrona.</param>
        <param name="arg1">Primo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="arg2">Secondo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="arg3">Terzo argomento passato al delegato <c>beginMethod</c>.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>beginMethod</c>.</param>
        <param name="creationOptions">Oggetto che controlla il comportamento dell'attività creata.</param>
        <summary>Crea un'attività che rappresenta una coppia di metodi Begin ed End conformi al modello di programmazione asincrona.</summary>
        <returns>Attività creata che rappresenta l'operazione asincrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo genera qualsiasi eccezione generata dal `beginMethod`. Le eccezioni per `endmethod` vengono generate quando si attende l'attività restituita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="beginMethod" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="endMethod" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nel parametro <paramref name="creationOptions" /> è stato specificato un valore non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheduler">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskScheduler Scheduler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.TaskScheduler Scheduler" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory`1.Scheduler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheduler As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskScheduler ^ Scheduler { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'utilità di pianificazione per questa factory delle attività.</summary>
        <value>Utilità di pianificazione per questa factory delle attività.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce l'utilità di pianificazione predefinita per questa factory. Da utilizzare per pianificare tutte le attività, a meno che non è specificato in modo esplicito un'altra utilità di pianificazione durante le chiamate ai metodi di questa factory.  
  
 Se questa proprietà restituisce `null`, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> verrà utilizzato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartNew">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea e avvia un'attività.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`1&lt;!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Delegato della funzione che restituisce il risultato futuro da rendere disponibile tramite l'attività.</param>
        <summary>Crea e avvia un'attività.</summary>
        <returns>Attività avviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata `StartNew` è funzionalmente equivalente alla creazione di un'attività utilizzando uno del <xref:System.Threading.Tasks.Task%601> costruttori e quindi chiamando il <xref:System.Threading.Tasks.Task.Start%2A> metodo per pianificarne l'esecuzione.  
  
 Tuttavia, a meno che non devono essere separati creazione e la pianificazione, `StartNew` è l'approccio consigliato per motivi di semplicità e prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="function" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`2&lt;object, !TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (function As Func(Of Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="function">Delegato della funzione che restituisce il risultato futuro da rendere disponibile tramite l'attività.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>function</c>.</param>
        <summary>Crea e avvia un'attività.</summary>
        <returns>Attività avviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata `StartNew` è funzionalmente equivalente alla creazione di un'attività utilizzando uno del <xref:System.Threading.Tasks.Task%601> costruttori e quindi chiamando il <xref:System.Threading.Tasks.Task.Start%2A> metodo per pianificarne l'esecuzione.  
  
 Tuttavia, a meno che non devono essere separati creazione e la pianificazione, `StartNew` è l'approccio consigliato per motivi di semplicità e prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="function" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Delegato della funzione che restituisce il risultato futuro da rendere disponibile tramite l'attività.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività.</param>
        <summary>Crea e avvia un'attività.</summary>
        <returns>Attività avviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata `StartNew` è funzionalmente equivalente alla creazione di un'attività utilizzando uno del <xref:System.Threading.Tasks.Task%601> costruttori e quindi chiamando il <xref:System.Threading.Tasks.Task.Start%2A> metodo per pianificarne l'esecuzione.  
  
 Tuttavia, a meno che non devono essere separati creazione e la pianificazione, `StartNew` è l'approccio consigliato per motivi di semplicità e prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'origine del token di annullamento che ha creato <paramref name="cancellationToken" /> è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="function" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (function As Func(Of TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Delegato della funzione che restituisce il risultato futuro da rendere disponibile tramite l'attività.</param>
        <param name="creationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività creata.</param>
        <summary>Crea e avvia un'attività.</summary>
        <returns>Oggetto <see cref="T:System.Threading.Tasks.Task`1" /> avviato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata `StartNew` è funzionalmente equivalente alla creazione di un'attività utilizzando uno del <xref:System.Threading.Tasks.Task%601> costruttori e quindi chiamando il <xref:System.Threading.Tasks.Task.Start%2A> metodo per pianificarne l'esecuzione.  
  
 Tuttavia, a meno che non devono essere separati creazione e la pianificazione, `StartNew` è l'approccio consigliato per motivi di semplicità e prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="function" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nel parametro <paramref name="creationOptions" /> è stato specificato un valore non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Delegato della funzione che restituisce il risultato futuro da rendere disponibile tramite l'attività.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>function</c>.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività.</param>
        <summary>Crea e avvia un'attività.</summary>
        <returns>Attività avviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata `StartNew` è funzionalmente equivalente alla creazione di un'attività utilizzando uno del <xref:System.Threading.Tasks.Task%601> costruttori e quindi chiamando il <xref:System.Threading.Tasks.Task.Start%2A> metodo per pianificarne l'esecuzione.  
  
 Tuttavia, a meno che non devono essere separati creazione e la pianificazione, `StartNew` è l'approccio consigliato per motivi di semplicità e prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'origine del token di annullamento che ha creato <paramref name="cancellationToken" /> è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="function" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Delegato della funzione che restituisce il risultato futuro da rendere disponibile tramite l'attività.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>function</c>.</param>
        <param name="creationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività creata.</param>
        <summary>Crea e avvia un'attività.</summary>
        <returns>Attività avviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata `StartNew` è funzionalmente equivalente alla creazione di un'attività utilizzando uno del <xref:System.Threading.Tasks.Task%601> costruttori e quindi chiamando il <xref:System.Threading.Tasks.Task.Start%2A> metodo per pianificarne l'esecuzione.  
  
 Tuttavia, a meno che non devono essere separati creazione e la pianificazione, `StartNew` è l'approccio consigliato per motivi di semplicità e prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="function" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nel parametro <paramref name="creationOptions" /> è stato specificato un valore non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="function">Delegato della funzione che restituisce il risultato futuro da rendere disponibile tramite l'attività.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività.</param>
        <param name="creationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività creata.</param>
        <param name="scheduler">Utilità di pianificazione usata per pianificare l'attività creata.</param>
        <summary>Crea e avvia un'attività.</summary>
        <returns>Attività avviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata `StartNew` è funzionalmente equivalente alla creazione di un'attività utilizzando uno del <xref:System.Threading.Tasks.Task%601> costruttori e quindi chiamando il <xref:System.Threading.Tasks.Task.Start%2A> metodo per pianificarne l'esecuzione.  
  
 Tuttavia, a meno che non devono essere separati creazione e la pianificazione, `StartNew` è l'approccio consigliato per motivi di semplicità e prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'origine del token di annullamento che ha creato <paramref name="cancellationToken" /> è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="function" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nel parametro <paramref name="creationOptions" /> è stato specificato un valore non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="function">Delegato della funzione che restituisce il risultato futuro da rendere disponibile tramite l'attività.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal delegato <c>function</c>.</param>
        <param name="cancellationToken">Token di annullamento che verrà assegnato alla nuova attività.</param>
        <param name="creationOptions">Uno dei valori di enumerazione che controlla il comportamento dell'attività creata.</param>
        <param name="scheduler">Utilità di pianificazione usata per pianificare l'attività creata.</param>
        <summary>Crea e avvia un'attività.</summary>
        <returns>Attività avviata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata `StartNew` è funzionalmente equivalente alla creazione di un'attività utilizzando uno del <xref:System.Threading.Tasks.Task%601> costruttori e quindi chiamando il <xref:System.Threading.Tasks.Task.Start%2A> metodo per pianificarne l'esecuzione.  
  
 Tuttavia, a meno che non devono essere separati creazione e la pianificazione, `StartNew` è l'approccio consigliato per motivi di semplicità e prestazioni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'origine del token di annullamento che ha creato <paramref name="cancellationToken" /> è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="function" /> è <see langword="null" />.  
  
 oppure  
  
 Il valore dell'argomento <paramref name="scheduler" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Nel parametro <paramref name="creationOptions" /> è stato specificato un valore non valido.</exception>
      </Docs>
    </Member>
  </Members>
</Type>