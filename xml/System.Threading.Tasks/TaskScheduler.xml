<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="9f785-101">Rappresenta un oggetto che gestisce le operazioni di basso livello relative all'accodamento delle attività nei thread.</span><span class="sxs-lookup"><span data-stu-id="9f785-101">Represents an object that handles the low-level work of queuing tasks onto threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-102">Un'istanza di <xref:System.Threading.Tasks.TaskScheduler> classe rappresenta un'utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-102">An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler.</span></span> <span data-ttu-id="9f785-103">Un'utilità di pianificazione assicura che il lavoro di un'attività viene eseguito.</span><span class="sxs-lookup"><span data-stu-id="9f785-103">A task scheduler ensures that the work of a task is eventually executed.</span></span>  
  
 <span data-ttu-id="9f785-104">L'utilità di pianificazione predefinita si basa su pool di thread .NET Framework 4, che fornisce l'acquisizione del lavoro per il bilanciamento del carico, l'aggiunta/ritiro dei thread per la velocità effettiva massima e buone prestazioni complessive.</span><span class="sxs-lookup"><span data-stu-id="9f785-104">The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</span></span> <span data-ttu-id="9f785-105">Dovrebbe essere sufficiente per la maggior parte degli scenari.</span><span class="sxs-lookup"><span data-stu-id="9f785-105">It should be sufficient for most scenarios.</span></span>  
  
 <span data-ttu-id="9f785-106">La <xref:System.Threading.Tasks.TaskScheduler> classe funge anche da punto di estensione per tutta la logica pianificazione personalizzabile.</span><span class="sxs-lookup"><span data-stu-id="9f785-106">The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.</span></span>  <span data-ttu-id="9f785-107">Questo include meccanismi, ad esempio come pianificare un'attività per l'esecuzione e come le attività pianificate deve essere esposte al debugger.</span><span class="sxs-lookup"><span data-stu-id="9f785-107">This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</span></span> <span data-ttu-id="9f785-108">Se sono necessarie funzionalità speciali, è possibile creare un'utilità di pianificazione personalizzata e abilitarla per attività o query specifiche.</span><span class="sxs-lookup"><span data-stu-id="9f785-108">If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</span></span>  
  
 <span data-ttu-id="9f785-109">In questo argomento</span><span class="sxs-lookup"><span data-stu-id="9f785-109">In this topic:</span></span>  
[<span data-ttu-id="9f785-110">Utilità di pianificazione predefinita e il pool di thread</span><span class="sxs-lookup"><span data-stu-id="9f785-110">The default task scheduler and the thread pool</span></span>](#Default)  
 [<span data-ttu-id="9f785-111">Coda globale e code locali</span><span class="sxs-lookup"><span data-stu-id="9f785-111">The global queue vs. local queues</span></span>](#Queues)  
 [<span data-ttu-id="9f785-112">Acquisizione del lavoro</span><span class="sxs-lookup"><span data-stu-id="9f785-112">Work stealing</span></span>](#Stealing)  
 [<span data-ttu-id="9f785-113">Attività a esecuzione prolungata</span><span class="sxs-lookup"><span data-stu-id="9f785-113">Long-running tasks</span></span>](#LongRunning)  
 [<span data-ttu-id="9f785-114">Attività inline</span><span class="sxs-lookup"><span data-stu-id="9f785-114">Task inlining</span></span>](#Inlining)  
[<span data-ttu-id="9f785-115">Specificare un contesto di sincronizzazione</span><span class="sxs-lookup"><span data-stu-id="9f785-115">Specifying a synchronization context</span></span>](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a><span data-ttu-id="9f785-116">Utilità di pianificazione predefinita e il pool di thread</span><span class="sxs-lookup"><span data-stu-id="9f785-116">The default task scheduler and the thread pool</span></span>  
 <span data-ttu-id="9f785-117">Utilità di pianificazione predefinita per la libreria Task Parallel Library e PLINQ Usa pool di thread .NET Framework, è rappresentato dal <xref:System.Threading.ThreadPool> (classe), per accodare ed eseguire il lavoro.</span><span class="sxs-lookup"><span data-stu-id="9f785-117">The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work.</span></span> <span data-ttu-id="9f785-118">Il pool di thread utilizza le informazioni che viene eseguite il <xref:System.Threading.Tasks.Task> tipo da supportare in modo efficiente il parallelismo con granularità fine (unità di lavoro di breve durata) che attività e query parallele spesso rappresentano.</span><span class="sxs-lookup"><span data-stu-id="9f785-118">The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</span></span>  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a><span data-ttu-id="9f785-119">Coda globale e code locali</span><span class="sxs-lookup"><span data-stu-id="9f785-119">The global queue vs. local queues</span></span>  
 <span data-ttu-id="9f785-120">Il pool di thread gestisce una globale FIFO (first-in First-Out) coda di lavoro per i thread in ogni dominio applicazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-120">The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</span></span> <span data-ttu-id="9f785-121">Ogni volta che un programma chiama il <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (o <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) metodo, il lavoro viene inserito in questa coda condivisa e infine rimosso dalla coda al primo thread che diventa disponibile.</span><span class="sxs-lookup"><span data-stu-id="9f785-121">Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</span></span> <span data-ttu-id="9f785-122">A partire da .NET Framework 4, la coda è stata migliorata per usare un algoritmo senza blocco analogo la <xref:System.Collections.Concurrent.ConcurrentQueue%601> classe.</span><span class="sxs-lookup"><span data-stu-id="9f785-122">Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class.</span></span> <span data-ttu-id="9f785-123">Tramite questa implementazione senza blocco, il pool di thread possibile impiegare meno tempo per l'accodamento e coda degli elementi di lavoro.</span><span class="sxs-lookup"><span data-stu-id="9f785-123">By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</span></span> <span data-ttu-id="9f785-124">Questo miglioramento delle prestazioni è disponibile per tutti i programmi che utilizzano il pool di thread.</span><span class="sxs-lookup"><span data-stu-id="9f785-124">This performance benefit is available to all programs that use the thread pool.</span></span>  
  
 <span data-ttu-id="9f785-125">Le attività di primo livello, ovvero quelle non create nell'ambito di un'altra attività, vengono inserite nella coda globale come qualsiasi altro elemento di lavoro.</span><span class="sxs-lookup"><span data-stu-id="9f785-125">Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</span></span> <span data-ttu-id="9f785-126">Tuttavia le attività annidate o figlio, create nell'ambito di un'altra attività, vengono gestite in modo molto diverso.</span><span class="sxs-lookup"><span data-stu-id="9f785-126">However, nested or child tasks, which are created in the context of another task, are handled quite differently.</span></span> <span data-ttu-id="9f785-127">Un'attività figlio o annidata viene inserita in una coda locale specifica del thread in cui è in esecuzione l'attività padre.</span><span class="sxs-lookup"><span data-stu-id="9f785-127">A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</span></span> <span data-ttu-id="9f785-128">L'attività padre può essere un'attività di primo livello o anche l'elemento figlio di un'altra attività.</span><span class="sxs-lookup"><span data-stu-id="9f785-128">The parent task may be a top-level task or it also may be the child of another task.</span></span> <span data-ttu-id="9f785-129">Quando questo thread è disponibile per altro lavoro, esegue innanzitutto una ricerca nella coda locale.</span><span class="sxs-lookup"><span data-stu-id="9f785-129">When this thread is ready for more work, it first looks in the local queue.</span></span> <span data-ttu-id="9f785-130">Se sono presenti elementi di lavoro in attesa, è possibile accedervi rapidamente.</span><span class="sxs-lookup"><span data-stu-id="9f785-130">If work items are waiting there, they can be accessed quickly.</span></span> <span data-ttu-id="9f785-131">Le code locali sono accessibili in last-in, First-Out ordine LIFO () per mantenere la località della cache e ridurre i conflitti.</span><span class="sxs-lookup"><span data-stu-id="9f785-131">The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</span></span> <span data-ttu-id="9f785-132">Per ulteriori informazioni sulle attività figlio e le attività annidate, vedere [attività connesse e disconnesse figlio](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9f785-132">For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
 <span data-ttu-id="9f785-133">L'utilizzo delle code locali non solo riduce la pressione sulla coda globale, ma consente anche di sfruttare la località dei dati.</span><span class="sxs-lookup"><span data-stu-id="9f785-133">The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</span></span> <span data-ttu-id="9f785-134">Coda di elementi di lavoro locale spesso fanno riferimento a strutture dati che sono fisicamente una accanto a altra in memoria.</span><span class="sxs-lookup"><span data-stu-id="9f785-134">Work items in the local queue frequently reference data structures that are physically near one another in memory.</span></span> <span data-ttu-id="9f785-135">In questi casi, i dati sono già nella cache dopo la prima attività è stata eseguita ed è possibile accedervi rapidamente.</span><span class="sxs-lookup"><span data-stu-id="9f785-135">In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</span></span> <span data-ttu-id="9f785-136">Entrambi [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) e <xref:System.Threading.Tasks.Parallel> classe ampiamente attività annidate e attività figlio e aumentano considerevolmente usando le code di lavoro locale.</span><span class="sxs-lookup"><span data-stu-id="9f785-136">Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</span></span>  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a><span data-ttu-id="9f785-137">Acquisizione del lavoro</span><span class="sxs-lookup"><span data-stu-id="9f785-137">Work stealing</span></span>  
 <span data-ttu-id="9f785-138">A partire da .NET Framework 4, il pool di thread offre inoltre un algoritmo di acquisizione del lavoro per assicurarsi che nessun thread sia inattivo mentre altri hanno ancora lavoro nelle code.</span><span class="sxs-lookup"><span data-stu-id="9f785-138">Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</span></span> <span data-ttu-id="9f785-139">Quando un thread del pool di thread è disponibile per altro lavoro, effettua prima una ricerca all'inizio della propria coda locale, quindi nella coda globale e infine nelle code locali degli altri thread.</span><span class="sxs-lookup"><span data-stu-id="9f785-139">When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</span></span> <span data-ttu-id="9f785-140">Se trova un elemento di lavoro nella coda locale di un altro thread, prima applica l'euristica per avere la certezza di poter eseguire il lavoro in modo efficiente.</span><span class="sxs-lookup"><span data-stu-id="9f785-140">If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</span></span> <span data-ttu-id="9f785-141">In caso contrario, la coda l'elemento di lavoro dalla fine della coda (in ordine FIFO).</span><span class="sxs-lookup"><span data-stu-id="9f785-141">If it can, it de-queues the work item from the tail (in FIFO order).</span></span> <span data-ttu-id="9f785-142">In questo modo viene ridotto il conflitto in ogni coda locale e viene mantenuta la località dei dati.</span><span class="sxs-lookup"><span data-stu-id="9f785-142">This reduces contention on each local queue and preserves data locality.</span></span> <span data-ttu-id="9f785-143">Questa architettura consente il bilanciamento del carico thread del pool di lavoro in modo più efficiente rispetto alle versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="9f785-143">This architecture helps the  thread pool load-balance work more efficiently than past versions did.</span></span>  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a><span data-ttu-id="9f785-144">Attività a esecuzione prolungata</span><span class="sxs-lookup"><span data-stu-id="9f785-144">Long-running tasks</span></span>  
 <span data-ttu-id="9f785-145">Può essere opportuno impedire in modo esplicito l'inserimento di un'attività in una coda locale.</span><span class="sxs-lookup"><span data-stu-id="9f785-145">You may want to explicitly prevent a task from being put on a local queue.</span></span> <span data-ttu-id="9f785-146">Ad esempio, si potrebbe sapere che un particolare elemento di lavoro verrà eseguito per un tempo relativamente lungo e probabilmente bloccherà tutti gli altri elementi di lavoro nella coda locale.</span><span class="sxs-lookup"><span data-stu-id="9f785-146">For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</span></span> <span data-ttu-id="9f785-147">In questo caso, è possibile specificare l'opzione <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>, che fornisce all'utilità di pianificazione il suggerimento che per l'attività potrebbe essere necessario un altro thread in modo che non blocchi l'avanzamento di altri thread o elementi di lavoro nella coda locale.</span><span class="sxs-lookup"><span data-stu-id="9f785-147">In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</span></span> <span data-ttu-id="9f785-148">Utilizzando questa opzione si evita il pool di thread completamente, incluse le code locali e globali.</span><span class="sxs-lookup"><span data-stu-id="9f785-148">By using this option you avoid the thread pool completely, including the global and local queues.</span></span>  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a><span data-ttu-id="9f785-149">Attività inline</span><span class="sxs-lookup"><span data-stu-id="9f785-149">Task inlining</span></span>  
 <span data-ttu-id="9f785-150">In alcuni casi, quando un <xref:System.Threading.Tasks.Task> viene attesa, può essere eseguita in modo sincrono sul thread che sta eseguendo l'operazione di attesa.</span><span class="sxs-lookup"><span data-stu-id="9f785-150">In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</span></span> <span data-ttu-id="9f785-151">Ciò migliora le prestazioni evitando la necessità di un altro thread e utilizzando invece il thread esistente che sarebbe stato bloccato in caso contrario.</span><span class="sxs-lookup"><span data-stu-id="9f785-151">This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</span></span> <span data-ttu-id="9f785-152">Per evitare errori dovuti alla reentrancy, l'inline dell'attività si verifica solo quando viene trovata la destinazione in attesa nella coda locale del thread pertinente.</span><span class="sxs-lookup"><span data-stu-id="9f785-152">To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</span></span>  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a><span data-ttu-id="9f785-153">Specificare un contesto di sincronizzazione</span><span class="sxs-lookup"><span data-stu-id="9f785-153">Specifying a synchronization context</span></span>  
 <span data-ttu-id="9f785-154">È possibile usare il metodo <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> per specificare che è necessario pianificare l'esecuzione di un'attività in un particolare thread.</span><span class="sxs-lookup"><span data-stu-id="9f785-154">You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method to specify that a task should be scheduled to run on a particular thread.</span></span> <span data-ttu-id="9f785-155">Ciò risulta utile in framework come Windows Form e Windows Presentation Foundation dove l'accesso agli oggetti dell'interfaccia utente è spesso limitato alla coda in esecuzione nello stesso thread in cui è stato creato l'oggetto dell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="9f785-155">This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</span></span>  
  
 <span data-ttu-id="9f785-156">L'esempio seguente usa il <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> metodo in un'app di Windows Presentation Foundation (WPF) per pianificare un'attività nello stesso thread a cui è stato creato il controllo dell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="9f785-156">The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</span></span>   <span data-ttu-id="9f785-157">Nell'esempio viene creato un mosaico di immagini che vengono selezionate casualmente da una directory specificata.</span><span class="sxs-lookup"><span data-stu-id="9f785-157">The example creates a mosaic of images that are randomly selected from a specified directory.</span></span> <span data-ttu-id="9f785-158">Gli oggetti WPF vengono utilizzati per caricare e ridimensionare le immagini.</span><span class="sxs-lookup"><span data-stu-id="9f785-158">The WPF objects are used to load and resize the images.</span></span> <span data-ttu-id="9f785-159">Pixel non elaborati vengono quindi passati a un'attività che utilizza un <xref:System.Threading.Tasks.Parallel.For%2A> ciclo per scrivere i dati di pixel in una matrice a byte singolo di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="9f785-159">The raw pixels are then passed to a task that uses a <xref:System.Threading.Tasks.Parallel.For%2A> loop to write the pixel data into a large single-byte array.</span></span> <span data-ttu-id="9f785-160">È necessaria alcuna sincronizzazione poiché non esistono due sezioni occupano gli stessi elementi di matrice.</span><span class="sxs-lookup"><span data-stu-id="9f785-160">No synchronization is required because no two tiles occupy the same array elements.</span></span> <span data-ttu-id="9f785-161">I riquadri possono essere scritti in qualsiasi ordine perché la loro posizione viene calcolata in modo indipendente da qualsiasi altra tessera.</span><span class="sxs-lookup"><span data-stu-id="9f785-161">The tiles can also be written in any order because their position is calculated independently of any other tile.</span></span> <span data-ttu-id="9f785-162">La matrice di grandi dimensioni viene quindi passata a un'attività in esecuzione sul thread dell'interfaccia utente, in cui i dati pixel viene caricati in un controllo immagine.</span><span class="sxs-lookup"><span data-stu-id="9f785-162">The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</span></span>  
  
 <span data-ttu-id="9f785-163">L'esempio sposta i dati dal thread dell'interfaccia utente, modifica con cicli paralleli e <xref:System.Threading.Tasks.Task> degli oggetti e quindi lo passa nuovamente a un'attività in esecuzione sul thread dell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="9f785-163">The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread.</span></span> <span data-ttu-id="9f785-164">Questo approccio è utile quando è necessario utilizzare Task Parallel Library per eseguire operazioni che non sono supportate dall'API di WPF, o non sono sufficientemente veloci.</span><span class="sxs-lookup"><span data-stu-id="9f785-164">This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</span></span> <span data-ttu-id="9f785-165">Un altro modo per creare un mosaico di immagini in WPF è utilizzare un <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> controllare e aggiungere le immagini.</span><span class="sxs-lookup"><span data-stu-id="9f785-165">Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> control and add images to it.</span></span> <span data-ttu-id="9f785-166">Il <xref:System.Windows.Controls.WrapPanel> gestisce le operazioni di posizionamento i riquadri.</span><span class="sxs-lookup"><span data-stu-id="9f785-166">The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles.</span></span> <span data-ttu-id="9f785-167">Tuttavia, questa operazione può essere eseguita solo nel thread UI.</span><span class="sxs-lookup"><span data-stu-id="9f785-167">However, this work can only be performed on the UI thread.</span></span>  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 <span data-ttu-id="9f785-168">Per creare l'esempio, creare un progetto di applicazione WPF in Visual Studio e assegnargli un nome di propria scelta.</span><span class="sxs-lookup"><span data-stu-id="9f785-168">To create the example, create a WPF application project in Visual Studio and assign it a name of your choice.</span></span> <span data-ttu-id="9f785-169">Quindi eseguire le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="9f785-169">Then do the following:</span></span>  
  
1.  <span data-ttu-id="9f785-170">In visualizzazione progettazione, trascinare un <xref:System.Windows.Controls.Image> controllo il **della casella degli strumenti** all'area di progettazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-170">In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** to the design surface.</span></span> <span data-ttu-id="9f785-171">Nella visualizzazione XAML, specificare l'allineamento orizzontale come "Left".</span><span class="sxs-lookup"><span data-stu-id="9f785-171">In XAML view, specify the horizontal alignment as "Left."</span></span> <span data-ttu-id="9f785-172">La dimensione non è importante perché il controllo viene ridimensionato in modo dinamico in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="9f785-172">The size does not matter because the control is be dynamically resized at run time.</span></span> <span data-ttu-id="9f785-173">Accettare il nome predefinito, "image".</span><span class="sxs-lookup"><span data-stu-id="9f785-173">Accept the default name, "image".</span></span>  
  
2.  <span data-ttu-id="9f785-174">Trascinare un <xref:System.Windows.Controls.Button> controllo il **della casella degli strumenti** nella parte inferiore sinistra della finestra dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-174">Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window.</span></span> <span data-ttu-id="9f785-175">Fare doppio clic sul pulsante per aggiungere un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> gestore dell'evento.</span><span class="sxs-lookup"><span data-stu-id="9f785-175">Double-click the button to add a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event handler.</span></span> <span data-ttu-id="9f785-176">Nella visualizzazione XAML, specificare il <xref:System.Windows.Controls.ContentControl.Content%2A> proprietà del pulsante come "Hanno un mosaico" e specificare l'allineamento orizzontale "Left".</span><span class="sxs-lookup"><span data-stu-id="9f785-176">In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as "Make a Mosaic" and specify its horizontal alignment as "Left".</span></span> <span data-ttu-id="9f785-177">Accettare il nome predefinito, "button".</span><span class="sxs-lookup"><span data-stu-id="9f785-177">Accept the default name, "button".</span></span>  
  
3.  <span data-ttu-id="9f785-178">Sostituire tutto il contenuto del file MainWindow.xaml.cs o. Xaml. vb con il codice di questo esempio.</span><span class="sxs-lookup"><span data-stu-id="9f785-178">Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</span></span> <span data-ttu-id="9f785-179">Assicurarsi che il nome dell'area di lavoro corrisponda al nome del progetto.</span><span class="sxs-lookup"><span data-stu-id="9f785-179">Make sure that the name of the workspace matches the project name.</span></span>  
  
4.  <span data-ttu-id="9f785-180">Nell'esempio viene letto le immagini JPEG da una directory denominata immagini C:\Users\Public\Pictures\Sample\\.</span><span class="sxs-lookup"><span data-stu-id="9f785-180">The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures\\.</span></span> <span data-ttu-id="9f785-181">Creare la directory e posizionare alcune immagini in essa contenuti o modificare il percorso per fare riferimento a altre directory che contiene immagini.</span><span class="sxs-lookup"><span data-stu-id="9f785-181">Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</span></span>  
  
 <span data-ttu-id="9f785-182">L'esempio include alcune limitazioni.</span><span class="sxs-lookup"><span data-stu-id="9f785-182">This example has some limitations.</span></span> <span data-ttu-id="9f785-183">Ad esempio, sono supportate immagini solo 32-bit per pixel; le immagini in altri formati sono danneggiate per il <xref:System.Windows.Media.Imaging.BitmapImage> dell'oggetto durante l'operazione di ridimensionamento.</span><span class="sxs-lookup"><span data-stu-id="9f785-183">For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation.</span></span> <span data-ttu-id="9f785-184">Inoltre, le immagini di origine devono essere tutti maggiore delle dimensioni del riquadro.</span><span class="sxs-lookup"><span data-stu-id="9f785-184">Also, the source images must all be larger than the tile size.</span></span> <span data-ttu-id="9f785-185">Come esercizio ulteriore, è possibile aggiungere la funzionalità per gestire più formati di pixel e dimensioni dei file.</span><span class="sxs-lookup"><span data-stu-id="9f785-185">As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9f785-186">L'esempio seguente è tratto dal [esempi per la programmazione parallela con .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) nel sito Web MSDN Code Gallery.</span><span class="sxs-lookup"><span data-stu-id="9f785-186">The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.</span></span>  <span data-ttu-id="9f785-187">Crea un'utilità di pianificazione di attività personalizzata che limita il numero di thread utilizzati dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-187">It creates a custom task scheduler that limits the number of threads used by the app.</span></span> <span data-ttu-id="9f785-188">Quindi avviati due set di attività e visualizza le informazioni sull'attività e il thread su cui è in esecuzione l'attività.</span><span class="sxs-lookup"><span data-stu-id="9f785-188">It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</span></span>  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 <span data-ttu-id="9f785-189">Inoltre, sono disponibili diverse utilità di pianificazione delle attività di esempio in Code Gallery: [esempi per la programmazione parallela con .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).</span><span class="sxs-lookup"><span data-stu-id="9f785-189">In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="9f785-190">Tutti i membri della classe astratta <see cref="T:System.Threading.Tasks.TaskScheduler" /> tipo sono thread-safe e possono essere utilizzati da più thread contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="9f785-190">All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9f785-191">Inizializza <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="9f785-191">Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9f785-192">Ottiene l'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> associato all'attività attualmente in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="9f785-192">Gets the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></summary>
        <value><span data-ttu-id="9f785-193">Restituisce l'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> associato all'attività attualmente in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="9f785-193">Returns the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-194">Quando viene chiamato dall'interno di un'attività, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> restituirà il <xref:System.Threading.Tasks.TaskScheduler.Default%2A> dell'utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-194">When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.</span></span>  
  
 <span data-ttu-id="9f785-195">Per ulteriori informazioni, vedere <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="9f785-195">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9f785-196">Ottiene l'istanza di <see cref="T:System.Threading.Tasks.TaskScheduler" /> predefinita fornita da .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="9f785-196">Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance that is provided by the .NET Framework.</span></span></summary>
        <value><span data-ttu-id="9f785-197">Restituisce l'istanza di <see cref="T:System.Threading.Tasks.TaskScheduler" /> predefinita.</span><span class="sxs-lookup"><span data-stu-id="9f785-197">Returns the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-198">Per ulteriori informazioni, vedere [le utilità di pianificazione](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="9f785-198">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9f785-199">Crea un oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> associato all'oggetto <see cref="T:System.Threading.SynchronizationContext" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="9f785-199">Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />.</span></span></summary>
        <returns><span data-ttu-id="9f785-200">Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> associato all'oggetto <see cref="T:System.Threading.SynchronizationContext" /> corrente, come determinato dalla proprietà <see cref="P:System.Threading.SynchronizationContext.Current" />.</span><span class="sxs-lookup"><span data-stu-id="9f785-200">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />, as determined by <see cref="P:System.Threading.SynchronizationContext.Current" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-201">Tutti <xref:System.Threading.Tasks.Task> istanze in coda all'utilità di pianificazione verrà eseguita tramite una chiamata al <xref:System.Threading.SynchronizationContext.Post%2A> metodo su tale contesto.</span><span class="sxs-lookup"><span data-stu-id="9f785-201">All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.</span></span>  
  
 <span data-ttu-id="9f785-202">Per ulteriori informazioni, vedere [le utilità di pianificazione](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="9f785-202">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9f785-203">Impossibile utilizzare SynchronizationContext corrente come TaskScheduler.</span><span class="sxs-lookup"><span data-stu-id="9f785-203">The current SynchronizationContext may not be used as a TaskScheduler.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9f785-204">Solo per il supporto del debugger, genera un oggetto enumerabile di istanze di <see cref="T:System.Threading.Tasks.Task" /> correntemente accodate all'utilità di pianificazione in attesa di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="9f785-204">For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" /> instances currently queued to the scheduler waiting to be executed.</span></span></summary>
        <returns><span data-ttu-id="9f785-205">Oggetto enumerabile che consente a un debugger l'attraversamento delle attività correntemente accodate all'utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-205">An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-206">Una classe derivata da <xref:System.Threading.Tasks.TaskScheduler> implementa questo metodo per supportare l'integrazione con i debugger.</span><span class="sxs-lookup"><span data-stu-id="9f785-206">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers.</span></span> <span data-ttu-id="9f785-207">Questo metodo verrà chiamato solo da .NET Framework quando il debugger richiede l'accesso ai dati.</span><span class="sxs-lookup"><span data-stu-id="9f785-207">This method will only be invoked by the .NET Framework when the debugger requests access to the data.</span></span> <span data-ttu-id="9f785-208">L'enumerabile restituito verrà attraversato dall'utilità di debug per accedere alle attività attualmente in coda all'utilità di pianificazione, consentendo al debugger di fornire una rappresentazione di queste informazioni nell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="9f785-208">The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</span></span>  
  
 <span data-ttu-id="9f785-209">È importante notare che, quando viene chiamato questo metodo, tutti gli altri thread nel processo verrà bloccata.</span><span class="sxs-lookup"><span data-stu-id="9f785-209">It is important to note that, when this method is called, all other threads in the process will be frozen.</span></span> <span data-ttu-id="9f785-210">Pertanto, è importante evitare una sincronizzazione con altri thread che potrebbero causare problemi di blocco.</span><span class="sxs-lookup"><span data-stu-id="9f785-210">Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</span></span> <span data-ttu-id="9f785-211">Se è necessaria la sincronizzazione e non è possibile acquisire il blocco di questo metodo, è necessario generare un'eccezione in modo che il debugger non si blocchi.</span><span class="sxs-lookup"><span data-stu-id="9f785-211">If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.</span></span> <span data-ttu-id="9f785-212">Nell'esempio seguente viene illustrato un possibile approccio in c#:</span><span class="sxs-lookup"><span data-stu-id="9f785-212">The following example shows one possible approach in C#:</span></span>  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 <span data-ttu-id="9f785-213">Inoltre, questo metodo ed enumerabile restituita non deve modificare qualsiasi stato visibile a livello globale.</span><span class="sxs-lookup"><span data-stu-id="9f785-213">Additionally, this method and the enumerable returned must not modify any globally visible state.</span></span>  
  
 <span data-ttu-id="9f785-214">L'enumerabile restituito non deve mai essere null.</span><span class="sxs-lookup"><span data-stu-id="9f785-214">The returned enumerable should never be null.</span></span> <span data-ttu-id="9f785-215">Se non esistono attualmente in coda attività, deve essere restituito invece un enumerabile vuoto.</span><span class="sxs-lookup"><span data-stu-id="9f785-215">If there are currently no queued tasks, an empty enumerable should be returned instead.</span></span>  
  
 <span data-ttu-id="9f785-216">Gli sviluppatori che siano eseguendo l'implementazione di debugger personalizzati non devono chiamare questo metodo direttamente, ma deve utilizzare il metodo wrapper `GetScheduledTasksForDebugger` invece: `internal Task[] GetScheduledTasksForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="9f785-216">Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`.</span></span> <span data-ttu-id="9f785-217">Questo metodo wrapper restituisce una matrice delle attività anziché un oggetto enumerabile.</span><span class="sxs-lookup"><span data-stu-id="9f785-217">This wrapper method returns an array of tasks instead of an enumerable.</span></span> <span data-ttu-id="9f785-218">Per recuperare un elenco di utilità di pianificazione attive, utilizzare il metodo interno `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="9f785-218">To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span></span> <span data-ttu-id="9f785-219">Questo metodo statico restituisce una matrice di tutte attive <xref:System.Threading.Tasks.TaskScheduler> istanze.</span><span class="sxs-lookup"><span data-stu-id="9f785-219">This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances.</span></span> <span data-ttu-id="9f785-220">È quindi possibile utilizzare `GetScheduledTasksForDebugger` in ciascuna istanza dell'utilità di pianificazione per recuperare l'elenco delle attività pianificate.</span><span class="sxs-lookup"><span data-stu-id="9f785-220">You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9f785-221">Questa utilità di pianificazione in questo momento non è in grado di generare un elenco delle attività in coda.</span><span class="sxs-lookup"><span data-stu-id="9f785-221">This scheduler is unable to generate a list of queued tasks at this time.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9f785-222">Ottiene l'ID univoco di questo oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="9f785-222">Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <value><span data-ttu-id="9f785-223">Restituisce l'ID univoco di questo oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="9f785-223">Returns the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-224">Per ulteriori informazioni, vedere [le utilità di pianificazione](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="9f785-224">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9f785-225">Indica il livello di concorrenza massimo supportato da questo oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="9f785-225">Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.</span></span></summary>
        <value><span data-ttu-id="9f785-226">Restituisce un intero che rappresenta il livello di concorrenza massimo.</span><span class="sxs-lookup"><span data-stu-id="9f785-226">Returns an integer that represents the maximum concurrency level.</span></span> <span data-ttu-id="9f785-227">L'utilità di pianificazione predefinita restituisce <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="9f785-227">The default scheduler returns <see cref="F:System.Int32.MaxValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-228">Per ulteriori informazioni, vedere [le utilità di pianificazione](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="9f785-228">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="9f785-229">Oggetto <see cref="T:System.Threading.Tasks.Task" /> da accodare.</span><span class="sxs-lookup"><span data-stu-id="9f785-229">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</span></span></param>
        <summary><span data-ttu-id="9f785-230">Accoda un oggetto <see cref="T:System.Threading.Tasks.Task" /> all'utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-230">Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-231">Una classe derivata da <xref:System.Threading.Tasks.TaskScheduler> implementa questo metodo per accettare le attività pianificate nell'utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-231">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.</span></span>  
  
 <span data-ttu-id="9f785-232">Un'implementazione tipica archivia l'attività in una struttura dati interna, che potrebbe essere gestita dal thread che eseguirà le attività in un momento in futuro.</span><span class="sxs-lookup"><span data-stu-id="9f785-232">A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</span></span>  
  
 <span data-ttu-id="9f785-233">Questo metodo è destinato solo a una chiamata da .NET Framework e non deve essere chiamato direttamente dalla classe derivata.</span><span class="sxs-lookup"><span data-stu-id="9f785-233">This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</span></span> <span data-ttu-id="9f785-234">Ciò è necessario per mantenere la coerenza del sistema.</span><span class="sxs-lookup"><span data-stu-id="9f785-234">This is necessary for maintaining the consistency of the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9f785-235">L'argomento <paramref name="task" /> è Null.</span><span class="sxs-lookup"><span data-stu-id="9f785-235">The <paramref name="task" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="9f785-236">Oggetto <see cref="T:System.Threading.Tasks.Task" /> da rimuovere dalla coda.</span><span class="sxs-lookup"><span data-stu-id="9f785-236">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</span></span></param>
        <summary><span data-ttu-id="9f785-237">Tenta di rimuovere dalla coda un oggetto <see cref="T:System.Threading.Tasks.Task" /> accodato in precedenza a questa utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-237">Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.</span></span></summary>
        <returns><span data-ttu-id="9f785-238">Valore booleano che indica se l'argomento <paramref name="task" /> è stato rimosso correttamente dalla coda.</span><span class="sxs-lookup"><span data-stu-id="9f785-238">A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-239">Per ulteriori informazioni, vedere [le utilità di pianificazione](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="9f785-239">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 <span data-ttu-id="9f785-240">Questo metodo può essere eseguita un blocco finally; Pertanto, deve restituire il più rapidamente possibile in modo che le risorse, ad esempio <xref:System.Threading.CancellationTokenRegistration> oggetti possano essere eliminati in modo tempestivo.</span><span class="sxs-lookup"><span data-stu-id="9f785-240">This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9f785-241">L'argomento <paramref name="task" /> è Null.</span><span class="sxs-lookup"><span data-stu-id="9f785-241">The <paramref name="task" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="9f785-242">Oggetto <see cref="T:System.Threading.Tasks.Task" /> da eseguire.</span><span class="sxs-lookup"><span data-stu-id="9f785-242">A <see cref="T:System.Threading.Tasks.Task" /> object to be executed.</span></span></param>
        <summary><span data-ttu-id="9f785-243">Tenta di eseguire l'oggetto <see cref="T:System.Threading.Tasks.Task" /> fornito in questa utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-243">Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task" /> on this scheduler.</span></span></summary>
        <returns><span data-ttu-id="9f785-244">Valore booleano uguale a true se l'oggetto <paramref name="task" /> è stato eseguito correttamente, a false in caso contrario.</span><span class="sxs-lookup"><span data-stu-id="9f785-244">A Boolean that is true if <paramref name="task" /> was successfully executed, false if it was not.</span></span> <span data-ttu-id="9f785-245">In genere gli errori di esecuzione si verificano perché l'attività è già stata eseguita in precedenza oppure sta per essere eseguita da un altro thread.</span><span class="sxs-lookup"><span data-stu-id="9f785-245">A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-246">Le implementazioni dell'utilità di pianificazione vengono fornite con <xref:System.Threading.Tasks.Task> istanze deve essere eseguito tramite il <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> metodo o <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="9f785-246">Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method.</span></span> <span data-ttu-id="9f785-247">Quando si ritiene appropriata per eseguire l'attività specificata, l'utilità di pianificazione <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> deve essere utilizzato per eseguire questa operazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-247">When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so.</span></span> <span data-ttu-id="9f785-248">TryExecuteTask gestisce tutti gli aspetti dell'esecuzione di un'attività, tra cui l'azione viene richiamata, la gestione delle eccezioni, gestione dello stato e controllo del ciclo di vita.</span><span class="sxs-lookup"><span data-stu-id="9f785-248">TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</span></span>  
  
 <span data-ttu-id="9f785-249"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> deve essere usato solo per le attività fornite all'utilità di pianificazione per l'infrastruttura .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="9f785-249"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</span></span> <span data-ttu-id="9f785-250">E non deve essere utilizzato per eseguire attività arbitrarie ottenute tramite meccanismi personalizzati.</span><span class="sxs-lookup"><span data-stu-id="9f785-250">It should not be used to execute arbitrary tasks obtained through custom mechanisms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9f785-251"><paramref name="task" /> non è associato a questa utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-251">The <paramref name="task" /> is not associated with this scheduler.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="9f785-252">Oggetto <see cref="T:System.Threading.Tasks.Task" /> da eseguire.</span><span class="sxs-lookup"><span data-stu-id="9f785-252">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</span></span></param>
        <param name="taskWasPreviouslyQueued"><span data-ttu-id="9f785-253">Boolean che indica se l'attività è stata accodata in precedenza.</span><span class="sxs-lookup"><span data-stu-id="9f785-253">A Boolean denoting whether or not task has previously been queued.</span></span> <span data-ttu-id="9f785-254">Se questo parametro è True, è possibile che l'attività sia stata accodata (pianificata) in precedenza. Se è False, è noto che l'attività non è stata accodata e questa chiamata viene effettuata per eseguire l'attività inline senza accodarla.</span><span class="sxs-lookup"><span data-stu-id="9f785-254">If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</span></span></param>
        <summary><span data-ttu-id="9f785-255">Determina se l'oggetto <see cref="T:System.Threading.Tasks.Task" /> fornito può essere eseguito in modo sincrono in questa chiamata e, in tal caso, lo esegue.</span><span class="sxs-lookup"><span data-stu-id="9f785-255">Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously in this call, and if it can, executes it.</span></span></summary>
        <returns><span data-ttu-id="9f785-256">Valore booleano che indica se l'attività è stata eseguita inline.</span><span class="sxs-lookup"><span data-stu-id="9f785-256">A Boolean value indicating whether the task was executed inline.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-257">Una classe derivata da <xref:System.Threading.Tasks.TaskScheduler> implementa questa funzione per supportare l'esecuzione di inline di un'attività su un thread che inizia un'attesa su tale oggetto dell'attività.</span><span class="sxs-lookup"><span data-stu-id="9f785-257">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</span></span> <span data-ttu-id="9f785-258">Esecuzione inline è facoltativo, e la richiesta può essere rifiutata restituendo false.</span><span class="sxs-lookup"><span data-stu-id="9f785-258">Inline execution is optional, and the request may be rejected by returning false.</span></span> <span data-ttu-id="9f785-259">Tuttavia, le altre attività che possono essere impostati come inline, migliori saranno le utilità di pianificazione consente di scalare.</span><span class="sxs-lookup"><span data-stu-id="9f785-259">However, the more tasks that can be inlined, the better the scheduler will scale.</span></span> <span data-ttu-id="9f785-260">Infatti, un'utilità di pianificazione che si incorpora troppo poco può essere soggetto a deadlock.</span><span class="sxs-lookup"><span data-stu-id="9f785-260">In fact, a scheduler that inlines too little may be prone to deadlocks.</span></span> <span data-ttu-id="9f785-261">Un'implementazione appropriata deve assicurare che una richiesta eseguita in base ai criteri garantiti dall'utilità di pianificazione possa correttamente inline.</span><span class="sxs-lookup"><span data-stu-id="9f785-261">A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</span></span> <span data-ttu-id="9f785-262">Ad esempio, se un'utilità di pianificazione utilizza un thread dedicato per eseguire attività, qualsiasi richiesta inline da tale thread dovrebbe avere esito positivo.</span><span class="sxs-lookup"><span data-stu-id="9f785-262">For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</span></span>  
  
 <span data-ttu-id="9f785-263">Se un'utilità di pianificazione decide di eseguire l'esecuzione inline, deve farlo chiamando il metodo per l'oggetto TaskScheduler base <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> (metodo) con l'oggetto dell'attività fornita, il valore restituito di propagazione.</span><span class="sxs-lookup"><span data-stu-id="9f785-263">If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value.</span></span> <span data-ttu-id="9f785-264">Potrebbe anche essere appropriato per l'utilità di pianificazione rimuovere un'attività inline relative strutture dati interne se decide di accettare la richiesta di incorporamento.</span><span class="sxs-lookup"><span data-stu-id="9f785-264">It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</span></span> <span data-ttu-id="9f785-265">Si noti, tuttavia, che in alcune circostanze, un'utilità di pianificazione potrebbe essere necessario inline un'attività che non è stata fornita in precedenza con il <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="9f785-265">Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.</span></span>  
  
 <span data-ttu-id="9f785-266">L'utilità di pianificazione derivata è responsabilità di assicurarsi che il thread chiamante è adatto per l'esecuzione dell'attività specificata per la pianificazione e criteri di esecuzione sono interessati.</span><span class="sxs-lookup"><span data-stu-id="9f785-266">The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</span></span>  
  
 <span data-ttu-id="9f785-267">Per ulteriori informazioni, vedere [le utilità di pianificazione](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="9f785-267">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9f785-268">L'argomento <paramref name="task" /> è Null.</span><span class="sxs-lookup"><span data-stu-id="9f785-268">The <paramref name="task" /> argument is null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9f785-269">L'oggetto <paramref name="task" /> è stato già eseguito.</span><span class="sxs-lookup"><span data-stu-id="9f785-269">The <paramref name="task" /> was already executed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9f785-270">Si verifica quando l'eccezione non osservata di un'attività con errori sta per attivare i criteri di escalation delle eccezioni, che per impostazione predefinita interrompono il processo.</span><span class="sxs-lookup"><span data-stu-id="9f785-270">Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9f785-271">Questo evento a livello di dominio di applicazione fornisce un meccanismo per evitare che i criteri di escalation di eccezioni (ovvero, per impostazione predefinita, terminano il processo) da attivare.</span><span class="sxs-lookup"><span data-stu-id="9f785-271">This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</span></span>  
  
 <span data-ttu-id="9f785-272">Per semplificare agli sviluppatori di scrivere codice asincrono basato su attività, il [!INCLUDE[net_v45](~/includes/net-v45-md.md)] viene modificato il comportamento predefinito dell'eccezione per le eccezioni non osservate.</span><span class="sxs-lookup"><span data-stu-id="9f785-272">To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions.</span></span> <span data-ttu-id="9f785-273">Anche se le eccezioni non osservate ancora generano il <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> eccezione, il processo non viene interrotto per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="9f785-273">Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default.</span></span> <span data-ttu-id="9f785-274">Al contrario, l'eccezione viene gestita dal runtime dopo l'evento viene generato, indipendentemente dal fatto che un gestore eventi rileva l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="9f785-274">Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</span></span> <span data-ttu-id="9f785-275">Questo comportamento può essere configurato.</span><span class="sxs-lookup"><span data-stu-id="9f785-275">This behavior can be configured.</span></span> <span data-ttu-id="9f785-276">A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile utilizzare l'elemento di configurazione per ripristinare il comportamento del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] e terminare il processo:</span><span class="sxs-lookup"><span data-stu-id="9f785-276">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the  configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:</span></span>  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>