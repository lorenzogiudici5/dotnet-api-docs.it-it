<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b2345d31971ac8a2f7e541a291d5c42b6463c751" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51925134" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un oggetto che gestisce le operazioni di basso livello relative all'accodamento delle attività nei thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'istanza di <xref:System.Threading.Tasks.TaskScheduler> classe rappresenta un'utilità di pianificazione. Un'utilità di pianificazione assicura che il lavoro di un'attività viene eseguito.  
  
 L'utilità di pianificazione predefinita si basa su pool di thread .NET Framework 4, che fornisce l'acquisizione del lavoro per il bilanciamento del carico, l'aggiunta/ritiro dei thread per la velocità effettiva massima e buone prestazioni complessive. Dovrebbe essere sufficiente per la maggior parte degli scenari.  
  
 Il <xref:System.Threading.Tasks.TaskScheduler> classe funge anche da punto di estensione per tutta la logica di programmazione personalizzabile.  Ciò include meccanismi, ad esempio come pianificare un'attività per l'esecuzione e come le attività pianificate deve essere esposte al debugger. Se sono necessarie funzionalità speciali, è possibile creare un'utilità di pianificazione personalizzata e abilitarla per attività specifiche o le query.  
  
 In questo argomento  
[Utilità di pianificazione predefinita e il pool di thread](#Default)  
 [Coda globale e le code locali](#Queues)  
 [Acquisizione del lavoro](#Stealing)  
 [Attività a esecuzione prolungata](#LongRunning)  
 [Inline dell'attività](#Inlining)  
[Specifica un contesto di sincronizzazione](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>Utilità di pianificazione predefinita e il pool di thread  
 L'utilità di pianificazione predefinita per la Task Parallel Library e PLINQ Usa il pool di thread .NET Framework, che è rappresentato dal <xref:System.Threading.ThreadPool> (classe), per accodare ed eseguire il lavoro. Il pool di thread utilizza le informazioni che viene fornite dal <xref:System.Threading.Tasks.Task> tipo da supportare in modo efficiente il parallelismo con granularità fine (unità di lavoro di breve durata) che attività e query parallele spesso rappresentano.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>Coda globale e le code locali  
 Il pool di thread gestisce una globale FIFO (first in, First-Out) coda di lavoro per i thread in ogni dominio applicazione. Ogni volta che un programma chiama il <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (o <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) metodo, il lavoro viene inserito in questa coda condivisa e infine rimossi dalla coda al primo thread che diventa disponibile. A partire da .NET Framework 4, la coda è stata migliorata per usare un algoritmo senza blocco che è simile al <xref:System.Collections.Concurrent.ConcurrentQueue%601> classe. Tramite questa implementazione senza blocco, il pool di thread impiega meno tempo quando si inseriscono elementi di lavoro nella coda. Questo miglioramento delle prestazioni è disponibile per tutti i programmi che usano il pool di thread.  
  
 Le attività di primo livello, ovvero quelle non create nell'ambito di un'altra attività, vengono inserite nella coda globale come qualsiasi altro elemento di lavoro. Tuttavia le attività annidate o figlio, create nell'ambito di un'altra attività, vengono gestite in modo molto diverso. Un'attività figlio o annidata viene inserita in una coda locale specifica del thread in cui è in esecuzione l'attività padre. L'attività padre può essere un'attività di primo livello o anche l'elemento figlio di un'altra attività. Quando questo thread è disponibile per altro lavoro, esegue innanzitutto una ricerca nella coda locale. Se sono presenti elementi di lavoro in attesa, è possibile accedervi rapidamente. Le code locali sono accessibili in last in, First-Out ordine LIFO () per mantenere la località della cache e ridurre le contese. Per altre informazioni sulle attività annidate e attività figlio, vedere [attività connesse e disconnesse figlio](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  
  
 L'uso di code locali non solo riduce la pressione sulla coda globale, ma consente anche di sfruttare la località dei dati. Gli elementi di lavoro locale accodare spesso strutture di dati di riferimento che si trovano fisicamente vicine in memoria. In questi casi, i dati sono già nella cache dopo la prima attività è stata eseguita ed è possibile accedervi rapidamente. Entrambe [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) e il <xref:System.Threading.Tasks.Parallel> classe ampiamente attività annidate e attività figlio e considerevolmente la usando le code di lavoro locale.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Acquisizione del lavoro  
 A partire da .NET Framework 4, il pool di thread offre inoltre un algoritmo di acquisizione del lavoro per garantire che nessun thread sia inattivo mentre altri hanno ancora lavoro nelle code. Quando un thread del pool di thread è disponibile per altro lavoro, effettua prima una ricerca all'inizio della propria coda locale, quindi nella coda globale e infine nelle code locali degli altri thread. Se trova un elemento di lavoro nella coda locale di un altro thread, prima applica l'euristica per avere la certezza di poter eseguire il lavoro in modo efficiente. In caso contrario, deprovisioning mette in coda l'elemento di lavoro dalla coda (in ordine FIFO). In questo modo viene ridotto il conflitto in ogni coda locale e viene mantenuta la località dei dati. Questa architettura consente il bilanciamento del carico thread del pool di lavoro in modo più efficiente rispetto alle versioni precedenti.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Attività a esecuzione prolungata  
 Può essere opportuno impedire in modo esplicito l'inserimento di un'attività in una coda locale. Ad esempio, si potrebbe sapere che un particolare elemento di lavoro verrà eseguito per un tempo relativamente lungo e probabilmente bloccherà tutti gli altri elementi di lavoro nella coda locale. In questo caso, è possibile specificare l'opzione <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>, che fornisce all'utilità di pianificazione il suggerimento che per l'attività potrebbe essere necessario un altro thread in modo che non blocchi l'avanzamento di altri thread o elementi di lavoro nella coda locale. Usando questa opzione si evita il pool di thread completamente, tra cui le code globale e locale.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Inline dell'attività  
 In alcuni casi, quando un <xref:System.Threading.Tasks.Task> è rimasto in attesa, può essere eseguita in modo sincrono sul thread che sta eseguendo l'operazione di attesa. Ciò migliora le prestazioni evitando la necessità di un altro thread e utilizzando invece il thread esistente, che sarebbe stata bloccata in caso contrario. Per evitare errori dovuti alla reentrancy, l'inline dell'attività si verifica solo quando viene trovata la destinazione in attesa nella coda locale del thread pertinente.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Specifica un contesto di sincronizzazione  
 È possibile usare il metodo <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> per specificare che è necessario pianificare l'esecuzione di un'attività in un particolare thread. Ciò risulta utile in framework come Windows Form e Windows Presentation Foundation dove l'accesso agli oggetti dell'interfaccia utente è spesso limitato alla coda in esecuzione nello stesso thread in cui è stato creato l'oggetto dell'interfaccia utente.  
  
 L'esempio seguente usa il <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> metodo in un'app di Windows Presentation Foundation (WPF) per pianificare un'attività nello stesso thread che è stato creato il controllo dell'interfaccia utente.   Nell'esempio viene creato un mosaico di immagini che vengono selezionate casualmente da una directory specificata. Gli oggetti WPF sono utilizzati per caricare e ridimensionare le immagini. I pixel non elaborati vengono quindi passati a un'attività che usa un <xref:System.Threading.Tasks.Parallel.For%2A> ciclo per scrivere i dati pixel in una matrice a byte singolo di grandi dimensioni. È richiesta alcuna sincronizzazione poiché non esistono due sezioni occupano gli stessi elementi di matrice. I riquadri possono anche essere scritti in qualsiasi ordine perché la loro posizione viene calcolata indipendentemente da qualsiasi altro riquadro. La matrice di grandi dimensioni viene quindi passata a un'attività che viene eseguito sul thread dell'interfaccia utente, in cui i dati pixel viene caricati in un controllo immagine.  
  
 L'esempio consente di spostare dati dal thread dell'interfaccia utente, lo modifica utilizzando cicli paralleli e <xref:System.Threading.Tasks.Task> oggetti e quindi lo passa nuovamente a un'attività che viene eseguito sul thread UI. Questo approccio è utile quando è necessario usare Task Parallel Library per eseguire operazioni che non sono supportate dall'API di WPF, o non sono sufficientemente veloci. Un altro modo per creare un mosaico di immagini in WPF consiste nell'usare un <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> controllano e aggiungervi immagini. Il <xref:System.Windows.Controls.WrapPanel> gestisce le operazioni dei riquadri di posizionamento. Tuttavia, questa operazione può essere eseguita solo sul thread UI.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Per creare l'esempio, creare un progetto di applicazione WPF in Visual Studio e denominarlo WPF_CS1 (per un C# progetto WPF) o WPF_VB1 (per un progetto WPF di Visual Basic). Quindi eseguire le operazioni seguenti:  
  
1. Nella visualizzazione progettazione, trascinare un' <xref:System.Windows.Controls.Image> controllare dal **casella degli strumenti** nell'angolo superiore sinistro dell'area di progettazione. Nel **Name** nella casella di testo il **proprietà** finestra, denominato il controllo "image".    
  
2. Trascinare un <xref:System.Windows.Controls.Button> controllare dal **casella degli strumenti** nella parte inferiore sinistra della finestra dell'applicazione. Nella visualizzazione XAML, specificare il <xref:System.Windows.Controls.ContentControl.Content%2A> proprietà del pulsante come il comando "Make un mosaico" e specificare il <xref:System.Windows.FrameworkElement.Width> proprietà come "100". Connettere il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento con il `button_Click` gestore dell'evento definito nel codice dell'esempio mediante l'aggiunta `Click="button_Click"` per il `<Button>` elemento. Nel **Name** nella casella di testo le **proprietà** finestra, denominare il controllo "pulsante".  
  
3. Sostituire l'intero contenuto del file XAML. vb o MainWindow.xaml.cs con il codice dell'esempio. Per un C# WPF del progetto, assicurarsi che il nome dell'area di lavoro corrisponda al nome del progetto. 
  
4. Nell'esempio le immagini JPEG vengono letti da una directory denominata C:\Users\Public\Pictures\Sample Pubbliche\immagini campione\\. Creare la directory e inserire alcune immagini in essa o modificare il percorso per fare riferimento a altre directory che contiene immagini. 
  
In questo esempio presenta alcune limitazioni. Ad esempio, sono supportate immagini solo 32-bit per pixel; le immagini in altri formati sono danneggiate dal <xref:System.Windows.Media.Imaging.BitmapImage> dell'oggetto durante l'operazione di ridimensionamento. Inoltre, le immagini di origine devono essere tutti maggiore delle dimensioni riquadro. Come ulteriore esercizio, è possibile aggiungere la funzionalità per gestire più formati pixel e dimensioni dei file.  
  
## Examples  
 L'esempio seguente è tratto dal [esempi di programmazione parallela con .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) nel sito Web MSDN Code Gallery.  Crea un'utilità di pianificazione di attività personalizzata che limiti il numero di thread usati dall'app. Quindi avviati due set di attività e visualizza le informazioni sull'attività e il thread su cui è in esecuzione l'attività.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 Inoltre, nella galleria di codice sono disponibili diverse utilità di pianificazione delle attività di esempio: [esempi di programmazione parallela con .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Tutti i membri della classe astratta <see cref="T:System.Threading.Tasks.TaskScheduler" /> tipo sono thread-safe e possono essere utilizzati da più thread contemporaneamente.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> associato all'attività attualmente in esecuzione.</summary>
        <value>Restituisce l'oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> associato all'attività attualmente in esecuzione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando non viene chiamato all'interno di un'attività <xref:System.Threading.Tasks.TaskScheduler.Current%2A> restituirà il <xref:System.Threading.Tasks.TaskScheduler.Default%2A> dell'utilità di pianificazione.  
  
 Per ulteriori informazioni, vedere <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'istanza di <see cref="T:System.Threading.Tasks.TaskScheduler" /> predefinita fornita da .NET Framework.</summary>
        <value>Restituisce l'istanza di <see cref="T:System.Threading.Tasks.TaskScheduler" /> predefinita.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera tutte le risorse associate a questa utilità di pianificazione.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> associato all'oggetto <see cref="T:System.Threading.SynchronizationContext" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" /> associato all'oggetto <see cref="T:System.Threading.SynchronizationContext" /> corrente, come determinato dalla proprietà <see cref="P:System.Threading.SynchronizationContext.Current" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti i <xref:System.Threading.Tasks.Task> istanze in coda per l'oggetto restituito dell'utilità di pianificazione verrà eseguita tramite una chiamata al <xref:System.Threading.SynchronizationContext.Post%2A> metodo su tale contesto.  
  
 Per ulteriori informazioni, vedere <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossibile utilizzare SynchronizationContext corrente come TaskScheduler.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Solo per il supporto del debugger, genera un oggetto enumerabile di istanze di <see cref="T:System.Threading.Tasks.Task" /> correntemente accodate all'utilità di pianificazione in attesa di esecuzione.</summary>
        <returns>Oggetto enumerabile che consente a un debugger l'attraversamento delle attività correntemente accodate all'utilità di pianificazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una classe derivata da <xref:System.Threading.Tasks.TaskScheduler> implementa questo metodo per supportare l'integrazione con i debugger. Questo metodo viene richiamato da .NET Framework solo quando il debugger richiede l'accesso ai dati. L'enumerabile restituito verranno attraversati da utilità di debug per accedere alle attività correntemente accodate all'utilità di pianificazione, abilitare il debugger fornire una rappresentazione di queste informazioni nell'interfaccia utente.  
  
 È importante notare che, quando viene chiamato questo metodo, tutti gli altri thread nel processo verrà bloccato. Pertanto, è importante evitare la sincronizzazione con altri thread che possono causare il blocco. Se sia necessaria la sincronizzazione e si è in grado di acquisire il blocco in questo metodo, è necessario generare un'eccezione in modo che il debugger non si blocca. Nell'esempio seguente viene illustrato uno degli approcci possibili nel linguaggio c#:  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 Inoltre, questo metodo ed enumerabile restituita non deve modificare qualsiasi stato visibile globalmente.  
  
 L'enumerabile restituito non deve mai essere null. Se non sono attualmente presenti attività in coda, un enumerabile vuoto deve invece essere restituito.  
  
 Gli sviluppatori che intendono implementare debugger personalizzati non devono chiamare questo metodo direttamente, ma devono usare il metodo wrapper interna `GetScheduledTasksForDebugger` invece: `internal Task[] GetScheduledTasksForDebugger()`. Questo metodo wrapper restituisce una matrice di attività anziché un oggetto enumerabile. Per recuperare un elenco di utilità di pianificazione attive, usare il metodo interno `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. Questo metodo statico restituisce una matrice di tutte attive <xref:System.Threading.Tasks.TaskScheduler> istanze. È quindi possibile usare `GetScheduledTasksForDebugger` in ogni istanza dell'utilità di pianificazione per recuperare l'elenco delle attività pianificate.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Questa utilità di pianificazione in questo momento non è in grado di generare un elenco delle attività in coda.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'ID univoco di questo oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Restituisce l'ID univoco di questo oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica il livello di concorrenza massimo supportato da questo oggetto <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Restituisce un intero che rappresenta il livello di concorrenza massimo. L'utilità di pianificazione predefinita restituisce <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Oggetto <see cref="T:System.Threading.Tasks.Task" /> da accodare.</param>
        <summary>Accoda un oggetto <see cref="T:System.Threading.Tasks.Task" /> all'utilità di pianificazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una classe derivata da <xref:System.Threading.Tasks.TaskScheduler> implementa questo metodo per accettare le attività pianificate nell'utilità di pianificazione.  
  
 Un'implementazione tipica sarebbe per memorizzare l'attività in una struttura dati interna, che sarebbe gestita dal thread che esegue queste attività in un momento in futuro.  
  
 Questo metodo è destinato solo a essere chiamato da .NET Framework e non deve essere chiamato direttamente dalla classe derivata. Ciò è necessario per mantenere la coerenza del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="task" /> è Null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Oggetto <see cref="T:System.Threading.Tasks.Task" /> da rimuovere dalla coda.</param>
        <summary>Tenta di rimuovere dalla coda un oggetto <see cref="T:System.Threading.Tasks.Task" /> accodato in precedenza a questa utilità di pianificazione.</summary>
        <returns>Valore booleano che indica se l'argomento <paramref name="task" /> è stato rimosso correttamente dalla coda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere <xref:System.Threading.Tasks.TaskScheduler>.  
  
 Questo metodo può essere eseguito in un blocco finally; di conseguenza deve restituire il più rapidamente possibile in modo che le risorse, ad esempio <xref:System.Threading.CancellationTokenRegistration> oggetti possano essere eliminati in modo tempestivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="task" /> è Null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Oggetto <see cref="T:System.Threading.Tasks.Task" /> da eseguire.</param>
        <summary>Tenta di eseguire l'oggetto <see cref="T:System.Threading.Tasks.Task" /> fornito in questa utilità di pianificazione.</summary>
        <returns>Valore booleano uguale a true se l'oggetto <paramref name="task" /> è stato eseguito correttamente, a false in caso contrario. In genere gli errori di esecuzione si verificano perché l'attività è già stata eseguita in precedenza oppure sta per essere eseguita da un altro thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le implementazioni dell'utilità di pianificazione vengono fornite con <xref:System.Threading.Tasks.Task> istanze da eseguire tramite il <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> metodo o il <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> (metodo). Quando si ritiene appropriata eseguire l'attività specificata, l'utilità di pianificazione <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> deve essere usato per eseguire questa operazione. TryExecuteTask gestisce tutti gli aspetti dell'esecuzione di un'attività, tra cui chiamata di un'azione, la gestione delle eccezioni, gestione dello stato e il controllo del ciclo di vita.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> deve essere usato solo per le attività fornite all'utilità di pianificazione per l'infrastruttura .NET Framework. Consigliabile non usarla per eseguire attività arbitrarie ottenuta mediante meccanismi personalizzati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="task" /> non è associato a questa utilità di pianificazione.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">Oggetto <see cref="T:System.Threading.Tasks.Task" /> da eseguire.</param>
        <param name="taskWasPreviouslyQueued">Boolean che indica se l'attività è stata accodata in precedenza. Se questo parametro è True, è possibile che l'attività sia stata accodata (pianificata) in precedenza. Se è False, è noto che l'attività non è stata accodata e questa chiamata viene effettuata per eseguire l'attività inline senza accodarla.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Threading.Tasks.Task" /> fornito può essere eseguito in modo sincrono in questa chiamata e, in tal caso, lo esegue.</summary>
        <returns>Valore booleano che indica se l'attività è stata eseguita inline.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una classe derivata da <xref:System.Threading.Tasks.TaskScheduler> implementa questa funzione per supportare l'esecuzione di inline di un'attività in un thread che avvia un'attesa su tale oggetto attività. Esecuzione inline è facoltativo e la richiesta può essere rifiutata restituendo false. Tuttavia, le altre attività che può essere impostato come inline, migliore sarà l'utilità di pianificazione verrà ridimensionato. Infatti, un'utilità di pianificazione che si incorpora troppo poco può essere soggetta a deadlock. Un'implementazione appropriata deve assicurare che una richiesta eseguita in base ai criteri garantiti dall'utilità di pianificazione può eseguire inline. Ad esempio, se un'utilità di pianificazione Usa un thread dedicato per eseguire le attività, le richieste di incorporamento dal thread in questione dovrebbero avere esito positivo.  
  
 Se un'utilità di pianificazione decide di eseguire l'esecuzione inline, deve farlo chiamando il metodo per l'oggetto TaskScheduler base <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> metodo con l'oggetto dell'attività fornita, la propagazione del valore restituito. Potrebbe anche essere appropriata per l'utilità di pianificazione rimuovere un'attività inline da relative strutture dati interne se decide di accettare la richiesta di incorporamento. Si noti, tuttavia, che in alcune circostanze un'utilità di pianificazione potrebbe essere chiesto inline un'attività che non è stata specificata in precedenza a esso con il <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> (metodo).  
  
 L'utilità di pianificazione derivato è responsabile di assicurarsi che il thread chiamante è adatto per l'esecuzione di attività specifica per quanto riguarda la pianificazione e riguardano i criteri di esecuzione.  
  
 Per ulteriori informazioni, vedere <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argomento <paramref name="task" /> è Null.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <paramref name="task" /> è stato già eseguito.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando l'eccezione non osservata di un'attività con errori sta per attivare i criteri di escalation delle eccezioni, che per impostazione predefinita interrompono il processo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento di livello di dominio applicazione fornisce un meccanismo per impedire i criteri di escalation delle eccezioni (ovvero, per impostazione predefinita, terminano il processo) dall'attivazione.  
  
 Per renderne più semplice per gli sviluppatori di scrivere codice asincrono basato su attività, il [!INCLUDE[net_v45](~/includes/net-v45-md.md)] cambia il comportamento predefinito dell'eccezione per le eccezioni non osservate. Anche se generano eccezioni non osservate comunque il <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> eccezione, il processo non viene terminato per impostazione predefinita. Al contrario, l'eccezione viene gestita dal runtime dopo che l'evento viene generato, indipendentemente dal fatto che un gestore eventi rileva l'eccezione. Questo comportamento può essere configurato. Inizia con la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile utilizzare l'elemento di configurazione per ripristinare il comportamento del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] e terminare il processo:  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Task Parallel Library (TPL)</related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md">&lt;ThrowUnobservedTaskExceptions&gt; elemento</related>
      </Docs>
    </Member>
  </Members>
</Type>