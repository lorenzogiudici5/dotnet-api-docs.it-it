<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0ccd8e8796d91623d453ef299472d90582525e77" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407711" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce supporto per aree e cicli in parallelo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Parallel> classe fornisce sostituzioni parallele basata su raccolta dati per operazioni comuni quali cicli, per ogni esecuzione di un set di istruzioni e cicli,.  
  
   
  
## Examples  
 Questo esempio illustra diversi approcci per l'implementazione di un ciclo parallelo tramite più costrutti del linguaggio.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tutti i membri pubblici e protetti di <see cref="T:System.Threading.Tasks.Parallel" /> sono thread-safe e possono essere utilizzate contemporaneamente da più thread.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) in cui le iterazioni possono essere eseguite in parallelo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con due argomenti:  
  
-   Un <xref:System.Int32> valore che rappresenta il conteggio delle iterazioni.  
  
-   Oggetto <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere utilizzato per interrompere il ciclo in modo anomalo. Il <xref:System.Threading.Tasks.ParallelLoopState> oggetto viene creato dal compilatore; non è possibile creare un'istanza nel codice utente.  
  
 Chiamata di <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo informa il `for` operazione che non dispongono di iterazioni successivo a quello corrente per l'esecuzione. Tuttavia, tutte le iterazioni prima corrente uno sarà comunque necessario deve essere eseguito se è già stato fatto.  
  
 Pertanto, la chiamata <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> è simile all'utilizzo di un'operazione di interruzione all'interno di una tradizionale `for` ciclo in un linguaggio come c#, ma non è un sostituto perfetto: ad esempio, non è garantito che le iterazioni successivo a quello corrente verranno sicuramente non eseguire.  
  
 Se l'esecuzione di tutte le iterazioni prima di quella corrente non è necessario, utilizzare il <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo anziché <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. La chiamata <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa il `for` ciclo che può abbandonare tutti i rimanenti iterazioni, indipendentemente dal fatto che essi si prima o dopo l'iterazione corrente, in quanto tutte le necessarie lavoro verrà sono già stato completato. Tuttavia, come con <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, non vi sono garanzie riguardo a quali altre iterazioni non verranno eseguito.  
  
 Se un ciclo termina prematuramente, il <xref:System.Threading.Tasks.ParallelLoopResult> struttura restituita conterrà le informazioni relative al completamento del ciclo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita fino a 100 iterazioni di un ciclo in parallelo. Ogni iterazione viene sospeso per un intervallo casuale da 1 a 1.000 millisecondi. Un valore generato casualmente determina a quali iterazione del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metodo viene chiamato. Come output illustrato nell'esempio, nessuna iterazione il cui indice è maggiore di <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> inizio del valore proprietà dopo la chiamata al <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metodo.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Poiché le iterazioni del ciclo vengono ancora soggetti a essere in esecuzione al termine il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metodo viene chiamato, le chiamate di ogni iterazione il <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> proprietà per verificare se un'altra iterazione è chiamato il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> (metodo). Se il valore della proprietà `true`, l'iterazione controlla il valore del <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> proprietà e, se è maggiore del valore di indice dell'iterazione corrente, restituisce immediatamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) in cui le iterazioni possono essere eseguite in parallelo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con il conteggio delle iterazioni (<xref:System.Int32>) come parametro.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Threading.Tasks.Parallel.For%2A> metodo per 100 chiamate di un delegato che genera l'errore byte casuali valori e calcola la somma.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un loop <see langword="for" /> (<see langword="For" /> in Visual Basic) con gli indici a 64 bit in cui le iterazioni possono eseguire in parallelo e lo stato del loop può essere monitorato e manipolato.</summary>
        <returns>Struttura <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i seguenti parametri: il conteggio delle iterazioni (<xref:System.Int64>) e un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo.  
  
 Chiamata di <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo informa il `for` operazione iterazioni successiva a quella corrente non deve essere eseguito, ma eseguire tutte le iterazioni precedenti a quella corrente.  
  
 Pertanto, la chiamata di interruzione è simile all'utilizzo di un'operazione di interruzione all'interno di una tradizionale `for` ciclo in un linguaggio come c#, ma non è un sostituto perfetto: ad esempio, non è garantito che le iterazioni dopo quello corrente sicuramente non verrà eseguiti.  
  
 Se l'esecuzione di tutte le iterazioni prima di quella corrente non è necessario, utilizzare il <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo anziché <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. La chiamata <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa il `for` ciclo che può abbandonare tutti i rimanenti iterazioni, indipendentemente dal fatto che essi si prima o dopo l'iterazione corrente, in quanto tutte le necessarie lavoro verrà sono già stato completato. Tuttavia, come con <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, non vi sono garanzie riguardo a quali altre iterazioni non verranno eseguito.  
  
 Se un ciclo termina prematuramente, il <xref:System.Threading.Tasks.ParallelLoopResult> struttura restituita conterrà le informazioni relative al completamento del ciclo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con indici a 64 bit in cui le iterazioni possono essere eseguite in parallelo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con il conteggio delle iterazioni (<xref:System.Int64>) come parametro.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i seguenti parametri: il conteggio delle iterazioni (<xref:System.Int32>) e un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) nel quale le iterazioni possono essere eseguite in parallelo ed è possibile configurare le opzioni di ciclo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con il conteggio delle iterazioni (<xref:System.Int32>) come parametro.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come annullare un ciclo parallelo:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con indici a 64 bit nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i seguenti parametri: il conteggio delle iterazioni (<xref:System.Int64>) e un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metodo con un <xref:System.Threading.Tasks.ParallelOptions> oggetto:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con indici a 64 bit in cui è possibile eseguire le iterazioni in parallelo e configurare le opzioni del ciclo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Supporta gli indici a 64 bit. Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con il conteggio delle iterazioni (<xref:System.Int64>) come parametro.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare <xref:System.Threading.Tasks.ParallelOptions> per specificare un'utilità di pianificazione di attività personalizzato:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con dati locali del thread nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i seguenti parametri: il conteggio delle iterazioni (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni eseguite sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` chiamate su ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più attività; Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
 Per un esempio che usa questo metodo, vedere [procedura: scrivere un ciclo Parallel. for con variabili Thread-Local](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con indici a 64 bit e dati locali del thread nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i seguenti parametri: il conteggio delle iterazioni (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni eseguite per la stessa attività.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` chiamate su ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più attività; Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
 Per un esempio che usa questo metodo, vedere [procedura: scrivere un ciclo Parallel. for con variabili Thread-Local](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con dati locali del thread nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i seguenti parametri: il conteggio delle iterazioni (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni eseguite per la stessa attività.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` chiamate su ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più thread. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 L'esempio seguente usa le variabili thread-local per calcolare la somma dei risultati di molte operazioni di lunga durate. In questo esempio consente di limitare il grado di parallelismo a quattro.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localFinally" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni thread.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni thread.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con indici a 64 bit e dati locali del thread nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i seguenti parametri: il conteggio delle iterazioni (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni eseguite sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni thread che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuno di tali thread. Questi stati iniziali vengono passati al primo `body` chiamate in ogni thread. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni thread restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni thread per eseguire un'azione finale sullo stato locale di ogni thread. Questo delegato può essere chiamato simultaneamente su più thread. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localFinally" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each " /> in Visual Basic) in cui le iterazioni possono essere eseguite in parallelo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi in <c>origine</c>.</typeparam>
        <param name="source">Oggetto Partitioner ordinabile contenente l'origine dati originale.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene fornito per scenari in cui si desidera sostituire l'impostazione predefinita lo schema di partizionamento. Ad esempio corpi di ciclo di dimensioni ridotte potrebbero risultare utile partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner ordinabile <paramref name="source" /> restituisce <see langword="false" />.  -oppure- La proprietà <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> nel partitioner ordinabile di origine restituisce <see langword="false" />.  -oppure- Qualsiasi metodo nel partitioner ordinabile di origine restituisce <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi in <c>origine</c>.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene fornito per scenari in cui si desidera sostituire l'impostazione predefinita lo schema di partizionamento. Ad esempio corpi di ciclo di dimensioni ridotte potrebbero risultare utile partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner <paramref name="source" /> restituisce <see langword="false" />.  -oppure- Un metodo nel partitioner <paramref name="source" /> restituisce <see langword="null" />.  -oppure- Il metodo <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> nel partitioner <paramref name="source" /> non restituisce il numero corretto di partizioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi in <c>origine</c>.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> in cui le iterazioni possono essere eseguite in parallelo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene fornito per scenari in cui si desidera sostituire l'impostazione predefinita lo schema di partizionamento. Ad esempio corpi di ciclo di dimensioni ridotte potrebbero risultare utile partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come implementare un partitioner intervallo per l'utilizzo con <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner <paramref name="source" /> restituisce <see langword="false" />.  -oppure- Eccezione generata quando qualsiasi metodo del partitioner <paramref name="source" /> restituisce <see langword="null" />.  -oppure- Il metodo <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> nel partitioner <paramref name="source" /> non restituisce il numero corretto di partizioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con indici a 64 bit su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i seguenti parametri: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e l'indice dell'elemento corrente (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i seguenti parametri: l'elemento corrente e un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.IEnumerable" /> in cui le iterazioni possono essere eseguite in parallelo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con l'elemento corrente come parametro.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> metodo per contare il numero di caratteri diversi da spazi in un file di testo e le vocali. In questo caso, il <xref:System.Threading.Tasks.ParallelLoopResult> valore restituito dal metodo viene ignorato. Si noti che, poiché le operazioni possono essere eseguiti in parallelo, è necessario assicurarsi che si incrementa le variabili di contatore è un'operazione atomica, e che più thread non tentare di accedere alle variabili di contatore contemporaneamente. A tale scopo, nell'esempio viene utilizzata la `lock` istruzione (in c#) e il `SyncLock` istruzione (in Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi in <c>origine</c>.</typeparam>
        <param name="source">Oggetto Partitioner ordinabile contenente l'origine dati originale.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene fornito per scenari in cui si desidera sostituire l'impostazione predefinita lo schema di partizionamento. Ad esempio corpi di ciclo di dimensioni ridotte potrebbero risultare utile partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner ordinabile <paramref name="source" /> restituisce <see langword="false" />.  -oppure- La proprietà <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> nel partitioner ordinabile <paramref name="source" /> restituisce <see langword="false" />.  -oppure- Eccezione generata quando qualsiasi metodo nell'oggetto partitioner ordinabile <paramref name="source" /> restituisce <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi in <c>origine</c>.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene fornito per scenari in cui si desidera sostituire l'impostazione predefinita lo schema di partizionamento. Ad esempio corpi di ciclo di dimensioni ridotte potrebbero risultare utile partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner <paramref name="source" /> restituisce <see langword="false" />.  -oppure- Eccezione generata quando qualsiasi metodo del partitioner <paramref name="source" /> restituisce <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi in <c>origine</c>.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> nel quale le iterazioni possono essere eseguite in parallelo ed è possibile configurare le opzioni di ciclo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene fornito per scenari in cui si desidera sostituire l'impostazione predefinita lo schema di partizionamento. Ad esempio corpi di ciclo di dimensioni ridotte potrebbero risultare utile partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner <paramref name="source" /> restituisce <see langword="false" />.  -oppure- Eccezione generata quando qualsiasi metodo del partitioner <paramref name="source" /> restituisce <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con indici a 64 bit su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i seguenti parametri: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e l'indice dell'elemento corrente (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i seguenti parametri: l'elemento corrente e un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo ed è possibile configurare le opzioni di ciclo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con l'elemento corrente come parametro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi in <c>origine</c>.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Oggetto Partitioner ordinabile contenente l'origine dati originale.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene fornito per scenari in cui si desidera sostituire l'impostazione predefinita lo schema di partizionamento. Ad esempio corpi di ciclo di dimensioni ridotte potrebbero risultare utile partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodo prevede partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` chiamate su ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più attività; Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> in <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> restituisce <see langword="false" /> oppure il partitioner restituisce partizioni <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi in <c>origine</c>.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene fornito per scenari in cui si desidera sostituire l'impostazione predefinita lo schema di partizionamento. Ad esempio corpi di ciclo di dimensioni ridotte potrebbero risultare utile partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodo prevede partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Il `localInit` delegato viene richiamato una volta per ogni thread che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` chiamate su ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più attività; Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> in <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> restituisce <see langword="false" /> oppure il partitioner restituisce partizioni <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i seguenti parametri: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo, indice dell'elemento corrente (<xref:System.Int64>) e uno stato locale che può essere condiviso fra le iterazioni eseguite sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` chiamate su ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più attività; Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i seguenti parametri: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni eseguite sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` chiamate su ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni thread per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più attività; Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare un <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodo con lo stato locale:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi in <c>origine</c>.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Oggetto Partitioner ordinabile contenente l'origine dati originale.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con indici a 64 bit e dati locali del thread su un oggetto <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene fornito per scenari in cui si desidera sostituire l'impostazione predefinita lo schema di partizionamento. Ad esempio corpi di ciclo di dimensioni ridotte potrebbero risultare utile partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodo prevede partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` chiamate su ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni thread restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più attività; Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> o <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> in <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> restituisce <see langword="false" /> oppure il partitioner restituisce partizioni <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Il tipo degli elementi in <c>origine</c>.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene fornito per scenari in cui si desidera sostituire l'impostazione predefinita lo schema di partizionamento. Ad esempio corpi di ciclo di dimensioni ridotte potrebbero risultare utile partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodo prevede partitioner personalizzati per supportare il partizionamento dinamico. Questo overload viene fornito per scenari con corpi di ciclo di dimensioni ridotte che potrebbero risultare utile eseguire il partizionamento range statico. I partitioner devono supportare le partizioni dinamiche.  Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` chiamate su ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più attività; Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> in <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> restituisce <see langword="false" /> oppure il partitioner restituisce partizioni <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread e indici a 64 bit su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i seguenti parametri: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo, indice dell'elemento corrente (<xref:System.Int64>) e uno stato locale che può essere condiviso fra le iterazioni eseguite sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` chiamate su ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni thread per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più attività; Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i seguenti parametri: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni eseguite sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` chiamate su ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla chiamata corpo successivo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato per il `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni thread per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più attività; Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> (metodo), possono utilizzare più attività rispetto a thread in base alla durata della propria esecuzione come completato le attività esistenti e vengono sostituiti dalle nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che il ciclo del servizio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="body" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localInit" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue ognuna delle azioni fornite, eventualmente in parallelo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">Matrice di <see cref="T:System.Action" /> da eseguire.</param>
        <summary>Esegue ognuna delle azioni fornite, eventualmente in parallelo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per eseguire un set di operazioni, potenzialmente in parallelo.  
  
 L'ordine con cui eseguire le operazioni o se vengono eseguite in parallelo viene resa alcuna garanzia. Questo metodo non restituisce fino a quando non è stato di tutte le operazioni fornite completato, indipendentemente dal fatto completamento si verifica a causa di terminazione normale o eccezionale.  
  
 Per altre informazioni, vedere [Procedura: utilizzare Parallel.Invoke per eseguire operazioni in parallelo](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare il <xref:System.Threading.Tasks.Parallel.Invoke%2A> metodo con altri metodi, anonimi delegati ed espressioni lambda.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="actions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione generata quando qualsiasi azione nella matrice <paramref name="actions" /> genera un'eccezione.</exception>
        <exception cref="T:System.ArgumentException">La matrice di <paramref name="actions" /> contiene un elemento <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="actions">Matrice di azioni da eseguire.</param>
        <summary>Esegue ciascuna delle azioni fornite, possibilmente in parallelo, a meno che l'operazione non venga annullata dall'utente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per eseguire un set di operazioni, potenzialmente in parallelo. Il token di annullamento passato con la <xref:System.Threading.Tasks.ParallelOptions> struttura consente al chiamante di annullare l'intera operazione. Per altre informazioni, vedere [Annullamento in thread gestiti](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
 L'ordine con cui eseguire le operazioni o se vengono eseguite in parallelo viene resa alcuna garanzia. Questo metodo non restituisce fino a quando non è stato di tutte le operazioni fornite completato, indipendentemente dal fatto completamento si verifica a causa di terminazione normale o eccezionale.  
  
 Per altre informazioni, vedere [Procedura: utilizzare Parallel.Invoke per eseguire operazioni in parallelo](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'oggetto <paramref name="parallelOptions" /> è impostato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="actions" /> è <see langword="null" />.  -oppure- L'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione generata quando qualsiasi azione nella matrice <paramref name="actions" /> genera un'eccezione.</exception>
        <exception cref="T:System.ArgumentException">La matrice di <paramref name="actions" /> contiene un elemento <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
      </Docs>
    </Member>
  </Members>
</Type>