<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9400e38d0e86f78825a1539468c98397e83c3420" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52236283" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce supporto per aree e cicli in parallelo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Tasks.Parallel> classe fornisce sostituzioni parallela di dati basato sulla libreria per le operazioni comuni quali cicli, per ogni cicli e l'esecuzione di un set di istruzioni.  
  
   
  
## Examples  
 Questo esempio illustra diversi approcci all'implementazione di un ciclo parallelo tramite più costrutti del linguaggio.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tutti i membri pubblici e protetti di <see cref="T:System.Threading.Tasks.Parallel" /> sono thread-safe e possono essere utilizzati contemporaneamente da più thread.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md">Parallelismo dei dati (Task Parallel Library)</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Esempi di programmazione parallela con .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) in cui le iterazioni possono essere eseguite in parallelo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con due argomenti:  
  
-   Un <xref:System.Int32> valore che rappresenta il conteggio delle iterazioni.  
  
-   Oggetto <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere utilizzata per uscire dal ciclo in modo anomalo. Il <xref:System.Threading.Tasks.ParallelLoopState> oggetto viene creato dal compilatore; non è possibile creare un'istanza nel codice utente.  
  
 Chiama il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo informa il `for` operazione che le iterazioni successive a quella corrente non sono necessario eseguire. Tuttavia, tutte le iterazioni prima di quella corrente uno sarà ancora da eseguire se è già stato fatto.  
  
 Pertanto, la chiamata <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> è simile all'uso di un'operazione di interruzione all'interno di un tradizionale `for` ciclo in un linguaggio come c#, ma non è un sostituto perfetto: ad esempio, non c'è garanzia che le iterazioni successive a quella corrente verranno sicuramente non eseguire.  
  
 Se l'esecuzione di tutte le iterazioni prima di quello corrente non è necessario, usare il <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo invece di usare <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. La chiamata <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa il `for` ciclo che può abbandonare tutte le rimanenti iterazioni, indipendentemente dal fatto che siano connessi prima o dopo l'iterazione corrente, in quanto tutte le necessarie lavoro verrà sono già stato completato. Tuttavia, come con <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, non vi sono garanzie relative alle altre iterazioni non verranno eseguiti.  
  
 Se è stato interrotta, a un ciclo di <xref:System.Threading.Tasks.ParallelLoopResult> struttura restituita conterrà le informazioni relative al completamento del ciclo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita fino a 100 iterazioni di un ciclo in parallelo. Ogni iterazione viene sospeso per un intervallo casuale compreso tra 1 e 1.000 millisecondi. Un valore generato casualmente determina a quali iterazione del ciclo di <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> viene chiamato il metodo. Come l'output illustrato nell'esempio, non ci sono iterazioni il cui indice è maggiore di <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> inizio del valore proprietà dopo la chiamata al <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> (metodo).  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Poiché sono ancora soggetti a essere in esecuzione al termine delle iterazioni del ciclo il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> viene chiamato il metodo, le chiamate di ogni iterazione il <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> proprietà da controllare se un'altra iterazione ha chiamato la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> (metodo). Se il valore della proprietà `true`, l'iterazione controlla il valore della <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> proprietà e, se è maggiore del valore di indice dell'iterazione corrente, viene restituito immediatamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) in cui le iterazioni possono essere eseguite in parallelo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con il conteggio delle iterazioni (<xref:System.Int32>) come parametro.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Threading.Tasks.Parallel.For%2A> metodo per chiamate di un delegato che viene generato l'errore byte casuali di 100 valori e calcola la somma.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un loop <see langword="for" /> (<see langword="For" /> in Visual Basic) con gli indici a 64 bit in cui le iterazioni possono eseguire in parallelo e lo stato del loop può essere monitorato e manipolato.</summary>
        <returns>Struttura <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i parametri seguenti: il conteggio delle iterazioni (<xref:System.Int64>) e un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo.  
  
 Chiama il <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metodo informa il `for` operazione che le iterazioni successive a quella corrente non devono essere eseguiti, ma eseguire tutte le iterazioni prima di quello corrente.  
  
 Pertanto, la chiamata di interruzione è simile all'uso di un'operazione di interruzione all'interno di un tradizionale `for` ciclo in un linguaggio come c#, ma non è un sostituto perfetto: ad esempio, non c'è garanzia che le iterazioni dopo quello corrente sicuramente non verrà eseguiti.  
  
 Se l'esecuzione di tutte le iterazioni prima di quello corrente non è necessario, usare il <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metodo invece di usare <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. La chiamata <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa il `for` ciclo che può abbandonare tutte le rimanenti iterazioni, indipendentemente dal fatto che siano connessi prima o dopo l'iterazione corrente, in quanto tutte le necessarie lavoro verrà sono già stato completato. Tuttavia, come con <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, non vi sono garanzie relative alle altre iterazioni non verranno eseguiti.  
  
 Se è stato interrotta, a un ciclo di <xref:System.Threading.Tasks.ParallelLoopResult> struttura restituita conterrà le informazioni relative al completamento del ciclo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con indici a 64 bit in cui le iterazioni possono essere eseguite in parallelo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con il conteggio delle iterazioni (<xref:System.Int64>) come parametro.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i parametri seguenti: il conteggio delle iterazioni (<xref:System.Int32>) e un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) nel quale le iterazioni possono essere eseguite in parallelo ed è possibile configurare le opzioni di ciclo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con il conteggio delle iterazioni (<xref:System.Int32>) come parametro.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come annullare un ciclo parallelo:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con indici a 64 bit nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i parametri seguenti: il conteggio delle iterazioni (<xref:System.Int64>) e un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo viene restituito immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metodo con un <xref:System.Threading.Tasks.ParallelOptions> oggetto:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con indici a 64 bit in cui è possibile eseguire le iterazioni in parallelo e configurare le opzioni del ciclo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Supporta gli indici a 64 bit. Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con il conteggio delle iterazioni (<xref:System.Int64>) come parametro.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare <xref:System.Threading.Tasks.ParallelOptions> per specificare un'utilità di pianificazione di attività personalizzato:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con dati locali del thread nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i parametri seguenti: il conteggio delle iterazioni (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni che vengono eseguite sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato potrebbe essere chiamato simultaneamente su più attività. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
 Per un esempio che usa questo metodo, vedere [procedura: scrivere un ciclo Parallel. for con variabili Thread-Local](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localInit" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con indici a 64 bit e dati locali del thread nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i parametri seguenti: il conteggio delle iterazioni (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni che eseguono la stessa attività.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato potrebbe essere chiamato simultaneamente su più attività. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
 Per un esempio che usa questo metodo, vedere [procedura: scrivere un ciclo Parallel. for con variabili Thread-Local](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localInit" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con dati locali del thread nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i parametri seguenti: il conteggio delle iterazioni (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni che eseguono la stessa attività.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato può essere chiamato simultaneamente su più thread. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
   
  
## Examples  
 L'esempio seguente usa le variabili thread-local per calcolare la somma dei risultati di molte operazioni di lunga durate. In questo esempio consente di limitare il grado di parallelismo a quattro.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localInit" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localFinally" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="fromInclusive">Indice iniziale, incluso.</param>
        <param name="toExclusive">Indice finale, escluso.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni thread.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni thread.</param>
        <summary>Esegue un ciclo <see langword="for" /> (<see langword="For" /> in Visual Basic) con indici a 64 bit e dati locali del thread nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni valore nell'intervallo di iterazione (`fromInclusive`, `toExclusive`). Viene fornito con i parametri seguenti: il conteggio delle iterazioni (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni che vengono eseguite sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni thread che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuno di questi thread. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni thread. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni thread restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni thread per eseguire un'azione finale sullo stato locale di ogni thread. Questo delegato può essere chiamato simultaneamente su più thread. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
 Se `fromInclusive` è maggiore o uguale a `toExclusive`, il metodo restituisce immediatamente senza eseguire alcuna iterazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localInit" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localFinally" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each " /> in Visual Basic) in cui le iterazioni possono essere eseguite in parallelo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nell'oggetto <paramref name="source" />.</typeparam>
        <param name="source">Oggetto Partitioner ordinabile contenente l'origine dati originale.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è disponibile per gli scenari in cui si desidera sostituire il valore predefinito di schema di partizionamento. Ad esempio, i corpi di ciclo di dimensioni ridotte potrebbero trarre vantaggio dal partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede che il partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner ordinabile <paramref name="source" /> restituisce <see langword="false" />.  
  
oppure 
La proprietà <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> nel partitioner ordinabile di origine restituisce <see langword="false" />.  
  
oppure 
Qualsiasi metodo nel partitioner ordinabile di origine restituisce <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nell'oggetto <paramref name="source" />.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è disponibile per gli scenari in cui si desidera sostituire il valore predefinito di schema di partizionamento. Ad esempio, i corpi di ciclo di dimensioni ridotte potrebbero trarre vantaggio dal partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede che il partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner <paramref name="source" /> restituisce <see langword="false" />.  
  
oppure 
Un metodo nel partitioner <paramref name="source" /> restituisce <see langword="null" />.  
  
oppure 
Il metodo <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> nel partitioner <paramref name="source" /> non restituisce il numero corretto di partizioni.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nell'oggetto <paramref name="source" />.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> in cui le iterazioni possono essere eseguite in parallelo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è disponibile per gli scenari in cui si desidera sostituire il valore predefinito di schema di partizionamento. Ad esempio, i corpi di ciclo di dimensioni ridotte potrebbero trarre vantaggio dal partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede che il partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come implementare un partitioner dell'intervallo per l'uso con <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner <paramref name="source" /> restituisce <see langword="false" />.  
  
oppure 
Eccezione generata quando qualsiasi metodo del partitioner <paramref name="source" /> restituisce <see langword="null" />.  
  
oppure 
Il metodo <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> nel partitioner <paramref name="source" /> non restituisce il numero corretto di partizioni.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con indici a 64 bit su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i parametri seguenti: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e l'indice dell'elemento corrente (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i parametri seguenti: l'elemento corrente e un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.IEnumerable" /> in cui le iterazioni possono essere eseguite in parallelo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con l'elemento corrente come parametro.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> metodo contare il numero di caratteri diversi dallo spazio vuoto in un file di testo e vocali. In questo caso, il <xref:System.Threading.Tasks.ParallelLoopResult> valore restituito dal metodo viene ignorato. Si noti che, poiché le operazioni possono essere eseguiti in parallelo, è necessario assicurarsi che le variabili di contatore incrementato è un'operazione atomica, e che più thread non tentare di accedere contemporaneamente alle variabili di contatore. A tale scopo, l'esempio Usa la `lock` istruzione (in c#) e il `SyncLock` istruzione (in Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nell'oggetto <paramref name="source" />.</typeparam>
        <param name="source">Oggetto Partitioner ordinabile contenente l'origine dati originale.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è disponibile per gli scenari in cui si desidera sostituire il valore predefinito di schema di partizionamento. Ad esempio, i corpi di ciclo di dimensioni ridotte potrebbero trarre vantaggio dal partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede che il partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner ordinabile <paramref name="source" /> restituisce <see langword="false" />.  
  
oppure 
La proprietà <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> nel partitioner ordinabile <paramref name="source" /> restituisce <see langword="false" />.  
  
oppure 
Eccezione generata quando qualsiasi metodo nell'oggetto partitioner ordinabile <paramref name="source" /> restituisce <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nell'oggetto <paramref name="source" />.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è disponibile per gli scenari in cui si desidera sostituire il valore predefinito di schema di partizionamento. Ad esempio, i corpi di ciclo di dimensioni ridotte potrebbero trarre vantaggio dal partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede che il partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner <paramref name="source" /> restituisce <see langword="false" />.  
  
oppure 
Eccezione generata quando qualsiasi metodo del partitioner <paramref name="source" /> restituisce <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nell'oggetto <paramref name="source" />.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> nel quale le iterazioni possono essere eseguite in parallelo ed è possibile configurare le opzioni di ciclo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è disponibile per gli scenari in cui si desidera sostituire il valore predefinito di schema di partizionamento. Ad esempio, i corpi di ciclo di dimensioni ridotte potrebbero trarre vantaggio dal partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo prevede che il partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> nel partitioner <paramref name="source" /> restituisce <see langword="false" />.  
  
oppure 
Eccezione generata quando qualsiasi metodo del partitioner <paramref name="source" /> restituisce <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con indici a 64 bit su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i parametri seguenti: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e l'indice dell'elemento corrente (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i parametri seguenti: l'elemento corrente e un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo ed è possibile configurare le opzioni di ciclo.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con l'elemento corrente come parametro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nell'oggetto <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Oggetto Partitioner ordinabile contenente l'origine dati originale.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è disponibile per gli scenari in cui si desidera sostituire il valore predefinito di schema di partizionamento. Ad esempio, i corpi di ciclo di dimensioni ridotte potrebbero trarre vantaggio dal partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodo prevede che il partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato potrebbe essere chiamato simultaneamente su più attività. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localInit" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> in <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> restituisce <see langword="false" /> oppure il partitioner restituisce partizioni <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nell'oggetto <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è disponibile per gli scenari in cui si desidera sostituire il valore predefinito di schema di partizionamento. Ad esempio, i corpi di ciclo di dimensioni ridotte potrebbero trarre vantaggio dal partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodo prevede che il partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Il `localInit` delegato viene richiamato una volta per ogni thread che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato potrebbe essere chiamato simultaneamente su più attività. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localInit" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> in <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> restituisce <see langword="false" /> oppure il partitioner restituisce partizioni <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i parametri seguenti: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo, indice dell'elemento corrente (<xref:System.Int64>) e uno stato locale che può essere condiviso fra le iterazioni che eseguono sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato potrebbe essere chiamato simultaneamente su più attività. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localInit" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i parametri seguenti: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni che vengono eseguite sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni thread per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato potrebbe essere chiamato simultaneamente su più attività. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare un <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodo con lo stato locale:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localInit" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nell'oggetto <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Oggetto Partitioner ordinabile contenente l'origine dati originale.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con indici a 64 bit e dati locali del thread su un oggetto <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è disponibile per gli scenari in cui si desidera sostituire il valore predefinito di schema di partizionamento. Ad esempio, i corpi di ciclo di dimensioni ridotte potrebbero trarre vantaggio dal partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodo prevede che il partitioner personalizzati per supportare il partizionamento dinamico. Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni thread restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato potrebbe essere chiamato simultaneamente su più attività. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
L'argomento <paramref name="localInit" /> o <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> in <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> restituisce <see langword="false" /> oppure il partitioner restituisce partizioni <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo degli elementi nell'oggetto <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Oggetto Partitioner contenente l'origine dati originale.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.Concurrent.Partitioner" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è disponibile per gli scenari in cui si desidera sostituire il valore predefinito di schema di partizionamento. Ad esempio, i corpi di ciclo di dimensioni ridotte potrebbero trarre vantaggio dal partizionamento dell'intervallo. Il <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodo prevede che il partitioner personalizzati per supportare il partizionamento dinamico. Questo overload è disponibile per gli scenari con corpi di ciclo di dimensioni ridotte che potrebbero trarre vantaggio dal partizionamento per intervalli statici. I partitioner devono supportare partizioni dinamiche.  Per altre informazioni, vedere [partitioner personalizzati per PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [procedura: implementare partizioni dinamiche](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni attività per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato potrebbe essere chiamato simultaneamente su più attività. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localInit" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> in <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> restituisce <see langword="false" /> oppure il partitioner restituisce partizioni <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread e indici a 64 bit su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i parametri seguenti: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo, indice dell'elemento corrente (<xref:System.Int64>) e uno stato locale che può essere condiviso fra le iterazioni che eseguono sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni thread per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato potrebbe essere chiamato simultaneamente su più attività. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localInit" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo di dati nell'origine.</typeparam>
        <typeparam name="TLocal">Tipo dei dati locali del thread.</typeparam>
        <param name="source">Origine dati enumerabile.</param>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="localInit">Delegato della funzione che restituisce lo stato iniziale dei dati locali per ogni attività.</param>
        <param name="body">Delegato richiamato una volta per iterazione.</param>
        <param name="localFinally">Delegato che esegue un'azione finale sullo stato locale di ogni attività.</param>
        <summary>Esegue un'operazione <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con dati locali del thread su un oggetto <see cref="T:System.Collections.IEnumerable" /> nel quale le iterazioni possono essere eseguite in parallelo, è possibile configurare le opzioni di ciclo e lo stato del ciclo può essere monitorato e modificato.</summary>
        <returns>Struttura che contiene informazioni sulla parte di ciclo completata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `body` delegato viene richiamato una volta per ogni elemento di `source` enumerabile. Viene fornito con i parametri seguenti: l'elemento corrente, un <xref:System.Threading.Tasks.ParallelLoopState> istanza che può essere usato per uscire dal ciclo in modo anomalo e uno stato locale che può essere condiviso fra le iterazioni che vengono eseguite sullo stesso thread.  
  
 Il `localInit` delegato viene richiamato una volta per ogni attività che partecipa all'esecuzione del ciclo e restituisce lo stato locale iniziale per ognuna di queste attività. Questi stati iniziali vengono passati al primo `body` le chiamate in ogni attività. Quindi, ogni chiamata successiva del corpo restituisce un valore di stato probabilmente modificato che viene passato alla successiva chiamata del corpo. Infine, l'ultima chiamata corpo su ogni attività restituisce un valore di stato che viene passato al `localFinally` delegare. Il `localFinally` delegato viene richiamato una volta per ogni thread per eseguire un'azione finale sullo stato locale di ogni attività. Questo delegato potrebbe essere chiamato simultaneamente su più attività. Pertanto, è necessario sincronizzare l'accesso a tutte le variabili condivise.  
  
 Il <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metodo potrebbe usare più attività di thread in base alla durata dell'esecuzione, come le attività esistenti completate e vengono sostituiti da nuove attività. In questo modo sottostante <xref:System.Threading.Tasks.TaskScheduler> oggetto la possibilità di aggiungere, modificare o rimuovere i thread che gestiscono il ciclo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="source" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="body" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localInit" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="localFinally" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'argomento <paramref name="parallelOptions" /> è annullato.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
        <exception cref="T:System.AggregateException">Eccezione che contiene tutte le eccezioni singole generate su tutti i thread.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Cicli paralleli</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue ognuna delle azioni fornite, eventualmente in parallelo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">Matrice di <see cref="T:System.Action" /> da eseguire.</param>
        <summary>Esegue ognuna delle azioni fornite, eventualmente in parallelo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per eseguire una serie di operazioni, potenzialmente in parallelo.  
  
 Non sono garanzie sull'ordine in cui eseguire le operazioni o se vengono eseguite in parallelo. Questo metodo non restituisce fino a quando ognuna delle operazioni fornite è completata, indipendentemente dal fatto che il completamento si verifica a causa di chiusura normale o insolita.  
  
 Per altre informazioni, vedere [Procedura: utilizzare Parallel.Invoke per eseguire operazioni in parallelo](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
   
  
## Examples  
 In questo esempio viene illustrato come utilizzare il <xref:System.Threading.Tasks.Parallel.Invoke%2A> metodo con altri metodi, delegati anonimi ed espressioni lambda.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="actions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione generata quando qualsiasi azione nella matrice <paramref name="actions" /> genera un'eccezione.</exception>
        <exception cref="T:System.ArgumentException">La matrice di <paramref name="actions" /> contiene un elemento <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">Oggetto che configura il comportamento di questa operazione.</param>
        <param name="actions">Matrice di azioni da eseguire.</param>
        <summary>Esegue ciascuna delle azioni fornite, possibilmente in parallelo, a meno che l'operazione non venga annullata dall'utente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per eseguire una serie di operazioni, potenzialmente in parallelo. Il token di annullamento passato con la <xref:System.Threading.Tasks.ParallelOptions> struttura consente al chiamante annullare l'intera operazione. Per altre informazioni, vedere [Annullamento in thread gestiti](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
 Non sono garanzie sull'ordine in cui eseguire le operazioni o se vengono eseguite in parallelo. Questo metodo non restituisce fino a quando ognuna delle operazioni fornite è completata, indipendentemente dal fatto che il completamento si verifica a causa di chiusura normale o insolita.  
  
 Per altre informazioni, vedere [Procedura: utilizzare Parallel.Invoke per eseguire operazioni in parallelo](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L'oggetto <see cref="T:System.Threading.CancellationToken" /> nell'oggetto <paramref name="parallelOptions" /> è impostato.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore dell'argomento <paramref name="actions" /> è <see langword="null" />.  
  
oppure 
Il valore dell'argomento <paramref name="parallelOptions" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Eccezione generata quando qualsiasi azione nella matrice <paramref name="actions" /> genera un'eccezione.</exception>
        <exception cref="T:System.ArgumentException">La matrice di <paramref name="actions" /> contiene un elemento <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.CancellationTokenSource" /> associato all'oggetto <see cref="T:System.Threading.CancellationToken" /> nel <paramref name="parallelOptions" /> è stato eliminato.</exception>
      </Docs>
    </Member>
  </Members>
</Type>