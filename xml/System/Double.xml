<Type Name="Double" FullName="System.Double">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c15da40cd4c6f9918c0ee1953e5b3d059b86e2bb" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34255141" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un numero a virgola mobile a precisione doppia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double> tipo di valore rappresenta un numero a 64 bit e con precisione doppia con valori compresi tra 1, 79769313486232e308 negativo e 1, 79769313486232e308 positivo, nonché zero positivo o negativo, <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>e non un numero (<xref:System.Double.NaN>). Serve per rappresentare i valori che sono molto grande (ad esempio le distanze tra pianeti o galassie) o ed estremamente basso (massa molecolare della materia in kg) e che spesso sono imprecisa (ad esempio la distanza da terra in un altro sistema solare), il <xref:System.Double> tipo è conforme a IEC 60559: 1989 (IEEE 754) per i calcoli a virgola mobile binario.  
  
 Questo argomento include le sezioni seguenti:  
  
-   [Precisione e la rappresentazione a virgola mobile](#Precision)  
  
-   [La verifica dell'uguaglianza](#Equality)  
  
-   [Le eccezioni e i valori a virgola mobile](#Exceptions)  
  
-   [Conversioni di tipi e la struttura Double](#Conversions)  
  
-   [Funzionalità a virgola mobile](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Precisione e la rappresentazione a virgola mobile  
 Il <xref:System.Double> tipo di dati archivia i valori a virgola mobile a precisione doppia in un formato binario a 64 bit, come illustrato nella tabella seguente:  
  
|Parte|Bit|  
|----------|----------|  
|Significando o mantissa|0-51|  
|Esponente|52-62|  
|Sign (0 = positivi, 1 = negativo)|63|  
  
 Analogamente a come frazioni decimali sono in grado esattamente rappresentano alcuni valori frazionari (ad esempio 1/3 o <xref:System.Math.PI?displayProperty=nameWithType>), frazioni binarie sono in grado di rappresentare alcuni valori frazionari. Ad esempio, 1/10, che corrisponde esattamente a.1 come frazione decimale, è rappresentato da.001100110011 come frazione binaria con il modello "0011" ripetuto all'infinito. In questo caso, il valore a virgola mobile fornisce una rappresentazione imprecisa del numero che rappresenta. Eseguire altre operazioni matematiche sul valore a virgola mobile originale spesso tende ad aumentare la mancanza di precisione. Ad esempio, se è confrontare il risultato della moltiplicazione.1 da 10 e aggiunta.1 a.1 nove volte, è che, inoltre, perché è coinvolto otto altre operazioni, ha prodotto il risultato meno preciso. Si noti che questa disparità è evidente solo se i due, viene visualizzato <xref:System.Double> valori mediante "R" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md), se necessario Visualizza tutte le 17 cifre di precisione supportato dal <xref:System.Double> tipo.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Poiché alcuni numeri non possono essere rappresentati esattamente come valori binari frazionari, numeri a virgola mobile possono solo approssimativi numeri reali.  
  
 Tutti i numeri a virgola mobile hanno anche un numero limitato di cifre significative, che determina anche l'accuratezza è un valore a virgola mobile all'incirca un numero reale.   Oggetto <xref:System.Double> valore ha fino a 15 cifre decimali di precisione, anche se internamente viene gestito un massimo di 17 cifre. Ciò significa che alcune operazioni a virgola mobile potrebbero non essere la precisione per modificare mobile valore punto. Nell'esempio seguente viene illustrato questo concetto. Definisce un valore a virgola mobile molto grande e quindi aggiunge il prodotto di <xref:System.Double.Epsilon?displayProperty=nameWithType> e quadrillion uno ad esso. Il prodotto, tuttavia, è troppo piccolo per modificare il valore a virgola mobile originale. La cifra meno significativa è millesimi, mentre la cifra più significativa all'interno del prodotto è 1<sup>-312</sup>.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 Precisione limitata di un numero a virgola mobile ha diverse conseguenze:  
  
-   Due numeri a virgola mobile apparentemente uguali per una particolare precisione potrebbero non risultare uguali perché cifre meno significative sono diverse. Nell'esempio seguente, una serie di numeri vengono sommati e il totale viene confrontato con il totale previsto. Anche se sembrano essere lo stesso, una chiamata a due valori di `Equals` metodo indica che non lo siano.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     Se si modificano gli elementi di formato nel <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> from dell'istruzione `{0}` e `{1}` a `{0:R}` e `{1:R}` per visualizzare tutte le cifre significative delle due <xref:System.Double> valori, risulta chiaro che i due valori sono uguali perché di una perdita di precisione durante le operazioni di aggiunta. In questo caso, è possibile risolvere il problema chiamando il <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> metodo per arrotondare il <xref:System.Double> valori alla precisione desiderato prima di eseguire il confronto.  
  
-   Un'operazione matematica o di confronto che utilizza un numero a virgola mobile potrebbe non restituire lo stesso risultato se viene utilizzato un numero decimale, perché il numero a virgola mobile binario non può essere uguale a numero decimale. Un esempio precedente illustrato questo visualizzando il risultato della moltiplicazione.1 da 10 e l'aggiunta di.1 volte.  
  
     Quando la precisione numerica operazioni con valori frazionari è importante, è possibile utilizzare il <xref:System.Decimal> anziché <xref:System.Double> tipo. Quando la precisione numerica operazioni con i valori integrali oltre l'intervallo del <xref:System.Int64> o <xref:System.UInt64> tipi è importante, utilizzare il <xref:System.Numerics.BigInteger> tipo.  
  
-   Un valore potrebbe non completa il round trip se è interessato un numero a virgola mobile. Un valore viene definito per il round trip se un'operazione converte un numero a virgola mobile originale in un altro formato, un'operazione inversa trasforma il formato convertito nuovamente in un numero a virgola mobile e il numero a virgola mobile finale non è uguale all'istanza originale numero a virgola mobile. Il round trip potrebbe non riuscire perché uno o più cifre meno significative vengono perse o modificate in una conversione. Nell'esempio seguente, tre <xref:System.Double> valori vengono convertiti in stringhe e salvati in un file. Come illustrato nell'output, tuttavia, anche se i valori vengono visualizzati in modo identico, i valori ripristinati non sono uguali ai valori originali.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     In questo caso, i valori possono essere correttamente sottoposto a round-trip utilizzando "G17" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md) per mantenere la precisione completa del <xref:System.Double> valori, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  Quando si utilizza un <xref:System.Double> valore, l'identificatore di formato "R" in alcuni casi non riesce a completano il round trip al valore originale. Per garantire che <xref:System.Double> valori completano il round trip, utilizzare l'identificatore di formato "G17".

-   <xref:System.Single> valori hanno una precisione inferiore rispetto a <xref:System.Double> valori. Oggetto <xref:System.Single> valore che viene convertito in un equivalente apparentemente <xref:System.Double> spesso non è uguale al <xref:System.Double> valore a causa delle differenze di precisione. Nell'esempio seguente, il risultato di operazioni di divisione identici viene assegnato a un <xref:System.Double> e <xref:System.Single> valore. Dopo il <xref:System.Single> viene eseguito il cast di valore a un <xref:System.Double>, un confronto tra i due valori mostra che non sono uguali.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Per evitare questo problema, utilizzare il <xref:System.Double> al posto di <xref:System.Single> tipo di dati o utilizzare il <xref:System.Math.Round%2A> metodo in modo che entrambi i valori hanno la stessa precisione.  
  
 Inoltre, il risultato di operazioni aritmetiche e di assegnazione con <xref:System.Double> valori possono differire leggermente a seconda della piattaforma a causa della perdita di precisione del <xref:System.Double> tipo. Ad esempio, il risultato dell'assegnazione di un valore letterale <xref:System.Double> valore può essere diverso nelle versioni a 32 e 64 bit di .NET Framework. Nell'esempio seguente viene illustrata questa differenza quando il valore letterale valore - 4.42330604244772 e-305 e una variabile il cui valore è - 4.42330604244772 e-305 vengono assegnati a un <xref:System.Double> variabile. Si noti che il risultato di <xref:System.Double.Parse%28System.String%29> metodo in questo caso non subisce una perdita di precisione.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>La verifica dell'uguaglianza  
 Per essere considerati uguali, due <xref:System.Double> i valori devono rappresentare valori identici. Tuttavia, a causa delle differenze tra i valori di precisione o a causa di una perdita di precisione da uno o entrambi valori, valori a virgola mobile che devono essere identici spesso risultano per essere uguali a causa delle differenze nelle cifre meno significative. Di conseguenza, le chiamate al <xref:System.Double.Equals%2A> metodo per determinare se due valori sono uguali oppure chiamate al <xref:System.Double.CompareTo%2A> metodo per determinare la relazione tra due <xref:System.Double> valori, spesso restituire risultati imprevisti. Ciò è evidente nell'esempio seguente, in cui due apparentemente uguali <xref:System.Double> valori risultano per essere uguali in quanto il primo ha 15 cifre di precisione, mentre il secondo è 17.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 I valori calcolati che seguono percorsi del codice diversi e in modi diversi che vengono modificati spesso risultare uguali. Nell'esempio seguente, una <xref:System.Double> valore è al quadrato e quindi la radice quadrata viene calcolata per ripristinare il valore originale. Un secondo <xref:System.Double> viene moltiplicato per 3.51 e al quadrato prima che la radice quadrata del risultato viene diviso per 3.51 per ripristinare il valore originale. Anche se i due valori sembrano identiche, una chiamata al <xref:System.Double.Equals%28System.Double%29> metodo indica che non sono uguali. Utilizzando la stringa di formato standard "R" per restituire una stringa di risultato che visualizza tutte le cifre significative di ogni valore Double indica che il secondo valore è.0000000000001 minore rispetto alla prima.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 Nei casi in cui è probabile che influisce sul risultato di un confronto di una perdita di precisione, è possibile adottare una delle alternative seguenti per la chiamata di <xref:System.Double.Equals%2A> o <xref:System.Double.CompareTo%2A> metodo:  
  
-   Chiamare il <xref:System.Math.Round%2A?displayProperty=nameWithType> metodo per assicurarsi che entrambi i valori hanno la stessa precisione. Nell'esempio seguente viene modificato un esempio precedente per utilizzare questo approccio, in modo che due valori frazionari sono equivalenti.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Si noti tuttavia che il problema di precisione è ancora valida per l'arrotondamento dei valori di punto centrale. Per altre informazioni, vedere il metodo <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Test di uguaglianza approssimativo anziché l'uguaglianza. Ciò che è necessario definire entrambi assoluto quantità mediante il quale i due valori possono differire ma comunque essere uguale o che si definisce un importo relativo mediante il quale il valore più piccolo possibile differente dal valore più grande.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> a volte viene utilizzato come misura della distanza tra due assoluta <xref:System.Double> valori durante il test per verificarne l'uguaglianza.  Tuttavia, <xref:System.Double.Epsilon?displayProperty=nameWithType> misura il valore più piccolo che può essere aggiunto o sottratto da un <xref:System.Double> il cui valore è zero. Per la maggior parte delle positivi e negativi <xref:System.Double> valori, il valore di <xref:System.Double.Epsilon?displayProperty=nameWithType> è troppo piccolo per essere rilevato. Pertanto, tranne per i valori che sono pari a zero, non è consigliabile l'uso nei test di uguaglianza.  
  
     L'esempio seguente usa l'approccio di quest'ultimo per definire un `IsApproximatelyEqual` metodo che verifica la relativa differenza tra due valori. Contrasti anche il risultato di chiamate per il `IsApproximatelyEqual` (metodo) e <xref:System.Double.Equals%28System.Double%29> metodo.  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Le eccezioni e i valori a virgola mobile  
 A differenza delle operazioni con i tipi integrali, che generano eccezioni in caso di overflow o di operazioni non valide, ad esempio divisione per zero, le operazioni con valori a virgola mobile non generano eccezioni. In alternativa, in situazioni eccezionali, il risultato dell'operazione a virgola mobile è zero, un numero infinito positivo, infinito negativo o non è un numero (NaN):  
  
-   Se il risultato di un'operazione a virgola mobile è troppo piccolo per il formato di destinazione, il risultato è zero. Ciò può verificarsi quando vengono moltiplicati due numeri molto piccoli, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   Se la grandezza del risultato dell'operazione a virgola mobile supera l'intervallo del formato di destinazione, il risultato dell'operazione è <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>, come appropriato per il segno del risultato. Il risultato di un'operazione che causa un overflow <xref:System.Double.MaxValue?displayProperty=nameWithType> è <xref:System.Double.PositiveInfinity>e il risultato di un'operazione che causa un overflow <xref:System.Double.MinValue?displayProperty=nameWithType> è <xref:System.Double.NegativeInfinity>, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> anche i risultati da una divisione per zero con un dividendo positivo, e <xref:System.Double.NegativeInfinity> risultante dalla divisione per zero con un dividendo negativo.  
  
-   Se un'operazione a virgola mobile non è valida, il risultato dell'operazione è <xref:System.Double.NaN>. Ad esempio, <xref:System.Double.NaN> risultati delle operazioni seguenti:  
  
    -   Divisione per zero con un dividendo pari a zero. Si noti che gli altri casi di divisione per zero risultati in entrambi <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>.  
  
-   Qualsiasi operazione a virgola mobile con un input non valido. Ad esempio, la chiamata il <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> metodo con un valore negativo restituisce <xref:System.Double.NaN>, come avviene la chiamata di <xref:System.Math.Acos%2A?displayProperty=nameWithType> metodo con un valore maggiore di 1 o meno uno negativo.  
  
-   Qualsiasi operazione con un argomento il cui valore è <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>Conversioni di tipi e la struttura Double  
 Il <xref:System.Double> struttura definiscono tutti gli operatori di conversione esplicita o implicita, invece, le conversioni vengono implementate dal compilatore.  
  
 La conversione del valore di qualsiasi tipo numerico primitivo a un <xref:System.Double> una conversione verso e pertanto non richiede un operatore di cast esplicito o chiamata a un metodo di conversione, a meno che un compilatore richieda in modo esplicito. Ad esempio, il compilatore c# richiede un operatore di cast per le conversioni da <xref:System.Decimal> a <xref:System.Double>, mentre il compilatore Visual Basic non. Nell'esempio seguente converte il valore minimo o massimo di altri tipi numerici primitivi in un <xref:System.Double>.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 Inoltre, il <xref:System.Single> valori <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> convertire a <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, rispettivamente.  
  
 Si noti che la conversione del valore di alcuni tipi numerici a un <xref:System.Double> valore può comportare una perdita di precisione. Come illustrato nell'esempio, una perdita di precisione è possibile durante la conversione <xref:System.Decimal>, <xref:System.Int64>, <xref:System.Single>, e <xref:System.UInt64> valori <xref:System.Double> valori.  
  
 La conversione di un <xref:System.Double> valore in un valore di qualsiasi altro tipo di dati numerico primitivo è una conversione di narrowing e richiede un operatore di cast (in c#), un metodo di conversione (in Visual Basic) o una chiamata a un <xref:System.Convert> metodo. Valori non compresi nell'intervallo del tipo di dati di destinazione, che sono definiti dal tipo di destinazione `MinValue` e `MaxValue` proprietà, si comportano come illustrato nella tabella seguente.  
  
|Tipo di destinazione|Risultato|  
|-----------------|------------|  
|Qualsiasi tipo integrale|Un <xref:System.OverflowException> eccezione se la conversione viene eseguita in un contesto controllato.<br /><br /> Se la conversione viene eseguita in un contesto non verificato (impostazione predefinita in c#), l'operazione di conversione ha esito positivo ma il valore causa un overflow.|  
|<xref:System.Decimal>|Eccezione <xref:System.OverflowException>.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> per i valori negativi.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> per i valori positivi.|  
  
 Inoltre, <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> generano un <xref:System.OverflowException> per le conversioni di valori integer in un contesto verificato, ma questi overflow di valori quando convertiti in numeri interi in un contesto non verificato. Per le conversioni in <xref:System.Decimal>, generano sempre un <xref:System.OverflowException>. Per le conversioni in <xref:System.Single>, la conversione in <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, rispettivamente.  
  
 Tenere presente che una perdita di precisione può produrre tramite la conversione di un <xref:System.Double> valore a un altro tipo numerico. Nel caso di conversione non integrale <xref:System.Double> valori, come illustrato nell'output dell'esempio, il componente frazionario viene perso quando il <xref:System.Double> valore viene arrotondato (come in Visual Basic) o troncati (come in c#). Per le conversioni in <xref:System.Decimal> e <xref:System.Single> valori, il <xref:System.Double> valore potrebbe non essere una rappresentazione precisa nel tipo di dati di destinazione.  
  
 Nell'esempio seguente converte un numero di <xref:System.Double> valori da diversi altri tipi numerici. Le conversioni si verificano in un contesto controllato in Visual Basic (impostazione predefinita) e in c# (perché il [selezionata](~/docs/csharp/language-reference/keywords/checked.md) parola chiave). L'output dell'esempio viene illustrato il risultato per le conversioni in entrambi un selezionato un contesto non verificato. È possibile eseguire conversioni in un contesto non controllato in Visual Basic per la compilazione con il `/removeintchecks+` opzione del compilatore e in c# Commentando il `checked` istruzione.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 Per ulteriori informazioni sulla conversione dei tipi numerici, vedere [conversione di tipi in .NET Framework](~/docs/standard/base-types/type-conversion.md) e [tabelle di conversione dei tipi](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Funzionalità a virgola mobile  
 Il <xref:System.Double> struttura e i tipi correlati forniscono metodi per eseguire le operazioni nelle aree seguenti:  
  
-   **Confronto di valori**. È possibile chiamare il <xref:System.Double.Equals%2A> metodo per determinare se due <xref:System.Double> valori sono uguali, o <xref:System.Double.CompareTo%2A> metodo per determinare la relazione tra due valori.  
  
     Il <xref:System.Double> struttura supporta inoltre un set completo di operatori di confronto. È possibile ad esempio, di test per verificarne l'uguaglianza o disuguaglianza, o determinare se un valore è maggiore o uguale a un altro. Se uno degli operandi è un tipo numerico diverso da un <xref:System.Double>, viene convertito in un <xref:System.Double> prima di eseguire il confronto.  
  
    > [!WARNING]
    >  A causa delle differenze nella precisione, due <xref:System.Double> valori che si prevedono siano uguali potrebbero risultano per essere uguali, che influisce sul risultato del confronto. Vedere il [la verifica dell'uguaglianza](#Equality) sezione per ulteriori informazioni sul confronto tra due <xref:System.Double> valori.  
  
     È inoltre possibile chiamare il <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, e <xref:System.Double.IsNegativeInfinity%2A> metodi per verificare la presenza di questi valori speciali.  
  
-   **Operazioni matematiche**. Operazioni aritmetiche comuni, ad esempio addizione, sottrazione, moltiplicazione e divisione, vengono implementate dai compilatori di linguaggio e istruzioni Common Intermediate Language (CIL), anziché dal <xref:System.Double> metodi. Se uno degli operandi in un'operazione matematica è un tipo numerico diverso da un <xref:System.Double>, viene convertito in un <xref:System.Double> prima di eseguire l'operazione. Il risultato dell'operazione è anche un <xref:System.Double> valore.  
  
     Altre operazioni matematiche possono essere eseguite chiamando `static` (`Shared` in Visual Basic) metodi di <xref:System.Math?displayProperty=nameWithType> classe. Include metodi aggiuntivi utilizzati per i calcoli (ad esempio <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, e <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), geometry (ad esempio <xref:System.Math.Cos%2A?displayProperty=nameWithType> e <xref:System.Math.Sin%2A?displayProperty=nameWithType>) e calcolo (ad esempio <xref:System.Math.Log%2A?displayProperty=nameWithType>).  
  
     È inoltre possibile modificare i singoli bit in un <xref:System.Double> valore. Il <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> metodo mantiene un <xref:System.Double> modello di valore del bit in un integer a 64 bit. Il <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> metodo restituisce il relativo schema di bit in una matrice di byte.  
  
-   **Arrotondamento**. Arrotondamento viene spesso utilizzato come una tecnica per ridurre l'impatto delle differenze tra valori causati da problemi di rappresentazione a virgola mobile e precisione. È possibile arrotondare un <xref:System.Double> valore chiamando il <xref:System.Math.Round%2A?displayProperty=nameWithType> metodo.  
  
-   **Formattazione**. È possibile convertire un <xref:System.Double> valore nella relativa rappresentazione di stringa chiamando il <xref:System.Double.ToString%2A> metodo o utilizzando la funzionalità di formattazione composta. Per informazioni su come le stringhe di formato controllano la rappresentazione di stringa di valori a virgola mobile, vedere il [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md) argomenti.  
  
-   **Analisi di stringhe**. È possibile convertire la rappresentazione di stringa di un valore a virgola mobile a un <xref:System.Double> valore chiamando il <xref:System.Double.Parse%2A> o <xref:System.Double.TryParse%2A> metodo. Se l'operazione di analisi non riesce, il <xref:System.Double.Parse%2A> metodo genera un'eccezione, mentre il <xref:System.Double.TryParse%2A> restituisce `false`.  
  
-   **Conversione di tipo**. Il <xref:System.Double> struttura fornisce un'implementazione esplicita dell'interfaccia per il <xref:System.IConvertible> interfaccia, che supporta la conversione tra qualsiasi due tipi di dati .NET Framework standard. I compilatori di linguaggio supportano anche la conversione implicita di valori di tutti gli altri tipi numerici standard per <xref:System.Double> valori. Conversione di un valore di qualsiasi tipo numerico standard per un <xref:System.Double> una conversione verso e richiede all'utente di un metodo di conversione o operatore di cast,  
  
     Tuttavia, la conversione di <xref:System.Int64> e <xref:System.Single> valori possono comportare una perdita di precisione. Nella tabella seguente sono elencate le differenze di precisione per ognuno di questi tipi:  
  
    |Tipo|Precisione massima|Precisione interna|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 cifre decimali|19 cifre decimali|  
    |<xref:System.Single>|7 cifre decimali|9 cifre decimali|  
  
     Il problema di precisione interessa più di frequente <xref:System.Single> i valori vengono convertiti in <xref:System.Double> valori. Nell'esempio seguente, due valori prodotti da operazioni di divisione identici sono uguali perché uno dei valori è un valore a virgola mobile e precisione singola convertito in un <xref:System.Double>.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tutti i membri di questo tipo sono thread-safe. I membri che apparentemente modificano lo stato dell'istanza è in realtà restituiscono una nuova istanza inizializzata con il nuovo valore. Come con qualsiasi altro tipo, lettura e scrittura in una variabile condivisa che contiene un'istanza di questo tipo deve essere protetto da un blocco per garantire la thread safety.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta questa istanza con un oggetto specificato o un oggetto <see cref="T:System.Double" /> e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore rispetto al valore dell'oggetto specificato o dell'oggetto <see cref="T:System.Double" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Numero a virgola mobile a precisione doppia da confrontare.</param>
        <summary>Confronta questa istanza con un numero a virgola mobile e precisione doppia specificato e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore del valore del numero a virgola mobile e precisione doppia specificato.</summary>
        <returns>Numero con segno che indica i valori relativi di questa istanza e di <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valore restituito  </term><description> Descrizione  </description></listheader><item><term> Minore di zero  </term><description> L'istanza è minore di <paramref name="value" />.  - oppure - L'istanza non è un numero (<see cref="F:System.Double.NaN" />) e <paramref name="value" /> è un numero.  </description></item><item><term> Zero  </term><description> L'istanza è uguale a <paramref name="value" />.  - oppure - L'istanza e <paramref name="value" /> non sono un numero (<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NegativeInfinity" />.  </description></item><item><term> Maggiore di zero  </term><description> L'istanza è maggiore di <paramref name="value" />.  - oppure - L'istanza è un numero e <paramref name="value" /> non è un numero (<see cref="F:System.Double.NaN" />).  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori devono essere identici per essere considerate uguali. In particolare quando più operazioni matematiche dipendono da valori a virgola mobile, è comune per la perdita di precisione e i rispettivi valori in modo quasi identico ad eccezione delle cifre meno significative. Per questo motivo, il valore restituito di <xref:System.Double.CompareTo%2A> metodo orari sembri sorprendente. Ad esempio, moltiplicazione per un particolare valore seguito da una divisione con lo stesso valore dovrebbe produrre il valore originale. Nell'esempio seguente, tuttavia, il valore calcolato è risultata per essere maggiore del valore originale. Visualizzazione di tutte le cifre significative dei due valori mediante "R" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md) indica che il valore calcolato è diverso rispetto al valore originale nel relativo cifre meno significative. Per informazioni sulla gestione di questi confronti, vedere la sezione Note del <xref:System.Double.Equals%28System.Double%29> metodo.  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 Questo metodo implementa il <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia ed esegue leggermente migliori rispetto di <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> metodo perché non è necessario convertire il `value` parametro a un oggetto.  
  
 Si noti che, anche se un oggetto il cui valore è <xref:System.Double.NaN> non viene considerato uguale a un altro oggetto il cui valore è <xref:System.Double.NaN> (anche se stesso), il <xref:System.IComparable%601> interfaccia richiede che `A.CompareTo(A)` restituito zero.  
  
## <a name="widening-conversions"></a>conversioni verso un tipo di dati più grande  
 A seconda del linguaggio di programmazione, potrebbe essere possibile codificare una <xref:System.Double.CompareTo%2A> metodo in cui il tipo di parametro presenta meno bit (è più ristretto) rispetto al tipo di istanza. Questo è possibile perché alcuni linguaggi di programmazione eseguono conversioni implicite che rappresenta il parametro come un tipo con il numero di bit dell'istanza.  
  
 Ad esempio, si supponga che sia il tipo di istanza <xref:System.Double> e il tipo di parametro è <xref:System.Int32>. Il compilatore Microsoft c# genera istruzioni per rappresentare il valore del parametro come un <xref:System.Double> , quindi genera un <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> metodo che confronta i valori dell'istanza e la rappresentazione ampliata del parametro.  
  
 Consultare la documentazione del linguaggio di programmazione per determinare se il compilatore esegue conversioni di ampliamento implicite dei tipi numerici. Per ulteriori informazioni, vedere il [tabelle di conversione dei tipi](~/docs/standard/base-types/conversion-tables.md) argomento.  
  
## <a name="precision-in-comparisons"></a>Precisione nei confronti  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto tra due numeri particolari potrebbe cambiare tra le versioni di .NET Framework in quanto potrà modificare la precisione della rappresentazione interna dei numeri.  
  
   
  
## Examples  
 Esempio di codice seguente illustra le versioni generiche e del <xref:System.Double.CompareTo%2A> metodo per diversi tipi di riferimento e valore.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da confrontare o <see langword="null" />.</param>
        <summary>Confronta questa istanza con un oggetto specificato e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore rispetto al valore dell'oggetto specificato.</summary>
        <returns>Numero con segno che indica i valori relativi di questa istanza e di <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valore  </term><description> Descrizione  </description></listheader><item><term> Un intero negativo  </term><description> L'istanza è minore di <paramref name="value" />.  - oppure - L'istanza non è un numero (<see cref="F:System.Double.NaN" />) e <paramref name="value" /> è un numero.  </description></item><item><term> Zero  </term><description> L'istanza è uguale a <paramref name="value" />.  - oppure -  L'istanza e <paramref name="value" /> sono entrambi <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Un intero positivo  </term><description> L'istanza è maggiore di <paramref name="value" />.  - oppure -  L'istanza è un numero e <paramref name="value" /> non è un numero (<see cref="F:System.Double.NaN" />).  - oppure -  <paramref name="value" /> è <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro deve essere `null` o un'istanza di `Double`; in caso contrario, viene generata un'eccezione. Qualsiasi istanza di <xref:System.Double>, indipendentemente dal valore, viene considerato maggiore `null`.  
  
 I valori devono essere identici per essere considerate uguali. In particolare quando più operazioni matematiche dipendono da valori a virgola mobile, è comune per la perdita di precisione e i rispettivi valori in modo quasi identico ad eccezione delle cifre meno significative. Per questo motivo, il valore restituito di <xref:System.Double.CompareTo%2A> metodo orari sembri sorprendente. Ad esempio, moltiplicazione per un particolare valore seguito da una divisione con lo stesso valore dovrebbe produrre il valore originale. Nell'esempio seguente, tuttavia, il valore calcolato è risultata per essere maggiore del valore originale. Visualizzazione di tutte le cifre significative dei due valori mediante "R" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md) indica che il valore calcolato è diverso rispetto al valore originale nel relativo cifre meno significative. Per informazioni sulla gestione di questi confronti, vedere la sezione Note del <xref:System.Double.Equals%28System.Double%29> metodo.  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 Questo metodo viene implementato per supportare il <xref:System.IComparable> interfaccia. Si noti che, sebbene un <xref:System.Double.NaN> non viene considerato uguale a un altro <xref:System.Double.NaN> (anche se stesso), il <xref:System.IComparable> interfaccia richiede che `A.CompareTo(A)` restituito zero.  
  
## <a name="precision-in-comparisons"></a>Precisione nei confronti  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto tra due numeri particolari potrebbe cambiare tra le versioni di .NET Framework in quanto potrà modificare la precisione della rappresentazione interna dei numeri.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di `CompareTo` nel contesto di `Double`.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> non è un oggetto <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>Rappresenta il valore <see cref="T:System.Double" /> positivo più piccolo maggiore di zero. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore del <xref:System.Double.Epsilon> proprietà riflette positivo più piccolo <xref:System.Double> valore significativo in operazioni numeriche o confronti quando il valore di <xref:System.Double> istanza è uguale a zero. Ad esempio, il codice seguente mostra che zero e <xref:System.Double.Epsilon> vengono considerati valori uguali, mentre zero e metà del valore di <xref:System.Double.Epsilon> sono considerati uguali.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 Più precisamente, mobile punto formato è costituito da un simbolo, una mantissa a 52 bit o significando e un esponente a 11 bit. Come illustrato nell'esempio seguente, zero è un esponente di -1022 e una mantissa pari a 0. <xref:System.Double.Epsilon> esponente -1022 e una mantissa a 1. Ciò significa che <xref:System.Double.Epsilon> è positivo più piccolo <xref:System.Double> valore maggiore di zero e rappresenta il valore minimo possibile e l'incremento più piccolo possibile per un <xref:System.Double> cui esponente è -1022.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 Tuttavia, il <xref:System.Double.Epsilon> proprietà non è una misura generale di precisione del <xref:System.Double> digitare; si applica solo a <xref:System.Double> le istanze che hanno un valore pari a zero o un esponente di -1022.  
  
> [!NOTE]
>  Il valore di <xref:System.Double.Epsilon> proprietà non è equivalente a epsilon del computer che rappresenta il limite superiore dell'errore relativo a causa di arrotondamento in aritmetica a virgola mobile.  
  
 Il valore di questa costante è da 4, 94065645841247E-324.  
  
 Due numeri a virgola mobile apparentemente equivalenti potrebbero non risultare uguali a causa delle differenze nelle cifre meno significative. Ad esempio, l'espressione c#, `(double)1/3 == (double)0.33333`, non risultano uguali in quanto l'operazione di divisione a sinistra ha precisione massima, mentre la costante sul lato destro è limitata alle cifre specificate. Se si crea un algoritmo personalizzato che determina se due numeri a virgola mobile possono essere considerati uguali, non è consigliabile che l'algoritmo si basa sul valore della <xref:System.Double.Epsilon> per stabilire il margine di differenza per assoluto accettabile (costante) i due valori per essere considerate uguali.  (In genere, il margine di differenza è maggiore del numero di volte per <xref:System.Double.Epsilon>.) Per informazioni sul confronto tra due valori a virgola mobile a precisione doppia, vedere <xref:System.Double> e <xref:System.Double.Equals%28System.Double%29>.  
  
## <a name="platform-notes"></a>Note sulla piattaforma  
 Nei sistemi ARM, il valore di <xref:System.Double.Epsilon> costante è troppo piccolo per essere rilevato, in modo che corrisponde a zero. È possibile definire un valore alternativo epsilon uguale a 2, 2250738585072014E-308 invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se due istanze di <see cref="T:System.Double" /> rappresentano lo stesso valore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto <see cref="T:System.Double" /> da confrontare con l'istanza.</param>
        <summary>Restituisce un valore che indica se l'istanza e un oggetto <see cref="T:System.Double" /> specificato rappresentano lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> è uguale all'istanza. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il <xref:System.IEquatable%601?displayProperty=nameWithType> interfaccia ed esegue leggermente migliore <xref:System.Double.Equals%2A> perché non è necessario convertire il `obj` parametro a un oggetto.  
  
## <a name="widening-conversions"></a>conversioni verso un tipo di dati più grande  
 A seconda del linguaggio di programmazione, potrebbe essere possibile codificare una <xref:System.Double.Equals%2A> metodo in cui il tipo di parametro presenta meno bit (è più ristretto) rispetto al tipo di istanza. Questo è possibile perché alcuni linguaggi di programmazione eseguono conversioni implicite che rappresenta il parametro come un tipo con il numero di bit dell'istanza.  
  
 Ad esempio, si supponga che sia il tipo di istanza <xref:System.Double> e il tipo di parametro è <xref:System.Int32>. Il compilatore Microsoft c# genera istruzioni per rappresentare il valore del parametro come un <xref:System.Double> , quindi genera un <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> metodo che confronta i valori dell'istanza e la rappresentazione ampliata del parametro.  
  
 Consultare la documentazione del linguaggio di programmazione per determinare se il compilatore esegue conversioni di ampliamento implicite dei tipi numerici. Per ulteriori informazioni, vedere il [tabelle di conversione dei tipi](~/docs/standard/base-types/conversion-tables.md) argomento.  
  
## <a name="precision-in-comparisons"></a>Precisione nei confronti  
 Il <xref:System.Double.Equals%2A> metodo deve essere utilizzato con cautela, poiché i due valori apparentemente equivalenti possono essere uguali a causa della diversa precisione dei due valori. L'esempio seguente segnala che il <xref:System.Double> valore.333333 e <xref:System.Double> valore restituito dividendo 1 per 3 sono uguali.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 Anziché confrontare l'uguaglianza, una tecnica che definisca un margine accettabile relativo della differenza tra due valori (ad esempio. 001% di uno dei valori). Se il valore assoluto della differenza tra i due valori è minore o uguale a margine, la differenza è probabilmente a causa delle differenze di precisione e, di conseguenza, i valori possono essere uguali. Nell'esempio seguente viene utilizzata questa tecnica per confrontare.33333 e 1/3, i due <xref:System.Double> valori nell'esempio di codice precedente per essere uguali. In questo caso, i valori sono uguali.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  Poiché <xref:System.Double.Epsilon> definisce l'espressione minima di un valore positivo, il cui intervallo è prossimo a zero, il margine di differenza tra due valori simili deve essere maggiore di <xref:System.Double.Epsilon>. In genere, è maggiore del numero di volte per <xref:System.Double.Epsilon>. Per questo motivo, è consigliabile non utilizzare <xref:System.Double.Epsilon> quando si confrontano <xref:System.Double> valori per verificarne l'uguaglianza.  
  
 Una tecnica secondo implica il confronto la differenza tra due numeri a virgola mobile con un valore assoluto. Se la differenza è minore o uguale al valore assoluto, i numeri sono uguali. Se è maggiore, i numeri non sono uguali. Un'alternativa consiste nel selezionare in modo arbitrario un valore assoluto. Questo rappresenta un problema, tuttavia, poiché un margine accettabile di differenza dipende dalla grandezza del <xref:System.Double> valori. Una seconda alternativa si avvale di una funzionalità di progettazione nel formato a virgola mobile: la differenza tra la rappresentazione di integer di due valori a virgola mobile indica il numero di possibili valori a virgola mobile che li separa. Ad esempio, la differenza tra 0,0 e <xref:System.Double.Epsilon> è 1, perché <xref:System.Double.Epsilon> è il valore più piccolo rappresentabile quando si lavora con un <xref:System.Double> il cui valore è zero. Nell'esempio seguente viene utilizzata questa tecnica per confrontare.33333 e 1/3, che sono i due <xref:System.Double> valori il precedente esempio di codice con il <xref:System.Double.Equals%28System.Double%29> metodo risulta per essere uguali. Si noti che nell'esempio viene utilizzato il <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> metodo per convertire un valore a virgola mobile a precisione doppia nella relativa rappresentazione di tipo integer.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto tra due numeri particolari potrebbe cambiare tra le versioni di .NET Framework in quanto potrà modificare la precisione della rappresentazione interna dei numeri.  
  
 Se due <xref:System.Double.NaN?displayProperty=nameWithType> chiamando i valori vengono verificati per verificarne l'uguaglianza di <xref:System.Double.Equals%2A> , il metodo restituisce `true`. Tuttavia, se due <xref:System.Double.NaN> utilizzando l'operatore di uguaglianza, i valori vengono verificati per verificarne l'uguaglianza, l'operatore restituisce `false`. Quando si desidera determinare se il valore di un <xref:System.Double> non è un numero (NaN), in alternativa è possibile chiamare il <xref:System.Double.IsNaN%2A> metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Risoluzione dell'overload del compilatore possono rendere conto per un'apparente differenza nel comportamento dei due <see cref="M:System.Double.Equals(System.Object)" /> overload del metodo. Se una conversione implicita tra i <paramref name="obj" /> argomento e un <see cref="T:System.Double" /> è definito e l'argomento non è tipizzato come un <see cref="T:System.Object" />, i compilatori possono eseguire una conversione implicita e chiamare il <see cref="M:System.Double.Equals(System.Double)" /> (metodo). In caso contrario, chiamano il <see cref="M:System.Double.Equals(System.Object)" /> metodo, che restituisce sempre <see langword="false" /> se il relativo <paramref name="obj" /> argomento non è un <see cref="T:System.Double" /> valore. Nell'esempio seguente viene illustrata la differenza nel comportamento tra i due overload. Nel caso di tutti i tipi numerici primitivi, ad eccezione di <see cref="T:System.Decimal" /> e in c#, restituisce il primo confronto <see langword="true" /> perché il compilatore esegue automaticamente una conversione widening e chiama il <see cref="M:System.Double.Equals(System.Double)" /> (metodo), mentre il secondo confronto Restituisce <see langword="false" /> perché il compilatore chiama il <see cref="M:System.Double.Equals(System.Object)" /> metodo.  [! code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con l'istanza.</param>
        <summary>Restituisce un valore che indica se questa istanza è uguale a un oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> è un'istanza di <see cref="T:System.Double" /> ed è uguale al valore dell'istanza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.Equals%2A> metodo deve essere utilizzato con cautela, poiché i due valori apparentemente equivalenti possono essere uguali a causa della diversa precisione dei due valori. L'esempio seguente segnala che il <xref:System.Double> valore.3333 e <xref:System.Double> restituito dividendo 1 per 3 sono uguali.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 Per alternative a una chiamata di <xref:System.Double.Equals%2A> metodo, vedere la documentazione per il <xref:System.Double.Equals%28System.Double%29> overload.  
  
> [!NOTE]
>  Poiché <xref:System.Double.Epsilon> definisce l'espressione minima di un valore positivo, il cui intervallo è prossimo a zero, il margine di differenza tra due valori simili deve essere maggiore di <xref:System.Double.Epsilon>. In genere, è maggiore del numero di volte per <xref:System.Double.Epsilon>.  
  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto tra due numeri particolari potrebbe cambiare tra le versioni di .NET Framework in quanto potrà modificare la precisione della rappresentazione interna dei numeri.  
  
 Se due <xref:System.Double.NaN?displayProperty=nameWithType> chiamando i valori vengono verificati per verificarne l'uguaglianza di <xref:System.Double.Equals%2A> , il metodo restituisce `true`. Tuttavia, se due <xref:System.Double.NaN> utilizzando l'operatore di uguaglianza, i valori vengono verificati per verificarne l'uguaglianza, l'operatore restituisce `false`. Quando si desidera determinare se il valore di un <xref:System.Double> non è un numero (NaN), in alternativa è possibile chiamare il <xref:System.Double.IsNaN%2A> metodo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Risoluzione dell'overload del compilatore possono rendere conto per un'apparente differenza nel comportamento dei due <see cref="M:System.Double.Equals(System.Object)" /> overload del metodo. Se una conversione implicita tra i <paramref name="obj" /> argomento e un <see cref="T:System.Double" /> è definito e l'argomento non è tipizzato come un <see cref="T:System.Object" />, i compilatori possono eseguire una conversione implicita e chiamare il <see cref="M:System.Double.Equals(System.Double)" /> (metodo). In caso contrario, chiamano il <see cref="M:System.Double.Equals(System.Object)" /> metodo, che restituisce sempre <see langword="false" /> se il relativo <paramref name="obj" /> argomento non è un <see cref="T:System.Double" /> valore. Nell'esempio seguente viene illustrata la differenza nel comportamento tra i due overload. Nel caso di tutti i tipi numerici primitivi, ad eccezione di <see cref="T:System.Decimal" /> e in c#, restituisce il primo confronto <see langword="true" /> perché il compilatore esegue automaticamente una conversione widening e chiama il <see cref="M:System.Double.Equals(System.Double)" /> (metodo), mentre il secondo confronto Restituisce <see langword="false" /> perché il compilatore chiama il <see cref="M:System.Double.Equals(System.Object)" /> metodo.  [! code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.TypeCode" /> del tipo di valore <see cref="T:System.Double" />.</summary>
        <returns>Costante enumerata <see cref="F:System.TypeCode.Double" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Numero a virgola mobile a precisione doppia.</param>
        <summary>Restituisce un valore che indica se il numero specificato restituisce l'infinito negativo o positivo</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> restituisce <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NegativeInfinity" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity> per segnalare una condizione di overflow.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Numero a virgola mobile a precisione doppia.</param>
        <summary>Restituisce un valore che indica se il valore specificato non è un numero (<see cref="F:System.Double.NaN" />).</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> restituisce un <see cref="F:System.Double.NaN" />. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Double.NaN> per segnalare che il risultato dell'operazione è definito. Ad esempio, dividendo 0,0 per 0,0 comporta <xref:System.Double.NaN>.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A> Restituisce `false` se un <xref:System.Double> il valore è <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>. Per verificare questi valori, utilizzare il <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, e <xref:System.Double.IsNegativeInfinity%2A> metodi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Numero a virgola mobile a precisione doppia.</param>
        <summary>Restituisce un valore che indica se il numero specificato restituisce l'infinito negativo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> restituisce un <see cref="F:System.Double.NegativeInfinity" />. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Double.NegativeInfinity> per segnalare una condizione di overflow.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Numero a virgola mobile a precisione doppia.</param>
        <summary>Restituisce un valore che indica se il numero specificato restituisce l'infinito positivo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> restituisce un <see cref="F:System.Double.PositiveInfinity" />. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Double.PositiveInfinity> per segnalare una condizione di overflow.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.79769313486232E+308;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Rappresenta il valore massimo possibile di <see cref="T:System.Double" />. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è positivo 1.7976931348623157 e + 308.  
  
 Il risultato di un'operazione che supera <xref:System.Double.MaxValue?displayProperty=nameWithType> è <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. Nell'esempio seguente, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> risultati dalle operazioni di addizione e moltiplicazione elevamento a potenza quando il risultato supera <xref:System.Double.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.79769313486232E+308;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Rappresenta il valore minimo possibile di un oggetto <see cref="T:System.Double" />. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è negativo 1.7976931348623157 e + 308.  
  
 Il risultato di un'operazione che è minore di <xref:System.Double.MinValue?displayProperty=nameWithType> è <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Nell'esempio seguente, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> risultante dalla sottrazione e moltiplicazione operazioni quando il risultato è minore di <xref:System.Double.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Rappresenta un valore che non è un numero (<see langword="NaN" />). Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Restituisce un metodo o un operatore <xref:System.Double.NaN> quando il risultato di un'operazione non è definito. Ad esempio, il risultato della divisione per zero di zero è <xref:System.Double.NaN>, come illustrato nell'esempio seguente. (Ma si noti che divide un numero diverso da zero per zero restituisce uno <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>, in base al segno del divisore.)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 Inoltre, di chiamare un metodo con un <xref:System.Double.NaN> valore o un'operazione su un <xref:System.Double.NaN> valore restituisce <xref:System.Double.NaN>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 Utilizzare il <xref:System.Double.IsNaN%2A> metodo per determinare se un valore non è un numero. Il <xref:System.Double.op_Equality%2A> operatore considera due <xref:System.Double.NaN> i valori siano diversi tra loro. In generale, <xref:System.Double> operatori non possono essere utilizzati per confrontare <xref:System.Double.NaN?displayProperty=nameWithType> con altri <xref:System.Double> valori, anche se i metodi di confronto (ad esempio <xref:System.Double.Equals%2A> e <xref:System.Double.CompareTo%2A>) può. Nell'esempio seguente viene illustrata la differenza nel comportamento tra <xref:System.Double> metodi e gli operatori di confronto.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato l'utilizzo di <xref:System.Double.NaN>:  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Rappresenta l'infinito negativo. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è il risultato della divisione per zero di un numero negativo.  
  
 Questa costante viene restituita quando il risultato di un'operazione è minore di <xref:System.Double.MinValue>.  
  
 Utilizzare <xref:System.Double.IsNegativeInfinity%2A> per determinare se un valore restituisce l'infinito negativo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se due valori <see cref="T:System.Double" /> specificati sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_Equality%2A> metodo definisce l'operatore di uguaglianza per <xref:System.Double> valori.  
  
 Se due <xref:System.Double.NaN?displayProperty=nameWithType> valori vengono verificati per verificarne l'uguaglianza utilizzando l'operatore di uguaglianza, il risultato è `false`; due <xref:System.Double.NaN?displayProperty=nameWithType> valori non vengono considerati uguali. Se vengono verificati per verificarne l'uguaglianza chiamando il <xref:System.Double.Equals%2A> (metodo), il risultato è `true`.  Quando si desidera determinare se il valore di un <xref:System.Double> non è un numero (NaN), in alternativa è possibile chiamare il <xref:System.Double.IsNaN%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Double" />specificato è maggiore di un altro valore <see cref="T:System.Double" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_GreaterThan%2A> metodo definisce il funzionamento di maggiore-operatore per <xref:System.Double> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Double" /> specificato è maggiore o uguale a un altro valore <see cref="T:System.Double" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_GreaterThanOrEqual%2A> metodo definisce il funzionamento dell'operatore di maggiori di o uguali per <xref:System.Double> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se due valori <see cref="T:System.Double" /> specificati non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_Inequality%2A> metodo definisce l'operatore di disuguaglianza per <xref:System.Double> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se il valore <see cref="T:System.Double" /> specificato è minore o uguale a un altro valore <see cref="T:System.Double" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_LessThan%2A> metodo definisce il funzionamento di minore di-operatore per <xref:System.Double> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Double" /> specificato è minore o uguale a un altro valore <see cref="T:System.Double" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_LessThanOrEqual%2A> metodo definisce il funzionamento dell'operatore minore di o uguale per <xref:System.Double> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte la rappresentazione di stringa di un numero nel rispettivo numero a virgola mobile e precisione doppia equivalente.</summary>
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <summary>Converte la rappresentazione di stringa di un numero nel rispettivo numero a virgola mobile e precisione doppia equivalente.</summary>
        <returns>Numero a virgola mobile a precisione doppia equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `s` parametro può contenere le impostazioni cultura correnti <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>, o una stringa nel formato:  
  
 [*ws*] [*sign*] [*cifre integrali*[*,*]]*cifre integrali*[*.* [*cifre frazionarie*]] [E [*sign*]*cifre esponenziali*] [*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti.|  
|*sign*|Simbolo di segno negativo (-) o un simbolo di segno positivo (+). Può essere utilizzato solo con un segno iniziale.|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Viene eseguito *cifre integrali* possibile partizionare un simbolo di separatore di gruppi. In alcune impostazioni cultura, ad esempio, una virgola (,) separa delle migliaia. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.|  
|,|Specifiche delle impostazioni cultura migliaia simbolo di separatore.|  
|.|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero.|  
|E|Il "e" o il carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Il `s` parametro viene interpretato utilizzando una combinazione del <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag. Ciò significa che lo spazio vuoto e delle migliaia sono consentiti i separatori, ad esempio, sebbene non siano simboli di valuta. Per maggiore certezza che lo stile di elementi consentiti in `s` per l'operazione di analisi abbia esito positivo, chiamare il <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> o <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 Il `s` parametro viene interpretato utilizzando le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto inizializzato per impostazioni cultura del thread corrente. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Per analizzare una stringa utilizzando le informazioni di formattazione di altre impostazioni cultura, chiamare il <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> o <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 In genere, se si passa il <xref:System.Double.Parse%2A?displayProperty=nameWithType> metodo una stringa che viene creata chiamando il <xref:System.Double.ToString%2A?displayProperty=nameWithType> (metodo), originale <xref:System.Double> viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e separatori di gruppi sono uguali, l'operazione di analisi si presume che il separatore è un separatore decimale, anziché un gruppo separatore. Per ulteriori informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato l'utilizzo del metodo <xref:System.Double.Parse%28System.String%29>.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non rappresenta un numero in un formato valido.</exception>
        <exception cref="T:System.OverflowException">L'oggetto <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che indica gli elementi di stile che possono essere presenti in <c>s</c>. Un valore tipico da specificare è una combinazione di <see cref="F:System.Globalization.NumberStyles.Float" /> e <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato nel rispettivo numero a virgola mobile e precisione doppia equivalente.</summary>
        <returns>Numero a virgola mobile a precisione doppia equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `style` parametro definisce gli elementi di stile (ad esempio gli spazi vuoti, migliaia separatori e i simboli di valuta) che sono consentiti nel `s` parametro per l'operazione di analisi abbia esito positivo. Deve essere una combinazione di flag di bit del <xref:System.Globalization.NumberStyles> enumerazione. Le operazioni seguenti <xref:System.Globalization.NumberStyles> membri non sono supportati:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Il `s` parametro può contenere le impostazioni cultura correnti <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>. A seconda del valore di `style`, può anche richiedere il formato:  
  
 [*ws*] [*$*] [*sign*] [*cifre integrali*[*,*]]* cifre integrali*[*.* [*cifre frazionarie*]] [E [*sign*]*cifre esponenziali*] [*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti. Gli spazi vuoti possono essere visualizzati all'inizio di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag e può apparire alla fine di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|$|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita per il <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> delle impostazioni cultura correnti. Simbolo di valuta le impostazioni cultura correnti può apparire `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Simbolo di segno negativo (-) o un simbolo di segno positivo (+). Il segno può essere visualizzati all'inizio di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag e può apparire alla fine di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `s` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.|  
|,|Separatore di gruppi di impostazioni cultura specifiche. Simbolo di separatore di gruppo di impostazioni cultura correnti può apparire `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag|  
|.|Simbolo di separatore decimale delle impostazioni cultura specifiche. Simbolo di separatore decimale della lingua corrente può essere visualizzati `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero. Cifre frazionarie possono essere visualizzati `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|E|Il "e" o il carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `s` parametro può rappresentare un numero in notazione esponenziale se `style` include il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Una stringa che contiene solo cifre (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) viene sempre analizzata correttamente. Le restanti <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membri controllano gli elementi che possono essere presenti, ma non deve essere presente, nella stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> flag interessano gli elementi che possono essere presenti in `s`.  
  
|Valore NumberStyles|Elementi consentiti in `s` oltre alle cifre|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre integrali* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale (*.*) e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il "e" o il carattere "E", che indica la notazione esponenziale. Il flag supporta valori nel formato *cifre*E*cifre*; altri flag necessari per analizzare correttamente stringhe con elementi quali segno positivo o negativo e simboli del separatore decimale.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Migliaia elemento separatore (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Elemento valuta ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `s` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* elemento all'inizio o alla fine di `s`, *sign* all'inizio del `s`e il simbolo di separatore decimale (.). Il `s` parametro inoltre possibile utilizzare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, migliaia separatore (,) e gli elementi il separatore decimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `s` può rappresentare un numero esadecimale.|  
  
 Il `s` parametro viene analizzato utilizzando le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto inizializzato per la lingua corrente. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 In genere, se si passa il <xref:System.Double.Parse%2A?displayProperty=nameWithType> metodo una stringa che viene creata chiamando il <xref:System.Double.ToString%2A?displayProperty=nameWithType> (metodo), originale <xref:System.Double> viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e separatori di gruppi sono uguali, l'operazione di analisi si presume che il separatore è un separatore decimale, anziché un gruppo separatore. Per ulteriori informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> metodo per analizzare le rappresentazioni di stringa di <xref:System.Double> i valori usando le impostazioni cultura en-US.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non rappresenta un numero in un formato valido.</exception>
        <exception cref="T:System.OverflowException">L'oggetto <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  - oppure - <paramref name="style" /> include il valore <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="provider">Oggetto che offre informazioni di formattazione specifiche delle impostazioni cultura relative a <c>s</c>.</param>
        <summary>Converte la rappresentazione di stringa di un numero in un determinato formato specifico delle impostazioni cultura nel numero a virgola mobile e doppia precisione equivalente.</summary>
        <returns>Numero a virgola mobile a precisione doppia equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo di <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> metodo viene in genere utilizzato per convertire un testo che può essere formattato in diversi modi per un <xref:System.Double> valore. Ad esempio, può essere utilizzato per convertire il testo immesso dall'utente in una casella di testo HTML in un valore numerico.  
  
 Il `s` parametro viene interpretato utilizzando una combinazione del <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag. Il `s` parametro può contenere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> per impostazioni cultura specificate da `provider`, oppure può contenere una stringa nel formato:  
  
 [*ws*] [*sign*]*cifre integrali*[*.* [*cifre frazionarie*]] [E [*sign*]*cifre esponenziali*] [*ws*]  
  
 Elementi facoltativi sono racchiuse tra parentesi quadre ([e]). Gli elementi che contengono il termine "cifre" sono costituiti da una serie di caratteri numerici compresi tra 0 e 9.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti.|  
|*sign*|Simbolo di segno negativo (-) o un simbolo di segno positivo (+).|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Viene eseguito *cifre integrali* possibile partizionare un simbolo di separatore di gruppi. In alcune impostazioni cultura, ad esempio, una virgola (,) separa delle migliaia. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.|  
|.|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero.|  
|E|Il "e" o il carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Per ulteriori informazioni sui formati numerici, vedere il [formattazione dei tipi](~/docs/standard/base-types/formatting-types.md) argomento.  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura utilizzate per interpretare il formato di `s`. È in genere, un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> oggetto. Se `provider` è `null` o <xref:System.Globalization.NumberFormatInfo> non è possibile ottenere, le informazioni di formattazione per la lingua corrente viene utilizzata.  
  
 In genere, se si passa il <xref:System.Double.Parse%2A?displayProperty=nameWithType> metodo una stringa che viene creata chiamando il <xref:System.Double.ToString%2A?displayProperty=nameWithType> (metodo), originale <xref:System.Double> viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e separatori di gruppi sono uguali, l'operazione di analisi si presume che il separatore è un separatore decimale, anziché un gruppo separatore. Per ulteriori informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L'esempio seguente è il gestore eventi di un Web form click del pulsante. Usa la matrice restituita dal <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> proprietà per determinare la lingua dell'utente. Crea quindi un <xref:System.Globalization.CultureInfo> oggetto che corrisponde a quella lingua. Il <xref:System.Globalization.NumberFormatInfo> oggetto a cui appartiene che <xref:System.Globalization.CultureInfo> oggetto viene quindi passato al <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> input del metodo per convertire l'utente a un <xref:System.Double> valore.  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non rappresenta un numero in un formato valido.</exception>
        <exception cref="T:System.OverflowException">L'oggetto <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che indica gli elementi di stile che possono essere presenti in <c>s</c>. Un valore tipico da specificare è <see cref="F:System.Globalization.NumberStyles.Float" /> combinato con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Oggetto che offre informazioni di formattazione specifiche delle impostazioni cultura relative a <c>s</c>.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato e in un formato specifico delle impostazioni cultura nel numero a virgola mobile e precisione doppia equivalente.</summary>
        <returns>Numero a virgola mobile a precisione doppia equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `style` parametro definisce gli elementi di stile (ad esempio gli spazi vuoti, migliaia separatori e i simboli di valuta) che sono consentiti nel `s` parametro per l'operazione di analisi abbia esito positivo. Deve essere una combinazione di flag di bit del <xref:System.Globalization.NumberStyles> enumerazione. Le operazioni seguenti <xref:System.Globalization.NumberStyles> membri non sono supportati:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Il `s` parametro può contenere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> per impostazioni cultura specificate da `provider`. A seconda del valore di `style`, può anche richiedere il formato:  
  
 [*ws*] [*$*] [*sign*] [*cifre integrali*,]*cifre integrali*[. [ *cifre frazionarie*]] [E [*sign*]*cifre esponenziali*] [*ws*]  
  
 Elementi racchiusi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti. Gli spazi vuoti possono essere visualizzati all'inizio di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag e può apparire alla fine di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|$|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita per il <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> delle impostazioni cultura correnti. Simbolo di valuta le impostazioni cultura correnti può apparire `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Simbolo di segno negativo (-) o un simbolo di segno positivo (+). Il segno può essere visualizzati all'inizio di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag e può apparire alla fine di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `s` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.|  
|,|Separatore di gruppi di impostazioni cultura specifiche. Simbolo di separatore di gruppo di impostazioni cultura correnti può apparire `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag|  
|.|Simbolo di separatore decimale delle impostazioni cultura specifiche. Simbolo di separatore decimale della lingua corrente può essere visualizzati `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero. Cifre frazionarie possono essere visualizzati `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|E|Il "e" o il carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `s` parametro può rappresentare un numero in notazione esponenziale se `style` include il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Una stringa che contiene solo cifre (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) viene sempre analizzata correttamente. Le restanti <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membri controllano gli elementi che possono essere presenti, ma non deve essere presente, nella stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> flag interessano gli elementi che possono essere presenti in `s`.  
  
|Valore NumberStyles|Elementi consentiti in `s` oltre alle cifre|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre integrali* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale (*.*) e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il "e" o il carattere "E", che indica la notazione esponenziale. Il flag supporta valori nel formato *cifre*E*cifre*; altri flag necessari per analizzare correttamente stringhe con elementi quali segno positivo o negativo e simboli del separatore decimale.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Migliaia elemento separatore (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Elemento valuta ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `s` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* elemento all'inizio o alla fine di `s`, *sign* all'inizio del `s`e il simbolo di separatore decimale (.). Il `s` parametro inoltre possibile utilizzare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, migliaia separatore (,) e gli elementi il separatore decimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `s` può rappresentare un numero esadecimale.|  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto che fornisce informazioni specifiche delle impostazioni cultura utilizzate per interpretare il formato di `s`. È in genere, un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> oggetto. Se `provider` è `null` o <xref:System.Globalization.NumberFormatInfo> non è possibile ottenere, le informazioni di formattazione per la lingua corrente viene utilizzata.  
  
 In genere, se si passa il <xref:System.Double.Parse%2A?displayProperty=nameWithType> metodo una stringa che viene creata chiamando il <xref:System.Double.ToString%2A?displayProperty=nameWithType> (metodo), originale <xref:System.Double> viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e separatori di gruppi sono uguali, l'operazione di analisi si presume che il separatore è un separatore decimale, anziché un gruppo separatore. Per ulteriori informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metodo varie rappresentazioni di stringa dei valori di temperatura per assegnare un `Temperature` oggetto.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non rappresenta un valore numerico.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  - oppure - <paramref name="style" /> è il valore <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException">L'oggetto <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Rappresenta l'infinito positivo. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è il risultato della divisione di un numero positivo per zero.  
  
 Questa costante viene restituita quando il risultato di un'operazione è maggiore di <xref:System.Double.MaxValue>.  
  
 Utilizzare <xref:System.Double.IsPositiveInfinity%2A> per determinare se un valore restituisce l'infinito positivo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> se il valore dell'istanza corrente non è uguale a zero; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Questa conversione non è supportata. Il tentativo di usare questo metodo genera un'eccezione <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Questa conversione non è supportata. Non vengono restituiti valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Questa conversione non è supportata. Il tentativo di usare questo metodo genera un'eccezione <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Questa conversione non è supportata. Non vengono restituiti valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, invariato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Tipo nel quale convertire questo valore <see cref="T:System.Double" />.</param>
        <param name="provider">Implementazione <see cref="T:System.IFormatProvider" /> che fornisce informazioni specifiche delle impostazioni cultura sul formato del valore restituito.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore numerico dell'istanza nella rappresentazione di stringa equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte il valore numerico dell'istanza nella rappresentazione di stringa equivalente.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.ToString> formati del metodo un <xref:System.Double> valore il valore predefinito ("G" o generale) formato delle impostazioni cultura correnti. Se si desidera specificare un formato diverso, precisione o delle impostazioni cultura, utilizzare gli altri overload di <xref:System.Double.ToString%2A> (metodo), come indicato di seguito:  
  
|Per utilizzare il formato|Per impostazioni cultura|Utilizzare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un formato specifico o la precisione|Impostazioni cultura predefinite del (corrente)|<xref:System.Double.ToString%28System.String%29>|  
|Un formato specifico o la precisione|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una stringa nel formato:  
  
 cifre integrali [accesso] [. [ cifre frazionarie]] [[accesso] e cifre esponenziali]  
  
 Elementi facoltativi sono racchiuse tra parentesi quadre ([e]). Gli elementi che contengono il termine "cifre" sono costituiti da una serie di caratteri numerici compresi tra 0 e 9. Gli elementi elencati nella tabella riportata di seguito sono supportati.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*sign*|Un segno negativo o un simbolo di segno positivo.|  
|*integral-digits*|Una serie di cifre che specificano la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|'*.*'|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di cifre che specificano la parte frazionaria del numero.|  
|'*e*'|Un carattere minuscolo "e", che indica la notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di cifre che specificano un esponente.|  
  
 Alcuni esempi del valore restituito sono "100", "-123,456.,789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" e "-Infinity".  
  
 .NET Framework fornisce supporto di formattazione completo, come descritto in maggior dettaglio negli argomenti di formattazione seguenti:  
  
-   Per ulteriori informazioni sugli identificatori di formato numerico, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per ulteriori informazioni sulla formattazione, vedere [formattazione dei tipi di](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 L'esempio seguente usa il valore predefinito <xref:System.Double.ToString?displayProperty=nameWithType> metodo per visualizzare le rappresentazioni di stringa di un numero di <xref:System.Double> valori.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo di <xref:System.Double.ToString%2A>.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore numerico di questa istanza nella rappresentazione di stringa equivalente usando le informazioni di formato specifiche delle impostazioni cultura.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza, in base a quanto specificato da <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.ToString%28System.IFormatProvider%29> formati del metodo un <xref:System.Double> valore il valore predefinito ("G" o generale) formato di impostazioni cultura specificate. Se si desidera specificare un formato diverso o delle impostazioni cultura, utilizzare gli altri overload di <xref:System.Double.ToString%2A> (metodo), come indicato di seguito:  
  
|Per utilizzare il formato|Per impostazioni cultura|Utilizzare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Predefinito (corrente)|<xref:System.Double.ToString>|  
|Un formato specifico o la precisione|Impostazioni cultura predefinite del (corrente)|<xref:System.Double.ToString%28System.String%29>|  
|Un formato specifico o la precisione|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una stringa nel formato:  
  
 cifre integrali [accesso] [. [ cifre frazionarie]] [[accesso] e cifre esponenziali]  
  
 Elementi facoltativi sono racchiuse tra parentesi quadre ([e]). Gli elementi che contengono il termine "cifre" sono costituiti da una serie di caratteri numerici compresi tra 0 e 9. Gli elementi elencati nella tabella riportata di seguito sono supportati.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*sign*|Un segno negativo o un simbolo di segno positivo.|  
|*integral-digits*|Una serie di cifre che specificano la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|'*.*'|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di cifre che specificano la parte frazionaria del numero.|  
|'*e*'|Un carattere minuscolo "e", che indica la notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di cifre che specificano un esponente.|  
  
 Alcuni esempi del valore restituito sono "100", "-123,456.,789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" e "-Infinity".  
  
 Questa istanza viene formattata con l'identificatore di formato numerico ("G").  
  
 .NET Framework fornisce supporto di formattazione completo, come descritto in maggior dettaglio negli argomenti di formattazione seguenti:  
  
-   Per ulteriori informazioni sugli identificatori di formato numerico, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per ulteriori informazioni sulla formattazione, vedere [formattazione dei tipi di](~/docs/standard/base-types/formatting-types.md).  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto. In genere, `provider` è un <xref:System.Globalization.CultureInfo> oggetto o un <xref:System.Globalization.NumberFormatInfo> oggetto. Il `provider` parametro fornisce le informazioni specifiche delle impostazioni cultura utilizzate per la formattazione. Se `provider` è `null`, il valore restituito viene formattato con il <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti.  
  
   
  
## Examples  
 L'esempio seguente mostra la rappresentazione di stringa di due <xref:System.Double> valori utilizzando <xref:System.Globalization.CultureInfo> gli oggetti che rappresentano varie impostazioni cultura.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo di <xref:System.Double.ToString%2A>, considerando un <xref:System.String> e <xref:System.IFormatProvider> come parametri.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato numerico.</param>
        <summary>Converte il valore numerico di questa istanza nell'equivalente rappresentazione di stringa usando il formato specificato.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza, in base a quanto specificato da <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.ToString%28System.String%29> formati del metodo un <xref:System.Double> valore in un formato specificato usando le convenzioni delle impostazioni cultura correnti. Se si desidera specificare un formato diverso o delle impostazioni cultura, utilizzare gli altri overload di <xref:System.Double.ToString%2A> (metodo), come indicato di seguito:  
  
|Per utilizzare il formato|Per impostazioni cultura|Utilizzare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Impostazioni cultura predefinite del (corrente)|<xref:System.Double.ToString>|  
|Formato predefinito ("G")|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un formato specifico o la precisione|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o la rappresentazione di stringa di un numero, come specificato da `format`.  
  
 Il `format` parametro può essere qualsiasi identificatore di formato numerico standard valido, ad eccezione D e X, nonché qualsiasi combinazione di identificatori di formato numerico personalizzate. Se `format` è `null` o una stringa vuota, il valore restituito viene formattata con l'identificatore di formato numerico ("G").  
  
 .NET Framework fornisce supporto di formattazione completo, come descritto in maggior dettaglio negli argomenti di formattazione seguenti:  
  
-   Per ulteriori informazioni sugli identificatori di formato numerico, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per ulteriori informazioni sulla formattazione, vedere [formattazione dei tipi di](~/docs/standard/base-types/formatting-types.md).  
  
 Per impostazione predefinita, il valore restituito contiene solo 15 cifre di precisione anche se internamente viene gestito un massimo di 17 cifre. Se il valore di questa istanza è maggiore di 15 cifre, <xref:System.Double.ToString%2A> restituisce <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> o <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anziché il numero previsto. Se è necessaria una maggiore precisione, specificare `format` con la specifica di formato "G17", che restituisce sempre 17 cifre di precisione o "R", che restituisce 15 cifre se il numero può essere rappresentato con tale precisione o 17 cifre se il numero può essere solo rappresentati con la massima precisione.  
  
   
  
## Examples  
 Nell'esempio seguente definisce un valore numerico e formatta come valore di valuta tramite la stringa di formato numerico standard "C" e come un valore numerico a tre cifre decimali utilizzando la stringa di formato numerico standard "N". Le stringhe di risultati vengono formattate usando le convenzioni delle impostazioni cultura en-US. Per ulteriori informazioni sulle stringhe di formato numerico, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 L'esempio seguente mostra alcune <xref:System.Double> valori utilizzando gli identificatori di formato numerico standard supportati con tre stringhe di formato numerico personalizzate. Una delle stringhe di formato personalizzate viene illustrato come aggiungere un <xref:System.Single> valore con gli zeri iniziali. Inoltre, l'esempio Usa identificatori di precisione con ogni identificatore di formato standard, ad eccezione di "R". I valori di precisione identificatori compreso tra 0 e 3. Per convertire i valori numerici in stringhe, l'esempio Usa le convenzioni di formattazione delle impostazioni cultura en-US.  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.</exception>
        <block subset="none" type="usage">
          <para>In alcuni casi <see cref="T:System.Double" /> formattati i valori con i non stringa di formato numerico standard "R" non completano il round trip se compilati usando il <see langword="/platform:x64" /> o <see langword="/platform:anycpu" /> commutatori e in esecuzione su sistemi a 64 bit. Per aggirare questo problema, è possibile formattare i valori <see cref="T:System.Double" /> usando la stringa di formato numerico standard "G17". L'esempio seguente usa la stringa di formato "R" con un <see cref="T:System.Double" /> valore che non non completa il round trip correttamente e anche stringa formato "G17" viene utilizzato correttamente il round trip sul valore originale.  [! codice csharp [System.Double.ToString#6] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. Double.ToString/cs/roundtripex2.cs#6)] [! codice vb [System.Double.ToString#6] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. Double.ToString/vb/roundtripex2.vb#6)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato numerico.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore numerico dell'istanza nella rappresentazione di stringa equivalente usando il formato specificato e le informazioni di formattazione specifiche delle impostazioni cultura.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza corrente, in base a quanto specificato da <paramref name="format" /> e <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> formati del metodo un <xref:System.Double> valore in un formato specifico delle impostazioni cultura specificato. Se si desidera specificare un formato diverso o delle impostazioni cultura, utilizzare gli altri overload di <xref:System.Double.ToString%2A> (metodo), come indicato di seguito:  
  
|Per utilizzare il formato|Per impostazioni cultura|Utilizzare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Impostazioni cultura predefinite del (corrente)|<xref:System.Double.ToString>|  
|Formato predefinito ("G")|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un formato specifico o la precisione|Impostazioni cultura predefinite del (corrente)|<xref:System.Double.ToString%28System.String%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o la rappresentazione di stringa di un numero, come specificato da `format`.  
  
 Il `format` parametro può essere qualsiasi identificatore di formato numerico standard valido, ad eccezione D e X, nonché qualsiasi combinazione di identificatori di formato numerico personalizzate. Se `format` è `null` o una stringa vuota, il valore restituito per questa istanza verrà formattata con l'identificatore di formato numerico generale ("G").  
  
 .NET Framework fornisce supporto di formattazione completo, come descritto in maggior dettaglio negli argomenti di formattazione seguenti:  
  
-   Per ulteriori informazioni sugli identificatori di formato numerico, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per ulteriori informazioni sulla formattazione, vedere [formattazione dei tipi di](~/docs/standard/base-types/formatting-types.md).  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto. In genere, `provider` è un <xref:System.Globalization.CultureInfo> oggetto o un <xref:System.Globalization.NumberFormatInfo> oggetto. Il `provider` parametro fornisce le informazioni specifiche delle impostazioni cultura utilizzate per la formattazione. Se `provider` è `null`, il valore restituito viene formattato con il <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti.  
  
 Per impostazione predefinita, il valore restituito contiene solo 15 cifre di precisione anche se internamente viene gestito un massimo di 17 cifre. Se il valore di questa istanza è maggiore di 15 cifre, <xref:System.Double.ToString%2A> restituisce <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> o <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anziché il numero previsto. Se è necessaria una maggiore precisione, specificare `format` con la specifica di formato "G17", che restituisce sempre 17 cifre di precisione o "R", che restituisce 15 cifre se il numero può essere rappresentato con tale precisione o 17 cifre se il numero può essere solo rappresentati con la massima precisione.  
  
   
  
## Examples  
 L'esempio seguente mostra un <xref:System.Double> valore usando ognuno degli identificatori di formato numerico standard supportati per varie impostazioni cultura.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo di <xref:System.Double.ToString%2A>, considerando un <xref:System.String> e <xref:System.IFormatProvider> come parametri.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>In alcuni casi <see cref="T:System.Double" /> formattati i valori con i non stringa di formato numerico standard "R" non completano il round trip se compilati usando il <see langword="/platform:x64" /> o <see langword="/platform:anycpu" /> commutatori e in esecuzione su sistemi a 64 bit. Per aggirare questo problema, è possibile formattare i valori <see cref="T:System.Double" /> usando la stringa di formato numerico standard "G17". L'esempio seguente usa la stringa di formato "R" con un <see cref="T:System.Double" /> valore che non non completa il round trip correttamente e anche stringa formato "G17" viene utilizzato correttamente il round trip sul valore originale.  [! codice csharp [System.Double.ToString#5] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. Double.ToString/cs/roundtripex1.cs#5)] [! codice vb [System.Double.ToString#5] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. Double.ToString/vb/roundtripex1.vb#5)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte la rappresentazione di stringa di un numero nel rispettivo numero a virgola mobile e precisione doppia equivalente. Un valore restituito indica se la conversione è riuscita o meno.</summary>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="result">Al momento della restituzione, questo metodo contiene il numero a virgola mobile a precisione doppia equivalente al parametro <c>s</c>, se la conversione ha esito positivo oppure zero se la conversione non riesce. La conversione non riesce se il parametro <c>s</c> è <see langword="null" /> o <see cref="F:System.String.Empty" />, non è un numero in formato valido o rappresenta un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />. Questo parametro viene passato non inizializzato. Qualsiasi valore specificato in origine in <c>result</c> verrà sovrascritto.</param>
        <summary>Converte la rappresentazione di stringa di un numero nel rispettivo numero a virgola mobile e precisione doppia equivalente. Un valore restituito indica se la conversione è riuscita o meno.</summary>
        <returns>
          <see langword="true" /> se <paramref name="s" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload differisce dal <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> metodo restituendo un valore booleano che indica se l'operazione di analisi è riuscita anziché restituire il valore numerico analizzato. Elimina la necessità di utilizzare la gestione delle eccezioni per verificare la presenza di un <xref:System.FormatException> nel caso in cui `s` non è valido e non può essere analizzato correttamente.  
  
 Il `s` parametro può contenere le impostazioni cultura correnti <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (il confronto di stringhe è distinzione maiuscole/minuscole), o una stringa nel formato:  
  
 [ws] [accesso] [cifre integrali,] cifre integrali [. [ cifre frazionarie]] [[accesso] e cifre esponenziali] [ws]  
  
 Gli elementi tra parentesi quadre sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti.|  
|*sign*|Un segno negativo o un simbolo di segno positivo.|  
|*integral-digits*|Una serie di caratteri numerici compresi tra 0 e 9 che specificano la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|*,*|Un simbolo di separatore di gruppo di impostazioni cultura specifiche.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di caratteri numerici compresi tra 0 e 9 che specificano la parte frazionaria del numero.|  
|*E*|Un carattere maiuscolo o minuscolo 'e', che indica la notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di caratteri numerici compresi tra 0 e 9 che specificano un esponente.|  
  
 Per ulteriori informazioni sui formati numerici, vedere [formattazione dei tipi di](~/docs/standard/base-types/formatting-types.md).  
  
 Il `s` parametro viene interpretato utilizzando una combinazione del <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag. Ciò significa che lo spazio vuoto e delle migliaia sono consentiti separatori ma non sono i simboli di valuta. Per definire in modo esplicito gli elementi (ad esempio i simboli di valuta, migliaia, gli spazi vuoti e separatori) che possono essere presenti in `s`, utilizzare il <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> overload del metodo.  
  
 Il `s` parametro viene analizzato utilizzando le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto inizializzato per la lingua corrente. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Per analizzare una stringa utilizzando le informazioni di formattazione di un altro specificato delle impostazioni cultura, usare il <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> overload del metodo.  
  
 In genere, se si passa il <xref:System.Double.TryParse%2A?displayProperty=nameWithType> metodo una stringa che viene creata chiamando il <xref:System.Double.ToString%2A?displayProperty=nameWithType> (metodo), originale <xref:System.Double> viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e i separatori decimali e di gruppo sono gli stessi, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un separatore di gruppi. Per ulteriori informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> metodo per convertire le rappresentazioni di stringa di valori numerici per <xref:System.Double> valori. Si presuppone che en-US è le impostazioni cultura correnti.  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori <see cref="T:System.Globalization.NumberStyles" /> che indica il formato consentito di <c>s</c>. Un valore tipico da specificare è <see cref="F:System.Globalization.NumberStyles.Float" /> combinato con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Oggetto <see cref="T:System.IFormatProvider" /> che offre informazioni di formattazione specifiche delle impostazioni cultura relative a <c>s</c>.</param>
        <param name="result">Quando questo metodo viene restituito, contiene il numero a virgola mobile a precisione doppia equivalente al valore numerico o al simbolo contenuto in <c>s</c>, se la conversione ha esito positivo oppure zero se la conversione non riesce. La conversione non riesce se il parametro <c>s</c> è <see langword="null" /> o <see cref="F:System.String.Empty" />, non presenta un formato conforme a <c>style</c>, rappresenta un numero minore di <see cref="F:System.SByte.MinValue" /> o maggiore di <see cref="F:System.SByte.MaxValue" /> o se <c>style</c> non è una combinazione valida di costanti enumerate di <see cref="T:System.Globalization.NumberStyles" />. Questo parametro viene passato non inizializzato. Qualsiasi valore specificato in origine in <c>result</c> verrà sovrascritto.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato e in un formato specifico delle impostazioni cultura nel numero a virgola mobile e precisione doppia equivalente. Un valore restituito indica se la conversione è riuscita o meno.</summary>
        <returns>
          <see langword="true" /> se <paramref name="s" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.TryParse%2A> metodo è simile di <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> (metodo), ma questo metodo non genera un'eccezione se la conversione non riesce. Se la conversione ha esito positivo, il valore restituito è `true` e `result` parametro è impostato sul risultato della conversione. Se la conversione non riesce, il valore restituito è `false` e `result` parametro è impostato su zero. Questo elimina la necessità di utilizzare la gestione delle eccezioni per verificare la presenza di un <xref:System.FormatException> nel caso in cui `s` non è valido e non può essere analizzato correttamente.  
  
 Il `style` parametro definisce il formato consentito del `s` parametro per l'operazione di analisi abbia esito positivo. Deve essere una combinazione di flag di bit del <xref:System.Globalization.NumberStyles> enumerazione. Le operazioni seguenti <xref:System.Globalization.NumberStyles> membri non sono supportati:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Il `s` parametro può contenere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> per le impostazioni cultura indicate da `provider`. Inoltre, a seconda del valore di `style`, `s` parametro può includere gli elementi seguenti:  
  
 [ws] [$] [accesso] [cifre integrali,] cifre integrali [. cifre frazionarie] [[accesso] e cifre esponenziali] [ws]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo. Gli spazi vuoti possono essere visualizzati all'inizio di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag. Può essere visualizzato alla fine di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|*$*|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita dal <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> o <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> le proprietà del <xref:System.Globalization.NumberFormatInfo> oggetto restituito dal <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> metodo il `provider` parametro. Il simbolo di valuta può essere visualizzati `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Un segno facoltativo. Il segno può essere visualizzati all'inizio di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag e può apparire alla fine di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `s` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|*,*|Specifiche delle impostazioni cultura migliaia simbolo di separatore. Migliaia di cultura correnti simbolo di separatore può essere presente in `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche. Simbolo di separatore decimale della lingua corrente può essere visualizzati `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero. Cifre frazionarie possono essere visualizzati `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*e*|Il carattere e o E, che indica che `s` può rappresentare un numero utilizzando la notazione esponenziale. Il `s` parametro può rappresentare un numero in notazione esponenziale se style include il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Una stringa che contiene solo cifre (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) viene sempre analizzata correttamente. Le restanti <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membri controllano gli elementi che possono essere ma non devono essere presenti nella stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> flag interessano gli elementi che possono essere presenti in `s`.  
  
|Valore NumberStyles|Elementi consentiti in s oltre alle cifre|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre integrali* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|L'elemento language *.* e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il `s` parametro inoltre possibile utilizzare la notazione esponenziale. Il flag supporta valori nel formato *cifre integrali*E*cifre esponenziali*; altri flag sono necessari per analizzare correttamente le stringhe in notazione esponenziale con elementi quali segno positivo o negativo e simboli del separatore decimale.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Il *,* elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Il * $ * elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti. Il `s` parametro non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* elemento all'inizio o alla fine di `s`, *sign* all'inizio di `s`e *.* simbolo. Il `s` parametro inoltre possibile utilizzare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, migliaia separatore (*,),* e punto decimale (*.*) elementi.|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli stili, ad eccezione di `s` può rappresentare un numero esadecimale.|  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione, ad esempio un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> oggetto. Il `provider` parametro fornisce le informazioni specifiche delle impostazioni cultura utilizzate nell'analisi. Se `provider` è `null` o <xref:System.Globalization.NumberFormatInfo> non è possibile ottenere l'oggetto, viene utilizzate le informazioni di formato per le impostazioni cultura correnti.  
  
 La conversione non riesce se il `s` parametro `null` o un valore non numerico, il `provider` parametro non produce un <xref:System.Globalization.NumberFormatInfo> oggetto, o `style` parametro non è una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione.  
  
 In genere, se si passa il <xref:System.Double.TryParse%2A?displayProperty=nameWithType> metodo una stringa che viene creata chiamando il <xref:System.Double.ToString%2A?displayProperty=nameWithType> (metodo), originale <xref:System.Double> viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di <xref:System.Double.MinValue> o <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e separatori di gruppi sono uguali, l'operazione di analisi si presume che il separatore è un separatore decimale, anziché un gruppo separatore. Per ulteriori informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> metodo per analizzare la rappresentazione di stringa di numeri che hanno uno stile specifico e vengono formattati utilizzando le convenzioni delle impostazioni cultura specifiche.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  - oppure - <paramref name="style" /> include il valore <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>