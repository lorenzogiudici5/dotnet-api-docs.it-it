<Type Name="Double" FullName="System.Double">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ac9be917d69754e6e0a149d21f0d3462c7186d5b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37730819" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un numero a virgola mobile a precisione doppia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double> tipo di valore rappresenta un numero a precisione doppia a 64 bit con valori compresi tra 1,79769313486232e308 negativo e 1,79769313486232e308 positivo, nonché zero positivo o negativo <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>e non un numero (<xref:System.Double.NaN>). Consente di rappresentare i valori che sono estremamente grande (ad esempio, le distanze tra pianeti o galassie) o molto piccolo (modellistica massa di materia in chilogrammi) e che spesso sono imprecisa (ad esempio la distanza da terra a un altro sistema solare), il <xref:System.Double> tipo è conforme a IEC 60559: 1989 (IEEE 754) per l'aritmetica binaria a virgola mobile.  
  
 Questo argomento include le sezioni seguenti:  
  
-   [Rappresentazione a virgola mobile e precisione](#Precision)  
  
-   [Test dell'uguaglianza](#Equality)  
  
-   [Le eccezioni e valori a virgola mobile](#Exceptions)  
  
-   [Conversioni di tipi e la struttura Double](#Conversions)  
  
-   [Funzionalità a virgola mobile](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Rappresentazione a virgola mobile e precisione  
 Il <xref:System.Double> tipo di dati archivia i valori a virgola mobile a precisione doppia in un formato binario a 64 bit, come illustrato nella tabella seguente:  
  
|Parte|Bit|  
|----------|----------|  
|Significando o nella mantissa|0-51|  
|Esponente|52-62|  
|Sign (0 = positivo, 1 = negativo)|63|  
  
 Proprio come le frazioni decimali in grado di rappresentare esattamente alcuni valori frazionari (ad esempio 1 o 3 o <xref:System.Math.PI?displayProperty=nameWithType>), frazioni binarie in grado di rappresentare alcuni valori frazionari. Ad esempio, 1 o 10, che viene rappresentato esattamente da.1 come frazione decimale, è rappresentato da.001100110011 come frazione binaria, con il modello "0011" ripetuta all'infinito. In questo caso, il valore a virgola mobile e fornisce una rappresentazione imprecisa del numero che rappresenta. Eseguire altre operazioni matematiche sul valore a virgola mobile originale spesso tende ad aumentare la mancanza di precisione. Ad esempio, se si confronta il risultato della moltiplicazione.1 da 10 e si è aggiunta.1 a.1 nove tentativi, vedere questa aggiunta, perché è coinvolto più operazioni di otto, ha prodotto i risultati meno precisi. Si noti che questa disparità è evidente solo se viene visualizzato due <xref:System.Double> valori mediante "R" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md), ovvero se necessarie vengono visualizzate tutte le 17 cifre di precisione supportato dal <xref:System.Double> tipo.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Poiché alcuni numeri non possono essere rappresentati esattamente come valori binari frazionari, numeri a virgola mobile possono solo i numeri reali approssimativi.  
  
 Tutti i numeri a virgola mobile hanno anche un numero limitato di cifre significative, che determina anche l'accuratezza con cui un valore a virgola mobile offre un'approssimazione di un numero reale.   Oggetto <xref:System.Double> valore ha fino a 15 cifre decimali di precisione, anche se internamente viene gestito un massimo di 17 cifre. Ciò significa che alcune operazioni a virgola mobile potrebbero non essere la precisione per modificare mobile valore del punto. Nell'esempio seguente viene illustrato questo concetto. Definisce un valore a virgola mobile molto grande e quindi aggiunge il prodotto di <xref:System.Double.Epsilon?displayProperty=nameWithType> e un milione di miliardi ad esso. Tuttavia, il prodotto, è troppo piccolo per modificare il valore a virgola mobile originale. La cifra meno significativa è dei millesimi, mentre la cifra più significativa del prodotto è 1<sup>-312</sup>.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 Precisione limitata di un numero a virgola mobile ha diverse conseguenze:  
  
-   Due numeri a virgola mobile apparentemente uguali per una particolare precisione potrebbero non risultare uguali perché le cifre meno significative sono diverse. Nell'esempio seguente, una serie di numeri verranno sommati e il totale viene confrontato con il totale previsto. Anche se i due valori sembrano uguali, una chiamata al `Equals` metodo indica che non si trovano.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     Se si modificano gli elementi di formato nel <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> istruzione dal `{0}` e `{1}` al `{0:R}` e `{1:R}` per visualizzare tutte le cifre significative dei due <xref:System.Double> valori, è chiaro che due valori sono diversi perché di una perdita di precisione durante le operazioni di addizione. In questo caso, il problema può essere risolto tramite la chiamata di <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> metodo per arrotondare il <xref:System.Double> valori alla precisione desiderato prima di eseguire il confronto.  
  
-   Un'operazione matematica o di confronto che usa un numero a virgola mobile potrebbe non produrre lo stesso risultato se viene usato un numero decimale, perché il numero a virgola mobile binario potrebbe non essere uguale al numero decimale. Un esempio precedente illustrato questo visualizzando il risultato della moltiplicazione.1 da 10 e l'aggiunta di.1 volte.  
  
     Quando la precisione numerica operazioni con i valori frazionari è importante, è possibile usare la <xref:System.Decimal> anziché il <xref:System.Double> tipo. Quando la precisione numerica operazioni con i valori integrali oltre l'intervallo del <xref:System.Int64> o <xref:System.UInt64> tipi è importante, utilizzare il <xref:System.Numerics.BigInteger> tipo.  
  
-   Un valore potrebbe non eseguire il round trip se è interessato un numero a virgola mobile. Eseguire il round trip si ha un valore se un'operazione converte un numero a virgola mobile originale in un altro formato, un'operazione inversa trasforma il formato convertito nuovamente in un numero a virgola mobile e il numero a virgola mobile finale non è uguale all'istanza originale numero a virgola mobile. Il round trip potrebbe non riuscire perché uno o più cifre meno significative vengono perse o modificate in una conversione. Nell'esempio seguente tre <xref:System.Double> valori vengono convertiti in stringhe e salvati in un file. Come illustrato nell'output, tuttavia, anche se i valori sembrano identiche, i valori ripristinati non sono uguali ai valori originali.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     In questo caso, i valori possono essere correttamente sottoposto a round-trip tramite il "G17" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md) per mantenere la precisione completa dei <xref:System.Double> valori, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  Se usato con un <xref:System.Double> il valore, l'identificatore di formato "R" in alcuni casi non completano il round trip al valore originale. Per garantire che <xref:System.Double> valori correttamente il round trip, usare l'identificatore di formato "G17".

-   <xref:System.Single> i valori hanno precisione inferiore rispetto a <xref:System.Double> valori. Oggetto <xref:System.Single> valore che viene convertito in un equivalente apparentemente <xref:System.Double> spesso non è uguale il <xref:System.Double> valore a causa delle differenze nella precisione. Nell'esempio seguente, il risultato di operazioni di divisione identici viene assegnato a un <xref:System.Double> e un <xref:System.Single> valore. Dopo il <xref:System.Single> viene eseguito il cast di valore a un <xref:System.Double>, viene illustrato un confronto tra i due valori che non sono uguali.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Per evitare questo problema, usare il <xref:System.Double> invece del <xref:System.Single> tipo di dati o usare il <xref:System.Math.Round%2A> metodo in modo che entrambi i valori hanno la stessa precisione.  
  
 Inoltre, il risultato di operazioni aritmetiche e assegnazione con <xref:System.Double> i valori possono differire leggermente dalla piattaforma a causa della perdita di precisione del <xref:System.Double> tipo. Ad esempio, il risultato di assegnazione di un valore letterale <xref:System.Double> valore può variare nelle versioni a 32 e 64 bit di .NET Framework. L'esempio seguente illustra questa differenza quando il valore letterale valore - 4.42330604244772 e-305 e una variabile il cui valore è - 4.42330604244772 e-305 vengono assegnati a un <xref:System.Double> variabile. Si noti che il risultato del <xref:System.Double.Parse%28System.String%29> metodo in questo caso non è soggetta a una perdita di precisione.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Test dell'uguaglianza  
 Per essere considerati uguali, due <xref:System.Double> valori devono rappresentare valori identici. Tuttavia, a causa delle differenze nella precisione tra i valori o a causa di una perdita di precisione da uno o entrambi i valori, valori a virgola mobile che dovrebbero essere identici spesso risultare venga fatta a causa delle differenze nelle cifre meno significative. Di conseguenza, le chiamate al <xref:System.Double.Equals%2A> metodo per determinare se due valori sono uguali o chiamate per il <xref:System.Double.CompareTo%2A> metodo per stabilire la relazione tra due <xref:System.Double> valori, spesso provocare risultati imprevisti. Ciò è evidente nell'esempio seguente, in cui due apparentemente uguali <xref:System.Double> valori risultare venga fatta in quanto il primo presenta 15 cifre di precisione, mentre il secondo è 17.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 I valori calcolati che seguire diversi percorsi di codice e che vengono modificati in modi diversi spesso rivelino non uguali. Nell'esempio seguente, una <xref:System.Double> viene elevato al quadrato valore e quindi viene calcolata la radice quadrata per ripristinare il valore originale. Un secondo <xref:System.Double> viene moltiplicato per 3.51 ed elevato al quadrato prima che la radice quadrata del risultato viene diviso per 3.51 per ripristinare il valore originale. Anche se i due valori sembrano identiche, una chiamata al <xref:System.Double.Equals%28System.Double%29> metodo indica che non sono uguali. La stringa di formato standard "R" per restituire una stringa di risultato che consente di visualizzare tutte le cifre significative di ogni valore Double mostra che il secondo valore è.0000000000001 minore rispetto alla prima.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 Nei casi in cui è probabile che influiscono sul risultato di un confronto di una perdita di precisione, è possibile adottare una delle alternative seguenti per chiamare il <xref:System.Double.Equals%2A> o <xref:System.Double.CompareTo%2A> metodo:  
  
-   Chiamare il <xref:System.Math.Round%2A?displayProperty=nameWithType> metodo per assicurarsi che entrambi i valori hanno la stessa precisione. L'esempio seguente modifica un esempio precedente per usare questo approccio, in modo che due valori frazionari sono equivalenti.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Si noti tuttavia che il problema di precisione sono ancora valide per l'arrotondamento dei valori punto intermedio. Per altre informazioni, vedere il metodo <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Test di uguaglianza approssimativo anziché l'uguaglianza. Ciò richiede la definizione di entrambe assoluto quantità mediante il quale i due valori possono differire ma ancora essere uguale o che si definiscono una relativa quantità mediante il quale il valore più piccolo possibile divergono dal valore più grande.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> In alcuni casi viene utilizzata come misura della distanza tra due assoluta <xref:System.Double> valori durante la verifica dell'uguaglianza.  Tuttavia <xref:System.Double.Epsilon?displayProperty=nameWithType> misura il valore più piccolo che può essere aggiunto a o sottratto da, un <xref:System.Double> il cui valore è uguale a zero. Per la maggior parte delle positivo e negativo <xref:System.Double> valori, il valore di <xref:System.Double.Epsilon?displayProperty=nameWithType> è troppo piccolo per essere rilevato. Pertanto, tranne i valori che sono pari a zero, non è consigliabile l'uso nei test per verificarne l'uguaglianza.  
  
     L'esempio seguente usa il secondo approccio per definire un `IsApproximatelyEqual` metodo che verifica la relativa differenza tra due valori. Anche di mette a confronto i risultati di chiamate per il `IsApproximatelyEqual` metodo e il <xref:System.Double.Equals%28System.Double%29> (metodo).  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Le eccezioni e valori a virgola mobile  
 A differenza delle operazioni con tipi integrali, che generano eccezioni in caso di overflow o di operazioni non valide, ad esempio divisione per zero, operazioni con i valori a virgola mobile non generano eccezioni. In alternativa, in situazioni eccezionali, il risultato di un'operazione a virgola mobile è zero, un numero infinito positivo, infinito negativo o non è un numero (NaN):  
  
-   Se il risultato di un'operazione a virgola mobile è troppo piccolo per il formato di destinazione, il risultato è zero. Ciò può verificarsi quando vengono moltiplicati due numeri molto piccoli, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   Se la grandezza del risultato dell'operazione a virgola mobile supera l'intervallo del formato di destinazione, il risultato dell'operazione è <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>, nel modo appropriato per il segno del risultato. Il risultato di un'operazione che causa l'overflow <xref:System.Double.MaxValue?displayProperty=nameWithType> viene <xref:System.Double.PositiveInfinity>e il risultato di un'operazione che causa l'overflow <xref:System.Double.MinValue?displayProperty=nameWithType> è <xref:System.Double.NegativeInfinity>, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> comporta anche da una divisione per zero con un dividendi positivi, e <xref:System.Double.NegativeInfinity> dà come risultato una divisione per zero con dividendo negativo.  
  
-   Se un'operazione a virgola mobile non è valida, il risultato dell'operazione è <xref:System.Double.NaN>. Ad esempio, <xref:System.Double.NaN> risultati dalle operazioni seguenti:  
  
    -   Divisione per zero con dividendo pari a zero. Si noti che gli altri casi di divisione per zero risultati in uno <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>.  
  
-   Qualsiasi operazione a virgola mobile con un input non valido. Ad esempio, si chiama il <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> metodo con un valore negativo viene restituito <xref:System.Double.NaN>, come avviene la chiamata il <xref:System.Math.Acos%2A?displayProperty=nameWithType> metodo con un valore maggiore di 1 o meno il valore uno negativo.  
  
-   Qualsiasi operazione con un argomento il cui valore è <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>Conversioni di tipi e la struttura Double  
 Il <xref:System.Double> struttura non definisce qualsiasi operatore di conversione esplicita o implicita, invece, le conversioni vengono implementate dal compilatore.  
  
 La conversione del valore di qualsiasi tipo numerico primitivo a un <xref:System.Double> è una conversione verso e pertanto non richiede un operatore cast esplicito o chiamare un metodo di conversione, a meno che un compilatore in modo esplicito lo richiede. Ad esempio, il compilatore c# richiede un operatore di cast per le conversioni da <xref:System.Decimal> a <xref:System.Double>, mentre il compilatore Visual Basic non. Nell'esempio seguente converte il valore minimo o massimo di altri tipi numerici primitivi in un <xref:System.Double>.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 Inoltre, il <xref:System.Single> i valori <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> convertire a <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, rispettivamente.  
  
 Si noti che la conversione del valore di alcuni tipi numeric a un <xref:System.Double> valore possa comportare una perdita di precisione. Come illustrato nell'esempio, una perdita di precisione viene possibile quando si convertono <xref:System.Decimal>, <xref:System.Int64>, <xref:System.Single>, e <xref:System.UInt64> valori <xref:System.Double> valori.  
  
 La conversione di un <xref:System.Double> valore su un valore di qualsiasi altro tipo di dati numerico primitivo è una conversione di narrowing e richiede un operatore di cast (in c#), un metodo di conversione (in Visual Basic) o una chiamata a un <xref:System.Convert> (metodo). Valori non compresi nell'intervallo del tipo di dati di destinazione, che sono definiti per il tipo di destinazione `MinValue` e `MaxValue` le proprietà, si comportano come illustrato nella tabella seguente.  
  
|Tipo di destinazione|Risultato|  
|-----------------|------------|  
|Qualsiasi tipo integrale|Un <xref:System.OverflowException> eccezione se la conversione viene eseguita in un contesto controllato.<br /><br /> Se la conversione viene eseguita in un contesto non verificato (impostazione predefinita in c#), l'operazione di conversione ha esito positivo ma il valore causa un overflow.|  
|<xref:System.Decimal>|Eccezione <xref:System.OverflowException>.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> per i valori negativi.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> per i valori positivi.|  
  
 È inoltre <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> generare un <xref:System.OverflowException> per le conversioni da valori integer in un contesto controllato, ma questi overflow di valori quando convertiti in numeri interi in un contesto non verificato. Per le conversioni verso <xref:System.Decimal>, genera sempre un' <xref:System.OverflowException>. Per le conversioni verso <xref:System.Single>, vengono convertite <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, rispettivamente.  
  
 Si noti che tramite la conversione può comportare una perdita di precisione un <xref:System.Double> valore a un altro tipo numerico. Nel caso di conversione non integrali <xref:System.Double> valori, come illustrato nell'output dell'esempio, il componente frazionario viene perso quando il <xref:System.Double> valore viene arrotondato (come in Visual Basic) o troncato (come in c#). Per le conversioni verso <xref:System.Decimal> e <xref:System.Single> valori, il <xref:System.Double> valore non può avere una rappresentazione esatta nel tipo di dati di destinazione.  
  
 L'esempio seguente converte un numero di <xref:System.Double> valori a diversi altri tipi numerici. Le conversioni si verificano in un contesto controllato in Visual Basic (predefinito) e nel linguaggio c# (perché il [controllato](~/docs/csharp/language-reference/keywords/checked.md) parola chiave). L'output dell'esempio mostra il risultato per le conversioni in sia selezionato un contesto non verificato. È possibile eseguire conversioni in un contesto non verificato in Visual Basic per la compilazione con il `/removeintchecks+` opzione del compilatore e nel linguaggio c# Commentando il `checked` istruzione.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 Per altre informazioni sulla conversione dei tipi numerici, vedere [conversione di tipi in .NET Framework](~/docs/standard/base-types/type-conversion.md) e [tabelle di conversione dei tipi](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Funzionalità a virgola mobile  
 Il <xref:System.Double> struttura e i tipi correlati forniscono metodi per eseguire operazioni nelle aree seguenti:  
  
-   **Confronto tra valori**. È possibile chiamare il <xref:System.Double.Equals%2A> metodo per determinare se due <xref:System.Double> i valori sono uguali, oppure il <xref:System.Double.CompareTo%2A> metodo per stabilire la relazione tra due valori.  
  
     Il <xref:System.Double> struttura supporta anche un set completo di operatori di confronto. Ad esempio, è possibile di test per verificarne l'uguaglianza o disuguaglianza, o determinare se un valore è maggiore o uguale a un altro. Se uno degli operandi è un tipo numerico diverso da un <xref:System.Double>, viene convertito in un <xref:System.Double> prima di eseguire il confronto.  
  
    > [!WARNING]
    >  A causa delle differenze nella precisione, due <xref:System.Double> valori che si prevedono di essere uguali potrebbero risultare venga fatta, che influisce sul risultato del confronto. Vedere le [test dell'uguaglianza](#Equality) sezione per altre informazioni sul confronto tra due <xref:System.Double> valori.  
  
     È inoltre possibile chiamare il <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, e <xref:System.Double.IsNegativeInfinity%2A> metodi da testare per questi valori speciali.  
  
-   **Operazioni matematiche**. Operazioni aritmetiche comuni, ad esempio addizione, sottrazione, moltiplicazione e divisione, vengono implementate da compilatori di linguaggio e istruzioni Common Intermediate Language (CIL), anziché <xref:System.Double> metodi. Se uno degli operandi in un'operazione matematica è un tipo numerico diverso da un <xref:System.Double>, viene convertito in un <xref:System.Double> prima di eseguire l'operazione. Il risultato dell'operazione è anche un <xref:System.Double> valore.  
  
     Altre operazioni matematiche possono essere eseguite tramite la chiamata `static` (`Shared` in Visual Basic) in metodi di <xref:System.Math?displayProperty=nameWithType> classe. Include metodi aggiuntivi aritmetici più utilizzati (come <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, e <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), geometry (, ad esempio <xref:System.Math.Cos%2A?displayProperty=nameWithType> e <xref:System.Math.Sin%2A?displayProperty=nameWithType>) e calcolo (ad esempio <xref:System.Math.Log%2A?displayProperty=nameWithType>).  
  
     È inoltre possibile modificare i singoli bit di un <xref:System.Double> valore. Il <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> metodo mantiene un <xref:System.Double> schema di valore del bit in un integer a 64 bit. Il <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> metodo restituisce il modello di bit in una matrice di byte.  
  
-   **Arrotondamento**. Arrotondamento viene spesso usato come una tecnica per ridurre l'impatto delle differenze tra i valori causati da problemi di rappresentazione a virgola mobile e precisione. È possibile arrotondare un <xref:System.Double> valore chiamando il <xref:System.Math.Round%2A?displayProperty=nameWithType> (metodo).  
  
-   **Formattazione**. È possibile convertire un <xref:System.Double> valore alla relativa rappresentazione di stringa chiamando il <xref:System.Double.ToString%2A> metodo oppure usando la funzionalità di formattazione composita. Per informazioni sul modo in cui le stringhe di formato controllano la rappresentazione di stringa dei valori a virgola mobile, vedere la [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md) argomenti.  
  
-   **Analisi di stringhe**. È possibile convertire la rappresentazione di stringa del valore a virgola mobile a un <xref:System.Double> valore chiamando il <xref:System.Double.Parse%2A> o <xref:System.Double.TryParse%2A> (metodo). Se l'operazione di analisi non riesce, il <xref:System.Double.Parse%2A> metodo genera un'eccezione, mentre la <xref:System.Double.TryParse%2A> restituzione del metodo `false`.  
  
-   **Conversione del tipo**. Il <xref:System.Double> struttura fornisce un'implementazione esplicita dell'interfaccia per il <xref:System.IConvertible> interfaccia, che supporta la conversione tra qualsiasi due tipi di dati .NET Framework standard. I compilatori di linguaggio supportano anche la conversione implicita di valori di tutti gli altri tipi numerici standard per <xref:System.Double> valori. Conversione di un valore di qualsiasi tipo numerico standard per un <xref:System.Double> è una conversione verso e non richiede l'utente di un metodo di conversione o di operatore di cast,  
  
     Tuttavia, la conversione dei <xref:System.Int64> e <xref:System.Single> valori possono comportare una perdita di precisione. Nella tabella seguente sono elencate le differenze di precisione per ognuno di questi tipi:  
  
    |Tipo|Precisione massima|Precisione interna|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 cifre decimali|19 cifre decimali|  
    |<xref:System.Single>|7 cifre decimali|9 cifre decimali|  
  
     Il problema di precisione più di frequente riguarda <xref:System.Single> i valori che vengono convertiti in <xref:System.Double> valori. Nell'esempio seguente, due valori prodotti da operazioni di divisione identiche sono diversi perché uno dei valori è un valore in virgola mobile e precisione singola convertito in un <xref:System.Double>.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tutti i membri di questo tipo sono thread-safe. I membri che sembrano modificare lo stato dell'istanza è in realtà restituiscono una nuova istanza inizializzata con il nuovo valore. Come con qualsiasi altro tipo, la lettura e scrittura in una variabile condivisa che contiene un'istanza di questo tipo deve essere protetto da un blocco per garantire la thread safety.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta questa istanza con un oggetto specificato o un oggetto <see cref="T:System.Double" /> e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore rispetto al valore dell'oggetto specificato o dell'oggetto <see cref="T:System.Double" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Numero a virgola mobile a precisione doppia da confrontare.</param>
        <summary>Confronta questa istanza con un numero a virgola mobile e precisione doppia specificato e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore del valore del numero a virgola mobile e precisione doppia specificato.</summary>
        <returns>Numero con segno che indica i valori relativi di questa istanza e di <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valore restituito  </term><description> Descrizione  </description></listheader><item><term> Minore di zero  </term><description> L'istanza è minore di <paramref name="value" />.  -o-  L'istanza non è un numero (<see cref="F:System.Double.NaN" />) e <paramref name="value" /> è un numero.  </description></item><item><term> Zero  </term><description> L'istanza è uguale a <paramref name="value" />.  -o-  L'istanza e <paramref name="value" /> non sono un numero (<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" />, o <see cref="F:System.Double.NegativeInfinity" />.  </description></item><item><term> Maggiore di zero  </term><description> L'istanza è maggiore di <paramref name="value" />.  - o - L'istanza è un numero e <paramref name="value" /> non è un numero (<see cref="F:System.Double.NaN" />).  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori devono essere identici per essere considerate uguali. In particolare quando i valori a virgola mobile dipendono da più operazioni matematiche, è comune per la perdita di precisione e i relativi valori essere quasi identici tranne che per le cifre meno significative. Per questo motivo, il valore restituito del <xref:System.Double.CompareTo%2A> metodo può a volte sembrare sorprendente. Moltiplicazione per un particolare valore seguito da una divisione per lo stesso valore, ad esempio, deve produrre il valore originale. Nell'esempio seguente, tuttavia, il valore calcolato risulta maggiore del valore originale. Visualizzazione di tutte le cifre significative dei due valori mediante "R" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md) indica che il valore calcolato è diverso dal valore originale in relative cifre meno significative. Per informazioni sulla gestione di questi confronti, vedere la sezione Osservazioni del <xref:System.Double.Equals%28System.Double%29> (metodo).  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 Questo metodo implementa il <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia ed esegue leggermente migliori rispetto il <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> metodo perché non è necessario convertire il `value` parametro a un oggetto.  
  
 Si noti che, anche se un oggetto il cui valore è <xref:System.Double.NaN> non viene considerato uguale a un altro oggetto il cui valore è <xref:System.Double.NaN> (anche se stesso), il <xref:System.IComparable%601> che richiede l'interfaccia `A.CompareTo(A)` restituiscono zero.  
  
## <a name="widening-conversions"></a>conversioni verso un tipo di dati più grande  
 A seconda del linguaggio di programmazione, potrebbe essere possibile codificare una <xref:System.Double.CompareTo%2A> metodo in cui il tipo di parametro ha un minor numero di bit (è più stretta) rispetto al tipo di istanza. Questo è possibile perché alcuni linguaggi di programmazione eseguono conversioni implicite che rappresenta il parametro come un tipo con il numero di bit dell'istanza.  
  
 Ad esempio, si supponga che il tipo di istanza sia <xref:System.Double> e il tipo di parametro è <xref:System.Int32>. Il compilatore Microsoft c# genera le istruzioni per rappresentare il valore del parametro come un <xref:System.Double> , quindi genera un <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> metodo che confronta i valori dell'istanza e la rappresentazione ampliata del parametro.  
  
 Consultare la documentazione del linguaggio di programmazione per determinare se il compilatore esegue conversioni di ampliamento implicite dei tipi numerici. Per altre informazioni, vedere la [tabelle di conversione dei tipi](~/docs/standard/base-types/conversion-tables.md) argomento.  
  
## <a name="precision-in-comparisons"></a>Precisione nei confronti  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto di due numeri particolari potrebbe cambiare tra versioni diverse di .NET Framework dal momento che la precisione della rappresentazione interna dei numeri.  
  
   
  
## Examples  
 Esempio di codice seguente illustra le versioni generiche e del <xref:System.Double.CompareTo%2A> metodo per diversi tipi di riferimento e valore.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da confrontare o <see langword="null" />.</param>
        <summary>Confronta questa istanza con un oggetto specificato e restituisce un intero che indica se il valore di questa istanza è minore, uguale o maggiore rispetto al valore dell'oggetto specificato.</summary>
        <returns>Numero con segno che indica i valori relativi di questa istanza e di <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valore  </term><description> Descrizione  </description></listheader><item><term> Un intero negativo  </term><description> L'istanza è minore di <paramref name="value" />.  - oppure - L'istanza non è un numero (<see cref="F:System.Double.NaN" />) e <paramref name="value" /> è un numero.  </description></item><item><term> Zero  </term><description> L'istanza è uguale a <paramref name="value" />.  - oppure -  L'istanza e <paramref name="value" /> sono entrambi <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Un intero positivo  </term><description> L'istanza è maggiore di <paramref name="value" />.  - oppure -  L'istanza è un numero e <paramref name="value" /> non è un numero (<see cref="F:System.Double.NaN" />).  - oppure -  <paramref name="value" /> è <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` il parametro deve essere `null` o un'istanza di `Double`; in caso contrario, viene generata un'eccezione. Qualsiasi istanza di <xref:System.Double>, indipendentemente dal relativo valore, viene considerato maggiore `null`.  
  
 I valori devono essere identici per essere considerate uguali. In particolare quando i valori a virgola mobile dipendono da più operazioni matematiche, è comune per la perdita di precisione e i relativi valori essere quasi identici tranne che per le cifre meno significative. Per questo motivo, il valore restituito del <xref:System.Double.CompareTo%2A> metodo può a volte sembrare sorprendente. Moltiplicazione per un particolare valore seguito da una divisione per lo stesso valore, ad esempio, deve produrre il valore originale. Nell'esempio seguente, tuttavia, il valore calcolato risulta maggiore del valore originale. Visualizzazione di tutte le cifre significative dei due valori mediante "R" [stringa di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md) indica che il valore calcolato è diverso dal valore originale in relative cifre meno significative. Per informazioni sulla gestione di questi confronti, vedere la sezione Osservazioni del <xref:System.Double.Equals%28System.Double%29> (metodo).  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 Questo metodo viene implementato per supportare il <xref:System.IComparable> interfaccia. Si noti che, sebbene una <xref:System.Double.NaN> non è considerato uguale a un altro <xref:System.Double.NaN> (anche se stesso), il <xref:System.IComparable> che richiede l'interfaccia `A.CompareTo(A)` restituiscono zero.  
  
## <a name="precision-in-comparisons"></a>Precisione nei confronti  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto di due numeri particolari potrebbe cambiare tra versioni diverse di .NET Framework dal momento che la precisione della rappresentazione interna dei numeri.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di `CompareTo` nel contesto di `Double`.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> non è un oggetto <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>Rappresenta il valore <see cref="T:System.Double" /> positivo più piccolo maggiore di zero. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore della <xref:System.Double.Epsilon> proprietà riflette il valore positivo più piccolo <xref:System.Double> valore significativo nelle operazioni numeriche o confronti quando il valore della <xref:System.Double> istanza è uguale a zero. Ad esempio, il codice seguente mostra che zero e <xref:System.Double.Epsilon> sono considerati uguali ai valori, mentre zero e la metà del valore di <xref:System.Double.Epsilon> sono considerati uguali.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 Più precisamente, mobile punto formato è costituito da un segno, una mantissa a 52 bit o significando e un esponente a 11 bit. Come illustrato nell'esempio seguente, zero ha un esponente di -1022 e una mantissa pari a 0. <xref:System.Double.Epsilon> ha un esponente di -1022 e una mantissa a 1. Ciò significa che <xref:System.Double.Epsilon> è positivo più piccolo <xref:System.Double> il valore maggiore di zero e rappresenta il valore minimo possibile e l'incremento più piccolo possibile per un <xref:System.Double> cui esponente è -1022.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 Tuttavia, il <xref:System.Double.Epsilon> proprietà non è una misura generale della precisione del <xref:System.Double> digitare; viene applicato solo ai <xref:System.Double> istanze con un valore pari a zero o un esponente di -1022.  
  
> [!NOTE]
>  Il valore della <xref:System.Double.Epsilon> proprietà non è equivalente alla epsilon macchina, che rappresenta il limite superiore dell'errore relativo a causa di arrotondamento in aritmetica a virgola mobile.  
  
 Il valore di questa costante è da 4, 94065645841247E-324.  
  
 Due numeri a virgola mobile apparentemente equivalenti potrebbero non risultare uguali a causa delle differenze nelle cifre meno significative. Ad esempio, l'espressione c#, `(double)1/3 == (double)0.33333`, non risulta uguale perché l'operazione di divisione sul lato sinistro ha la precisione massima, mentre la costante sul lato destro è precisa solo alle cifre specificate. Se si crea un algoritmo personalizzato che determina se due numeri a virgola mobile possono essere considerati uguali, non è consigliabile basare sul valore dell'algoritmo di <xref:System.Double.Epsilon> costante per stabilire il margine di differenza per assoluto accettabile i due valori per essere considerate uguali.  (In genere, il margine di differenza è notevolmente maggiore <xref:System.Double.Epsilon>.) Per informazioni sul confronto tra due valori a virgola mobile a precisione doppia, vedere <xref:System.Double> e <xref:System.Double.Equals%28System.Double%29>.  
  
## <a name="platform-notes"></a>Note sulla piattaforma  
 Nei sistemi ARM, il valore della <xref:System.Double.Epsilon> costante è troppo piccolo per essere rilevato, in modo che equivale a zero. È possibile definire un valore alternativo epsilon uguale a 2,2250738585072014E-308 invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se due istanze di <see cref="T:System.Double" /> rappresentano lo stesso valore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto <see cref="T:System.Double" /> da confrontare con l'istanza.</param>
        <summary>Restituisce un valore che indica se l'istanza e un oggetto <see cref="T:System.Double" /> specificato rappresentano lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> è uguale all'istanza. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il <xref:System.IEquatable%601?displayProperty=nameWithType> interfaccia le prestazioni leggermente migliori rispetto <xref:System.Double.Equals%2A> perché non è necessario convertire il `obj` parametro a un oggetto.  
  
## <a name="widening-conversions"></a>conversioni verso un tipo di dati più grande  
 A seconda del linguaggio di programmazione, potrebbe essere possibile codificare una <xref:System.Double.Equals%2A> metodo in cui il tipo di parametro ha un minor numero di bit (è più stretta) rispetto al tipo di istanza. Questo è possibile perché alcuni linguaggi di programmazione eseguono conversioni implicite che rappresenta il parametro come un tipo con il numero di bit dell'istanza.  
  
 Ad esempio, si supponga che il tipo di istanza sia <xref:System.Double> e il tipo di parametro è <xref:System.Int32>. Il compilatore Microsoft c# genera le istruzioni per rappresentare il valore del parametro come un <xref:System.Double> , quindi genera un <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> metodo che confronta i valori dell'istanza e la rappresentazione ampliata del parametro.  
  
 Consultare la documentazione del linguaggio di programmazione per determinare se il compilatore esegue conversioni di ampliamento implicite dei tipi numerici. Per altre informazioni, vedere la [tabelle di conversione dei tipi](~/docs/standard/base-types/conversion-tables.md) argomento.  
  
## <a name="precision-in-comparisons"></a>Precisione nei confronti  
 Il <xref:System.Double.Equals%2A> metodo deve essere utilizzato con cautela, perché due valori apparentemente equivalenti possono essere diversi a causa di diversa precisione tra due valori. L'esempio seguente segnala che il <xref:System.Double> valore.333333 e <xref:System.Double> valore restituito dalla divisione di 1 di 3 non sono uguali.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 Invece di confronto di uguaglianza, una tecnica che definisca un margine accettabile relativo di differenza tra due valori (ad esempio. % 001 di uno dei valori). Se il valore assoluto della differenza tra i due valori è minore o uguale a margine, la differenza è probabilmente a causa delle differenze nella precisione e, di conseguenza, i valori possono risultare uguali. L'esempio seguente usa questa tecnica per confrontare.33333 e 1 o 3, i due <xref:System.Double> valori che è disponibile l'esempio di codice precedente venga fatta. In questo caso, i valori sono uguali.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  In quanto <xref:System.Double.Epsilon> definisce l'espressione minimo di un valore positivo con un intervallo è prossimo a zero, il margine di differenza tra due valori analoghi deve essere maggiore <xref:System.Double.Epsilon>. In genere, è notevolmente maggiore <xref:System.Double.Epsilon>. Per questo motivo, è consigliabile non utilizzare <xref:System.Double.Epsilon> quando si confrontano <xref:System.Double> i valori per verificarne l'uguaglianza.  
  
 Una seconda tecnica prevede la differenza tra due numeri a virgola mobile con un valore assoluto. Se la differenza è minore o uguale al valore assoluto, i numeri sono uguali. Se è maggiore, i numeri non sono uguali. Un'alternativa consiste nel selezionare in modo arbitrario un valore assoluto. Questo rappresenta un problema, tuttavia, poiché un margine accettabile di differenza dipende dalla grandezza del <xref:System.Double> valori. Un'alternativa di secondo si avvale di una funzionalità di progettazione nel formato a virgola mobile: la differenza tra la rappresentazione in integer dei due valori a virgola mobile e indica il numero di possibili valori a virgola mobile che separa le loro. Ad esempio, la differenza tra 0,0 e <xref:System.Double.Epsilon> è 1, in quanto <xref:System.Double.Epsilon> è il più piccolo valore rappresentabile, quando si lavora con un <xref:System.Double> il cui valore è uguale a zero. L'esempio seguente usa questa tecnica per confrontare.33333 e 1 o 3, che sono illustrati i due <xref:System.Double> i valori che l'esempio di codice precedente con il <xref:System.Double.Equals%28System.Double%29> trovato metodo venga fatta. Si noti che nell'esempio viene usato il <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> metodo per convertire un valore a virgola mobile a precisione doppia alla relativa rappresentazione in integer.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto di due numeri particolari potrebbe cambiare tra versioni diverse di .NET Framework dal momento che la precisione della rappresentazione interna dei numeri.  
  
 Se due <xref:System.Double.NaN?displayProperty=nameWithType> i valori vengono testati per verificare l'uguaglianza chiamando il <xref:System.Double.Equals%2A> metodo, il metodo restituisce `true`. Tuttavia, se due <xref:System.Double.NaN> i valori vengono testati per verificare l'uguaglianza con l'operatore di uguaglianza, l'operatore restituisce `false`. Quando si desidera determinare se il valore di una <xref:System.Double> non è un numero (NaN), un'alternativa consiste nel chiamare il <xref:System.Double.IsNaN%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Risoluzione dell'overload del compilatore può tenere conto un'apparente differenza nel comportamento dei due <see cref="M:System.Double.Equals(System.Object)" /> overload del metodo. Se una conversione implicita tra il <paramref name="obj" /> argomento e una <see cref="T:System.Double" /> viene definito e l'argomento non è tipizzato come un <see cref="T:System.Object" />, i compilatori possono eseguire una conversione implicita e chiamare il <see cref="M:System.Double.Equals(System.Double)" /> (metodo). In caso contrario, che chiamano il <see cref="M:System.Double.Equals(System.Object)" /> metodo, che restituisce sempre <see langword="false" /> se relativi <paramref name="obj" /> argomento non è un <see cref="T:System.Double" /> valore. Nell'esempio seguente viene illustrata la differenza nel comportamento tra i due overload. Nel caso di tutti i tipi numerici primitivi, ad eccezione di <see cref="T:System.Decimal" /> e nel linguaggio c#, restituisce il primo confronto <see langword="true" /> perché il compilatore esegue automaticamente una conversione verso e chiama il <see cref="M:System.Double.Equals(System.Double)" /> (metodo), mentre il secondo confronto Restituisce <see langword="false" /> perché il compilatore chiama il <see cref="M:System.Double.Equals(System.Object)" /> (metodo).  [! code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con l'istanza.</param>
        <summary>Restituisce un valore che indica se questa istanza è uguale a un oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> è un'istanza di <see cref="T:System.Double" /> ed è uguale al valore dell'istanza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.Equals%2A> metodo deve essere utilizzato con cautela, perché due valori apparentemente equivalenti possono essere diversi a causa di diversa precisione tra due valori. L'esempio seguente segnala che il <xref:System.Double> valore.3333 e <xref:System.Double> restituito dalla divisione di 1 per 3 non sono uguali.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 Per alternative a chiamare il <xref:System.Double.Equals%2A> metodo, vedere la documentazione per il <xref:System.Double.Equals%28System.Double%29> overload.  
  
> [!NOTE]
>  In quanto <xref:System.Double.Epsilon> definisce l'espressione minimo di un valore positivo con un intervallo è prossimo a zero, il margine di differenza tra due valori analoghi deve essere maggiore <xref:System.Double.Epsilon>. In genere, è notevolmente maggiore <xref:System.Double.Epsilon>.  
  
 La precisione dei numeri a virgola mobile oltre la precisione documentata è specifica per l'implementazione e la versione di .NET Framework. Di conseguenza, un confronto di due numeri particolari potrebbe cambiare tra versioni diverse di .NET Framework dal momento che la precisione della rappresentazione interna dei numeri.  
  
 Se due <xref:System.Double.NaN?displayProperty=nameWithType> i valori vengono testati per verificare l'uguaglianza chiamando il <xref:System.Double.Equals%2A> metodo, il metodo restituisce `true`. Tuttavia, se due <xref:System.Double.NaN> i valori vengono testati per verificare l'uguaglianza con l'operatore di uguaglianza, l'operatore restituisce `false`. Quando si desidera determinare se il valore di una <xref:System.Double> non è un numero (NaN), un'alternativa consiste nel chiamare il <xref:System.Double.IsNaN%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Risoluzione dell'overload del compilatore può tenere conto un'apparente differenza nel comportamento dei due <see cref="M:System.Double.Equals(System.Object)" /> overload del metodo. Se una conversione implicita tra il <paramref name="obj" /> argomento e una <see cref="T:System.Double" /> viene definito e l'argomento non è tipizzato come un <see cref="T:System.Object" />, i compilatori possono eseguire una conversione implicita e chiamare il <see cref="M:System.Double.Equals(System.Double)" /> (metodo). In caso contrario, che chiamano il <see cref="M:System.Double.Equals(System.Object)" /> metodo, che restituisce sempre <see langword="false" /> se relativi <paramref name="obj" /> argomento non è un <see cref="T:System.Double" /> valore. Nell'esempio seguente viene illustrata la differenza nel comportamento tra i due overload. Nel caso di tutti i tipi numerici primitivi, ad eccezione di <see cref="T:System.Decimal" /> e nel linguaggio c#, restituisce il primo confronto <see langword="true" /> perché il compilatore esegue automaticamente una conversione verso e chiama il <see cref="M:System.Double.Equals(System.Double)" /> (metodo), mentre il secondo confronto Restituisce <see langword="false" /> perché il compilatore chiama il <see cref="M:System.Double.Equals(System.Object)" /> (metodo).  [! code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.TypeCode" /> del tipo di valore <see cref="T:System.Double" />.</summary>
        <returns>Costante enumerata <see cref="F:System.TypeCode.Double" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Numero a virgola mobile a precisione doppia.</param>
        <summary>Restituisce un valore che indica se il numero specificato restituisce l'infinito negativo o positivo</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> restituisce <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NegativeInfinity" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity> per segnalare una condizione di overflow.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Numero a virgola mobile a precisione doppia.</param>
        <summary>Restituisce un valore che indica se il valore specificato non è un numero (<see cref="F:System.Double.NaN" />).</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> restituisce un <see cref="F:System.Double.NaN" />. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Double.NaN> per segnalare che il risultato dell'operazione è non definito. Ad esempio, dividendo 0,0 da 0.0 comporta <xref:System.Double.NaN>.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A> Restituisce `false` se un <xref:System.Double> il valore è <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>. Per verificare questi valori, usare il <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, e <xref:System.Double.IsNegativeInfinity%2A> metodi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Numero a virgola mobile a precisione doppia.</param>
        <summary>Restituisce un valore che indica se il numero specificato restituisce l'infinito negativo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> restituisce un <see cref="F:System.Double.NegativeInfinity" />. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Double.NegativeInfinity> per segnalare una condizione di overflow.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Numero a virgola mobile a precisione doppia.</param>
        <summary>Restituisce un valore che indica se il numero specificato restituisce l'infinito positivo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> restituisce un <see cref="F:System.Double.PositiveInfinity" />. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni a virgola mobile restituiscono <xref:System.Double.PositiveInfinity> per segnalare una condizione di overflow.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Rappresenta il valore massimo possibile di <see cref="T:System.Double" />. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è 1,7976931348623157E+308 positivo.  
  
 Il risultato di un'operazione che supera <xref:System.Double.MaxValue?displayProperty=nameWithType> è <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. Nell'esempio riportato di seguito <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> risultati dalle operazioni di addizione e moltiplicazione elevamento a potenza quando il risultato supera <xref:System.Double.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Rappresenta il valore minimo possibile di un oggetto <see cref="T:System.Double" />. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è 1,7976931348623157E+308 negativo.  
  
 Il risultato di un'operazione che è minore di <xref:System.Double.MinValue?displayProperty=nameWithType> è <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Nell'esempio riportato di seguito <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> risultante dalla sottrazione e moltiplicazione operazioni quando il risultato è minore di <xref:System.Double.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Rappresenta un valore che non è un numero (<see langword="NaN" />). Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Restituisce un metodo o un operatore <xref:System.Double.NaN> quando il risultato di un'operazione è indefinito. Ad esempio, il risultato della divisione zero da zero è <xref:System.Double.NaN>, come illustrato nell'esempio seguente. (Ma si noti che un numero diverso da zero di divisione per zero restituisce uno <xref:System.Double.PositiveInfinity> o <xref:System.Double.NegativeInfinity>, in base al segno del divisore.)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 Inoltre, di chiamare un metodo con un <xref:System.Double.NaN> valore o un'operazione su una <xref:System.Double.NaN> valore restituisce <xref:System.Double.NaN>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 Usare il <xref:System.Double.IsNaN%2A> metodo per determinare se un valore non è un numero. Il <xref:System.Double.op_Equality%2A> operatore prende in considerazione due <xref:System.Double.NaN> i valori siano diversi tra loro. In generale, <xref:System.Double> operatori non possono essere utilizzati per confrontare <xref:System.Double.NaN?displayProperty=nameWithType> con altre <xref:System.Double> i valori, anche se i metodi di confronto (ad esempio <xref:System.Double.Equals%2A> e <xref:System.Double.CompareTo%2A>) possono. Nell'esempio seguente viene illustrata la differenza nel comportamento tra <xref:System.Double> metodi e gli operatori di confronto.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato l'utilizzo di <xref:System.Double.NaN>:  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Rappresenta l'infinito negativo. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è il risultato della divisione di un numero negativo per zero.  
  
 Questa costante viene restituita quando il risultato di un'operazione è minore di <xref:System.Double.MinValue>.  
  
 Usare <xref:System.Double.IsNegativeInfinity%2A> per determinare se un valore restituisce l'infinito negativo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se due valori <see cref="T:System.Double" /> specificati sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_Equality%2A> metodo consente di definire l'operatore di uguaglianza per <xref:System.Double> valori.  
  
 Se due <xref:System.Double.NaN?displayProperty=nameWithType> i valori vengono testati per verificare l'uguaglianza con l'operatore di uguaglianza, il risultato è `false`; due <xref:System.Double.NaN?displayProperty=nameWithType> valori non vengono considerati uguali. Se sono sono testati per verificare l'uguaglianza chiamando il <xref:System.Double.Equals%2A> metodo, il risultato è `true`.  Quando si desidera determinare se il valore di una <xref:System.Double> non è un numero (NaN), un'alternativa consiste nel chiamare il <xref:System.Double.IsNaN%2A> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Double" />specificato è maggiore di un altro valore <see cref="T:System.Double" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_GreaterThan%2A> metodo consente di definire l'operazione di maggiore-operatore per <xref:System.Double> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Double" /> specificato è maggiore o uguale a un altro valore <see cref="T:System.Double" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è maggiore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_GreaterThanOrEqual%2A> metodo consente di definire il funzionamento dell'operatore di maggiore-than-or-equal per <xref:System.Double> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se due valori <see cref="T:System.Double" /> specificati non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> non sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_Inequality%2A> metodo consente di definire l'operatore di disuguaglianza per <xref:System.Double> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se il valore <see cref="T:System.Double" /> specificato è minore o uguale a un altro valore <see cref="T:System.Double" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore di <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_LessThan%2A> metodo consente di definire l'operazione di minore di-operatore per <xref:System.Double> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Primo valore da confrontare.</param>
        <param name="right">Secondo valore da confrontare.</param>
        <summary>Restituisce un valore che indica se un valore <see cref="T:System.Double" /> specificato è minore o uguale a un altro valore <see cref="T:System.Double" /> specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è minore o uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.op_LessThanOrEqual%2A> metodo definisce il funzionamento dell'operatore minore di-than-or-equal per <xref:System.Double> valori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte la rappresentazione di stringa di un numero nel rispettivo numero a virgola mobile e precisione doppia equivalente.</summary>
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <summary>Converte la rappresentazione di stringa di un numero nel rispettivo numero a virgola mobile e precisione doppia equivalente.</summary>
        <returns>Numero a virgola mobile a precisione doppia equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `s` parametro può contenere le impostazioni cultura correnti <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>, o una stringa nel formato:  
  
 [*ws*] [*sign*] [*cifre integrali*[*,*]]*cifre integrali*[*.* [*cifre frazionarie*]] [E [*sign*]*esponenziale cifre*] [*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti.|  
|*sign*|Simbolo di segno negativo (-) o un simbolo di segno positivo (+). Può essere usato solo un segno iniziale.|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Viene eseguito *cifre integrali* possono essere partizionati da un simbolo di separatore di gruppi. In alcune impostazioni cultura, ad esempio, una virgola (,) separa i gruppi di migliaia. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.|  
|,|Impostazioni cultura specifiche migliaia simbolo del separatore.|  
|.|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero.|  
|E|Il "e" o un carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Il `s` parametro viene interpretato mediante una combinazione del <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag. Ciò significa che lo spazio vuoto e migliaia sono consentiti separatori, ad esempio, sebbene non siano simboli di valuta. Per maggiore certezza che lo stile di elementi consentiti negli `s` per l'operazione di analisi abbia esito positivo, chiamare il <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> o il <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 Il `s` parametro viene interpretato utilizzando le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto inizializzato per impostazioni cultura del thread corrente. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Per analizzare una stringa usando le informazioni di formattazione di altre impostazioni cultura, chiamare il <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> o <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (metodo).  
  
 In genere, se si passa il <xref:System.Double.Parse%2A?displayProperty=nameWithType> una stringa che viene creato chiamando il metodo di <xref:System.Double.ToString%2A?displayProperty=nameWithType> metodo, l'originale <xref:System.Double> valore viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di uno <xref:System.Double.MinValue> oppure <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e i separatori di gruppi sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un gruppo separatore. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato l'utilizzo del metodo <xref:System.Double.Parse%28System.String%29>.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non rappresenta un numero in un formato valido.</exception>
        <exception cref="T:System.OverflowException">L'oggetto <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che indica gli elementi di stile che possono essere presenti in <c>s</c>. Un valore tipico da specificare è una combinazione di <see cref="F:System.Globalization.NumberStyles.Float" /> e <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato nel rispettivo numero a virgola mobile e precisione doppia equivalente.</summary>
        <returns>Numero a virgola mobile a precisione doppia equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `style` parametro definisce gli elementi di stile (ad esempio gli spazi vuoti, migliaia separatori e i simboli di valuta) che sono consentiti nel `s` parametro per l'operazione di analisi abbia esito positivo. Deve essere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. Nell'esempio <xref:System.Globalization.NumberStyles> membri non sono supportati:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Il `s` parametro può contenere le impostazioni cultura correnti <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>. A seconda del valore di `style`, possono anche assumere la forma:  
  
 [*ws*] [*$*] [*sign*] [*cifre integrali*[*,*]]* cifre integrali*[*.* [*cifre frazionarie*]] [E [*sign*]*esponenziale cifre*] [*ws*]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti. Gli spazi vuoti possono essere visualizzati all'inizio di `s` se `style` include le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag che possono essere visualizzati alla fine del `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|$|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita per il <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> le proprietà delle impostazioni cultura correnti. Simbolo di valuta di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Simbolo di segno negativo (-) o un simbolo di segno positivo (+). Il segno può essere visualizzati all'inizio del `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati in fondo `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `s` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.|  
|,|Un separatore di gruppi di impostazioni cultura specifiche. Separatore di gruppi di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag|  
|.|Simbolo di separatore decimale delle impostazioni cultura specifiche. Simbolo di separatore decimale di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero. Cifre frazionarie visualizzabili nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|E|Il "e" o un carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `s` parametro può rappresentare un numero in notazione esponenziale se `style` include il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Una stringa che contiene solo cifre (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) sempre viene analizzata correttamente. I rimanenti <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membri controllano gli elementi che possono essere presenti, ma non devono essere presenti, nella stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> flag hanno effetto sugli elementi che possono essere presenti in `s`.  
  
|Valore NumberStyles|Elementi consentiti in `s` oltre alle cifre|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre integrali* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale (*.*) e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il "e" o un carattere "E, che indica la notazione esponenziale". Questo flag di per sé supporta i valori nel formato *cifre*elettronica*cifre*; altri flag sono necessari per analizzare correttamente le stringhe con tali elementi come segno positivo o negativo e simboli del separatore decimale.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Migliaia elemento separatore (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|L'elemento di valuta ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `s` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* all'inizio o alla fine dell'elemento `s`, *sign* all'inizio del `s`e il simbolo di separatore decimale (.). Il `s` parametro anche possibile usare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, migliaia separatore (,) e gli elementi il separatore decimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `s` non può rappresentare un numero esadecimale.|  
  
 Il `s` parametro viene analizzato utilizzando le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto inizializzato per impostazioni cultura correnti del sistema. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 In genere, se si passa il <xref:System.Double.Parse%2A?displayProperty=nameWithType> una stringa che viene creato chiamando il metodo di <xref:System.Double.ToString%2A?displayProperty=nameWithType> metodo, l'originale <xref:System.Double> valore viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di uno <xref:System.Double.MinValue> oppure <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e i separatori di gruppi sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un gruppo separatore. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> per analizzare le rappresentazioni di stringa del metodo <xref:System.Double> i valori usando le impostazioni cultura en-US.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non rappresenta un numero in un formato valido.</exception>
        <exception cref="T:System.OverflowException">L'oggetto <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  -o-  <paramref name="style" /> include il valore <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="provider">Oggetto che offre informazioni di formattazione specifiche delle impostazioni cultura relative a <c>s</c>.</param>
        <summary>Converte la rappresentazione di stringa di un numero in un determinato formato specifico delle impostazioni cultura nel numero a virgola mobile e doppia precisione equivalente.</summary>
        <returns>Numero a virgola mobile a precisione doppia equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo di <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> metodo viene in genere utilizzato per convertire il testo che può essere formattato in svariati modi per un <xref:System.Double> valore. Ad esempio, può essere utilizzato per convertire il testo immesso dall'utente in una casella di testo HTML in un valore numerico.  
  
 Il `s` parametro viene interpretato mediante una combinazione del <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag. Il `s` parametro può contenere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> per le impostazioni cultura specificate da `provider`, oppure può contenere una stringa nel formato:  
  
 [*ws*] [*sign*]*cifre integrali*[*.* [*cifre frazionarie*]] [E [*sign*]*esponenziale cifre*] [*ws*]  
  
 Elementi facoltativi vengono racchiusi tra parentesi quadre ([e]). Gli elementi che contengono il termine "cifre" sono costituiti da una serie di caratteri numerici compresi tra 0 e 9.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti.|  
|*sign*|Simbolo di segno negativo (-) o un simbolo di segno positivo (+).|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Viene eseguito *cifre integrali* possono essere partizionati da un simbolo di separatore di gruppi. In alcune impostazioni cultura, ad esempio, una virgola (,) separa i gruppi di migliaia. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.|  
|.|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero.|  
|E|Il "e" o un carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Per altre informazioni sui formati numerici, vedere la [formattazione di tipi](~/docs/standard/base-types/formatting-types.md) argomento.  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce una <xref:System.Globalization.NumberFormatInfo> che fornisce informazioni specifiche delle impostazioni cultura utilizzate per interpretare il formato di `s`. Si tratta in genere, un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> oggetto. Se `provider` viene `null` o un <xref:System.Globalization.NumberFormatInfo> non è possibile ottenere le informazioni di formattazione per impostazioni cultura correnti del sistema viene usata.  
  
 In genere, se si passa il <xref:System.Double.Parse%2A?displayProperty=nameWithType> una stringa che viene creato chiamando il metodo di <xref:System.Double.ToString%2A?displayProperty=nameWithType> metodo, l'originale <xref:System.Double> valore viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di uno <xref:System.Double.MinValue> oppure <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e i separatori di gruppi sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un gruppo separatore. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L'esempio seguente è il gestore di eventi di un form Web click del pulsante. Usa la matrice restituita dal <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> proprietà per determinare le impostazioni locali dell'utente. Crea quindi un <xref:System.Globalization.CultureInfo> oggetto che corrisponde a tali impostazioni locali. Il <xref:System.Globalization.NumberFormatInfo> appartenente all'oggetto <xref:System.Globalization.CultureInfo> oggetto viene quindi passato al <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> input del metodo per convertire l'utente a un <xref:System.Double> valore.  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non rappresenta un numero in un formato valido.</exception>
        <exception cref="T:System.OverflowException">L'oggetto <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori di enumerazione che indica gli elementi di stile che possono essere presenti in <c>s</c>. Un valore tipico da specificare è <see cref="F:System.Globalization.NumberStyles.Float" /> combinato con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Oggetto che offre informazioni di formattazione specifiche delle impostazioni cultura relative a <c>s</c>.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato e in un formato specifico delle impostazioni cultura nel numero a virgola mobile e precisione doppia equivalente.</summary>
        <returns>Numero a virgola mobile a precisione doppia equivalente al valore numerico o al simbolo specificato in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `style` parametro definisce gli elementi di stile (ad esempio gli spazi vuoti, migliaia separatori e i simboli di valuta) che sono consentiti nel `s` parametro per l'operazione di analisi abbia esito positivo. Deve essere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. Nell'esempio <xref:System.Globalization.NumberStyles> membri non sono supportati:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Il `s` parametro può contenere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> per le impostazioni cultura specificate da `provider`. A seconda del valore di `style`, possono anche assumere la forma:  
  
 [*ws*] [*$*] [*sign*] [*cifre integrali*,]*cifre integrali*[. [ *cifre frazionarie*]] [E [*sign*]*cifre esponenziali*] [*ws*]  
  
 Elementi racchiusi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti. Gli spazi vuoti possono essere visualizzati all'inizio di `s` se `style` include le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag che possono essere visualizzati alla fine del `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|$|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita per il <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> le proprietà delle impostazioni cultura correnti. Simbolo di valuta di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Simbolo di segno negativo (-) o un simbolo di segno positivo (+). Il segno può essere visualizzati all'inizio del `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati in fondo `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `s` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Il *cifre integrali* elemento può essere assente se la stringa contiene la *cifre frazionarie* elemento.|  
|,|Un separatore di gruppi di impostazioni cultura specifiche. Separatore di gruppi di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag|  
|.|Simbolo di separatore decimale delle impostazioni cultura specifiche. Simbolo di separatore decimale di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero. Cifre frazionarie visualizzabili nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|E|Il "e" o un carattere "E", che indica che il valore è rappresentato nella notazione esponenziale (scientifica). Il `s` parametro può rappresentare un numero in notazione esponenziale se `style` include il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Una stringa che contiene solo cifre (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) sempre viene analizzata correttamente. I rimanenti <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membri controllano gli elementi che possono essere presenti, ma non devono essere presenti, nella stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> flag hanno effetto sugli elementi che possono essere presenti in `s`.  
  
|Valore NumberStyles|Elementi consentiti in `s` oltre alle cifre|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre integrali* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Il separatore decimale (*.*) e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il "e" o un carattere "E, che indica la notazione esponenziale". Questo flag di per sé supporta i valori nel formato *cifre*elettronica*cifre*; altri flag sono necessari per analizzare correttamente le stringhe con tali elementi come segno positivo o negativo e simboli del separatore decimale.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Migliaia elemento separatore (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|L'elemento di valuta ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti gli elementi. Tuttavia, `s` non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* all'inizio o alla fine dell'elemento `s`, *sign* all'inizio del `s`e il simbolo di separatore decimale (.). Il `s` parametro anche possibile usare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, migliaia separatore (,) e gli elementi il separatore decimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli elementi. Tuttavia, `s` non può rappresentare un numero esadecimale.|  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce una <xref:System.Globalization.NumberFormatInfo> che fornisce informazioni specifiche delle impostazioni cultura utilizzate per interpretare il formato di `s`. Si tratta in genere, un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> oggetto. Se `provider` viene `null` o un <xref:System.Globalization.NumberFormatInfo> non è possibile ottenere le informazioni di formattazione per impostazioni cultura correnti del sistema viene usata.  
  
 In genere, se si passa il <xref:System.Double.Parse%2A?displayProperty=nameWithType> una stringa che viene creato chiamando il metodo di <xref:System.Double.ToString%2A?displayProperty=nameWithType> metodo, l'originale <xref:System.Double> valore viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di uno <xref:System.Double.MinValue> oppure <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e i separatori di gruppi sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un gruppo separatore. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> metodo a cui assegnare diverse rappresentazioni di stringa dei valori di temperatura da un `Temperature` oggetto.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> non rappresenta un valore numerico.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  -o-  <paramref name="style" /> è il valore <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException">L'oggetto <paramref name="s" /> rappresenta un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Rappresenta l'infinito positivo. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è il risultato della divisione di un numero positivo per zero.  
  
 Questa costante viene restituita quando il risultato di un'operazione è maggiore di <xref:System.Double.MaxValue>.  
  
 Usare <xref:System.Double.IsPositiveInfinity%2A> per determinare se un valore restituisce l'infinito positivo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di <xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> se il valore dell'istanza corrente non è uguale a zero; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Questa conversione non è supportata. Il tentativo di usare questo metodo genera un'eccezione <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Questa conversione non è supportata. Non vengono restituiti valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Questa conversione non è supportata. Il tentativo di usare questo metodo genera un'eccezione <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Questa conversione non è supportata. Non vengono restituiti valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, invariato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Tipo nel quale convertire questo valore <see cref="T:System.Double" />.</param>
        <param name="provider">Implementazione <see cref="T:System.IFormatProvider" /> che fornisce informazioni specifiche delle impostazioni cultura sul formato del valore restituito.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'istanza corrente, convertito in <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Double> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore numerico dell'istanza nella rappresentazione di stringa equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte il valore numerico dell'istanza nella rappresentazione di stringa equivalente.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.ToString> formati del metodo un <xref:System.Double> valore il valore predefinito ("G" o generali) formato delle impostazioni cultura correnti. Se si desidera specificare un formato diverso, precisione o delle impostazioni cultura, usare gli altri overload del <xref:System.Double.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un formato specifico o precisione|Impostazioni cultura (corrente) predefinite|<xref:System.Double.ToString%28System.String%29>|  
|Un formato specifico o precisione|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una stringa nel formato:  
  
 cifre integrali [accesso] [. [ cifre frazionarie]] [esponenziale e [accesso] cifre]  
  
 Elementi facoltativi vengono racchiusi tra parentesi quadre ([e]). Gli elementi che contengono il termine "cifre" sono costituiti da una serie di caratteri numerici compresi tra 0 e 9. Gli elementi elencati nella tabella riportata di seguito sono supportati.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*sign*|Un segno negativo o un simbolo di segno positivo.|  
|*integral-digits*|Una serie di cifre che specifica la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|'*.*'|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di cifre che specifica la parte frazionaria del numero.|  
|«*elettronica*»|Un carattere minuscolo "e", che indica una notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di cifre che specifica un esponente.|  
  
 Alcuni esempi del valore restituito sono "100", "-123,456,789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" e "-Infinity".  
  
 .NET Framework fornisce supporto di formattazione completo, che è descritti più dettagliatamente nella formattazione negli argomenti seguenti:  
  
-   Per altre informazioni sugli identificatori di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per altre informazioni sulla formattazione, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 L'esempio seguente usa il valore predefinito <xref:System.Double.ToString?displayProperty=nameWithType> metodo per visualizzare le rappresentazioni di stringa di un numero di <xref:System.Double> valori.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo di <xref:System.Double.ToString%2A>.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore numerico di questa istanza nella rappresentazione di stringa equivalente usando le informazioni di formato specifiche delle impostazioni cultura.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza, in base a quanto specificato da <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.ToString%28System.IFormatProvider%29> formati del metodo un <xref:System.Double> valore il valore predefinito ("G" o generali) formato di una cultura specificata. Se si desidera specificare un formato diverso o delle impostazioni cultura, usare gli altri overload del <xref:System.Double.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Predefinito (corrente)|<xref:System.Double.ToString>|  
|Un formato specifico o precisione|Impostazioni cultura (corrente) predefinite|<xref:System.Double.ToString%28System.String%29>|  
|Un formato specifico o precisione|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una stringa nel formato:  
  
 cifre integrali [accesso] [. [ cifre frazionarie]] [esponenziale e [accesso] cifre]  
  
 Elementi facoltativi vengono racchiusi tra parentesi quadre ([e]). Gli elementi che contengono il termine "cifre" sono costituiti da una serie di caratteri numerici compresi tra 0 e 9. Gli elementi elencati nella tabella riportata di seguito sono supportati.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*sign*|Un segno negativo o un simbolo di segno positivo.|  
|*integral-digits*|Una serie di cifre che specifica la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|'*.*'|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di cifre che specifica la parte frazionaria del numero.|  
|«*elettronica*»|Un carattere minuscolo "e", che indica una notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di cifre che specifica un esponente.|  
  
 Alcuni esempi del valore restituito sono "100", "-123,456,789", "123.45 e + 6", "500", "3.1416", "600", "-0.123" e "-Infinity".  
  
 Questa istanza viene formattata con l'identificatore di formato numerico standard ("G").  
  
 .NET Framework fornisce supporto di formattazione completo, che è descritti più dettagliatamente nella formattazione negli argomenti seguenti:  
  
-   Per altre informazioni sugli identificatori di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per altre informazioni sulla formattazione, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto. In genere `provider` è un <xref:System.Globalization.CultureInfo> oggetto o un <xref:System.Globalization.NumberFormatInfo> oggetto. Il `provider` parametro fornisce le informazioni specifiche delle impostazioni cultura utilizzate nella formattazione. Se `provider` viene `null`, il valore restituito viene formattato con il <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti.  
  
   
  
## Examples  
 L'esempio seguente mostra la rappresentazione di stringa di due <xref:System.Double> i valori usando <xref:System.Globalization.CultureInfo> gli oggetti che rappresentano più impostazioni cultura diverse.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo di <xref:System.Double.ToString%2A>, accettando un <xref:System.String> e un <xref:System.IFormatProvider> come parametri.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato numerico.</param>
        <summary>Converte il valore numerico di questa istanza nell'equivalente rappresentazione di stringa usando il formato specificato.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza, in base a quanto specificato da <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.ToString%28System.String%29> formati del metodo un <xref:System.Double> valore in un formato specificato usando le convenzioni delle impostazioni cultura correnti. Se si desidera specificare un formato diverso o delle impostazioni cultura, usare gli altri overload del <xref:System.Double.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Impostazioni cultura (corrente) predefinite|<xref:System.Double.ToString>|  
|Formato predefinito ("G")|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un formato specifico o precisione|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o la rappresentazione di stringa di un numero, come specificato dalle `format`.  
  
 Il `format` parametro può essere qualsiasi identificatore di formato numerico standard valida, ad eccezione D e X, nonché qualsiasi combinazione di identificatori di formato numerico personalizzato. Se `format` è `null` o una stringa vuota, il valore restituito viene formattata con l'identificatore di formato numerico standard ("G").  
  
 .NET Framework fornisce supporto di formattazione completo, che è descritti più dettagliatamente nella formattazione negli argomenti seguenti:  
  
-   Per altre informazioni sugli identificatori di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per altre informazioni sulla formattazione, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Per impostazione predefinita, il valore restituito contiene solo 15 cifre di precisione anche se internamente viene gestito un massimo di 17 cifre. Se il valore di questa istanza è maggiore di 15 cifre, <xref:System.Double.ToString%2A> restituisce <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> o <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anziché il numero previsto. Se è necessario ottenere una maggiore precisione, specificare `format` con la specifica di formato "G17", che restituisce sempre 17 cifre di precisione o "R", che restituisce 15 cifre se il numero può essere rappresentato con 17 cifre o che la precisione se il numero può essere solo rappresentati con la massima precisione.  
  
   
  
## Examples  
 Nell'esempio seguente definisce un valore numerico e li formatta come valore di valuta usando la stringa di formato numerico standard "C" e come valore numerico a tre cifre decimali utilizzando la stringa di formato numerico standard "N". Le stringhe di risultato vengono formattate usando le convenzioni delle impostazioni cultura en-US. Per altre informazioni sulle stringhe di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 L'esempio seguente mostra alcuni <xref:System.Double> valori usando gli specificatori del formato numerico standard supportato insieme ai tre stringhe di formato numerico personalizzato. Uno di tali stringhe di formato personalizzato viene illustrato come aggiungere un <xref:System.Single> valore con zeri iniziali. Inoltre, l'esempio Usa identificatori di precisione con ogni identificatore di formato standard, ad eccezione di "R". I valori dell'intervallo di identificatori di precisione da 0 a 3. Per convertire i valori numerici in stringhe, l'esempio Usa le convenzioni di formattazione delle impostazioni cultura en-US.  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.</exception>
        <block subset="none" type="usage">
          <para>In alcuni casi <see cref="T:System.Double" /> formattati i valori con i non stringa di formato numerico standard "R" non completano il round trip se compilati usando il <see langword="/platform:x64" /> o <see langword="/platform:anycpu" /> cambi e l'esecuzione su sistemi a 64 bit. Per aggirare questo problema, è possibile formattare i valori <see cref="T:System.Double" /> usando la stringa di formato numerico standard "G17". L'esempio seguente usa la stringa di formato "R" con un <see cref="T:System.Double" /> valore correttamente che non non round trip e anche Usa "G17" stringa di formato correttamente il round trip al valore originale.  [! codice csharp [System.Double.ToString#6] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. Double.ToString/cs/roundtripex2.cs#6)] [! codice vb [System.Double.ToString#6] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. Double.ToString/vb/roundtripex2.vb#6)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato numerico.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore numerico dell'istanza nella rappresentazione di stringa equivalente usando il formato specificato e le informazioni di formattazione specifiche delle impostazioni cultura.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza corrente, in base a quanto specificato da <paramref name="format" /> e <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> formati del metodo un <xref:System.Double> valore in un formato specifico delle impostazioni cultura specificata. Se si desidera specificare un formato diverso o delle impostazioni cultura, usare gli altri overload del <xref:System.Double.ToString%2A> (metodo), come indicato di seguito:  
  
|Per usare il formato|Per impostazioni cultura|Usare l'overload|  
|-------------------|-----------------|----------------------|  
|Formato predefinito ("G")|Impostazioni cultura (corrente) predefinite|<xref:System.Double.ToString>|  
|Formato predefinito ("G")|Impostazioni cultura specifiche|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Un formato specifico o precisione|Impostazioni cultura (corrente) predefinite|<xref:System.Double.ToString%28System.String%29>|  
  
 Il valore restituito può essere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o la rappresentazione di stringa di un numero, come specificato dalle `format`.  
  
 Il `format` parametro può essere qualsiasi identificatore di formato numerico standard valida, ad eccezione D e X, nonché qualsiasi combinazione di identificatori di formato numerico personalizzato. Se `format` è `null` o una stringa vuota, il valore restituito per questa istanza viene formattata con l'identificatore di formato numerico standard ("G").  
  
 .NET Framework fornisce supporto di formattazione completo, che è descritti più dettagliatamente nella formattazione negli argomenti seguenti:  
  
-   Per altre informazioni sugli identificatori di formato numerico, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per altre informazioni sulla formattazione, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione cui <xref:System.IFormatProvider.GetFormat%2A> metodo restituisce un <xref:System.Globalization.NumberFormatInfo> oggetto. In genere `provider` è un <xref:System.Globalization.CultureInfo> oggetto o un <xref:System.Globalization.NumberFormatInfo> oggetto. Il `provider` parametro fornisce le informazioni specifiche delle impostazioni cultura utilizzate nella formattazione. Se `provider` viene `null`, il valore restituito viene formattato con il <xref:System.Globalization.NumberFormatInfo> oggetto per le impostazioni cultura correnti.  
  
 Per impostazione predefinita, il valore restituito contiene solo 15 cifre di precisione anche se internamente viene gestito un massimo di 17 cifre. Se il valore di questa istanza è maggiore di 15 cifre, <xref:System.Double.ToString%2A> restituisce <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> o <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anziché il numero previsto. Se è necessario ottenere una maggiore precisione, specificare `format` con la specifica di formato "G17", che restituisce sempre 17 cifre di precisione o "R", che restituisce 15 cifre se il numero può essere rappresentato con 17 cifre o che la precisione se il numero può essere solo rappresentati con la massima precisione.  
  
   
  
## Examples  
 L'esempio seguente mostra un <xref:System.Double> valore tramite ognuno degli identificatori di formato numerico standard supportati per varie impostazioni cultura.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo di <xref:System.Double.ToString%2A>, accettando un <xref:System.String> e un <xref:System.IFormatProvider> come parametri.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>In alcuni casi <see cref="T:System.Double" /> formattati i valori con i non stringa di formato numerico standard "R" non completano il round trip se compilati usando il <see langword="/platform:x64" /> o <see langword="/platform:anycpu" /> cambi e l'esecuzione su sistemi a 64 bit. Per aggirare questo problema, è possibile formattare i valori <see cref="T:System.Double" /> usando la stringa di formato numerico standard "G17". L'esempio seguente usa la stringa di formato "R" con un <see cref="T:System.Double" /> valore correttamente che non non round trip e anche Usa "G17" stringa di formato correttamente il round trip al valore originale.  [! codice csharp [System.Double.ToString#5] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. Double.ToString/cs/roundtripex1.cs#5)] [! codice vb [System.Double.ToString#5] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. Double.ToString/vb/roundtripex1.vb#5)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte la rappresentazione di stringa di un numero nel rispettivo numero a virgola mobile e precisione doppia equivalente. Un valore restituito indica se la conversione è riuscita o meno.</summary>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="result">Al momento della restituzione, questo metodo contiene il numero a virgola mobile a precisione doppia equivalente al parametro <c>s</c>, se la conversione ha esito positivo oppure zero se la conversione non riesce. La conversione non riesce se il parametro <c>s</c> è <see langword="null" /> o <see cref="F:System.String.Empty" />, non è un numero in formato valido o rappresenta un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />. Questo parametro viene passato non inizializzato. Qualsiasi valore specificato in origine in <c>result</c> verrà sovrascritto.</param>
        <summary>Converte la rappresentazione di stringa di un numero nel rispettivo numero a virgola mobile e precisione doppia equivalente. Un valore restituito indica se la conversione è riuscita o meno.</summary>
        <returns>
          <see langword="true" /> se <paramref name="s" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload differisce dal <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> metodo restituendo un valore booleano che indica se l'operazione di analisi è stata completata invece di restituire il valore numerico analizzato. Elimina la necessità di usare la gestione delle eccezioni da testare per una <xref:System.FormatException> nel caso in cui `s` non è valido e non può essere analizzata correttamente.  
  
 Il `s` parametro può contenere le impostazioni cultura correnti <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (nel confronto tra stringhe è distinzione maiuscole/minuscole), o una stringa nel formato:  
  
 [ws] [accesso] [cifre integrali,] cifre integrali [. [ cifre frazionarie]] [esponenziale e [accesso] cifre] [ws]  
  
 Gli elementi tra parentesi quadre sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Una serie di spazi vuoti.|  
|*sign*|Un segno negativo o un simbolo di segno positivo.|  
|*integral-digits*|Una serie di caratteri numerici compresi tra 0 e 9 che specificano la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|*,*|Un simbolo di separatore gruppo di impostazioni cultura specifiche.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche.|  
|*fractional-digits*|Una serie di caratteri numerici compresi tra 0 e 9 che specificano la parte frazionaria del numero.|  
|*E*|Un carattere maiuscolo o minuscolo 'e', che indica una notazione esponenziale (scientifica).|  
|*cifre esponenziali.*|Una serie di caratteri numerici compresi tra 0 e 9 che specificano un esponente.|  
  
 Per altre informazioni sui formati numerici, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Il `s` parametro viene interpretato usando una combinazione del <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag. Ciò significa che lo spazio vuoto e migliaia sono consentiti separatori ma non sono i simboli di valuta. Per definire in modo esplicito gli elementi (ad esempio i simboli di valuta, migliaia, gli spazi vuoti e separatori) che possono essere presenti in `s`, usare il <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> overload del metodo.  
  
 Il `s` parametro viene analizzato utilizzando le informazioni di formattazione in un <xref:System.Globalization.NumberFormatInfo> oggetto inizializzato per impostazioni cultura correnti del sistema. Per ulteriori informazioni, vedere <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Analizzare una stringa, usando le informazioni di formattazione di un altro specificati dalle impostazioni cultura, usare il <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> overload del metodo.  
  
 In genere, se si passa il <xref:System.Double.TryParse%2A?displayProperty=nameWithType> una stringa che viene creato chiamando il metodo di <xref:System.Double.ToString%2A?displayProperty=nameWithType> metodo, l'originale <xref:System.Double> valore viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di uno <xref:System.Double.MinValue> oppure <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e i separatori decimali e di gruppo sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un separatore di gruppi. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> metodo per convertire le rappresentazioni di stringa di valori numerici per <xref:System.Double> valori. Si presuppone che en-US è la lingua corrente.  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un numero da convertire.</param>
        <param name="style">Combinazione bit per bit dei valori <see cref="T:System.Globalization.NumberStyles" /> che indica il formato consentito di <c>s</c>. Un valore tipico da specificare è <see cref="F:System.Globalization.NumberStyles.Float" /> combinato con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Oggetto <see cref="T:System.IFormatProvider" /> che offre informazioni di formattazione specifiche delle impostazioni cultura relative a <c>s</c>.</param>
        <param name="result">Quando questo metodo viene restituito, contiene il numero a virgola mobile a precisione doppia equivalente al valore numerico o al simbolo contenuto in <c>s</c>, se la conversione ha esito positivo oppure zero se la conversione non riesce. La conversione non riesce se il parametro <c>s</c> è <see langword="null" /> o <see cref="F:System.String.Empty" />, non presenta un formato conforme a <c>style</c>, rappresenta un numero minore di <see cref="F:System.SByte.MinValue" /> o maggiore di <see cref="F:System.SByte.MaxValue" /> o se <c>style</c> non è una combinazione valida di costanti enumerate di <see cref="T:System.Globalization.NumberStyles" />. Questo parametro viene passato non inizializzato. Qualsiasi valore specificato in origine in <c>result</c> verrà sovrascritto.</param>
        <summary>Converte la rappresentazione di stringa di un numero in uno stile specificato e in un formato specifico delle impostazioni cultura nel numero a virgola mobile e precisione doppia equivalente. Un valore restituito indica se la conversione è riuscita o meno.</summary>
        <returns>
          <see langword="true" /> se <paramref name="s" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Double.TryParse%2A> metodo è simile al <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> (metodo), ma questo metodo non genera un'eccezione se la conversione non riesce. Se la conversione ha esito positivo, il valore restituito è `true` e il `result` parametro è impostato sul risultato della conversione. Se la conversione non riesce, il valore restituito è `false` e il `result` parametro è impostato su zero. Ciò consente di eliminare la necessità di usare la gestione delle eccezioni da testare per una <xref:System.FormatException> nel caso in cui `s` non è valido e non può essere analizzata correttamente.  
  
 Il `style` parametro definisce il formato consentito del `s` parametro per l'operazione di analisi abbia esito positivo. Deve essere una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione. Nell'esempio <xref:System.Globalization.NumberStyles> membri non sono supportati:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Il `s` parametro può contenere <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> per le impostazioni cultura indicata da `provider`. Inoltre, a seconda del valore di `style`, il `s` parametro può includere gli elementi seguenti:  
  
 [ws] [$] [accesso] [cifre integrali,] cifre integrali [cifre frazionarie] [esponenziale e [accesso] cifre] [ws]  
  
 Gli elementi tra parentesi quadre ([e]) sono facoltativi. La tabella seguente descrive i singoli elementi.  
  
|Elemento|Descrizione|  
|-------------|-----------------|  
|*ws*|Spazio vuoto facoltativo. Gli spazi vuoti possono essere visualizzati all'inizio di `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag. Può essere visualizzato in fondo `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|  
|*$*|Un simbolo di valuta delle impostazioni cultura specifiche. La posizione nella stringa è definita dal <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> o <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> delle proprietà del <xref:System.Globalization.NumberFormatInfo> oggetto restituito dal <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> metodo del `provider` parametro. Il simbolo di valuta può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|  
|*sign*|Un segno facoltativo. Il segno può essere visualizzati all'inizio del `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag che possono essere visualizzati in fondo `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Le parentesi possono essere utilizzate `s` per indicare un valore negativo se `style` include il <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|  
|*integral-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte integrale del numero. Cifre integrali possono essere assente se vi sono cifre frazionarie.|  
|*,*|Impostazioni cultura specifiche migliaia simbolo del separatore. Migliaia di cultura correnti simbolo del separatore visualizzabili nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|  
|*.*|Simbolo di separatore decimale delle impostazioni cultura specifiche. Simbolo di separatore decimale di cultura correnti può essere visualizzati nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*fractional-digits*|Una serie di cifre comprese tra 0 e 9 che specificano la parte frazionaria del numero. Cifre frazionarie visualizzabili nella `s` se `style` include il <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|  
|*e*|Il carattere e o E, a indicare che `s` può rappresentare un numero usando la notazione esponenziale. Il `s` parametro può rappresentare un numero in notazione esponenziale se style è incluso il <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|  
|*cifre esponenziali.*|Una serie di cifre comprese tra 0 e 9 che specificano un esponente.|  
  
 Una stringa che contiene solo cifre (che corrisponde alla <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> stile) sempre viene analizzata correttamente. I rimanenti <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> membri controllano gli elementi che possono essere ma non devono essere presenti nella stringa di input. Nella tabella seguente indica come singoli <xref:System.Globalization.NumberStyles> flag hanno effetto sugli elementi che possono essere presenti in `s`.  
  
|Valore NumberStyles|Elementi consentiti in s oltre alle cifre|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Il *cifre integrali* solo l'elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|L'elemento language *.* e *cifre frazionarie* elementi.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Il `s` parametro anche possibile usare la notazione esponenziale. Questo flag di per sé supporta i valori nel formato *cifre integrali*E*cifre esponenziali*; altri flag necessari per analizzare correttamente le stringhe in una notazione esponenziale con elementi quali segno positivo o negativo e simboli del separatore decimale.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Il *ws* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Il *ws* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Il *sign* elemento all'inizio del `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Il *sign* elemento alla fine di `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Il *sign* elemento sotto forma di parentesi che racchiudono il valore numerico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Il *,* elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Il * $ * elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Tutti. Il `s` parametro non può rappresentare un numero esadecimale o un numero in notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Float>|Il *ws* all'inizio o alla fine dell'elemento `s`, *sign* all'inizio del `s`e il *.* simbolo. Il `s` parametro anche possibile usare la notazione esponenziale.|  
|<xref:System.Globalization.NumberStyles.Number>|Il `ws`, `sign`, migliaia separatore (*,),* e il punto decimale (*.*) elementi.|  
|<xref:System.Globalization.NumberStyles.Any>|Tutti gli stili, ad eccezione di `s` non può rappresentare un numero esadecimale.|  
  
 Il `provider` parametro è un <xref:System.IFormatProvider> implementazione, ad esempio un <xref:System.Globalization.NumberFormatInfo> o <xref:System.Globalization.CultureInfo> oggetto. Il `provider` parametro fornisce informazioni specifiche delle impostazioni cultura utilizzate durante l'analisi. Se `provider` viene `null` o un <xref:System.Globalization.NumberFormatInfo> non è possibile ottenere l'oggetto, viene utilizzati le informazioni sul formato per le impostazioni cultura correnti.  
  
 La conversione ha esito negativo se il `s` parametro è `null` o un valore non numerico, il `provider` parametro non viene prodotta una <xref:System.Globalization.NumberFormatInfo> oggetto, o la `style` parametro non è una combinazione di flag di bit dal <xref:System.Globalization.NumberStyles> enumerazione.  
  
 In genere, se si passa il <xref:System.Double.TryParse%2A?displayProperty=nameWithType> una stringa che viene creato chiamando il metodo di <xref:System.Double.ToString%2A?displayProperty=nameWithType> metodo, l'originale <xref:System.Double> valore viene restituito. Tuttavia, a causa di una perdita di precisione, i valori potrebbero non essere uguali. Inoltre, il tentativo di analizzare la rappresentazione di stringa di uno <xref:System.Double.MinValue> oppure <xref:System.Double.MaxValue> genera un <xref:System.OverflowException>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Se viene rilevato un separatore nel `s` parametro durante un'operazione di analisi e la valuta applicabile o il numero decimale e i separatori di gruppi sono uguali, l'operazione di analisi si presuppone che il separatore è un separatore decimale, anziché un gruppo separatore. Per altre informazioni sui separatori, vedere <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> metodo per analizzare la rappresentazione di stringa di numeri che hanno uno stile specifico e vengono formattati usando le convenzioni delle impostazioni cultura specifiche.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> non è un valore di <see cref="T:System.Globalization.NumberStyles" />.  -o-  <paramref name="style" /> include il valore <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>