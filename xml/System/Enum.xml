<Type Name="Enum" FullName="System.Enum">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a7a137de938199a0dd7dc074b7bb42e54b3c7461" /><Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="it-IT" /><Meta Name="ms.lasthandoff" Value="11/27/2018" /><Meta Name="ms.locfileid" Value="52359927" /></Metadata><TypeSignature Language="C#" Value="public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Enum extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Enum" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Enum&#xA;Inherits ValueType&#xA;Implements IComparable, IConvertible, IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Enum abstract : ValueType, IComparable, IConvertible, IFormattable" />
  <TypeSignature Language="F#" Value="type Enum = class&#xA;    inherit ValueType&#xA;    interface IComparable&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Si tratta della classe base per le enumerazioni.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'enumerazione è un set di costanti denominate cui tipo sottostante è qualsiasi tipo integrale. Se nessun tipo sottostante è dichiarato in modo esplicito, <xref:System.Int32> viene usato. <xref:System.Enum> è la classe base per tutte le enumerazioni di .NET Framework. Tipi di enumerazione sono definiti mediante il `enum` parola chiave nel linguaggio c# e il `Enum`... `End Enum` costruire in Visual Basic.  
  
 <xref:System.Enum> fornisce metodi per confrontare le istanze di questa classe, conversione del valore di un'istanza alla relativa rappresentazione di stringa, conversione la rappresentazione di stringa di un numero in un'istanza di questa classe e la creazione di un'istanza di un'enumerazione specificata e un valore.  
  
 È anche possibile considerare un'enumerazione come campo di bit. Per altre informazioni, vedere la [i membri Non esclusiva e l'attributo Flags](#Flags) sezione e <xref:System.FlagsAttribute> argomento.  
  
 In questo argomento  
  
 [Creazione di un tipo di enumerazione](#Creating)   
 [Creare un'istanza di un tipo di enumerazione](#Instantiating)   
 [Le procedure consigliate di enumerazione](#BestPractices)   
 [Esecuzione di operazioni con le enumerazioni](#Operations)   
 [Esecuzione delle conversioni](#conversions)  
 [L'analisi dei valori di enumerazione](#parsing)  
 [Formattazione dei valori di enumerazione](#formatting)  
[L'iterazione di membri dell'enumerazione](#iterating)  
[I membri non esclusiva e l'attributo Flags](#Flags)  
[Aggiunta di metodi di enumerazione](#Methods)  
  
<a name="Creating"></a>   
## <a name="creating-an-enumeration-type"></a>Creazione di un tipo di enumerazione  
 I linguaggi di programmazione in genere forniscono la sintassi per dichiarare un'enumerazione che è costituito da un set di costanti denominate e i relativi valori. Nell'esempio seguente viene illustrata la sintassi usata da codice c# e Visual Basic per definire un'enumerazione. Crea un enumeratore chiamato `ArrivalStatus` che dispone di tre membri: `ArrivalStatus.Early`, `ArrivalStatus.OnTime`, e `ArrivalStatus.Late`. Si noti che in entrambi i casi, l'enumerazione non esplicitamente eredita da <xref:System.Enum>; la relazione di ereditarietà viene gestita in modo implicito dal compilatore.  
  
 [!code-csharp[System.Enum.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class1.cs#1)]
 [!code-vb[System.Enum.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class1.vb#1)]  
  
> [!WARNING]
>  È consigliabile non creare mai un tipo di enumerazione il cui tipo sottostante è non integrali o <xref:System.Char>. Sebbene sia possibile creare un tipo di enumerazione tramite reflection, chiamate ai metodi che utilizzano il tipo risulta sono inaffidabili e può anche generare ulteriori eccezioni.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-an-enumeration-type"></a>Creare un'istanza di un tipo di enumerazione  
 È possibile creare un'istanza di un tipo di enumerazione esattamente come si crea un'istanza di qualsiasi altro tipo di valore: dichiarando una variabile e assegnarle una delle costanti dell'enumerazione. Nell'esempio seguente crea un `ArrivalStatus` il cui valore è `ArrivalStatus.OnTime`.  
  
 [!code-csharp[System.Enum.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class1.cs#2)]
 [!code-vb[System.Enum.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class1.vb#2)]  
  
 È anche possibile creare un'istanza di un valore di enumerazione nei modi seguenti:  
  
-   Usando le funzionalità di un particolare linguaggio di programmazione per eseguire il cast (come in c#) o convertire (ad esempio Visual Basic) un valore intero in un valore di enumerazione. L'esempio seguente crea un `ArrivalStatus` il cui valore è `ArrivalStatus.Early` in questo modo.  
  
     [!code-csharp[System.Enum.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#4)]
     [!code-vb[System.Enum.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#4)]  
  
-   Chiamando il costruttore predefinito implicito. Come illustrato nell'esempio seguente, in questo caso il valore sottostante dell'istanza di enumerazione è 0. Tuttavia, ciò non è necessariamente il valore di costante valido nell'enumerazione.  
  
     [!code-csharp[System.Enum.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#3)]
     [!code-vb[System.Enum.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#3)]  
  
-   Chiamando il <xref:System.Enum.Parse%2A> o <xref:System.Enum.TryParse%2A> metodo per analizzare una stringa che contiene il nome di una costante nell'enumerazione. Per altre informazioni, vedere la [l'analisi dei valori di enumerazione](#parsing) sezione.  
  
-   Chiamando il <xref:System.Enum.ToObject%2A> metodo per convertire un valore integrale in un tipo di enumerazione. Per altre informazioni, vedere la [esecuzione di conversioni](#conversions) sezione.  
  
<a name="BestPractices"></a>   
## <a name="enumeration-best-practices"></a>Le procedure consigliate di enumerazione  
 È consigliabile usare le procedure consigliate seguenti quando si definiscono i tipi di enumerazione:  
  
-   Se non è stato definito un membro di enumerazione il cui valore è 0, è consigliabile creare un `None` costante enumerata. Per impostazione predefinita, la memoria utilizzata per l'enumerazione viene inizializzata su zero da common language runtime. Di conseguenza, se non si definisce una costante il cui valore è uguale a zero, l'enumerazione contiene un valore non valido al momento della creazione.  
  
-   Se un caso predefinito evidente che l'applicazione deve rappresentare, è consigliabile usare enumerato costante il cui valore è zero per rappresentarlo. Se non c'è nessun caso predefinito, è consigliabile utilizzare una costante enumerata il cui valore è uguale a zero per specificare il case che non è rappresentato da una delle altre costanti enumerate.  
  
-   Non si specifica costanti enumerate che sono riservate per utilizzi futuri.  
  
-   Quando si definisce un metodo o proprietà che accetta un valore costante enumerata, prendere in considerazione la convalida del valore. Il motivo è è possibile eseguire il cast di un valore numerico per il tipo di enumerazione anche se tale valore numerico non è definito nell'enumerazione.  
  
 Procedure consigliate aggiuntive per i tipi di enumerazione cui costanti sono campi di bit sono racchiusi il [i membri Non esclusiva e l'attributo Flags](#Flags) sezione.  
  
<a name="Operations"></a>   
## <a name="performing-operations-with-enumerations"></a>Esecuzione di operazioni con le enumerazioni  
 È possibile definire nuovi metodi durante la creazione di un'enumerazione. Tuttavia, un tipo di enumerazione eredita un set completo di statici e metodi di istanza dal <xref:System.Enum> classe. Le sezioni seguenti del sondaggio la maggior parte di questi metodi, oltre a diversi altri metodi che vengono usate quando si lavora con valori di enumerazione.  
  
<a name="conversions"></a>   
### <a name="performing-conversions"></a>Esecuzione delle conversioni  
 È possibile convertire tra un membro di enumerazione e il relativo tipo sottostante usando un cast (in c#) o un operatore di conversione (in Visual Basic). L'esempio seguente usa gli operatori di conversione o cast per eseguire le conversioni da un integer a un valore di enumerazione e dal valore di enumerazione in un numero intero.  
  
 [!code-csharp[System.Enum.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#5)]
 [!code-vb[System.Enum.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#5)]  
  
 Il <xref:System.Enum> classe include anche un <xref:System.Enum.ToObject%2A> metodo che converte un valore di qualsiasi tipo integrale in un valore di enumerazione. L'esempio seguente usa il <xref:System.Enum.ToObject%28System.Type%2CSystem.Int32%29> metodo per convertire un' <xref:System.Int32> a un `ArrivalStatus` valore. Si noti che, in quanto il <xref:System.Enum.ToObject%2A> restituisce un valore di tipo <xref:System.Object>, l'uso di un operatore cast o conversione potrebbe essere ancora necessario il cast dell'oggetto nel tipo di enumerazione.  
  
 [!code-csharp[System.Enum.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#6)]
 [!code-vb[System.Enum.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#6)]  
  
 Quando si converte un numero intero a un valore di enumerazione, è possibile assegnare un valore che non è effettivamente un membro dell'enumerazione. Per evitare questo problema, è possibile passare il valore integer per il <xref:System.Enum.IsDefined%2A> metodo prima di eseguire la conversione. L'esempio seguente usa questo metodo per determinare se gli elementi in una matrice di valori integer possono essere convertiti in `ArrivalStatus` valori.  
  
 [!code-csharp[System.Enum.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classconversion1.cs#7)]
 [!code-vb[System.Enum.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classconversion1.vb#7)]  
  
 Anche se il <xref:System.Enum> classe fornisce le implementazioni esplicite dell'interfaccia del <xref:System.IConvertible> interfaccia per la conversione da un valore di enumerazione a un tipo integrale, è consigliabile usare i metodi delle <xref:System.Convert> classe, ad esempio <xref:System.Convert.ToInt32%2A>, a eseguire queste conversioni. L'esempio seguente illustra come usare il <xref:System.Enum.GetUnderlyingType%2A> metodo con il <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> metodo per convertire un valore di enumerazione al relativo tipo sottostante. Si noti che questo esempio non richiede il tipo sottostante dell'enumerazione deve essere noto in fase di compilazione.  
  
 [!code-csharp[System.Enum.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classconversion2.cs#8)]
 [!code-vb[System.Enum.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classconversion2.vb#8)]  
  
<a name="parsing"></a>   
### <a name="parsing-enumeration-values"></a>L'analisi dei valori di enumerazione  
 Il <xref:System.Enum.Parse%2A> e <xref:System.Enum.TryParse%2A> metodi consentono di convertire la rappresentazione di stringa del valore di enumerazione in tale valore. La rappresentazione di stringa può essere il nome o il valore sottostante di una costante di enumerazione. Si noti che i metodi di analisi convertirà correttamente le rappresentazioni di stringa di numeri che non sono membri di un'enumerazione particolare se le stringhe possono essere convertite in un valore di tipo sottostante dell'enumerazione. Per evitare questo problema, il <xref:System.Enum.IsDefined%2A> metodo può essere chiamato per garantire che il risultato del metodo di analisi è un valore di enumerazione valido. L'esempio illustra questo approccio e illustra le chiamate a entrambe le <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> e <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29?displayProperty=nameWithType> metodi. Si noti che il metodo di analisi non generica restituisce un oggetto che potrebbe essere necessario eseguire il cast (in c#) o convertire (in Visual Basic) per il tipo di enumerazione appropriati.  
  
 [!code-csharp[System.Enum.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classparse1.cs#9)]
 [!code-vb[System.Enum.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classparse1.vb#9)]  
  
<a name="formatting"></a>   
### <a name="formatting-enumeration-values"></a>Formattazione dei valori di enumerazione  
 È possibile convertire i valori di enumerazione per le rappresentazioni di stringa chiamando il metodo statico <xref:System.Enum.Format%2A> metodo, nonché l'overload dell'istanza <xref:System.Enum.ToString%2A> (metodo). È possibile utilizzare una stringa di formato per controllare il modo esatto in cui un valore di enumerazione è rappresentato sotto forma di stringa. Per altre informazioni, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md). L'esempio seguente Usa tutte le stringhe di formato di enumerazione supportata ("G" o "g", "D" o "d", "X" o "x" e "F" o "f") per convertire un membro del `ArrivalStatus` relative rappresentazioni di stringa dell'enumerazione.  
  
 [!code-csharp[System.Enum.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classformat1.cs#10)]
 [!code-vb[System.Enum.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classformat1.vb#10)]  
  
<a name="iterating"></a>   
### <a name="iterating-enumeration-members"></a>L'iterazione di membri dell'enumerazione  
 Il <xref:System.Enum> tipo non implementa le <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601> interfaccia, che consentirà di scorrere i membri di una raccolta utilizzando una `foreach` (in c#) o `For Each` (in Visual Basic), costruire. Tuttavia, è possibile enumerare i membri in due modi diversi.  
  
-   È possibile chiamare il <xref:System.Enum.GetNames%2A> metodo per recuperare una matrice di stringhe contenente i nomi dei membri dell'enumerazione. Successivamente, per ogni elemento della matrice di stringhe, è possibile chiamare il <xref:System.Enum.Parse%2A> metodo per convertire la stringa equivalente valore di enumerazione. Questo approccio viene illustrato nell'esempio seguente:  
  
     [!code-csharp[System.Enum.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classiterate.cs#11)]
     [!code-vb[System.Enum.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classiterate.vb#11)]  
  
-   È possibile chiamare il <xref:System.Enum.GetValues%2A> metodo per recuperare una matrice che contiene l'oggetto sottostante per i valori nell'enumerazione. Successivamente, per ogni elemento della matrice, è possibile chiamare il <xref:System.Enum.ToObject%2A> metodo per convertire il valore intero equivalente valore di enumerazione. Questo approccio viene illustrato nell'esempio seguente:  
  
     [!code-csharp[System.Enum.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classiterate.cs#12)]
     [!code-vb[System.Enum.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classiterate.vb#12)]  
  
<a name="Flags"></a>   
## <a name="non-exclusive-members-and-the-flags-attribute"></a>I membri non esclusiva e l'attributo Flags  
 Viene in genere utilizzato di un'enumerazione per rappresentare un set di valori si escludono a vicenda. Ad esempio, un' `ArrivalStatus` istanza può avere un valore pari `Early`, `OnTime`, o `Late`. Non ha senso per il valore di un `ArrivalStatus` istanza per riflettere più di una costante di enumerazione.  
  
 In altri casi, tuttavia, il valore di un oggetto di enumerazione può includere più membri dell'enumerazione e ogni membro rappresenta un campo di bit nel valore di enumerazione. Il <xref:System.FlagsAttribute> attributo può essere utilizzato per indicare che l'enumerazione è costituita da campi di bit. Ad esempio, un'enumerazione denominata `Pets` potrebbe essere utilizzato per indicare i tipi di animali domestici in casa. Può essere definita come indicato di seguito.  
  
 [!code-csharp[System.Enum.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#13)]
 [!code-vb[System.Enum.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#13)]  
  
 Il `Pets` enumerazione può quindi essere utilizzata come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Enum.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#14)]
 [!code-vb[System.Enum.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#14)]  
  
 Usare le procedure consigliate seguenti quando si definisce un bit per bit dell'enumerazione e applicando la <xref:System.FlagsAttribute> attributo.  
  
-   Usare il <xref:System.FlagsAttribute> attributo personalizzato per un'enumerazione solo se un'operazione OR bit per bit (AND, OR esclusivo o) deve essere eseguita su un valore numerico.  
  
-   Definire le costanti di enumerazione in potenze di due, ovvero 1, 2, 4, 8 e così via. Ciò significa che i singoli flag in costanti di enumerazione combinato non si sovrappongano.  
  
-   È consigliabile creare una costante enumerata per le combinazioni di flag di uso comune. Ad esempio, se si dispone di un'enumerazione utilizzata per le operazioni dei / o file che contiene le costanti enumerate `Read = 1` e `Write = 2`, è consigliabile creare costante enumerata `ReadWrite = Read OR Write`, che combina il `Read` e `Write` flag. Inoltre, l'operazione OR bit per bit usato per combinare i flag può essere considerato un concetto avanzato in alcuni casi che non dovrebbe essere necessaria per eseguire semplici operazioni.  
  
-   Prestare attenzione se si definisce un numero negativo come una costante enumerata flag perché molte posizioni di flag potrebbero essere impostate su 1, che potrebbe rendere il codice di confusione e incoraggiare gli errori di codifica.  
  
-   Un modo pratico per verificare se un flag è impostato in un valore numerico deve chiamare l'istanza <xref:System.Enum.HasFlag%2A> metodo, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Enum.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#15)]
     [!code-vb[System.Enum.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#15)]  
  
     È equivalente all'esecuzione di un'operazione con AND bit per bit tra il valore numerico e costante enumerata flag, che imposta tutti i bit nel valore numerico a zero, che non corrispondono al flag, e quindi a verificare se il risultato di tale operazione è uguale al Costante enumerata flag. Questa procedura è illustrata nell'esempio riportato di seguito.  
  
     [!code-csharp[System.Enum.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#16)]
     [!code-vb[System.Enum.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#16)]  
  
-   Usare `None` come il nome del flag enumerato costante il cui valore è zero. Non è possibile usare il `None` costante enumerata in un'operazione con AND bit per bit per testare un flag perché il risultato è sempre zero. Tuttavia, è possibile eseguire una logica, non un confronto bit per bit tra il valore numerico e `None` costante enumerata per determinare se si assegnano bit nel valore numerico. Questa procedura è illustrata nell'esempio riportato di seguito.  
  
     [!code-csharp[System.Enum.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#17)]
     [!code-vb[System.Enum.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#17)]  
  
-   Non definire un valore di enumerazione esclusivamente per rispecchiare lo stato dell'enumerazione stessa. Ad esempio, si definisce una costante enumerata che si limita a contrassegnare la fine dell'enumerazione. Se è necessario determinare l'ultimo valore dell'enumerazione, verificare la presenza di tale valore in modo esplicito. Inoltre, è possibile eseguire una verifica di intervallo per costante enumerata e il cognome se tutti i valori all'interno dell'intervallo sono validi.  
  
<a name="Methods"></a>   
## <a name="adding-enumeration-methods"></a>Aggiunta di metodi di enumerazione  
 Poiché i tipi di enumerazione definiti dalle strutture di linguaggio, quali `enum` (c#) e `Enum` (Visual Basic), non è possibile definire metodi personalizzati per un tipo di enumerazione diverso da tali metodi ereditati dal <xref:System.Enum> classe.  Tuttavia, è possibile utilizzare i metodi di estensione per aggiungere funzionalità a un tipo di enumerazione specifico.  
  
 Nell'esempio seguente, l'enumerazione `Grades` rappresenta il voto che uno studente potrebbe ricevere in un corso. Il metodo di estensione denominato `Passing` viene aggiunto al tipo `Grades` in modo che ogni istanza di tale tipo ora "sa" se rappresenta un voto sufficiente oppure no.       Il `Extensions` classe contiene inoltre una variabile statica di lettura / scrittura che definisce il voto minimo. Il valore restituito del `Passing` metodo di estensione riflette il valore corrente della variabile.  
  
 [!code-csharp[System.Enum.Class#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/Extensions.cs#18)]
 [!code-vb[System.Enum.Class#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/Extensions.vb#18)]  
  
   
  
## Examples  
 Nell'esempio seguente illustra l'uso di un'enumerazione per rappresentare valori denominati e un'altra enumerazione per rappresentare i campi di bit denominato.  
  
 [!code-cpp[enummain#1](~/samples/snippets/cpp/VS_Snippets_CLR/enummain/CPP/EnumMain.cpp#1)]
 [!code-csharp[enummain#1](~/samples/snippets/csharp/VS_Snippets_CLR/enummain/CS/EnumMain.cs#1)]
 [!code-vb[enummain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enummain/VB/EnumMain.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.ValueType" />
    <altmember cref="T:System.FlagsAttribute" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Enum ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Enum();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Enum" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (target As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ target);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="enum.CompareTo target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="target">Oggetto da confrontare o <see langword="null" />.</param>
        <summary>Confronta questa istanza con un oggetto specificato e restituisce un'indicazione dei valori relativi.</summary>
        <returns>Numero con segno che indica i valori relativi di questa istanza e <paramref name="target" />.  
  
 <list type="table"><listheader><term> Valore 
 </term><description> Significato 
 </description></listheader><item><term> Minore di zero 
 </term><description> Il valore dell'istanza è minore del valore di <paramref name="target" />.  
  
 </description></item><item><term> Zero 
 </term><description> Il valore di questa istanza è uguale al valore di <paramref name="target" />.  
  
 </description></item><item><term> Maggiore di zero 
 </term><description> Il valore di questa istanza è maggiore del valore di <paramref name="target" />.  
  
oppure 
 <paramref name="target" /> è <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di `CompareTo` nel contesto di `Enum`.  
  
 [!code-cpp[enumcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumcompareto/CPP/EnumCompareTo.cpp#1)]
 [!code-csharp[enumcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumcompareto/CS/EnumCompareTo.cs#1)]
 [!code-vb[enumcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumcompareto/VB/EnumCompareTo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> e questa istanza non sono dello stesso tipo.</exception>
        <exception cref="T:System.InvalidOperationException">Questa istanza non è di tipo <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" /> o <see cref="T:System.UInt64" />.</exception>
        <altmember cref="M:System.Enum.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="enum.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con questa istanza o <see langword="null" />.</param>
        <summary>Restituisce un valore che indica se questa istanza è uguale a un oggetto specificato.</summary>
        <returns><see langword="true" /> se <paramref name="obj" /> è un valore di enumerazione dello stesso tipo e con lo stesso valore sottostante dell'istanza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum.Equals%28System.Object%29?displayProperty=nameWithType> override dei metodi <xref:System.ValueType.Equals%28System.Object%29?displayProperty=nameWithType> per definire come membri dell'enumerazione vengono valutati per verificarne l'uguaglianza.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato l'utilizzo del metodo <xref:System.Enum.Equals%2A>.  
  
 [!code-cpp[enumequals#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumequals/CPP/EnumEquals.cpp#1)]
 [!code-csharp[enumequals#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumequals/CS/EnumEquals.cs#1)]
 [!code-vb[enumequals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumequals/VB/EnumEquals.vb#1)]  
  
 L'esempio seguente definisce due tipi di enumerazione `SledDog` e `WorkDog`. Il `SledDog` enumerazione contiene due membri, `SledDog.AlaskanMalamute` e `SledDog.Malamute`, che hanno lo stesso valore sottostante. La chiamata al <xref:System.Enum.Equals%2A> metodo indica che questi valori sono uguali perché i relativi valori sottostante sono uguali. Il `SledDog.Malamute` e `WorkDog.Newfoundland` membri hanno lo stesso valore sottostante, anche se rappresentano i tipi di enumerazione diverso. Una chiamata al <xref:System.Enum.Equals%2A> metodo indica che questi valori non sono uguali.  
  
 [!code-csharp[System.Enum.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.equals/cs/enumequals.cs#1)]
 [!code-vb[System.Enum.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.equals/vb/enumequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Enum.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (Type enumType, object value, string format);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.Type enumType, object value, string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Format(System.Type,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (enumType As Type, value As Object, format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(Type ^ enumType, System::Object ^ value, System::String ^ format);" />
      <MemberSignature Language="F#" Value="static member Format : Type * obj * string -&gt; string" Usage="System.Enum.Format (enumType, value, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione del valore da convertire.</param>
        <param name="value">Valore da convertire.</param>
        <param name="format">Formato di output da usare.</param>
        <summary>Converte il valore specificato di un determinato tipo enumerato nella rappresentazione di stringa equivalente, secondo il formato specificato.</summary>
        <returns>Rappresentazione di stringa di <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente illustra i valori validi per il `format` parametro.  
  
|Formato|Descrizione|  
|------------|-----------------|  
|"G" o "g"|Se `value` è uguale a una costante enumerata denominata, il nome della costante è restituita; in caso contrario, l'equivalente decimale `value` viene restituito.<br /><br /> Si supponga, ad esempio, la sola costante enumerata denominata Red e il relativo valore è 1. Se `value` viene specificata come 1, questo formato restituisce "Red". Tuttavia, se `value` viene specificato come 2, questo formato restituisce "2".<br /><br /> oppure<br /><br /> Se il <xref:System.FlagsAttribute> attributo personalizzato viene applicato all'enumerazione `value` viene considerato come un campo di bit che contiene uno o più flag costituiti da uno o più bit.<br /><br /> Se `value` è uguale a una combinazione di costanti enumerate denominate, viene restituito un elenco separati da delimitatori di nomi delle costanti. `value` viene eseguita la ricerca i flag, dal flag con il valore più grande al più piccolo valore. Per ogni flag che corrisponde a un campo di bit in `value`, il nome della costante viene concatenato all'elenco separati da delimitatori. Il valore del flag viene quindi considerato ulteriormente e continua la ricerca per il contrassegno next.<br /><br /> Se `value` non è uguale a una combinazione di costanti enumerate, l'equivalente decimale denominate `value` viene restituito.|  
|"X" o "x"|Rappresenta `value` in formato esadecimale senza un iniziale "0x".|  
|"D" o "d"|Rappresenta `value` in formato decimale.|  
|"F" o "f"|Si comporta come "G" o "g", ad eccezione del fatto che il <xref:System.FlagsAttribute> non deve essere presente nel <xref:System.Enum> dichiarazione.|  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di `Format` nel contesto di `Enum`.  
  
 [!code-cpp[enumformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumformat/CPP/EnumFormat.cpp#1)]
 [!code-csharp[enumformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumformat/CS/EnumFormat.cs#1)]
 [!code-vb[enumformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumformat/VB/EnumFormat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="enumType" />, <paramref name="value" /> o <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="enumType" /> non è un tipo <see cref="T:System.Enum" />.  
  
oppure 
Il parametro <paramref name="value" /> deriva da un'enumerazione con un tipo differente rispetto a <paramref name="enumType" />.  
  
oppure 
Il tipo di <paramref name="value" /> non è un tipo sottostante di <paramref name="enumType" />.</exception>
        <exception cref="T:System.FormatException">Il parametro <paramref name="format" /> contiene un valore non valido.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="format" /> è uguale a "X", ma il tipo di enumerazione è sconosciuto.</exception>
        <altmember cref="M:System.Enum.ToString(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formattazione di tipi in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Stringhe di formato di enumerazione</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="enum.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Viene restituito il codice hash per il valore dell'istanza.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetName(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetName(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (enumType As Type, value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(Type ^ enumType, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member GetName : Type * obj -&gt; string" Usage="System.Enum.GetName (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione.</param>
        <param name="value">Valore di una determinata costante enumerata in base al relativo tipo sottostante.</param>
        <summary>Restituisce il nome della costante nell'enumerazione del valore specificato.</summary>
        <returns>Stringa che contiene il nome della costante enumerata in <paramref name="enumType" /> il cui valore è <paramref name="value" /> oppure <see langword="null" /> se tale costante non viene trovata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se lo stesso valore sottostante, dispongono di più membri dell'enumerazione di <xref:System.Enum.GetName%2A> metodo garantisce che restituirà il nome di uno dei membri di enumerazione. Tuttavia, non garantisce che restituirà sempre il nome del membro dell'enumerazione stessa. Di conseguenza, quando più membri di enumerazione hanno lo stesso valore, il codice dell'applicazione non deve mai dipendono dal metodo che restituisce il nome di un membro specifico.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di `GetName`.  
  
 [!code-cpp[enumgetname#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetname/CPP/EnumGetName.cpp#1)]
 [!code-csharp[enumgetname#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetname/CS/EnumGetName.cs#1)]
 [!code-vb[enumgetname#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetname/VB/EnumGetName.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> o <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.  
  
oppure 
 <paramref name="value" /> non è di tipo <paramref name="enumType" /> e non ha lo stesso tipo sottostante di <paramref name="enumType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNames">
      <MemberSignature Language="C#" Value="public static string[] GetNames (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetNames(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetNames(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNames (enumType As Type) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetNames(Type ^ enumType);" />
      <MemberSignature Language="F#" Value="static member GetNames : Type -&gt; string[]" Usage="System.Enum.GetNames enumType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione.</param>
        <summary>Restituisce una matrice dei nomi delle costanti in una enumerazione specificata.</summary>
        <returns>Matrice di stringhe dei nomi delle costanti in <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi della matrice di valori restituiti vengono ordinati in base ai valori binari di costanti enumerate (vale a dire, dalla grandezza senza segno). Nell'esempio seguente fornisce informazioni consente di visualizzare la matrice restituita dal <xref:System.Enum.GetNames%2A> metodo per un'enumerazione che include un valore negativo, zero e un valore positivo.  
  
 [!code-csharp[System.Enum.GetNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getnames/cs/getnames1.cs#1)]
 [!code-vb[System.Enum.GetNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getnames/vb/getnames1.vb#1)]  
  
 Se sono presenti costanti enumerate con stesso valore, non è specificato l'ordine dei nomi corrispondenti.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato l'utilizzo del metodo <xref:System.Enum.GetNames%2A>.  
  
 [!code-cpp[enumgetnames#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetnames/CPP/EnumGetNames.cpp#1)]
 [!code-csharp[enumgetnames#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetnames/CS/EnumGetNames.cs#1)]
 [!code-vb[enumgetnames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetnames/VB/EnumGetNames.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="enumType" /> non è un oggetto <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="enum.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice del tipo sottostante di questo membro di enumerazione.</summary>
        <returns>Codice del tipo sottostante di questa istanza.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Il tipo di enumerazione è sconosciuto.</exception>
        <altmember cref="M:System.Enum.GetUnderlyingType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetUnderlyingType">
      <MemberSignature Language="C#" Value="public static Type GetUnderlyingType (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetUnderlyingType(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetUnderlyingType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnderlyingType (enumType As Type) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetUnderlyingType(Type ^ enumType);" />
      <MemberSignature Language="F#" Value="static member GetUnderlyingType : Type -&gt; Type" Usage="System.Enum.GetUnderlyingType enumType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">Enumerazione il cui tipo sottostante verrà recuperato.</param>
        <summary>Restituisce il tipo sottostante dell'enumerazione specificata.</summary>
        <returns>Tipo sottostante di <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum> struttura consente i valori essere rappresentato come costanti denominate. Il tipo di dati dei valori dell'enumerazione è noto come relativo tipo sottostante. Ad esempio, il tipo sottostante del <xref:System.DayOfWeek> enumerazione, che è costituito dalle costanti che rappresentano ogni giorno della settimana (<xref:System.DayOfWeek.Monday?displayProperty=nameWithType>, <xref:System.DayOfWeek.Tuesday?displayProperty=nameWithType>e così via), è <xref:System.Int32>.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Enum.GetUnderlyingType%2A> metodo per visualizzare il tipo sottostante di alcuni membri dell'enumerazione.  
  
 [!code-csharp[System.Enum.GetUnderlyingType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getunderlyingtype/cs/getunderlyingtype1.cs#1)]
 [!code-vb[System.Enum.GetUnderlyingType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getunderlyingtype/vb/getunderlyingtype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.GetTypeCode" />
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public static Array GetValues (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array GetValues(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetValues(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValues (enumType As Type) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ GetValues(Type ^ enumType);" />
      <MemberSignature Language="F#" Value="static member GetValues : Type -&gt; Array" Usage="System.Enum.GetValues enumType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione.</param>
        <summary>Restituisce una matrice dei valori delle costanti in una enumerazione specificata.</summary>
        <returns>Matrice che contiene i valori delle costanti in <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi della matrice vengono ordinati in base ai valori delle costanti di enumerazione binari (vale a dire, dalla grandezza senza segno). L'esempio seguente visualizza informazioni matrice restituita dal <xref:System.Enum.GetValues%2A> metodo per un'enumerazione che include un valore negativo, zero e un valore positivo.  
  
 [!code-csharp[System.Enum.GetValues#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues1.cs#1)]
 [!code-vb[System.Enum.GetValues#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues1.vb#1)]  
  
 Il <xref:System.Enum.GetValues%2A> metodo restituisce una matrice che contiene un valore per ogni membro del `enumType` enumerazione. Se più membri hanno lo stesso valore, la matrice restituita include valori duplicati. In questo caso, la chiamata di <xref:System.Enum.GetName%2A> metodo con ogni valore nella matrice restituita non ripristina i nomi univoci assegnati a membri che contengono valori duplicati. Per recuperare correttamente tutti i nomi dei membri dell'enumerazione, chiamare il <xref:System.Enum.GetNames%2A> (metodo).  
  
 Il <xref:System.Enum.GetValues%2A> (metodo) non può essere richiamato tramite reflection in un contesto reflection-only. In alternativa, è possibile recuperare il valore di tutti i membri di enumerazione utilizzando il <xref:System.Type.GetFields%2A?displayProperty=nameWithType> metodo per ottenere una matrice di <xref:System.Reflection.FieldInfo> gli oggetti che rappresentano i membri di enumerazione e chiamano quindi il <xref:System.Reflection.FieldInfo.GetRawConstantValue%2A?displayProperty=nameWithType> metodo su ogni elemento della matrice. L'esempio seguente illustra questa tecnica. Richiede la definizione di enumerazione seguente in un assembly denominato Enumerations.dll:  
  
 [!code-csharp[System.Enum.GetValues#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues_reflectiononly.cs#2)]
 [!code-vb[System.Enum.GetValues#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues_reflectiononly.vb#2)]  
  
 L'assembly viene caricato in un contesto reflection-only, un <xref:System.Type> oggetto che rappresenta il `Pets` enumerazione viene creata un'istanza, una matrice di <xref:System.Reflection.FieldInfo> vengono recuperati gli oggetti e i valori dei campi vengono visualizzati nella console.  
  
 [!code-csharp[System.Enum.GetValues#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues_reflectiononly.cs#3)]
 [!code-vb[System.Enum.GetValues#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues_reflectiononly.vb#3)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di <xref:System.Enum.GetValues%2A>.  
  
 [!code-cpp[enumgetvalues#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetvalues/CPP/EnumGetValues.cpp#1)]
 [!code-csharp[enumgetvalues#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetvalues/CS/EnumGetValues.cs#1)]
 [!code-vb[enumgetvalues#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetvalues/VB/EnumGetValues.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo viene richiamato tramite reflection in un contesto di sola reflection, 
oppure 
 <paramref name="enumType" /> è un tipo di un assembly caricato in un contesto di sola reflection.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasFlag">
      <MemberSignature Language="C#" Value="public bool HasFlag (Enum flag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasFlag(class System.Enum flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.HasFlag(System.Enum)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasFlag (flag As Enum) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasFlag(Enum ^ flag);" />
      <MemberSignature Language="F#" Value="member this.HasFlag : Enum -&gt; bool" Usage="enum.HasFlag flag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Enum" />
      </Parameters>
      <Docs>
        <param name="flag">Valore di enumerazione.</param>
        <summary>Determina se uno o più campi di bit vengono impostati nell'istanza corrente.</summary>
        <returns><see langword="true" /> se il campo di bit o i campi di bit impostati in <paramref name="flag" /> vengono impostati anche nell'istanza corrente; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum.HasFlag%2A> restituisce il risultato dell'espressione booleana seguente.  
  
```  
thisInstance And flag = flag   
```  
  
 Se il valore sottostante del `flag` è uguale a zero, il metodo restituisce `true`. Se questo comportamento non è auspicabile, è possibile usare la <xref:System.Enum.Equals%2A> metodo per verificare l'uguaglianza con zero e chiamare <xref:System.Enum.HasFlag%2A> solo se il valore sottostante del `flag` è diverso da zero, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Enum.HasFlag#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.hasflag/cs/hasflag0.cs#1)]
 [!code-vb[System.Enum.HasFlag#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.hasflag/vb/hasflag0.vb#1)]  
  
 Il <xref:System.Enum.HasFlag%2A> metodo è progettato per essere utilizzati con tipi di enumerazione che sono contrassegnati con il <xref:System.FlagsAttribute> attributo e può essere utilizzato per determinare se sono impostati più campi di bit. Per i tipi di enumerazione che non siano contrassegnati con il <xref:System.FlagsAttribute> dell'attributo, chiamare il <xref:System.Enum.Equals%2A> metodo o il <xref:System.Enum.CompareTo%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente definisce un `ItemsOrdered` enumerazione che riflette le categorie di elementi che un cliente può ordinare in un ristorante. L'esempio verifica se il cliente ha ordinato un entrata sia delle bibite.  
  
 [!code-csharp[System.Enum.HasFlag#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.hasflag/cs/hasflag1.cs#2)]
 [!code-vb[System.Enum.HasFlag#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.hasflag/vb/hasflag1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="flag" /> è un tipo diverso rispetto all'istanza corrente.</exception>
        <altmember cref="T:System.FlagsAttribute" />
        <altmember cref="M:System.Enum.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public static bool IsDefined (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefined(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.IsDefined(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefined (enumType As Type, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefined(Type ^ enumType, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IsDefined : Type * obj -&gt; bool" Usage="System.Enum.IsDefined (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione.</param>
        <param name="value">Valore o nome di una costante in <paramref name="enumType" />.</param>
        <summary>Restituisce un valore booleano se in un'enumerazione specificata esiste un determinato valore integrale o il relativo nome sotto forma di stringa.</summary>
        <returns><see langword="true" /> se una costante in <paramref name="enumType" /> ha un valore uguale a <paramref name="value" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro può essere uno dei seguenti:  
  
-   Qualsiasi membro del tipo `enumType`.  
  
-   Una variabile il cui valore è un membro di enumerazione di tipo `enumType`.  
  
-   La rappresentazione di stringa del nome di un membro di enumerazione. I caratteri nella stringa devono avere lo stesso evento come il nome del membro dell'enumerazione.  
  
-   Un valore del tipo sottostante di `enumType`.  
  
 Se le costanti `enumType` definire un set di campi di bit e `value` contiene i valori, i nomi o valori sottostanti dei diversi campi di bit, il <xref:System.Enum.IsDefined%2A> restituzione del metodo `false`. In altre parole, per le enumerazioni che definiscono un set di campi di bit, il metodo determina solo se un campo di bit appartiene all'enumerazione. Per determinare se più campi di bit vengono impostati in un tipo di enumerazione contrassegnata con il <xref:System.FlagsAttribute> attributo, è possibile chiamare il <xref:System.Enum.HasFlag%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente definisce un'enumerazione denominata `PetType` costituito da tre campi di bit. Chiama quindi il <xref:System.Enum.IsDefined%2A> metodo con i possibili sottostanti i valori di enumerazione, nomi di tipo stringa e compositi valori risultanti dall'impostazione più campi di bit.  
  
 [!code-csharp[System.Enum.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.IsDefined/cs/isdefined1.cs#1)]
 [!code-vb[System.Enum.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.IsDefined/vb/IsDefined1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> o <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see langword="Enum" />.  
  
oppure 
Il tipo di <paramref name="value" /> è un'enumerazione, ma non è un'enumerazione di tipo <paramref name="enumType" />.  
  
oppure 
Il tipo di <paramref name="value" /> non è un tipo sottostante di <paramref name="enumType" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> non è di tipo <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" /> o <see cref="T:System.UInt64" /> oppure <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage"><para>Se <paramref name="enumType" /> è un'enumerazione che viene definita tramite il <see cref="T:System.FlagsAttribute" /> dell'attributo, il metodo restituisce <see langword="false" /> se i campi bit più <paramref name="value" /> vengono impostati ma <paramref name="value" /> non corrisponde a un valore di enumerazione composito, oppure se <paramref name="value" /> è una concatenazione di stringhe dei nomi di più flag di bit. Nell'esempio seguente, un <c>Pets</c> enumerazione viene definita con la <see cref="T:System.FlagsAttribute" /> attributo. Il <see cref="M:System.Enum.IsDefined(System.Type,System.Object)" /> restituzione del metodo <see langword="false" /> quando si passa il valore di enumerazione che contiene due campi di bit (<c>Pets.Dog</c> e <c>Pets.Cat</c>) impostato, e quando si passa la rappresentazione di stringa di valore di enumerazione ("cane, gatto").  
  
[! codice-csharp[System.Enum.IsDefined#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.IsDefined/cs/isdefined2.cs#2)] [! codice vb[System.Enum.IsDefined#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.IsDefined/vb/isdefined2.vb#2)] 
È possibile determinare se più campi di bit vengono impostati chiamando la <see cref="M:System.Enum.HasFlag(System.Enum)" /> (metodo).</para></block>
        <altmember cref="M:System.Enum.GetName(System.Type,System.Object)" />
        <altmember cref="M:System.Enum.GetNames(System.Type)" />
        <altmember cref="M:System.Enum.GetValues(System.Type)" />
        <altmember cref="M:System.Enum.HasFlag(System.Enum)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte la rappresentazione di stringa del nome o del valore numerico di una o più costanti enumerate in un oggetto enumerato equivalente.</summary>
        <altmember cref="M:System.Enum.TryParse``1(System.String,``0@)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (Type enumType, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(class System.Type enumType, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (enumType As Type, value As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(Type ^ enumType, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : Type * string -&gt; obj" Usage="System.Enum.Parse (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione.</param>
        <param name="value">Stringa che contiene il nome o il valore da convertire.</param>
        <summary>Converte la rappresentazione di stringa del nome o del valore numerico di una o più costanti enumerate in un oggetto enumerato equivalente.</summary>
        <returns>Oggetto di tipo <paramref name="enumType" /> il cui valore è rappresentato da <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro contiene la rappresentazione di stringa del valore sottostante un membro di enumerazione o una costante denominata o un elenco di costanti denominate delimitato da virgole (,). Uno o più spazi vuoti possono precedere o seguire ogni valore, il nome o virgole nel `value`. Se `value` è un elenco, il valore restituito è il valore dei nomi specificati combinati con un bit per bit `OR` operazione.  
  
 Se `value` è un nome che non corrisponde a una costante denominata del `enumType`, il metodo genera un <xref:System.ArgumentException>. Se `value` è la rappresentazione di stringa di un numero intero che rappresenta un valore sottostante pari il `enumType` enumerazione, il metodo restituisce un membro di enumerazione il cui valore sottostante è `value` convertito in un tipo integrale. Se questo comportamento è indesiderato, chiamare il <xref:System.Enum.IsDefined%2A> metodo affinché abbia effettivamente un membro di una rappresentazione particolare di un intero `enumType`. L'esempio seguente definisce una `Colors` enumerazione, chiama il <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> metodo per convertire le stringhe per i corrispondenti valori di enumerazione e chiama il <xref:System.Enum.IsDefined%2A> metodo per assicurarsi che i valori integrali particolari sottostanti i valori in il `Colors` enumerazione.  
  
 [!code-csharp[System.Enum.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample1.cs#1)]
 [!code-vb[System.Enum.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample1.vb#1)]  
  
 Questa operazione è tra maiuscole e minuscole.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> metodo per analizzare una matrice di stringhe che vengono create chiamando il <xref:System.Enum.GetNames%2A> (metodo). Usa inoltre il <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> metodo analizzare il valore di enumerazione che è costituito da un campo di bit.  
  
 [!code-cpp[enumparse#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumparse/CPP/EnumParse.cpp#1)]
 [!code-csharp[enumparse#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumparse/CS/EnumParse.cs#1)]
 [!code-vb[enumparse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumparse/VB/EnumParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> o <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.  
  
oppure 
 <paramref name="value" /> è una stringa vuota o contiene solo spazi vuoti.  
  
oppure 
 <paramref name="value" /> è un nome, ma non una delle costanti denominate definite per l'enumerazione.</exception>
        <exception cref="T:System.OverflowException"><paramref name="value" /> non è compreso nell'intervallo del tipo sottostante di <paramref name="enumType" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (Type enumType, string value, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(class System.Type enumType, string value, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse(System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (enumType As Type, value As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(Type ^ enumType, System::String ^ value, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Parse : Type * string * bool -&gt; obj" Usage="System.Enum.Parse (enumType, value, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione.</param>
        <param name="value">Stringa che contiene il nome o il valore da convertire.</param>
        <param name="ignoreCase"><see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole; in caso contrario, <see langword="false" />.</param>
        <summary>Converte la rappresentazione di stringa del nome o del valore numerico di una o più costanti enumerate in un oggetto enumerato equivalente. Un parametro specifica se l'operazione verrà eseguita senza distinzione tra maiuscole e minuscole.</summary>
        <returns>Oggetto di tipo <paramref name="enumType" /> il cui valore è rappresentato da <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `value` parametro contiene la rappresentazione di stringa del valore sottostante un membro di enumerazione o una costante denominata o un elenco di costanti denominate delimitato da virgole (,). Uno o più spazi vuoti possono precedere o seguire ogni valore, il nome o virgole nel `value`. Se `value` è un elenco, il valore restituito è il valore dei nomi specificati combinati con un bit per bit `OR` operazione.  
  
 Se `value` è un nome che non corrisponde a una costante denominata del `enumType`, il metodo genera un <xref:System.ArgumentException>. Se `value` è la rappresentazione di stringa di un numero intero che rappresenta un valore sottostante pari il `enumType` enumerazione, il metodo restituisce un membro di enumerazione il cui valore sottostante è `value` convertito in un tipo integrale. Se questo comportamento è indesiderato, chiamare il <xref:System.Enum.IsDefined%2A> metodo affinché abbia effettivamente un membro di una rappresentazione particolare di un intero `enumType`. L'esempio seguente definisce una `Colors` enumerazione, chiama il <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> metodo per convertire le stringhe per i corrispondenti valori di enumerazione e chiama il <xref:System.Enum.IsDefined%2A> metodo per assicurarsi che i valori integrali particolari sottostanti i valori in il `Colors` enumerazione.  
  
 [!code-csharp[System.Enum.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample2.cs#2)]
 [!code-vb[System.Enum.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample2.vb#2)]  
  
 Il `ignoreCase` parametro specifica se questa operazione è tra maiuscole e minuscole.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> metodo per analizzare una matrice di stringhe che vengono create chiamando il <xref:System.Enum.GetNames%2A> (metodo). Usa inoltre il <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> metodo analizzare il valore di enumerazione che è costituito da un campo di bit.  
  
 [!code-csharp[System.Enum.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample2.cs#2)]
 [!code-vb[System.Enum.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> o <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.  
  
oppure 
 <paramref name="value" /> è una stringa vuota ("") o contiene solo spazi vuoti.  
  
oppure 
 <paramref name="value" /> è un nome, ma non una delle costanti denominate definite per l'enumerazione.</exception>
        <exception cref="T:System.OverflowException"><paramref name="value" /> non è compreso nell'intervallo del tipo sottostante di <paramref name="enumType" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Parse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum Parse&lt;TEnum&gt; (string value) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum Parse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse(Of TEnum As Structure) (value As String) As TEnum" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static TEnum Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; 'Enum (requires 'Enum : struct)" Usage="System.Enum.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">To be added.</typeparam>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum Parse&lt;TEnum&gt; (string value, bool ignoreCase) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum Parse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse``1(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse(Of TEnum As Structure) (value As String, ignoreCase As Boolean) As TEnum" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static TEnum Parse(System::String ^ value, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Parse : string * bool -&gt; 'Enum (requires 'Enum : struct)" Usage="System.Enum.Parse (value, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un valore booleano basato sul tipo sottostante.</summary>
        <returns>Questo membro genera sempre un'eccezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente non implementato. Genera sempre un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un intero senza segno a 8 bit basato sul tipo sottostante.</summary>
        <returns>Valore convertito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> per eseguire la conversione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un carattere Unicode basato sul tipo sottostante.</summary>
        <returns>Questo membro genera sempre un'eccezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente non implementato. Genera sempre un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un oggetto <see cref="T:System.DateTime" /> basato sul tipo sottostante.</summary>
        <returns>Questo membro genera sempre un'eccezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente non implementato. Genera sempre un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un oggetto <see cref="T:System.Decimal" /> basato sul tipo sottostante.</summary>
        <returns>Questo membro genera sempre un'eccezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente non implementato. Genera sempre un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un numero a virgola mobile e precisione doppia basato sul tipo sottostante.</summary>
        <returns>Questo membro genera sempre un'eccezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente non implementato. Genera sempre un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un intero con segno a 16 bit basato sul tipo sottostante.</summary>
        <returns>Valore convertito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> per eseguire la conversione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un intero con segno a 32 bit basato sul tipo sottostante.</summary>
        <returns>Valore convertito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> per eseguire la conversione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un intero con segno a 64 bit basato sul tipo sottostante.</summary>
        <returns>Valore convertito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> per eseguire la conversione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un intero con segno a 8 bit basato sul tipo sottostante.</summary>
        <returns>Valore convertito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> per eseguire la conversione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un numero a virgola mobile e con precisione singola in base al tipo sottostante.</summary>
        <returns>Questo membro genera sempre un'eccezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attualmente non implementato. Genera sempre un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">In tutti i casi.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString().")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Tipo in cui eseguire la conversione.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un tipo specificato basato sul tipo sottostante.</summary>
        <returns>Valore convertito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> per eseguire la conversione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un intero senza segno a 16 bit basato sul tipo sottostante.</summary>
        <returns>Valore convertito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> per eseguire la conversione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un intero senza segno a 32 bit basato sul tipo sottostante.</summary>
        <returns>Valore convertito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> per eseguire la conversione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore corrente in un intero senza segno a 64 bit basato sul tipo sottostante.</summary>
        <returns>Valore convertito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> per eseguire la conversione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (format As String, provider As IFormatProvider) As String Implements IFormattable.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IFormattable.ToString(System::String ^ format, IFormatProvider ^ provider) = IFormattable::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString(String).")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte un valore intero specificato in un membro di enumerazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Byte) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * byte -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione da restituire.</param>
        <param name="value">Valore da convertire in un membro di enumerazione.</param>
        <summary>Converte l'intero senza segno a 8 bit specificato in un membro di enumerazione.</summary>
        <returns>Istanza dell'enumerazione impostata su <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum.ToObject%28System.Type%2CSystem.Byte%29> metodo converte `value` a un membro di enumerazione il cui valore sottostante è `value`. Si noti che la conversione ha esito positivo anche se è di fuori dei limiti del valore `enumType` membri. Per assicurarsi che `value` è un valore sottostante valido il `enumType` enumerazione, passarlo al <xref:System.Enum.IsDefined%2A> (metodo).  
  
 Questo metodo di conversione restituisce un valore di tipo <xref:System.Object>. È quindi possibile eseguirne il cast o convertirlo in un oggetto di tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Short) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, short value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * int16 -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione da restituire.</param>
        <param name="value">Valore da convertire in un membro di enumerazione.</param>
        <summary>Converte l'intero con segno a 16 bit specificato in un membro di enumerazione.</summary>
        <returns>Istanza dell'enumerazione impostata su <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum.ToObject%28System.Type%2CSystem.Int16%29> metodo converte `value` a un membro di enumerazione il cui valore sottostante è `value`. Si noti che la conversione ha esito positivo anche se è di fuori dei limiti del valore `enumType` membri. Per assicurarsi che `value` è un valore sottostante valido il `enumType` enumerazione, passarlo al <xref:System.Enum.IsDefined%2A> (metodo).  
  
 Questo metodo di conversione restituisce un valore di tipo <xref:System.Object>. È quindi possibile eseguirne il cast o convertirlo in un oggetto di tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, int value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * int -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione da restituire.</param>
        <param name="value">Valore da convertire in un membro di enumerazione.</param>
        <summary>Converte l'intero con segno a 32 bit specificato in un membro di enumerazione.</summary>
        <returns>Istanza dell'enumerazione impostata su <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum.ToObject%28System.Type%2CSystem.Int32%29> metodo converte `value` a un membro di enumerazione il cui valore sottostante è `value`. Si noti che la conversione ha esito positivo anche se è di fuori dei limiti del valore `enumType` membri. Per assicurarsi che `value` è un valore sottostante valido il `enumType` enumerazione, passarlo al <xref:System.Enum.IsDefined%2A> (metodo).  
  
 Questo metodo di conversione restituisce un valore di tipo <xref:System.Object>. È quindi possibile eseguirne il cast o convertirlo in un oggetto di tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, long value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * int64 -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione da restituire.</param>
        <param name="value">Valore da convertire in un membro di enumerazione.</param>
        <summary>Converte l'intero con segno a 64 bit specificato in un membro di enumerazione.</summary>
        <returns>Istanza dell'enumerazione impostata su <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum.ToObject%28System.Type%2CSystem.Int64%29> metodo converte `value` a un membro di enumerazione il cui valore sottostante è `value`. Si noti che la conversione ha esito positivo anche se è di fuori dei limiti del valore `enumType` membri. Per assicurarsi che `value` è un valore sottostante valido il `enumType` enumerazione, passarlo al <xref:System.Enum.IsDefined%2A> (metodo).  
  
 Questo metodo di conversione restituisce un valore di tipo <xref:System.Object>. È quindi possibile eseguirne il cast o convertirlo in un oggetto di tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * obj -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione da restituire.</param>
        <param name="value">Valore da convertire in un membro di enumerazione.</param>
        <summary>Converte l'oggetto specificato con un valore intero in un membro di enumerazione.</summary>
        <returns>Oggetto di enumerazione il cui valore è <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum.ToObject%28System.Type%2CSystem.Object%29> metodo converte il valore integrale `value` a un membro di enumerazione il cui valore sottostante è `value`. Si noti che la conversione ha esito positivo anche se è di fuori dei limiti del valore `enumType` membri. Per assicurarsi che `value` è un valore sottostante valido il `enumType` enumerazione, passarlo al <xref:System.Enum.IsDefined%2A> (metodo).  
  
 Questo metodo di conversione restituisce un valore di tipo <xref:System.Object>. È quindi possibile eseguirne il cast o convertirlo in un oggetto di tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> o <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.  
  
oppure 
 <paramref name="value" /> non è di tipo <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" /> o <see cref="T:System.UInt64" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As SByte) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * sbyte -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione da restituire.</param>
        <param name="value">Valore da convertire in un membro di enumerazione.</param>
        <summary>Converte il valore dell'intero con segno a 8 bit specificato in un membro di enumerazione.</summary>
        <returns>Istanza dell'enumerazione impostata su <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum.ToObject%28System.Type%2CSystem.SByte%29> metodo converte `value` a un membro di enumerazione il cui valore sottostante è `value`. Si noti che la conversione ha esito positivo anche se è di fuori dei limiti del valore `enumType` membri. Per assicurarsi che `value` è un valore sottostante valido il `enumType` enumerazione, passarlo al <xref:System.Enum.IsDefined%2A> (metodo).  
  
 Questo metodo di conversione restituisce un valore di tipo <xref:System.Object>. È quindi possibile eseguirne il cast o convertirlo in un oggetto di tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As UShort) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * uint16 -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione da restituire.</param>
        <param name="value">Valore da convertire in un membro di enumerazione.</param>
        <summary>Converte il valore dell'intero senza segno a 16 bit specificato in un membro di enumerazione.</summary>
        <returns>Istanza dell'enumerazione impostata su <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt16%29> metodo converte `value` a un membro di enumerazione il cui valore sottostante è `value`. Si noti che la conversione ha esito positivo anche se è di fuori dei limiti del valore `enumType` membri. Per assicurarsi che `value` è un valore sottostante valido il `enumType` enumerazione, passarlo al <xref:System.Enum.IsDefined%2A> (metodo).  
  
 Questo metodo di conversione restituisce un valore di tipo <xref:System.Object>. È quindi possibile eseguirne il cast o convertirlo in un oggetto di tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As UInteger) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * uint32 -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione da restituire.</param>
        <param name="value">Valore da convertire in un membro di enumerazione.</param>
        <summary>Converte il valore dell'intero senza segno a 32 bit specificato in un membro di enumerazione.</summary>
        <returns>Istanza dell'enumerazione impostata su <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt32%29> metodo converte `value` a un membro di enumerazione il cui valore sottostante è `value`. Si noti che la conversione ha esito positivo anche se è di fuori dei limiti del valore `enumType` membri. Per assicurarsi che `value` è un valore sottostante valido il `enumType` enumerazione, passarlo al <xref:System.Enum.IsDefined%2A> (metodo).  
  
 Questo metodo di conversione restituisce un valore di tipo <xref:System.Object>. È quindi possibile eseguirne il cast o convertirlo in un oggetto di tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As ULong) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * uint64 -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo di enumerazione da restituire.</param>
        <param name="value">Valore da convertire in un membro di enumerazione.</param>
        <summary>Converte il valore dell'intero senza segno a 64 bit specificato in un membro di enumerazione.</summary>
        <returns>Istanza dell'enumerazione impostata su <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt64%29> metodo converte `value` a un membro di enumerazione il cui valore sottostante è `value`. Si noti che la conversione ha esito positivo anche se è di fuori dei limiti del valore `enumType` membri. Per assicurarsi che `value` è un valore sottostante valido il `enumType` enumerazione, passarlo al <xref:System.Enum.IsDefined%2A> (metodo).  
  
 Questo metodo di conversione restituisce un valore di tipo <xref:System.Object>. È quindi possibile eseguirne il cast o convertirlo in un oggetto di tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> non è un elemento <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore dell'istanza corrente nell'equivalente rappresentazione di stringa.</summary>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Stringhe di formato di enumerazione</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="enum.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte il valore dell'istanza corrente nell'equivalente rappresentazione di stringa.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito viene formattato con l'identificatore di formato generale ("G"). Vale a dire, se il <xref:System.FlagsAttribute> non viene applicato a questo tipo enumerato e vi è una costante denominata uguale al valore di questa istanza, quindi il valore restituito è una stringa contenente il nome della costante. Se il <xref:System.FlagsAttribute> viene applicata una combinazione di uno o più costanti denominate è uguale al valore di questa istanza, quindi il valore restituito è una stringa contenente un elenco separati da delimitatori di nomi delle costanti. In caso contrario, il valore restituito è la rappresentazione di stringa del valore numerico di questa istanza. Per altre informazioni sulla formattazione dei valori di enumerazione, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md). Per altre informazioni sulla formattazione in generale, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 L'esempio seguente illustra la conversione di un valore enumerato in una stringa.  
  
 [!code-cpp[Classic Enum.ToString2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Enum.ToString2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/CS/source.cs#1)]
 [!code-vb[Classic Enum.ToString2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Se più membri di enumerazione hanno lo stesso valore sottostante e si tenta di recuperare la rappresentazione di stringa del nome di un membro di enumerazione basato sul relativo valore sottostante, il codice non deve verificare supposizioni su quale nome verrà restituito il metodo. Ad esempio, l'enumerazione seguente definisce due membri, <c>Shade. Gray</c> e <c>Shade. Grey</c>, che hanno lo stesso valore sottostante.  
  
[! codice-csharp[System.Enum.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#1)] [! codice vb[System.Enum.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#1)] 
La seguente chiamata al metodo tenta di recuperare il nome di un membro del <c>Shade</c> enumerazione il cui valore sottostante è 1. Il metodo può restituire "Gray" o "Grey" e il codice non deve verificare supposizioni su cui verrà restituito string.  
  
[! codice-csharp[System.Enum.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#2)] [! codice vb[System.Enum.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#2)]</para></block>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="enum.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString().")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(obsoleto)</param>
        <summary>L'overload di questo metodo è obsoleto; usare <see cref="M:System.Enum.ToString" />.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="enum.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Stringa di formato.</param>
        <summary>Converte il valore dell'istanza corrente nella rappresentazione di stringa equivalente, usando il formato specificato.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza, in base a quanto specificato da <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `format` parametro può essere una delle stringhe di formato seguente: "G" o "g", "D" o "d", "X" o "x" e "F" o "f" (la stringa di formato non distinzione maiuscole/minuscole). Se `format` è `null` o una stringa vuota (""), viene usato l'identificatore di formato generale ("G"). Per altre informazioni sulle stringhe di formato di enumerazione e formattazione dei valori di enumerazione, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md). Per altre informazioni sulla formattazione in generale, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come convertire un valore enumerato in una stringa.  
  
 [!code-cpp[enum.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/enum.tostring/CPP/tostr.cpp#1)]
 [!code-csharp[enum.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/enum.tostring/CS/tostr.cs#1)]
 [!code-vb[enum.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enum.tostring/VB/tostr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> contiene una specifica non valida.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="format" /> è uguale a "X", ma il tipo di enumerazione è sconosciuto.</exception>
        <block subset="none" type="usage"><para>Se più membri di enumerazione hanno lo stesso valore sottostante e si tenta di recuperare la rappresentazione di stringa del nome di un membro di enumerazione basato sul relativo valore sottostante, il codice non deve verificare supposizioni su quale nome verrà restituito il metodo. Ad esempio, l'enumerazione seguente definisce due membri, <c>Shade. Gray</c> e <c>Shade. Grey</c>, che hanno lo stesso valore sottostante.  
  
[! codice-csharp[System.Enum.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#1)] [! codice vb[System.Enum.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#1)] 
La seguente chiamata al metodo tenta di recuperare il nome di un membro del <c>Shade</c> enumerazione il cui valore sottostante è 1. Il metodo può restituire "Gray" o "Grey" e il codice non deve verificare supposizioni su cui verrà restituito string.  
  
[! codice-csharp[System.Enum.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#3)] [! codice vb[System.Enum.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#3)]</para></block>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
        <altmember cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formattazione di tipi in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Stringhe di formato di enumerazione</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="enum.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString(String).")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Specifica di formato.</param>
        <param name="provider">(Obsoleto).</param>
        <summary>L'overload di questo metodo è obsoleto; usare <see cref="M:System.Enum.ToString(System.String)" />.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza, in base a quanto specificato da <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `format` parametro può essere una delle stringhe di formato seguente: "G" o "g", "D" o "d", "X" o "x" e "F" o "f" (la stringa di formato non distinzione maiuscole/minuscole). Se `format` è `null` o una stringa vuota (""), viene usato l'identificatore di formato generale ("G"). Per altre informazioni sulle stringhe di formato di enumerazione e formattazione dei valori di enumerazione, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md). Per altre informazioni sulla formattazione in generale, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).  
  
 Specificare solo `format`; il `provider` parametro è obsoleto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> non contiene una specifica di formato valida.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="format" /> è uguale a "X", ma il tipo di enumerazione è sconosciuto.</exception>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formattazione di tipi in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Stringhe di formato di enumerazione</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte la rappresentazione di stringa del nome o del valore numerico di una o più costanti enumerate in un oggetto enumerato equivalente. Il valore restituito indica se la conversione è riuscita.</summary>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (Type enumType, string value, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(class System.Type enumType, string value, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse(System.Type,System.String,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (enumType As Type, value As String, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(Type ^ enumType, System::String ^ value, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : Type * string *  -&gt; bool" Usage="System.Enum.TryParse (enumType, value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enumType">To be added.</param>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (Type enumType, string value, bool ignoreCase, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(class System.Type enumType, string value, bool ignoreCase, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse(System.Type,System.String,System.Boolean,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (enumType As Type, value As String, ignoreCase As Boolean, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(Type ^ enumType, System::String ^ value, bool ignoreCase, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : Type * string * bool *  -&gt; bool" Usage="System.Enum.TryParse (enumType, value, ignoreCase, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enumType">To be added.</param>
        <param name="value">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static bool TryParse&lt;TEnum&gt; (string value, out TEnum result) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, [out] !!TEnum&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse``1(System.String,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse(Of TEnum As Structure) (value As String, ByRef result As TEnum) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] TEnum % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool (requires 'Enum : struct)" Usage="System.Enum.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="TEnum" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">Tipo di enumerazione nel quale convertire <paramref name="value" />.</typeparam>
        <param name="value">Rappresentazione di stringa con distinzione tra maiuscole e minuscole del nome di enumerazione o del valore sottostante da convertire.</param>
        <param name="result">Quando questo metodo viene restituito, <paramref name="result" /> contiene un oggetto di tipo <c>TEnum</c> il cui valore è rappresentato da <paramref name="value" /> se l'operazione di analisi viene eseguita correttamente. Se l'operazione di analisi non riesce, <paramref name="result" /> contiene il valore predefinito del tipo sottostante di <c>TEnum</c>. Si noti che questo valore non deve necessariamente essere un membro dell'enumerazione di <c>TEnum</c>. Questo parametro viene passato non inizializzato.</param>
        <summary>Converte la rappresentazione di stringa del nome o del valore numerico di una o più costanti enumerate in un oggetto enumerato equivalente. Il valore restituito indica se la conversione è riuscita.</summary>
        <returns><see langword="true" /> se il parametro <paramref name="value" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29> è identico per le <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> metodo, con la differenza che anziché generare un'eccezione, restituisce `false` se la conversione non riesce. Elimina la necessità di gestione durante l'analisi la rappresentazione di stringa del valore di enumerazione delle eccezioni.  
  
 Il `value` parametro contiene la rappresentazione di stringa del valore sottostante un membro di enumerazione o una costante denominata o un elenco di costanti denominate o sottostanti valori delimitati da virgole (,). Se `value` include più costanti o valori denominati, uno o più spazi vuoti possono precedere o seguire ogni valore, il nome o virgole nel `value`. Se `value` è riportato un elenco `result` riflette il valore dei nomi specificati o dei valori combinati con un bit per bit sottostanti `OR` operazione. Se `value` è la rappresentazione di stringa del nome di un valore di enumerazione, il confronto di `value` con enumerazione nomi è tra maiuscole e minuscole.  
  
 Se `value` è un nome che non corrisponde a una costante denominata del `TEnum`, il metodo restituisce `false`. Se `value` è la rappresentazione di stringa di un numero intero che rappresenta un valore sottostante pari il `TEnum` enumerazione, il metodo restituisce un membro di enumerazione il cui valore sottostante è `value` convertito in un tipo integrale. Se questo comportamento è indesiderato, chiamare il <xref:System.Enum.IsDefined%2A> metodo affinché abbia effettivamente un membro di una rappresentazione particolare di un intero `TEnum`.  
  
   
  
## Examples  
 L'esempio seguente definisce una `Colors` enumerazione, chiama il <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29> metodo per convertire le stringhe per i corrispondenti valori di enumerazione e chiama il <xref:System.Enum.IsDefined%2A> metodo per assicurarsi che i valori integrali particolari sottostanti i valori in il `Colors` enumerazione.  
  
 [!code-csharp[System.Enum.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Enum.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="TEnum" /> non è un tipo di enumerazione.</exception>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static bool TryParse&lt;TEnum&gt; (string value, bool ignoreCase, out TEnum result) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, bool ignoreCase, [out] !!TEnum&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse``1(System.String,System.Boolean,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse(Of TEnum As Structure) (value As String, ignoreCase As Boolean, ByRef result As TEnum) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static bool TryParse(System::String ^ value, bool ignoreCase, [Runtime::InteropServices::Out] TEnum % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * bool *  -&gt; bool (requires 'Enum : struct)" Usage="System.Enum.TryParse (value, ignoreCase, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="result" Type="TEnum" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">Tipo di enumerazione nel quale convertire <paramref name="value" />.</typeparam>
        <param name="value">Rappresentazione di stringa del nome di enumerazione o del valore sottostante da convertire.</param>
        <param name="ignoreCase"><see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole, <see langword="false" /> per non ignorarla.</param>
        <param name="result">Quando questo metodo viene restituito, <paramref name="result" /> contiene un oggetto di tipo <c>TEnum</c> il cui valore è rappresentato da <paramref name="value" /> se l'operazione di analisi viene eseguita correttamente. Se l'operazione di analisi non riesce, <paramref name="result" /> contiene il valore predefinito del tipo sottostante di <c>TEnum</c>. Si noti che questo valore non deve necessariamente essere un membro dell'enumerazione di <c>TEnum</c>. Questo parametro viene passato non inizializzato.</param>
        <summary>Converte la rappresentazione di stringa del nome o del valore numerico di una o più costanti enumerate in un oggetto enumerato equivalente. Un parametro specifica se l'operazione verrà eseguita con distinzione tra maiuscole e minuscole. Il valore restituito indica se la conversione è riuscita.</summary>
        <returns><see langword="true" /> se il parametro <paramref name="value" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> è identico per le <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> metodo, con la differenza che anziché generare un'eccezione, restituisce `false` se la conversione non riesce. Elimina la necessità di gestione durante l'analisi la rappresentazione di stringa del valore di enumerazione delle eccezioni.  
  
 Il `value` parametro contiene la rappresentazione di stringa del valore sottostante un membro di enumerazione o una costante denominata o un elenco di costanti denominate o sottostanti valori delimitati da virgole (,). Se `value` include più costanti o valori denominati, uno o più spazi vuoti possono precedere o seguire ogni valore, il nome o virgole nel `value`. Se `value` è riportato un elenco `result` riflette il valore dei nomi specificati o dei valori combinati con un bit per bit sottostanti `OR` operazione. Se `value` è la rappresentazione di stringa del nome di un valore di enumerazione, il confronto dei `value` enumerazione nomi dipende il `ignoreCase` parametro. Se `true`, il confronto è tra maiuscole e minuscole; se `false`, si tratta di distinzione maiuscole/minuscole.  
  
 Se `value` è un nome che non corrisponde a una costante denominata del `TEnum`, il metodo restituisce `false`. Se `value` è la rappresentazione di stringa di un numero intero che rappresenta un valore sottostante pari il `TEnum` enumerazione, il metodo restituisce un membro di enumerazione il cui valore sottostante è `value` convertito in un tipo integrale. Se questo comportamento è indesiderato, chiamare il <xref:System.Enum.IsDefined%2A> metodo affinché abbia effettivamente un membro di una rappresentazione particolare di un intero `TEnum`.  
  
   
  
## Examples  
 L'esempio seguente definisce una `Colors` enumerazione, chiama il <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> metodo per convertire le stringhe per i corrispondenti valori di enumerazione e chiama il <xref:System.Enum.IsDefined%2A> metodo per assicurarsi che i valori integrali particolari sottostanti i valori in il `Colors` enumerazione. Il <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> metodo utilizza il confronto tra maiuscole e minuscole durante il tentativo di convertire le rappresentazioni di stringa di denominato costanti per valori di enumerazione equivalente.  
  
 [!code-csharp[System.Enum.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tryparse/cs/tryparse2.cs#2)]
 [!code-vb[System.Enum.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tryparse/vb/tryparse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="TEnum" /> non è un tipo di enumerazione.</exception>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String,System.Boolean)" />
      </Docs>
    </Member>
  </Members>
</Type>