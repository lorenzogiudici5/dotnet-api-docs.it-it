<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="11996d97bef6121bce982a8368bef5e8197c8a44" />
    <Meta Name="ms.sourcegitcommit" Value="1465f1a9bce3970cd9e95769eaa641b92a0a22d5" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/18/2018" />
    <Meta Name="ms.locfileid" Value="31469399" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Controlla il Garbage Collector di sistema, un servizio che recupera automaticamente la memoria inutilizzata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il garbage collector non è un componente di common language runtime che controlla l'allocazione e il rilascio di memoria gestita. I metodi in questa classe determinano quando l'operazione di garbage collection viene eseguita su un oggetto e quando vengono rilasciate le risorse allocate da un oggetto. Proprietà di questa classe forniscono informazioni sulla quantità totale di memoria disponibile nel sistema e la categoria di età o generazione, della memoria allocata a un oggetto.  
  
 Il garbage collector tiene traccia e recupera gli oggetti allocati nella memoria gestita. Periodicamente, il garbage collector esegue garbage collection per recuperare la memoria allocata agli oggetti per cui non sono presenti riferimenti validi. Operazione di Garbage collection viene eseguita automaticamente quando una richiesta di memoria non può essere soddisfatti mediante memoria libera disponibile. In alternativa, un'applicazione può forzare garbage collection con il <xref:System.GC.Collect%2A> metodo.  
  
 Operazione di Garbage collection è costituito dai passaggi seguenti:  
  
1.  Il garbage collector esegue la ricerca di oggetti gestiti a cui fa riferimento nel codice gestito.  
  
2.  Il garbage collector tenta di completare gli oggetti che non fa riferimento.  
  
3.  Il garbage collector libera gli oggetti che non fa riferimento e recupera la memoria.  
  
 Questo argomento include le sezioni seguenti:  
  
 [Il garbage collector e le risorse non gestite](#unmanaged)   
 [Generazioni e la durata dell'oggetto](#generations)   
 [Impedisce l'operazione di garbage collection](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>Il garbage collector e le risorse non gestite  
 Durante una raccolta, il garbage collector non libera un oggetto se vengono rilevati uno o più riferimenti all'oggetto nel codice gestito. Tuttavia, il garbage collector non riconosce i riferimenti a un oggetto dal codice non gestito e potrebbe liberare gli oggetti che vengono utilizzati esclusivamente nel codice non gestito a meno che non esplicitamente impedito di farlo. Il <xref:System.GC.KeepAlive%2A> metodo fornisce un meccanismo che impedisce al garbage collector di raccogliere gli oggetti che sono ancora in uso nel codice non gestito.  
  
 A parte le allocazioni di memoria gestita, le implementazioni del garbage collector non mantengono le informazioni sulle risorse occupate da un oggetto, ad esempio gli handle di file o le connessioni al database. Quando un tipo utilizza le risorse non gestite che devono essere rilasciate prima del recupero delle istanze del tipo, il tipo può implementare un finalizzatore.  
  
 Nella maggior parte dei casi, i finalizzatori vengono implementati eseguendo l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo; tuttavia, i tipi scritti in c# o C++ implementano i distruttori, quali i compilatori trasformare in un override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Nella maggior parte dei casi, se un oggetto ha un finalizzatore, il garbage collector viene chiamato prima di liberare l'oggetto. Tuttavia, il garbage collector non è necessario chiamare i finalizzatori in tutte le situazioni. ad esempio, il <xref:System.GC.SuppressFinalize%2A> metodo impedisce in modo esplicito un finalizzatore dell'oggetto venga chiamato. Inoltre, il garbage collector non è necessario utilizzare un thread specifico per completare gli oggetti o garantisce l'ordine in cui vengono chiamati i finalizzatori per gli oggetti che fanno riferimento a altro, ma sono comunque disponibili per l'operazione di garbage collection.  
  
 In scenari in cui le risorse devono essere rilasciate in un momento specifico, possono implementare le classi di <xref:System.IDisposable> interfaccia, che contiene il <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodo che esegue attività di gestione e la pulizia delle risorse. Le classi che implementano <xref:System.IDisposable.Dispose%2A> devono specificare, come parte del contratto classe, se e quando i consumer di classe chiamano il metodo per pulire l'oggetto. Il garbage collector non, per impostazione predefinita, chiama il <xref:System.IDisposable.Dispose%2A> metodo; tuttavia, le implementazioni del <xref:System.IDisposable.Dispose%2A> metodo può chiamare metodi <xref:System.GC> classe per personalizzare il comportamento di finalizzazione del garbage collector.  
  
 Per ulteriori informazioni sul completamento di un oggetto e il modello dispose, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>Generazioni e la durata dell'oggetto  
 Il garbage collector di common language runtime supporta la durata dell'oggetto utilizzando le generazioni. Una generazione è un'unità di misura della durata relativa degli oggetti in memoria. Il numero di generazione, o l'età, di un oggetto indica la generazione a cui appartiene l'oggetto. Gli oggetti creati più recente fanno parte delle generazioni più recenti e numeri di generazione più bassi rispetto a scorrere gli oggetti creati in precedenza in tutta la durata dell'applicazione. Gli oggetti della generazione più recente si trovano nella generazione 0. Questa implementazione del garbage collector supporta tre generazioni di oggetti, le generazioni 0, 1 e 2. È possibile recuperare il valore di <xref:System.GC.MaxGeneration%2A> proprietà per determinare il numero massimo di generazione supportato dal sistema.  
  
 La durata dell'oggetto consente alle applicazioni di operazione di garbage collection di destinazione in un set specifico di generazioni piuttosto che il garbage collector valutare tutte le generazioni. Esegue l'overload di <xref:System.GC.Collect%2A> metodo che includono un `generation` parametro consente di specificare la generazione meno recente per essere sottoposto a garbage collection.  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>Impedisce l'operazione di garbage collection  
 A partire dal [!INCLUDE[net_v46](~/includes/net-v46-md.md)], il garbage collector supporta una modalità aree GC latenza che può essere utilizzata durante l'esecuzione di percorsi critici in cui garbage raccolta può influire negativamente sulle prestazioni di un'app. Nessuna modalità di latenza delle aree di GC è necessario specificare una quantità di memoria da allocare senza interferenze del garbage collector. Se il runtime può allocare la memoria, il runtime non eseguire un'operazione di garbage collection durante l'esecuzione di codice in un percorso critico.  
  
 Si definisce l'inizio del percorso critico dell'area non GC chiamando uno degli overload di <xref:System.GC.TryStartNoGCRegion%2A>. Specificare la fine del percorso critico chiamando il <xref:System.GC.EndNoGCRegion%2A> metodo.  
  
 Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si devono chiamare solo il <xref:System.GC.EndNoGCRegion%2A> metodo se il runtime è attualmente in alcuna modalità di latenza delle aree GC. In altre parole, non è necessario chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata di metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo solo perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.  
  
   
  
## Examples  
 Nell'esempio seguente utilizza diversi metodi di catalogo globale per ottenere la generazione di informazioni sulla memoria relative a un blocco di oggetti inutilizzati e stamparlo nella console. Gli oggetti inutilizzati vengono quindi raccolti e vengono visualizzati i totali della memoria.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Quantità incrementale di memoria non gestita che è stata allocata.</param>
        <summary>Informa il runtime di un'allocazione di una grande quantità di memoria non gestita di cui tenere conto durante la pianificazione della procedura di Garbage Collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Determinazione della necessità di pianificare operazioni di garbage collection, il runtime tiene in considerazione la quantità di memoria gestito viene allocato. Se un oggetto gestito di piccole dimensioni viene allocata una grande quantità di memoria non gestita, il runtime prende in considerazione solo la memoria gestita e viene pertanto sottovalutata l'urgenza della pianificazione della procedura di garbage collection. Il <xref:System.GC.AddMemoryPressure%2A> metodo informa il runtime di questa pressione aggiuntiva sulla memoria di sistema.  
  
 Nel modello di utilizzo più semplice, un oggetto gestito alloca memoria non gestita nel costruttore e lo rilascia nel `Dispose` o `Finalize` metodo. Chiamare il <xref:System.GC.AddMemoryPressure%2A> metodo dopo l'allocazione di memoria non gestita e chiamare il <xref:System.GC.RemoveMemoryPressure%2A> metodo dopo averlo rilasciato.  
  
 In scenari più complessi, in cui l'allocazione di memoria non gestita cambia sostanzialmente durante la durata dell'oggetto gestito, è possibile chiamare il <xref:System.GC.AddMemoryPressure%2A> e <xref:System.GC.RemoveMemoryPressure%2A> metodi per comunicare le modifiche incrementali al runtime.  
  
> [!CAUTION]
>  È necessario assicurarsi di rimuovere esattamente la quantità di pressione che aggiunti. In caso contrario, può influenzare negativamente le prestazioni del sistema nelle applicazioni eseguite per lunghi periodi di tempo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> è minore o uguale a 0.  
  
 oppure  
  
 Su un computer a 32 bit, <paramref name="bytesAllocated" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter chiamare codice non gestito per la modifica delle priorità di garbage collection. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annulla la registrazione di una notifica di un'operazione di Garbage Collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo annulla una notifica di garbage collection che è stata registrata usando il <xref:System.GC.RegisterForFullGCNotification%2A> metodo. Non è necessario chiamare questo metodo prima di modificare i valori di soglia dei parametri nelle chiamate successive al <xref:System.GC.RegisterForFullGCNotification%2A> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente consente di annullare una registrazione di garbage collection. In questo esempio fa parte di un esempio più esaustivo disponibile per il [notifiche di Garbage Collection](~/docs/standard/garbage-collection/notifications.md) argomento.  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questo membro non è disponibile quando l'operazione di Garbage Collection in modalità simultanea è abilitata. Vedere l'impostazione di runtime [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) per informazioni su come disabilitare la Garbage Collection simultanea.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Forza la procedura di Garbage Collection.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Forza un'operazione immediata di Garbage Collection di tutte le generazioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per provare a recuperare tutta la memoria che non è accessibile. Esegue un'operazione di Garbage Collection bloccante per tutte le generazioni.  
  
 Tutti gli oggetti, indipendentemente dal tempo sono stati in memoria, sono considerati per la raccolta. Tuttavia, non vengono raccolti gli oggetti a cui fa riferimento nel codice gestito. Utilizzare questo metodo per forzare il sistema per provare a recuperare la quantità massima di memoria disponibile.  
  
 A partire da [!INCLUDE[net_v451](~/includes/net-v451-md.md)], è possibile compattare gli heap di oggetti grandi impostando la proprietà <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> su <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> prima di chiamare il metodo <xref:System.GC.Collect%2A>, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.GC.Collect%2A> metodo per eseguire una raccolta su tutte le generazioni di memoria. Il codice genera un numero di oggetti inutilizzati e quindi chiama il <xref:System.GC.Collect%2A> metodo per eliminarli dalla memoria.  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Numero della generazione meno recente da sottoporre a Garbage Collection.</param>
        <summary>Forza un immediato Garbage Collection a partire dalla generazione 0 fino a una determinata generazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per provare a recuperare la memoria non accessibile. Tuttavia, questo metodo non garantisce che tutta la memoria inaccessibile della generazione specificata è stata recuperata.  
  
 Se viene implementata la durata dell'oggetto, il garbage collector non raccoglie gli oggetti con un numero di generazione che è superiore alla generazione specificata. Se non viene implementata la durata dell'oggetto, il garbage collector considera tutti gli oggetti durante l'operazione di garbage collection.  
  
 Utilizzare il <xref:System.GC.MaxGeneration%2A> proprietà per determinare il valore massimo valido di `generation` parametro.  
  
 Per disporre il garbage collector di considerare tutti gli oggetti indipendentemente dalla loro generazione, utilizzare la versione di questo metodo che non accetta parametri. Per il garbage collector recupera gli oggetti in base a un <xref:System.GCCollectionMode> impostazione, utilizzare il <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.GC.Collect%2A> metodo per eseguire una raccolta su singoli livelli di memoria. Il codice genera un numero di oggetti inutilizzati e quindi chiama il <xref:System.GC.Collect%2A> metodo per eliminarli dalla memoria.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">Numero della generazione meno recente da sottoporre a Garbage Collection.</param>
        <param name="mode">Valore di enumerazione che specifica se l'operazione di Garbage Collection è forzata (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o ottimizzata (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <summary>Forza un'operazione di Garbage Collection dalla generazione 0 a una generazione specificata, in un momento specificato dal valore di <see cref="T:System.GCCollectionMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il `mode` parametro per specificare se garbage collection deve verificarsi immediatamente o solo se è il momento migliore per recuperare gli oggetti. Questo metodo non garantisce che tutta la memoria inaccessibile della generazione specificata è stata recuperata.  
  
 Per regolare l'ingerenza del garbage collection durante i periodi critici nell'applicazione, impostare il <xref:System.Runtime.GCSettings.LatencyMode%2A> proprietà.  
  
 Il garbage collector non raccoglie oggetti con un numero di generazione superiore a quello specificato per il `generation` parametro. Utilizzare il <xref:System.GC.MaxGeneration%2A> proprietà per determinare il valore massimo valido di `generation`.  
  
 Per disporre il garbage collector di considerare tutti gli oggetti indipendentemente dalla loro generazione, utilizzare la versione di questo metodo che non accetta parametri.  
  
 Per recuperare oggetti fino a una generazione specificata di oggetti, utilizzare il garbage collector di <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> overload del metodo. Quando si specifica il numero massimo di generazioni, vengono raccolti tutti gli oggetti.  
  
   
  
## Examples  
 Nell'esempio seguente forza un'operazione di garbage collection per gli oggetti di generazione 2 con la <xref:System.GCCollectionMode.Optimized> impostazione.  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> non è valido.  
  
 oppure  
  
 <paramref name="mode" /> non è uno dei valori di <see cref="T:System.GCCollectionMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">Numero della generazione meno recente da sottoporre a Garbage Collection.</param>
        <param name="mode">Valore di enumerazione che specifica se l'operazione di Garbage Collection è forzata (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o ottimizzata (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> per eseguire una procedura di Garbage Collection; <see langword="false" /> per eseguire una procedura di Garbage Collection in background, se possibile.</param>
        <summary>Forza un'operazione di Garbage Collection dalla generazione 0 fino a una determinata generazione, in un momento specificato dal valore di <see cref="T:System.GCCollectionMode" />, con un valore che specifica se la raccolta deve essere bloccante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente viene riepilogata l'interazione dei parametri `mode` e `blocking`.  
  
|`mode`|`blocking` è `true`|`blocking` è `false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> o <xref:System.GCCollectionMode.Default>|Viene eseguita una raccolta di blocco il prima possibile. Se è in corso una raccolta in background e `generation` è 0 o 1, il metodo <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> attiva immediatamente una raccolta di blocco e quando la raccolta viene completata esce dalla funzione. Se è in corso una raccolta in background e `generation` è 2, il metodo attende fino a quando la raccolta in background non viene completata, attiva una raccolta di blocco di generazione 2 ed esce dalla funzione.|Viene eseguita una raccolta il prima possibile. Il metodo <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> richiede una raccolta in background, la cui esecuzione non è comunque garantita. A seconda della situazione, può venire comunque eseguita una raccolta di blocco. Se è già in corso una raccolta in background, il metodo viene restituito immediatamente.|  
|<xref:System.GCCollectionMode.Optimized>|Può venire eseguita una raccolta di blocco, a seconda dello stato del Garbage Collector e del parametro `generation`. Il Garbage Collector tenta di garantire prestazioni ottimali.|È possibile eseguire una raccolta, a seconda dello stato del Garbage Collector. Il metodo <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> richiede una raccolta in background, la cui esecuzione non è comunque garantita. A seconda della situazione, può venire comunque eseguita una raccolta di blocco. Il Garbage Collector tenta di garantire prestazioni ottimali. Se è già in corso una raccolta in background, il metodo viene restituito immediatamente.|  
  
 Se una chiamata al metodo <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> esegue una procedura completa di Garbage Collection bloccante, è anche possibile compattare gli heap di oggetti grandi impostando la proprietà <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> su <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> prima di chiamare il metodo <xref:System.GC.Collect%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> non è valido.  
  
 oppure  
  
 <paramref name="mode" /> non è uno dei valori di <see cref="T:System.GCCollectionMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">Numero della generazione meno recente da sottoporre a Garbage Collection.</param>
        <param name="mode">Valore di enumerazione che specifica se l'operazione di Garbage Collection è forzata (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o ottimizzata (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <see langword="true" /> per eseguire una procedura di Garbage Collection; <see langword="false" /> per eseguire una procedura di Garbage Collection in background, se possibile.</param>
        <param name="compacting">
          <see langword="true" /> per comprimere l'heap degli oggetti piccoli; <see langword="false" /> per la sola organizzazione.</param>
        <summary>Forza un'operazione di Garbage Collection dalla generazione 0 fino a una determinata generazione, in un momento specificato dal valore di <see cref="T:System.GCCollectionMode" />, con valori che specificano se la raccolta deve essere bloccante e compattante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `blocking` è `false`, il Garbage Collector decide di eseguire in background o una garbage collection bloccante. Se `compacting` è `true`, esegue una garbage collection bloccante.  
  
 Se `compacting` è `true`, il runtime comprime l'heap oggetti piccoli (SOH). L'heap oggetti grandi (LOH) non viene compattato a meno che il <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> è impostata su <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>. Si noti che questo include tutti i blocchi di garbage collection, non appena completa blocco delle garbage collection.  
  
 È possibile chiamare il <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metodo per ridurre l'heap gestito per il più piccolo possibile di dimensioni, come illustrato nel frammento di codice seguente.  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 Specifica di `true` per il `compacting` argomento garantisce una compressione, completa di garbage collection bloccante. L'impostazione di <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> proprietà <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> assicura che il rapporto di integrità sia l'heap oggetti grandi vengono compattate.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Generazione di oggetti per la quale viene determinato il conteggio delle operazioni di Garbage Collection.</param>
        <summary>Restituisce il numero di volte che è stata effettuata la procedura di Garbage Collection per la generazione specificata di oggetti.</summary>
        <returns>Numero di esecuzioni del Garbage Collection per la generazione specificata dall'avvio del processo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se si implementa la propria gestione delle risorse, potrebbe essere necessario forzare periodicamente garbage collection chiamando il <xref:System.GC.Collect%2A> metodo. Poiché si tratta di un'operazione dispendiosa, è possibile migliorare le prestazioni ignorando la chiamata quando un'operazione di garbage collection si è verificata di recente. Salvare il valore restituito da <xref:System.GC.CollectionCount%2A> immediatamente dopo la chiamata <xref:System.GC.Collect%2A>. Alla successiva, è necessario chiamare <xref:System.GC.Collect%2A>, confrontare il valore corrente restituito da <xref:System.GC.CollectionCount%2A> con il valore salvato. Se i due valori sono uguali, Nessuna raccolta si è verificato nel frattempo ed è consigliabile chiamare <xref:System.GC.Collect%2A> nuovamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="generation" /> è minore di 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina la modalità di eliminazione della latenza delle aree GC.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.GC.EndNoGCRegion%2A> metodo genera un <xref:System.InvalidOperationException> se il garbage collector non è disponibile in alcuna modalità di latenza delle aree GC. Questo errore si verifica in presenza delle condizioni seguenti:  
  
-   Il <xref:System.GC.TryStartNoGCRegion%2A> (metodo) non è stato chiamato in precedenza.  
  
-   La chiamata al <xref:System.GC.TryStartNoGCRegion%2A> metodo restituito `false`.  
  
-   La chiamata al <xref:System.GC.TryStartNoGCRegion%2A> metodo ha generato un'eccezione.  
  
 Tramite il codice, ad esempio, è possibile impedire un'eccezione per i motivi seguenti:  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il Garbage Collector non è in modalità di assenza di latenza dell'area di Garbage Collection.  
  
 oppure  
  
 La modalità di assenza di latenza dell'area di Garbage Collection è stata terminata in precedenza perché è stata attivata un'operazione di Garbage Collection.  
  
 oppure  
  
 Un'allocazione di memoria ha superato la quantità specificata nella chiamata al metodo <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />.</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce il numero corrente di generazione di un oggetto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per cui vengono recuperate le informazioni sulla generazione.</param>
        <summary>Restituisce il numero corrente di generazione dell'oggetto specificato.</summary>
        <returns>Numero corrente di generazione di <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per determinare la validità di un oggetto e quindi utilizzare tali informazioni con il <xref:System.GC.Collect%2A> metodo per forzare il garbage collector per raccogliere gli oggetti nella stessa generazione. Ad esempio, utilizzare questo metodo quando si dispone di un set di oggetti che vengono creati come un gruppo e che diventano inaccessibili nello stesso momento.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.GC.GetGeneration%2A> metodo per determinare la validità di un oggetto. L'esempio quindi esegue operazioni di garbage collection per pulire la memoria e confrontare la pre e post raccolta totali della memoria nella console.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">Oggetto <see cref="T:System.WeakReference" /> che fa riferimento all'oggetto di destinazione di cui determinare il numero di generazione.</param>
        <summary>Restituisce il numero corrente di generazione della destinazione di uno specifico riferimento debole.</summary>
        <returns>Numero di generazione corrente della destinazione di <paramref name="wo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.GC.GetGeneration%2A> metodo per determinare la validità di un oggetto di riferimento debole.  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La procedura di Garbage Collection è già stata effettuata su <paramref name="wo" />.</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          <see langword="true" /> per indicare che questo metodo può attendere l'esecuzione dell'operazione di Garbage Collection prima di restituire un risultato; in caso contrario, <see langword="false" />.</param>
        <summary>Recupera il numero di byte correntemente considerati allocabili. Un parametro indica se questo metodo può attendere un breve intervallo prima di restituire un risultato per consentire l'esecuzione della procedura di Garbage Collection e la finalizzazione degli oggetti.</summary>
        <returns>Numero che rappresenta la migliore approssimazione disponibile del numero di byte correntemente allocati nella memoria gestita.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `forceFullCollection` parametro `true`, questo metodo attende un breve intervallo prima di restituire il sistema di Garbage Collection e il completamento degli oggetti. La durata dell'intervallo è un limite specificato internamente, determinato dal numero di cicli di garbage collection completata e la modifica nella quantità di memoria recuperata tra i cicli. Il garbage collector non garantisce che tutta la memoria inaccessibile verrà raccolti.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.GC.GetTotalMemory%2A> metodo per ottenere e visualizzare il numero di byte correntemente allocati nella memoria gestita.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto a cui fare riferimento.</param>
        <summary>Fa riferimento all'oggetto specificato, rendendolo inadatto per il Garbage Collection dall'inizio della routine corrente fino al momento in cui viene chiamato il metodo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo scopo del <xref:System.GC.KeepAlive%2A> metodo consiste nel verificare l'esistenza di un riferimento a un oggetto che è a rischio di in modo anomalo viene recuperato da garbage collector. In questa situazione potrebbe verificarsi uno scenario comune è quando non sono presenti riferimenti all'oggetto nel codice gestito o di dati, ma l'oggetto è ancora in uso nel codice non gestito, ad esempio le API Win32, le DLL non gestite, o i metodi tramite COM.  
  
 Questo metodo fa riferimento il `obj` parametro, rendendo questo oggetto non idonea per l'operazione di garbage collection dall'inizio della routine di ordine di esecuzione, al punto in cui questo metodo viene chiamato. Questo metodo al termine, non all'inizio, dell'intervallo di istruzioni di codice in cui `obj` devono essere disponibili.  
  
 Il <xref:System.GC.KeepAlive%2A> metodo non esegue alcuna operazione e non produce effetti collaterali diverso da prolungare la durata dell'oggetto passato come parametro.  
  
   
  
## Examples  
 Esempio di codice seguente crea un oggetto all'inizio del relativo `Main` (metodo) e non fa riferimento all'oggetto fino alla fine, quando il <xref:System.GC.KeepAlive%2A> metodo viene chiamato. L'oggetto viene mantenuto per tutta la durata di 30 secondi del `Main` nonostante chiamate al metodo di <xref:System.GC.Collect%2A> e <xref:System.GC.WaitForPendingFinalizers%2A> metodi.  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero massimo di generazioni supportate correntemente dal sistema.</summary>
        <value>Valore compreso tra zero e il numero massimo di generazioni supportate.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il numero di generazione, o l'età, di un oggetto è una misura relativa della durata di un oggetto definito dall'implementazione. Gli oggetti creati più di recente appartengono alla generazione 0, mentre quelli più vecchi rientrano in una generazione minore o uguale a quella restituita dalla proprietà <xref:System.GC.MaxGeneration%2A>.  
  
 Il garbage collector si presuppone che la memoria più recente è più probabile che essere idoneo per l'operazione di garbage collection rispetto alla memoria meno recente. Pertanto, il garbage collector vengono migliorate le prestazioni modificando i numeri di generazione ogni volta che recupera la memoria, e <xref:System.GC.MaxGeneration%2A> valore della proprietà può crescere nel tempo.  
  
 Se la durata dell'oggetto viene implementata, la <xref:System.GC.MaxGeneration%2A> proprietà restituisce il numero massimo di generazione utilizzato dal sistema; in caso contrario, questa proprietà restituisce zero.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare la proprietà MaxGeneration per visualizzare il numero massimo di generazione attualmente in uso.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Per questa implementazione, il valore restituito dal <see cref="P:System.GC.MaxGeneration" /> proprietà rimarrà costante per la durata di un'applicazione in esecuzione.  
  
 Utilizzare il <see cref="P:System.GC.MaxGeneration" /> proprietà per determinare il valore massimo è possibile specificare quando si chiama il <see cref="M:System.GC.Collect(System.Int32)" /> metodo che accetta un parametro di generazione.</para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">Numero compreso tra 1 e 99 che specifica se la notifica deve essere generata in base agli oggetti allocati nella generazione 2.</param>
        <param name="largeObjectHeapThreshold">Numero compreso tra 1 e 99 che specifica quando generare la notifica in base agli oggetti allocati nell'heap degli oggetti grandi.</param>
        <summary>Specifica che deve essere generata una notifica di un'operazione di Garbage Collection quando le condizioni favoriscono l'operazione di Garbage Collection completa e quando la raccolta è stata completata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ogni generazione, il garbage collector di impostare una soglia per le allocazioni in tale generazione. Quando le dimensioni delle allocazioni superano questa soglia, viene attivata un'operazione di garbage collection in tale generazione. Per esempio, se la soglia di generazione 2 è 20MB (ovvero resta raccolte di generazione 1 e 20MB viene promosso alla generazione 2) e più di 20MB è stato raccolto generazione 1 e viene richiesto nella generazione 2, verrà tentata la garbage collection successiva come una raccolta di generazione 2. Analogamente, se l'heap oggetti grandi (LOH) soglia è 20MB e l'applicazione è allocato più di 20MB di oggetti di grandi dimensioni, la garbage collection successiva verrà tentata anche come una raccolta di generazione 2 (poiché l'heap oggetti grandi raccolti soltanto in gen2 garbage collection).  
  
 Il `maxGenerationThreshold` e `largeObjectHeapThreshold` soglie di controllano la quantità in anticipo si riceve una notifica prima che si verifichi una garbage collection completa. Maggiore è la soglia, le altre allocazioni che possono verificarsi tra la notifica e la successiva completa di garbage collection.  
  
 Se si dispone di situazioni in cui una garbage collection completa da common language runtime influire negativamente sulle prestazioni dell'applicazione, è possibile richiedere una notifica quando il runtime sta per eseguire una garbage collection completa e aggirare tale raccolta da provocare una raccolta manualmente (utilizzando la <xref:System.GC.Collect%2A> metodo) quando le condizioni sono ancora favorevoli. Oltre a modificare la pianificazione di garbage collection, notifica completa di Garbage Collection è utile nei seguenti scenari:  
  
-   Esegue il monitoraggio l'approccio di garbage collection completa e, quando si riceve una notifica che uno è quasi raggiunto, si riduce la dimensione dei dati in tempo reale (ad esempio, rilasciando alcune voci di cache). Di conseguenza, quando si verifica la garbage collection, è in grado di recuperare memoria.  
  
-   Esegue il monitoraggio il completamento di un'operazione completa di garbage collection in modo che è possibile raccogliere alcune statistiche.  Potrebbe ad esempio, si desidera misurare le dimensioni dell'heap al completamento di GC in modo da sapere la dimensione dei dati in tempo reale. (Dopo un catalogo globale completo, l'heap è la dimensione più piccola).  
  
 Per ulteriori informazioni su ciò che rappresenta un'operazione completa di garbage collection, vedere [notifiche di Garbage Collection](~/docs/standard/garbage-collection/notifications.md).  
  
 Quando si registra per la notifica di un'operazione di garbage collection, può ricevere notifiche quando sta per raggiungere una garbage collection completa e quando viene completato il processo. Questo modello è simile a come il sistema operativo consente di monitorare le notifiche di memoria insufficiente.  
  
 Utilizzare le linee guida seguenti per specificare il `maxGenerationThreshold` e `largeObjectHeapThreshold` parametri:  
  
-   Maggiore è il valore di soglia, le allocazioni più verificherà tra la notifica e completa di garbage collection.  
  
     Un valore di soglia maggiore offre maggiori opportunità per il runtime verificare la presenza di una raccolta imminente. In questo modo si aumenta la probabilità che riceverà una notifica. Tuttavia, non è necessario impostare la soglia troppo alta perché che restituisce delle altre allocazioni prima che il runtime provochi la raccolta successiva.  
  
     Quando si forzare una raccolta dopo la notifica usando un valore soglia elevato, meno gli oggetti recuperati che potrebbe essere recuperato dalla raccolta successiva del runtime.  
  
-   Minore è il valore soglia, meno le allocazioni tra la notifica e completa di garbage collection.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come registrare una notifica di garbage collection e avviare un thread per monitorare lo stato della notifica dell'operazione di garbage collection. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per [notifiche di Garbage Collection](~/docs/standard/garbage-collection/notifications.md) argomento.  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxGenerationThreshold" /> o <paramref name="largeObjectHeapThreshold" /> non è compreso tra 1 e 99.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Quantità di memoria non gestita che è stata rilasciata.</param>
        <summary>Informa il runtime che è stata rilasciata memoria non gestita di cui non occorre più tenere conto durante la pianificazione della procedura di Garbage Collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Determinazione della necessità di pianificare operazioni di garbage collection, il runtime tiene in considerazione la quantità di memoria gestito viene allocato. Se un oggetto gestito di piccole dimensioni viene allocata una grande quantità di memoria non gestita, il runtime prende in considerazione solo la memoria gestita e viene pertanto sottovalutata l'urgenza della pianificazione della procedura di garbage collection. Il <xref:System.GC.AddMemoryPressure%2A> metodo informa il runtime di questa pressione aggiuntiva sulla memoria di sistema e <xref:System.GC.RemoveMemoryPressure%2A> metodo fornisce al runtime che è stato rilasciato pressione aggiuntiva.  
  
 Nel modello di utilizzo più semplice, un oggetto gestito alloca memoria non gestita nel costruttore e lo rilascia nel `Dispose` o `Finalize` metodo. Chiamare il <xref:System.GC.AddMemoryPressure%2A> metodo dopo l'allocazione di memoria non gestita e chiamare il <xref:System.GC.RemoveMemoryPressure%2A> metodo dopo averlo rilasciato.  
  
 In scenari più complessi, in cui l'allocazione di memoria non gestita cambia sostanzialmente durante la durata dell'oggetto gestito, è possibile chiamare il <xref:System.GC.AddMemoryPressure%2A> e <xref:System.GC.RemoveMemoryPressure%2A> metodi per comunicare le modifiche incrementali al runtime.  
  
> [!CAUTION]
>  È necessario assicurarsi di rimuovere esattamente la quantità di pressione che aggiunti. In caso contrario, può influenzare negativamente le prestazioni del sistema nelle applicazioni eseguite per lunghi periodi di tempo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> è minore o uguale a 0.  
  
 oppure  
  
 Su un computer a 32 bit, <paramref name="bytesAllocated" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter chiamare codice non gestito per la modifica delle priorità di garbage collection. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per cui è necessario chiamare un finalizzatore.</param>
        <summary>Richiede che il sistema chiami il finalizzatore per l'oggetto specificato, per il quale è stato precedentemente chiamato il metodo <see cref="M:System.GC.SuppressFinalize(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.GC.ReRegisterForFinalize%2A> metodo aggiunge il `obj` parametro all'elenco di oggetti che richiedono il completamento prima che il garbage collector libera l'oggetto. Il `obj` parametro deve essere il chiamante di questo metodo.  
  
 La chiamata di <xref:System.GC.ReRegisterForFinalize%2A> metodo non garantisce che il garbage collector non chiamerà un finalizzatore dell'oggetto.  
  
 Per impostazione predefinita, tutti gli oggetti che implementano i finalizzatori vengono aggiunti all'elenco di oggetti che richiedono la finalizzazione. Tuttavia, un oggetto potrebbe essere sia già stato completato o il completamento potrebbe essere stato disabilitato chiamando il <xref:System.GC.SuppressFinalize%2A> metodo.  
  
 Un finalizzatore può utilizzare questo metodo per ripristinare se stesso o un oggetto a cui fa riferimento.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il metodo ReRegisterForFinalize per rendere effettive di un oggetto in un secondo tempo dopo l'operazione di garbage collection.  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto di cui non è necessario eseguire il finalizzatore.</param>
        <summary>Richiede che Common Language Runtime non chiami il finalizzatore per l'oggetto specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo imposta un bit nell'intestazione dell'oggetto `obj`, il quale viene verificato dal runtime quando vengono chiamati i finalizzatori. Un finalizzatore, che è rappresentato dal metodo <xref:System.Object.Finalize%2A?displayProperty=nameWithType>, viene utilizzato per rilasciare le risorse non gestite prima che un oggetto venga raccolto dal Garbage Collector. Se `obj` non dispone di un finalizzatore, la chiamata al metodo <xref:System.GC.SuppressFinalize%2A> non avrà alcun effetto.  
  
 Gli oggetti che implementano l'interfaccia <xref:System.IDisposable> possono chiamare questo metodo dall'implementazione <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> dell'oggetto per impedire al Garbage Collector di chiamare <xref:System.Object.Finalize%2A?displayProperty=nameWithType> su un oggetto che non lo richiede. Tale operazione viene in genere eseguita per impedire al finalizzatore di rilasciare le risorse non gestite già liberate dall'implementazione <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come utilizzare il metodo <xref:System.GC.SuppressFinalize%2A> in una classe di risorse per impedire la chiamata ridondante di una Garbage Collection. Nell'esempio viene utilizzato il [modello dispose](~/docs/standard/design-guidelines/dispose-pattern.md) per liberare sia le risorse gestite (vale a dire gli oggetti che implementano <xref:System.IDisposable>) e le risorse non gestite.  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova a impedire l'operazione di Garbage Collection durante l'esecuzione di un percorso critico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si devono chiamare solo il <xref:System.GC.EndNoGCRegion%2A> metodo se il runtime è attualmente in alcuna modalità di latenza delle aree GC. In altre parole, non è necessario chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata di metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo solo perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">Quantità di memoria in byte da allocare senza attivare un'operazione di Garbage Collection. Deve essere minore o uguale alle dimensioni di un segmento temporaneo. Per informazioni sulle dimensioni di un segmento temporaneo, vedere la sezione "Generazioni e segmenti temporanei" nell'articolo [Principi fondamentali di Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <summary>Prova a impedire l'operazione di Garbage Collection durante l'esecuzione di un percorso critico se è disponibile una quantità specificata di memoria.</summary>
        <returns>
          <see langword="true" /> se il runtime è riuscito a eseguire il commit della quantità di memoria richiesta e il Garbage Collector può accedere alla modalità di eliminazione della latenza delle aree di Garbage Collection; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> metodo tenta di inserire il garbage collector in alcuna modalità latenza delle aree GC, che impedisce l'operazione di garbage collection durante l'esecuzione di un'app un'area critica del codice.  Se il runtime è riuscito ad allocare inizialmente la quantità di memoria richiesta, il garbage collector esegue una completa di garbage collection bloccante nel tentativo di liberare memoria aggiuntiva. Il garbage collector non immette Nessuna modalità di latenza delle aree GC, se è in grado di allocare la quantità necessaria di memoria, in questo caso è effettivamente 2 * `totalSize` byte (tenta di allocare `totalSize` byte per l'heap oggetti piccoli e `totalSize` byte per l'heap oggetti grandi).  
  
 `totalSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico. Ciò include le allocazioni dall'app, nonché le allocazioni eseguite per conto dell'applicazione di runtime.  
  
> [!IMPORTANT]
>  Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si devono chiamare solo il <xref:System.GC.EndNoGCRegion%2A> metodo se il runtime è attualmente in alcuna modalità di latenza delle aree GC. In altre parole, non è necessario chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata di metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo solo perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.  
  
 Si esce dalla modalità di latenza di Garbage Collection area chiamando il <xref:System.GC.EndNoGCRegion%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> supera le dimensioni del segmento temporaneo.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo è già in modalità di eliminazione della latenza delle aree di Garbage Collection.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">Quantità di memoria in byte da allocare senza attivare un'operazione di Garbage Collection. Deve essere minore o uguale alle dimensioni di un segmento temporaneo. Per informazioni sulle dimensioni di un segmento temporaneo, vedere la sezione "Generazioni e segmenti temporanei" nell'articolo [Principi fondamentali di Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> per omettere un'operazione completa di Garbage Collection bloccante se il Garbage Collector non è inizialmente in grado di allocare i byte del parametro <c>totalSize</c>; in caso contrario, <see langword="false" />.</param>
        <summary>Prova a impedire l'operazione di Garbage Collection durante l'esecuzione di un percorso critico se è disponibile una quantità specificata di memoria; controlla inoltre se il Garbage Collector esegue un'operazione completa di Garbage Collection bloccante se inizialmente non è disponibile memoria sufficiente.</summary>
        <returns>
          <see langword="true" /> se il runtime è riuscito a eseguire il commit della quantità di memoria richiesta e il Garbage Collector può accedere alla modalità di eliminazione della latenza delle aree di Garbage Collection; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> metodo tenta di inserire il garbage collector in alcuna modalità latenza delle aree GC, che impedisce l'operazione di garbage collection durante l'esecuzione di un'app un'area critica del codice.  Se il runtime non riesce ad allocare inizialmente la quantità di memoria richiesta e `disallowFullBlockingGC` argomento `false`, il garbage collector esegue una garbage collection bloccante completo nel tentativo di liberare memoria aggiuntiva; in caso contrario, l'allocazione ha esito negativo e il metodo restituisce `false`. Il garbage collector non immette Nessuna modalità di latenza delle aree GC, se è in grado di allocare la quantità necessaria di memoria, in questo caso è effettivamente 2 * `totalSize` (tenta di allocare `totalSize` per l'heap oggetti piccoli e `totalSize` per l'heap oggetti grandi).  
  
 `totalSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico. Ciò include le allocazioni dall'app, nonché le allocazioni eseguite per conto dell'applicazione di runtime.  
  
 Impostazione `disallowFullBlockingGC` a `true` per impedire un Garbage Collection bloccante completo raccolta se non è sufficiente è inizialmente disponibile è molto utile negli scenari di bilanciamento del carico: un sistema è possibile chiamare questo metodo e rilevato come pronto per accettare le richieste se restituisce `true`, e il bilanciamento del carico reindirizzare le richieste ad altri sistemi se restituisce `false`. Quindi possibile effettuare una completa di garbage collection bloccante quando non gestisce le richieste chiamando il <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metodo.  
  
> [!IMPORTANT]
>  Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si devono chiamare solo il <xref:System.GC.EndNoGCRegion%2A> metodo se il runtime è attualmente in alcuna modalità di latenza delle aree GC. In altre parole, non è necessario chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata di metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo solo perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.  
  
 Si esce dalla modalità di latenza di Garbage Collection area chiamando il <xref:System.GC.EndNoGCRegion%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> supera le dimensioni del segmento temporaneo.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo è già in modalità di eliminazione della latenza delle aree di Garbage Collection.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">Quantità di memoria in byte da allocare senza attivare un'operazione di Garbage Collection. <c>totalSize</c> -<c>lohSize</c> deve essere minore o uguale alle dimensioni di un segmento temporaneo. Per informazioni sulle dimensioni di un segmento temporaneo, vedere la sezione "Generazioni e segmenti temporanei" nell'articolo [Principi fondamentali di Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">Numero di byte in <c>totalSize</c> da usare per allocazioni di heap di oggetti grandi.</param>
        <summary>Prova a impedire l'operazione di Garbage Collection durante l'esecuzione di un percorso critico se è disponibile una quantità specificata di memoria per gli heap degli oggetti grandi e degli oggetti piccoli.</summary>
        <returns>
          <see langword="true" /> se il runtime è riuscito a eseguire il commit della quantità di memoria richiesta e il Garbage Collector può accedere alla modalità di eliminazione della latenza delle aree di Garbage Collection; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> metodo tenta di inserire il garbage collector in alcuna modalità latenza delle aree GC, che impedisce l'operazione di garbage collection durante l'esecuzione di un'app un'area critica del codice.  Se il runtime è riuscito ad allocare inizialmente la quantità di memoria richiesta, il garbage collector esegue una completa di garbage collection bloccante nel tentativo di liberare memoria aggiuntiva. Il garbage collector non immette Nessuna modalità di latenza delle aree GC, se è in grado di allocare `lohSize` per l'heap oggetti grandi e `totalSize` – `lohSize` per l'heap oggetti piccoli (SOH).  
  
 `lohSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico per l'heap oggetti grandi, e `totalSize` – `lohSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico per il rapporto di integrità. Ciò include le allocazioni dall'app, nonché le allocazioni eseguite per conto dell'applicazione di runtime.  
  
> [!IMPORTANT]
>  Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si devono chiamare solo il <xref:System.GC.EndNoGCRegion%2A> metodo se il runtime è attualmente in alcuna modalità di latenza delle aree GC. In altre parole, non è necessario chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata di metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo solo perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.  
  
 Si esce dalla modalità di latenza di Garbage Collection area chiamando il <xref:System.GC.EndNoGCRegion%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> - <paramref name="lohSize" /> supera le dimensioni del segmento temporaneo.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo è già in modalità di eliminazione della latenza delle aree di Garbage Collection.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">Quantità di memoria in byte da allocare senza attivare un'operazione di Garbage Collection. <c>totalSize</c> -<c>lohSize</c> deve essere minore o uguale alle dimensioni di un segmento temporaneo. Per informazioni sulle dimensioni di un segmento temporaneo, vedere la sezione "Generazioni e segmenti temporanei" nell'articolo [Principi fondamentali di Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">Numero di byte in <c>totalSize</c> da usare per allocazioni di heap di oggetti grandi.</param>
        <param name="disallowFullBlockingGC">
          <see langword="true" /> per omettere un'operazione completa di Garbage Collection bloccante se il Garbage Collector non è inizialmente in grado di allocare la memoria specificata nell'heap degli oggetti piccoli (SOH) e degli oggetti grandi (LOH); in caso contrario, <see langword="false" />.</param>
        <summary>Prova a impedire l'operazione di Garbage Collection durante l'esecuzione di un percorso critico se è disponibile una quantità specificata di memoria per gli heap degli oggetti grandi e degli oggetti piccoli; controlla inoltre se il Garbage Collector esegue un'operazione completa di Garbage Collection bloccante se inizialmente non è disponibile memoria sufficiente.</summary>
        <returns>
          <see langword="true" /> se il runtime è riuscito a eseguire il commit della quantità di memoria richiesta e il Garbage Collector può accedere alla modalità di eliminazione della latenza delle aree di Garbage Collection; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> metodo tenta di inserire il garbage collector in alcuna modalità latenza delle aree GC, che impedisce l'operazione di garbage collection durante l'esecuzione di un'app un'area critica del codice.  Se il runtime non riesce ad allocare inizialmente la quantità di memoria richiesta e `disallowFullBlockingGC` argomento `false`, il garbage collector esegue una garbage collection bloccante completo nel tentativo di liberare memoria aggiuntiva; in caso contrario, l'allocazione ha esito negativo e il metodo restituisce `false`. Il garbage collector non immette Nessuna modalità di latenza delle aree GC, se è in grado di allocare `lohSize` per l'heap oggetti grandi e `totalSize` – `lohSize` per l'heap oggetti piccoli (SOH).  
  
 `lohSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico per l'heap oggetti grandi, e `totalSize` – `lohSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico per il rapporto di integrità. Ciò include le allocazioni dall'app, nonché le allocazioni eseguite per conto dell'applicazione di runtime.  
  
 Impostazione `disallowFullBlockingGC` a `true` per impedire un Garbage Collection bloccante completo raccolta se non è sufficiente è inizialmente disponibile è molto utile negli scenari di bilanciamento del carico: un sistema è possibile chiamare questo metodo e rilevato come pronto per accettare le richieste se restituisce `true`, e il bilanciamento del carico reindirizzare le richieste ad altri sistemi se restituisce `false`. Quindi possibile effettuare una completa di garbage collection bloccante quando non gestisce le richieste chiamando il <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metodo.  
  
> [!IMPORTANT]
>  Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si devono chiamare solo il <xref:System.GC.EndNoGCRegion%2A> metodo se il runtime è attualmente in alcuna modalità di latenza delle aree GC. In altre parole, non è necessario chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata di metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo solo perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.  
  
 Si esce dalla modalità di latenza di Garbage Collection area chiamando il <xref:System.GC.EndNoGCRegion%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> - <paramref name="lohSize" /> supera le dimensioni del segmento temporaneo.</exception>
        <exception cref="T:System.InvalidOperationException">Il processo è già in modalità di eliminazione della latenza delle aree di Garbage Collection.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante tramite Common Language Runtime sia imminente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante tramite Common Language Runtime sia imminente.</summary>
        <returns>Stato della notifica dell'operazione di Garbage Collection registrata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.GCNotificationStatus> enumerazione restituito da questo metodo per determinare lo stato della notifica dell'operazione di garbage corrente che è stato registrato usando il <xref:System.GC.RegisterForFullGCNotification%2A> metodo. È inoltre possibile utilizzare il <xref:System.GC.WaitForFullGCComplete%2A> metodo per determinare se il garbage collection completa è stata completata.  
  
 Quando l'enumerazione restituisce <xref:System.GCNotificationStatus.Succeeded>, è possibile eseguire attività, ad esempio impedire ulteriori oggetti allocata e provocare una raccolta con il <xref:System.GC.Collect%2A> metodo. Si noti che la notifica non garantisce che una garbage collection completa verrà eseguita, solo che le condizioni hanno raggiunto la soglia favorevole per una garbage collection completa si verifichi.  
  
 Questo metodo attende indefinitamente per ottenere una notifica di garbage collection. Se si desidera specificare un periodo di timeout per il metodo restituire se non è possibile ottenere la notifica, utilizzare il <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> overload del metodo. Se si chiama questo metodo senza specificare un timeout, è possibile chiamare il <xref:System.GC.CancelFullGCNotification%2A> metodo se si resta in attesa più preferito.  
  
 È necessario seguire questo metodo con una chiamata al <xref:System.GC.WaitForFullGCComplete%2A> per verificare che si sia verificata una garbage collection completa. La chiamata a questo metodo soltanto genera risultati indeterminati.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito viene illustrato come utilizzare questo metodo per determinare se è imminente una procedura completa di Garbage Collection bloccante. Ogni volta che lo stato della notifica è <xref:System.GCNotificationStatus.Succeeded>, il metodo dell'utente `OnFullGCApproachNotify` viene chiamato per eseguire azioni in risposta alla raccolta imminente. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per [notifiche di Garbage Collection](~/docs/standard/garbage-collection/notifications.md) argomento.  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Tempo di attesa prima di poter ottenere lo stato di una notifica. Specificare -1 per restare in attesa in modo indefinito.</param>
        <summary>Restituisce, in un periodo di timeout specificato, lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante tramite Common Language Runtime sia imminente.</summary>
        <returns>Stato della notifica dell'operazione di Garbage Collection registrata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.GCNotificationStatus> enumerazione restituito da questo metodo per determinare lo stato della notifica dell'operazione di garbage corrente che è stato registrato usando il <xref:System.GC.RegisterForFullGCNotification%2A> metodo. È inoltre possibile utilizzare il <xref:System.GC.WaitForFullGCComplete%2A> metodo per determinare se il garbage collection completa è stata completata.  
  
 Si noti che questo metodo restituisce immediatamente ogni volta che viene ottenuto lo stato di notifica un'operazione di garbage collection, indipendentemente dal valore specificato da `millisecondsTimeout`. Se lo stato di notifica un'operazione di garbage collection non viene ottenuto prima `millisecondsTimeout` volte, questo metodo viene restituito <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Quando l'enumerazione restituisce <xref:System.GCNotificationStatus.Succeeded>, è possibile eseguire attività, ad esempio impedire ulteriori oggetti allocata e provocare una raccolta con il <xref:System.GC.Collect%2A> metodo. Si noti che la notifica non garantisce che una garbage collection completa verrà eseguita, solo che le condizioni hanno raggiunto la soglia favorevole per una garbage collection completa si verifichi.  
  
 È possibile chiamare il <xref:System.GC.CancelFullGCNotification%2A> metodo quando non è possibile attendere il periodo di timeout che deve trascorrere.  
  
 È necessario seguire questo metodo con una chiamata al <xref:System.GC.WaitForFullGCComplete%2A> per verificare che si sia verificata una garbage collection completa. La chiamata a questo metodo soltanto genera risultati indeterminati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> deve essere non negativo oppure minore o uguale a <see cref="F:System.Int32.MaxValue" /> o a -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante è stata portata a termine da Common Language Runtime.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante è stata portata a termine da Common Language Runtime.</summary>
        <returns>Stato della notifica dell'operazione di Garbage Collection registrata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.GCNotificationStatus> enumerazione restituito da questo metodo per determinare lo stato della notifica dell'operazione di garbage corrente che è stato registrato usando il <xref:System.GC.RegisterForFullGCNotification%2A> metodo. È inoltre possibile utilizzare il <xref:System.GC.WaitForFullGCApproach%2A> metodo per determinare se è imminente una garbage collection completa.  
  
 Quando l'enumerazione restituisce <xref:System.GCNotificationStatus.Succeeded>, è possibile eseguire attività come riprendere il lavoro e ottenere un conteggio di raccolta con il <xref:System.GC.CollectionCount%2A> proprietà.  
  
 Questo metodo attende indefinitamente per ottenere una notifica di garbage collection. Se si desidera specificare un periodo di timeout per il metodo restituire se non è possibile ottenere la notifica, utilizzare il <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> overload del metodo. Se si chiama questo metodo senza specificare un timeout, è possibile chiamare il <xref:System.GC.CancelFullGCNotification%2A> metodo se si resta in attesa più preferito.  
  
 Questa chiamata al metodo deve essere preceduta da una chiamata al <xref:System.GC.WaitForFullGCApproach%2A> per verificare che si sia verificata una garbage collection completa. Chiamare questo metodo solo può produrre risultati imprevisti.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare questo metodo per determinare se un'operazione completa di garbage collection è stata completata. Ogni volta che lo stato della notifica è <xref:System.GCNotificationStatus.Succeeded>, il metodo dell'utente `OnFullGCCompletedNotify` viene chiamato per eseguire azioni in risposta alla raccolta completata. Questo esempio di codice fa parte di un esempio più esaustivo disponibile per [notifiche di Garbage Collection](~/docs/standard/garbage-collection/notifications.md) argomento.  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Tempo di attesa prima di poter ottenere lo stato di una notifica. Specificare -1 per restare in attesa in modo indefinito.</param>
        <summary>Restituisce, in un periodo di timeout specificato, lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante tramite Common Language Runtime sia stata completata.</summary>
        <returns>Stato della notifica dell'operazione di Garbage Collection registrata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.GCNotificationStatus> enumerazione restituito da questo metodo per determinare lo stato della notifica dell'operazione di garbage corrente che è stato registrato usando il <xref:System.GC.RegisterForFullGCNotification%2A> metodo. È inoltre possibile utilizzare il <xref:System.GC.WaitForFullGCApproach%2A> metodo per determinare se è imminente una garbage collection completa.  
  
 Si noti che questo metodo restituisce immediatamente ogni volta che viene ottenuto lo stato di notifica un'operazione di garbage collection, indipendentemente dal valore specificato da `millisecondsTimeout`. Se lo stato di notifica un'operazione di garbage collection non viene ottenuto prima `millisecondsTimeout` volte, questo metodo viene restituito <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Quando l'enumerazione restituisce <xref:System.GCNotificationStatus.Succeeded>, è possibile eseguire attività come riprendere il lavoro e ottenere un conteggio di raccolta con il <xref:System.GC.CollectionCount%2A> proprietà.  
  
 È possibile chiamare il <xref:System.GC.CancelFullGCNotification%2A> metodo quando non è possibile attendere il periodo di timeout che deve trascorrere.  
  
 Questa chiamata al metodo deve essere preceduta da una chiamata al <xref:System.GC.WaitForFullGCApproach%2A> per verificare che si sia verificata una garbage collection completa. Chiamare questo metodo solo può produrre risultati imprevisti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="millisecondsTimeout" /> deve essere non negativo oppure minore o uguale a <see cref="F:System.Int32.MaxValue" /> o a -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">per l'attendibilità totale per il chiamante immediato. Impossibile usare questo membro in codice parzialmente attendibile.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sospende il thread corrente fino a quando la coda di finalizzatori non sarà stata svuotata dal thread che la elabora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il garbage collector rileva gli oggetti che possono essere recuperati, controlla ogni oggetto per determinare i requisiti di finalizzazione dell'oggetto. Se un oggetto implementa un finalizzatore e non ha disabilitato la finalizzazione chiamando <xref:System.GC.SuppressFinalize%2A>, l'oggetto viene posizionato in un elenco di oggetti che sono contrassegnati come pronti per la finalizzazione. Il garbage collector chiama la <xref:System.Object.Finalize%2A> metodi per gli oggetti nell'elenco e rimuove le voci dall'elenco. Questo metodo si blocca fino a quando tutti i finalizzatori è eseguiti fino al completamento.  
  
 Il thread in cui vengono eseguiti i finalizzatori non è specificato, pertanto non c'è alcuna garanzia che il metodo verrà terminato. Tuttavia, il thread può essere interrotta da un altro thread durante il <xref:System.GC.WaitForPendingFinalizers%2A> metodo è in corso. Ad esempio, è possibile avviare un altro thread in attesa di un periodo di tempo e quindi interrompa il thread corrente, se il thread è ancora in sospeso.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.GC.WaitForPendingFinalizers%2A> metodo per sospendere il thread corrente fino al completamento di tutti gli oggetti raccolti.  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>