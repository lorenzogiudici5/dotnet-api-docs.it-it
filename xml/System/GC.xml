<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9706c4cbe6129c12d465808c6336d81d30de906b" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48590869" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="e56b6-101">Controlla il Garbage Collector di sistema, un servizio che recupera automaticamente la memoria inutilizzata.</span>
      <span class="sxs-lookup">
        <span data-stu-id="e56b6-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-102">Il garbage collector è un componente common language runtime che controlla l'allocazione e il rilascio di memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="e56b6-102">The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</span></span> <span data-ttu-id="e56b6-103">Fattori che incidono i metodi in questa classe quando garbage collection viene eseguito su un oggetto e quando vengono rilasciate le risorse allocate da un oggetto.</span><span class="sxs-lookup"><span data-stu-id="e56b6-103">The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</span></span> <span data-ttu-id="e56b6-104">Proprietà di questa classe forniscono informazioni sulla quantità totale di memoria disponibile nel sistema e la categoria di età o generazione, della memoria allocata a un oggetto.</span><span class="sxs-lookup"><span data-stu-id="e56b6-104">Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</span></span>  
  
 <span data-ttu-id="e56b6-105">Il garbage collector tiene traccia e recupera gli oggetti allocati nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="e56b6-105">The garbage collector tracks and reclaims objects allocated in managed memory.</span></span> <span data-ttu-id="e56b6-106">Periodicamente, il garbage collector esegue garbage collection per recuperare memoria allocata agli oggetti per cui non sono presenti riferimenti validi.</span><span class="sxs-lookup"><span data-stu-id="e56b6-106">Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</span></span> <span data-ttu-id="e56b6-107">Operazione di Garbage collection viene eseguita automaticamente quando una richiesta per la memoria non può essere soddisfatta usando memoria libera disponibile.</span><span class="sxs-lookup"><span data-stu-id="e56b6-107">Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</span></span> <span data-ttu-id="e56b6-108">In alternativa, un'applicazione può forzare garbage collection usando il <xref:System.GC.Collect%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-108">Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.</span></span>  
  
 <span data-ttu-id="e56b6-109">Operazione di Garbage collection è costituita dai passaggi seguenti:</span><span class="sxs-lookup"><span data-stu-id="e56b6-109">Garbage collection consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="e56b6-110">Il garbage collector esegue la ricerca per gli oggetti gestiti che fanno riferimento a codice gestito.</span><span class="sxs-lookup"><span data-stu-id="e56b6-110">The garbage collector searches for managed objects that are referenced in managed code.</span></span>  
  
2.  <span data-ttu-id="e56b6-111">Il garbage collector tenta di completare gli oggetti che non vengono fatto riferimento.</span><span class="sxs-lookup"><span data-stu-id="e56b6-111">The garbage collector tries to finalize objects that are not referenced.</span></span>  
  
3.  <span data-ttu-id="e56b6-112">Il garbage collector libera gli oggetti che non vengono fatto riferimento e recupera la memoria.</span><span class="sxs-lookup"><span data-stu-id="e56b6-112">The garbage collector frees objects that are not referenced and reclaims their memory.</span></span>  
  
 <span data-ttu-id="e56b6-113">Questo argomento include le sezioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="e56b6-113">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="e56b6-114">[Il garbage collector e le risorse non gestite](#unmanaged) </span><span class="sxs-lookup"><span data-stu-id="e56b6-114">[The garbage collector and unmanaged resources](#unmanaged) </span></span>  
 <span data-ttu-id="e56b6-115">[Generazioni e la durata dell'oggetto](#generations) </span><span class="sxs-lookup"><span data-stu-id="e56b6-115">[Object aging and generations](#generations) </span></span>  
 [<span data-ttu-id="e56b6-116">Impedisce l'operazione di garbage collection</span><span class="sxs-lookup"><span data-stu-id="e56b6-116">Disallowing garbage collection</span></span>](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a><span data-ttu-id="e56b6-117">Il garbage collector e le risorse non gestite</span><span class="sxs-lookup"><span data-stu-id="e56b6-117">The garbage collector and unmanaged resources</span></span>  
 <span data-ttu-id="e56b6-118">Durante una raccolta, il garbage collector non liberare un oggetto se viene rilevato uno o più riferimenti all'oggetto nel codice gestito.</span><span class="sxs-lookup"><span data-stu-id="e56b6-118">During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</span></span> <span data-ttu-id="e56b6-119">Tuttavia, il garbage collector non riconosce i riferimenti a un oggetto dal codice non gestito e potrebbe liberare gli oggetti che vengono usati esclusivamente nel codice non gestito se non esplicitamente impedito di farlo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-119">However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</span></span> <span data-ttu-id="e56b6-120">Il <xref:System.GC.KeepAlive%2A> metodo fornisce un meccanismo che impedisce al garbage collector di raccogliere gli oggetti che sono ancora in uso nel codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="e56b6-120">The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</span></span>  
  
 <span data-ttu-id="e56b6-121">A parte le allocazioni di memoria gestita, le implementazioni del garbage collector non conterranno informazioni sulle risorse mantenute da un oggetto, ad esempio gli handle di file o le connessioni al database.</span><span class="sxs-lookup"><span data-stu-id="e56b6-121">Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</span></span> <span data-ttu-id="e56b6-122">Quando un tipo Usa le risorse non gestite che devono essere rilasciate prima del recupero delle istanze del tipo, il tipo può implementare un finalizzatore.</span><span class="sxs-lookup"><span data-stu-id="e56b6-122">When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</span></span>  
  
 <span data-ttu-id="e56b6-123">Nella maggior parte dei casi, i finalizzatori vengono implementati mediante l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo; tuttavia, tipi scritti in c# o C++ implementano i distruttori, quali i compilatori trasforma in un override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e56b6-123">In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e56b6-124">Nella maggior parte dei casi, se un oggetto ha un finalizzatore, il garbage collector non viene chiamato prima del rilascio dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="e56b6-124">In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</span></span> <span data-ttu-id="e56b6-125">Tuttavia, il garbage collector non è necessario chiamare i finalizzatori in tutte le situazioni. ad esempio, il <xref:System.GC.SuppressFinalize%2A> metodo impedisce in modo esplicito un finalizzatore dell'oggetto di chiamata.</span><span class="sxs-lookup"><span data-stu-id="e56b6-125">However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called.</span></span> <span data-ttu-id="e56b6-126">Inoltre, il garbage collector non è necessario usare un thread specifico per completare gli oggetti o garantisce l'ordine in cui vengono chiamati i finalizzatori per gli oggetti che fanno riferimento a altro, ma in caso contrario, sono disponibili per l'operazione di garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e56b6-126">Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</span></span>  
  
 <span data-ttu-id="e56b6-127">Negli scenari in cui le risorse devono essere rilasciate in un momento specifico, le classi possono implementare il <xref:System.IDisposable> interfaccia, che contiene il <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodo che esegue attività di gestione e pulizia di risorse.</span><span class="sxs-lookup"><span data-stu-id="e56b6-127">In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method that performs resource management and cleanup tasks.</span></span> <span data-ttu-id="e56b6-128">Le classi che implementano <xref:System.IDisposable.Dispose%2A> deve specificare, come parte del contratto, classe se e quando i consumer di classe chiamano il metodo per pulire l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="e56b6-128">Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</span></span> <span data-ttu-id="e56b6-129">Il garbage collector non, per impostazione predefinita, chiama il <xref:System.IDisposable.Dispose%2A> metodo; tuttavia, le implementazioni del <xref:System.IDisposable.Dispose%2A> metodo può chiamare metodi <xref:System.GC> classe per personalizzare il comportamento di finalizzazione del garbage collector.</span><span class="sxs-lookup"><span data-stu-id="e56b6-129">The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.</span></span>  
  
 <span data-ttu-id="e56b6-130">Per altre informazioni su alla finalizzazione dell'oggetto e il modello dispose, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="e56b6-130">For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a><span data-ttu-id="e56b6-131">Generazioni e la durata dell'oggetto</span><span class="sxs-lookup"><span data-stu-id="e56b6-131">Object aging and generations</span></span>  
 <span data-ttu-id="e56b6-132">Il garbage collector di common language runtime supporta la durata dell'oggetto utilizzando le generazioni.</span><span class="sxs-lookup"><span data-stu-id="e56b6-132">The garbage collector in the common language runtime supports object aging using generations.</span></span> <span data-ttu-id="e56b6-133">Una generazione è un'unità di misura della durata degli oggetti in memoria relativa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-133">A generation is a unit of measure of the relative age of objects in memory.</span></span> <span data-ttu-id="e56b6-134">Il numero di generazione o età, di un oggetto indica la generazione a cui appartiene un oggetto.</span><span class="sxs-lookup"><span data-stu-id="e56b6-134">The generation number, or age, of an object indicates the generation to which an object belongs.</span></span> <span data-ttu-id="e56b6-135">Gli oggetti creati più di recente fanno parte delle generazioni più recenti e numeri di generazione più bassi rispetto a scorrere gli oggetti creati in precedenza in tutta la durata dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="e56b6-135">Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</span></span> <span data-ttu-id="e56b6-136">Gli oggetti della generazione più recente si trovano nella generazione 0.</span><span class="sxs-lookup"><span data-stu-id="e56b6-136">Objects in the most recent generation are in generation 0.</span></span> <span data-ttu-id="e56b6-137">Questa implementazione del garbage collector supporta tre generazioni di oggetti, generazioni 0, 1 e 2.</span><span class="sxs-lookup"><span data-stu-id="e56b6-137">This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</span></span> <span data-ttu-id="e56b6-138">È possibile recuperare il valore della <xref:System.GC.MaxGeneration%2A> proprietà per determinare il numero di numero massimo di generazioni supportato dal sistema.</span><span class="sxs-lookup"><span data-stu-id="e56b6-138">You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.</span></span>  
  
 <span data-ttu-id="e56b6-139">La durata dell'oggetto consente alle applicazioni di operazione di garbage collection di destinazione in un set specifico di generazioni, anziché richiedere al garbage collector di valutare tutte le generazioni.</span><span class="sxs-lookup"><span data-stu-id="e56b6-139">Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</span></span> <span data-ttu-id="e56b6-140">Esegue l'overload del <xref:System.GC.Collect%2A> metodo che includono un `generation` parametro consentono di specificare la generazione meno recente per essere sottoposto a garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e56b6-140">Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.</span></span>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a><span data-ttu-id="e56b6-141">Impedisce l'operazione di garbage collection</span><span class="sxs-lookup"><span data-stu-id="e56b6-141">Disallowing garbage collection</span></span>  
 <span data-ttu-id="e56b6-142">A partire dal [!INCLUDE[net_v46](~/includes/net-v46-md.md)], il garbage collector supporta una latenza modalità delle aree GC che può essere utilizzata durante l'esecuzione di percorsi critici in garbage collection può influire negativamente sulle prestazioni dell'app.</span><span class="sxs-lookup"><span data-stu-id="e56b6-142">Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</span></span> <span data-ttu-id="e56b6-143">La latenza modalità delle aree GC richiede di specificare una quantità di memoria che può essere allocata senza interferenze dal garbage collector.</span><span class="sxs-lookup"><span data-stu-id="e56b6-143">The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</span></span> <span data-ttu-id="e56b6-144">Se il runtime può allocare la memoria, il runtime non eseguirà un'operazione di garbage collection durante l'esecuzione di codice in un percorso critico.</span><span class="sxs-lookup"><span data-stu-id="e56b6-144">If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</span></span>  
  
 <span data-ttu-id="e56b6-145">Si definisce l'inizio del percorso critico di alcuna area Garbage Collection chiamando uno degli overload del <xref:System.GC.TryStartNoGCRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="e56b6-145">You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>.</span></span> <span data-ttu-id="e56b6-146">Si specifica la fine del relativo percorso critico tramite una chiamata di <xref:System.GC.EndNoGCRegion%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-146">You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 <span data-ttu-id="e56b6-147">Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si deve solo chiamare il <xref:System.GC.EndNoGCRegion%2A> metodo, se il runtime è attualmente in alcuna modalità di latenza delle aree GC.</span><span class="sxs-lookup"><span data-stu-id="e56b6-147">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e56b6-148">In altre parole, non chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata al metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo semplicemente perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-148">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-149">L'esempio seguente usa diversi metodi di catalogo globale per ottenere la generazione e informazioni di memoria su un blocco di oggetti inutilizzati e stamparlo nella console.</span><span class="sxs-lookup"><span data-stu-id="e56b6-149">The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</span></span> <span data-ttu-id="e56b6-150">Gli oggetti inutilizzati vengono quindi raccolte e vengono visualizzati i totali della memoria.</span><span class="sxs-lookup"><span data-stu-id="e56b6-150">The unused objects are then collected, and the resulting memory totals are displayed.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md">
      <span data-ttu-id="e56b6-151">Garbage Collection</span>
      <span class="sxs-lookup">
        <span data-stu-id="e56b6-151">Garbage Collection</span>
      </span>
    </related>
    <related type="Article" href="http://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
      <span data-ttu-id="e56b6-152">Principi fondamentali di Garbage Collection</span>
      <span class="sxs-lookup">
        <span data-stu-id="e56b6-152">Fundamentals of Garbage Collection</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">
          <span data-ttu-id="e56b6-153">Quantità incrementale di memoria non gestita che è stata allocata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-153">The incremental amount of unmanaged memory that has been allocated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-154">Informa il runtime di un'allocazione di una grande quantità di memoria non gestita di cui tenere conto durante la pianificazione della procedura di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-154">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-155">Nella determinazione della necessità di pianificare l'operazione di garbage collection, il runtime prende in considerazione la quantità di memoria gestito viene allocato.</span><span class="sxs-lookup"><span data-stu-id="e56b6-155">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="e56b6-156">Se un oggetto gestito di piccole dimensioni viene allocata una grande quantità di memoria non gestita, il runtime tiene in considerazione solo la memoria gestita e viene pertanto sottovalutata l'urgenza della pianificazione della garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e56b6-156">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="e56b6-157">Il <xref:System.GC.AddMemoryPressure%2A> metodo informa il runtime di questa aggiuntiva pressione sulla memoria di sistema.</span><span class="sxs-lookup"><span data-stu-id="e56b6-157">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.</span></span>  
  
 <span data-ttu-id="e56b6-158">Nel modello di utilizzo più semplice, un oggetto gestito alloca memoria non gestita nel costruttore e lo rilascia nel `Dispose` o `Finalize` (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-158">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="e56b6-159">Chiamare il <xref:System.GC.AddMemoryPressure%2A> metodo dopo avere allocato memoria non gestita e chiamare il <xref:System.GC.RemoveMemoryPressure%2A> metodo dopo averlo rilasciato.</span><span class="sxs-lookup"><span data-stu-id="e56b6-159">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="e56b6-160">In scenari più complessi, in cui l'allocazione di memoria non gestita in modo sostanziale cambia nel corso della durata dell'oggetto gestito, è possibile chiamare il <xref:System.GC.AddMemoryPressure%2A> e <xref:System.GC.RemoveMemoryPressure%2A> metodi per comunicare le modifiche incrementali al runtime.</span><span class="sxs-lookup"><span data-stu-id="e56b6-160">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e56b6-161">È necessario assicurarsi di rimuovere esattamente la quantità di pressione che si aggiunge.</span><span class="sxs-lookup"><span data-stu-id="e56b6-161">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="e56b6-162">Se non si esegue questa operazione può influire negativamente sulle prestazioni del sistema in applicazioni in esecuzione per lunghi periodi di tempo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-162">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-163">
            <paramref name="bytesAllocated" /> è minore o uguale a 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-163">
              <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          </span>
          <span data-ttu-id="e56b6-164">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-164">-or-</span>
          </span>
          <span data-ttu-id="e56b6-165">Su un computer a 32 bit, <paramref name="bytesAllocated" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-165">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e56b6-166">la possibilità di chiamare codice non gestito durante la modifica delle priorità di garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-166">for the ability to call unmanaged code when manipulating garbage-collection priority.</span>
          </span>
          <span data-ttu-id="e56b6-167">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-167">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e56b6-168">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-168">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-169">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-169">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-170">Annulla la registrazione di una notifica di un'operazione di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-170">Cancels the registration of a garbage collection notification.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-171">Questo metodo consente di annullare una notifica di garbage collection che è stata registrata usando il <xref:System.GC.RegisterForFullGCNotification%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-171">This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="e56b6-172">Non è necessario chiamare questo metodo prima di modificare i valori di soglia dei parametri nelle chiamate successive al <xref:System.GC.RegisterForFullGCNotification%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-172">You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-173">Nell'esempio seguente Annulla una registrazione di garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e56b6-173">The following example cancels a garbage collection registration.</span></span> <span data-ttu-id="e56b6-174">In questo esempio fa parte di un esempio più esaustivo disponibile per il [notifiche di Garbage Collection](~/docs/standard/garbage-collection/notifications.md) argomento.</span><span class="sxs-lookup"><span data-stu-id="e56b6-174">This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="e56b6-175">Questo membro non è disponibile quando l'operazione di Garbage Collection in modalità simultanea è abilitata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-175">This member is not available when concurrent garbage collection is enabled.</span>
          </span>
          <span data-ttu-id="e56b6-176">Vedere l'impostazione di runtime [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) per informazioni su come disabilitare la Garbage Collection simultanea.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-176">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e56b6-177">per un'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-177">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-178">Impossibile usare questo membro in codice parzialmente attendibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-178">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e56b6-179">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-179">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-180">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-180">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="e56b6-181">Notifiche di Garbage Collection</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-181">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-182">Forza la procedura di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-182">Forces garbage collection.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-183">Forza un'operazione immediata di Garbage Collection di tutte le generazioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-183">Forces an immediate garbage collection of all generations.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-184">Utilizzare questo metodo per provare a recuperare tutta la memoria che non è accessibile.</span><span class="sxs-lookup"><span data-stu-id="e56b6-184">Use this method to try to reclaim all memory that is inaccessible.</span></span> <span data-ttu-id="e56b6-185">Esegue un'operazione di Garbage Collection bloccante per tutte le generazioni.</span><span class="sxs-lookup"><span data-stu-id="e56b6-185">It performs a blocking garbage collection of all generations.</span></span>  
  
 <span data-ttu-id="e56b6-186">Tutti gli oggetti, indipendentemente dal tempo sono stati in memoria, vengono considerati per la raccolta. Tuttavia, gli oggetti cui vengono fatto riferimento nel codice gestito non vengono raccolti.</span><span class="sxs-lookup"><span data-stu-id="e56b6-186">All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</span></span> <span data-ttu-id="e56b6-187">Usare questo metodo per forzare il sistema per provare a recuperare la quantità massima di memoria disponibile.</span><span class="sxs-lookup"><span data-stu-id="e56b6-187">Use this method to force the system to try to reclaim the maximum amount of available memory.</span></span>  
  
 <span data-ttu-id="e56b6-188">A partire da [!INCLUDE[net_v451](~/includes/net-v451-md.md)], è possibile compattare gli heap di oggetti grandi impostando la proprietà <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> su <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> prima di chiamare il metodo <xref:System.GC.Collect%2A>, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="e56b6-188">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-189">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.GC.Collect%2A> metodo per eseguire una raccolta in tutte le generazioni di memoria.</span><span class="sxs-lookup"><span data-stu-id="e56b6-189">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory.</span></span> <span data-ttu-id="e56b6-190">Il codice genera un numero di oggetti inutilizzati e quindi chiama il <xref:System.GC.Collect%2A> metodo eliminate dalla memoria.</span><span class="sxs-lookup"><span data-stu-id="e56b6-190">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">
          <span data-ttu-id="e56b6-191">Raccolte indotte</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-191">Induced Collections</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="e56b6-192">Numero della generazione meno recente da sottoporre a Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-192">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-193">Forza un immediato Garbage Collection a partire dalla generazione 0 fino a una determinata generazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-193">Forces an immediate garbage collection from generation 0 through a specified generation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-194">Usare questo metodo per provare a recuperare memoria che non è accessibile.</span><span class="sxs-lookup"><span data-stu-id="e56b6-194">Use this method to try to reclaim memory that is inaccessible.</span></span> <span data-ttu-id="e56b6-195">Tuttavia, questo metodo non garantisce che tutta la memoria inaccessibile nella generazione specificata viene recuperata.</span><span class="sxs-lookup"><span data-stu-id="e56b6-195">However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="e56b6-196">Se viene implementata la durata dell'oggetto, il garbage collector non raccoglie gli oggetti con un numero di generazione superiore rispetto alla generazione specificata.</span><span class="sxs-lookup"><span data-stu-id="e56b6-196">If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</span></span> <span data-ttu-id="e56b6-197">Se la durata dell'oggetto non viene implementata, il garbage collector non prende in considerazione tutti gli oggetti durante l'operazione di garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e56b6-197">If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</span></span>  
  
 <span data-ttu-id="e56b6-198">Usare la <xref:System.GC.MaxGeneration%2A> proprietà per determinare il valore massimo valido il `generation` parametro.</span><span class="sxs-lookup"><span data-stu-id="e56b6-198">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.</span></span>  
  
 <span data-ttu-id="e56b6-199">Per consentire al garbage collector prendere in considerazione tutti gli oggetti indipendentemente dalla generazione, usare la versione di questo metodo che non accetta parametri.</span><span class="sxs-lookup"><span data-stu-id="e56b6-199">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span> <span data-ttu-id="e56b6-200">Per avere il garbage collector di recuperare gli oggetti in base una <xref:System.GCCollectionMode> impostazione, usare il <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-200">To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-201">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.GC.Collect%2A> metodo per eseguire una raccolta su singoli livelli di memoria.</span><span class="sxs-lookup"><span data-stu-id="e56b6-201">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory.</span></span> <span data-ttu-id="e56b6-202">Il codice genera un numero di oggetti inutilizzati e quindi chiama il <xref:System.GC.Collect%2A> metodo eliminate dalla memoria.</span><span class="sxs-lookup"><span data-stu-id="e56b6-202">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-203">
            <paramref name="generation" /> non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-203">
              <paramref name="generation" /> is not valid.</span>
          </span>
        </exception>
        <related type="Article" href="http://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">
          <span data-ttu-id="e56b6-204">Raccolte indotte</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-204">Induced Collections</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="e56b6-205">Numero della generazione meno recente da sottoporre a Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-205">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="e56b6-206">Valore di enumerazione che specifica se l'operazione di Garbage Collection è forzata (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o ottimizzata (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-206">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-207">Forza un'operazione di Garbage Collection dalla generazione 0 a una generazione specificata, in un momento specificato dal valore di <see cref="T:System.GCCollectionMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-207">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-208">Usare il `mode` parametro per specificare se la garbage collection deve essere eseguito immediatamente o solo se il tempo è ottimale per recuperare oggetti.</span><span class="sxs-lookup"><span data-stu-id="e56b6-208">Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</span></span> <span data-ttu-id="e56b6-209">Con questo metodo non garantisce che venga recuperata tutta la memoria inaccessibile nella generazione specificata.</span><span class="sxs-lookup"><span data-stu-id="e56b6-209">Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="e56b6-210">Per rettificare l'ingerenza di garbage collection durante i periodi critici nell'applicazione, impostare il <xref:System.Runtime.GCSettings.LatencyMode%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="e56b6-210">To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.</span></span>  
  
 <span data-ttu-id="e56b6-211">Il garbage collector non raccogliere gli oggetti con un numero di generazione superiore a quello specificato da di `generation` parametro.</span><span class="sxs-lookup"><span data-stu-id="e56b6-211">The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter.</span></span> <span data-ttu-id="e56b6-212">Usare la <xref:System.GC.MaxGeneration%2A> proprietà per determinare il valore massimo valido `generation`.</span><span class="sxs-lookup"><span data-stu-id="e56b6-212">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.</span></span>  
  
 <span data-ttu-id="e56b6-213">Per consentire al garbage collector prendere in considerazione tutti gli oggetti indipendentemente dalla generazione, usare la versione di questo metodo che non accetta parametri.</span><span class="sxs-lookup"><span data-stu-id="e56b6-213">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span>  
  
 <span data-ttu-id="e56b6-214">Affinché il garbage collector di recuperare oggetti fino a una generazione specificata di oggetti, usare il <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-214">To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="e56b6-215">Quando si specifica il numero massimo di generazioni, tutti gli oggetti vengono raccolti.</span><span class="sxs-lookup"><span data-stu-id="e56b6-215">When you specify the maximum generation, all objects are collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-216">Nell'esempio seguente forza un'operazione di garbage collection per gli oggetti di generazione 2 con il <xref:System.GCCollectionMode.Optimized> impostazione.</span><span class="sxs-lookup"><span data-stu-id="e56b6-216">The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.</span></span>  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-217">
            <paramref name="generation" /> non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-217">
              <paramref name="generation" /> is not valid.</span>
          </span>
          <span data-ttu-id="e56b6-218">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-218">-or-</span>
          </span>
          <span data-ttu-id="e56b6-219">
            <paramref name="mode" /> non è uno dei valori di <see cref="T:System.GCCollectionMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-219">
              <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          </span>
        </exception>
        <related type="Article" href="http://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">
          <span data-ttu-id="e56b6-220">Raccolte indotte</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-220">Induced Collections</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="e56b6-221">Numero della generazione meno recente da sottoporre a Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-221">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="e56b6-222">Valore di enumerazione che specifica se l'operazione di Garbage Collection è forzata (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o ottimizzata (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-222">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <param name="blocking">
          <span data-ttu-id="e56b6-223">
            <see langword="true" /> per eseguire una procedura di Garbage Collection; <see langword="false" /> per eseguire una procedura di Garbage Collection in background, se possibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-223">
              <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-224">Forza un'operazione di Garbage Collection dalla generazione 0 fino a una determinata generazione, in un momento specificato dal valore di <see cref="T:System.GCCollectionMode" />, con un valore che specifica se la raccolta deve essere bloccante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-224">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-225">Nella tabella seguente viene riepilogata l'interazione dei parametri `mode` e `blocking`.</span><span class="sxs-lookup"><span data-stu-id="e56b6-225">The following table summarizes the interaction of the `mode` and `blocking` parameters:</span></span>  
  
|`mode`|<span data-ttu-id="e56b6-226">`blocking` è `true`</span><span class="sxs-lookup"><span data-stu-id="e56b6-226">`blocking` is `true`</span></span>|<span data-ttu-id="e56b6-227">`blocking` è `false`</span><span class="sxs-lookup"><span data-stu-id="e56b6-227">`blocking` is `false`</span></span>|  
|-|-|-|  
|<span data-ttu-id="e56b6-228"><xref:System.GCCollectionMode.Forced> o <xref:System.GCCollectionMode.Default></span><span class="sxs-lookup"><span data-stu-id="e56b6-228"><xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default></span></span>|<span data-ttu-id="e56b6-229">Viene eseguita una raccolta di blocco il prima possibile.</span><span class="sxs-lookup"><span data-stu-id="e56b6-229">A blocking collection is performed as soon as possible.</span></span> <span data-ttu-id="e56b6-230">Se è in corso una raccolta in background e `generation` è 0 o 1, il metodo <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> attiva immediatamente una raccolta di blocco e quando la raccolta viene completata esce dalla funzione.</span><span class="sxs-lookup"><span data-stu-id="e56b6-230">If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished.</span></span> <span data-ttu-id="e56b6-231">Se è in corso una raccolta in background e `generation` è 2, il metodo attende fino a quando la raccolta in background non viene completata, attiva una raccolta di blocco di generazione 2 ed esce dalla funzione.</span><span class="sxs-lookup"><span data-stu-id="e56b6-231">If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</span></span>|<span data-ttu-id="e56b6-232">Viene eseguita una raccolta il prima possibile.</span><span class="sxs-lookup"><span data-stu-id="e56b6-232">A collection is performed as soon as possible.</span></span> <span data-ttu-id="e56b6-233">Il metodo <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> richiede una raccolta in background, la cui esecuzione non è comunque garantita. A seconda della situazione, può venire comunque eseguita una raccolta di blocco.</span><span class="sxs-lookup"><span data-stu-id="e56b6-233">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="e56b6-234">Se è già in corso una raccolta in background, il metodo viene restituito immediatamente.</span><span class="sxs-lookup"><span data-stu-id="e56b6-234">If a background collection is already in progress, the method returns immediately.</span></span>|  
|<xref:System.GCCollectionMode.Optimized>|<span data-ttu-id="e56b6-235">Può venire eseguita una raccolta di blocco, a seconda dello stato del Garbage Collector e del parametro `generation`.</span><span class="sxs-lookup"><span data-stu-id="e56b6-235">A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter.</span></span> <span data-ttu-id="e56b6-236">Il Garbage Collector tenta di garantire prestazioni ottimali.</span><span class="sxs-lookup"><span data-stu-id="e56b6-236">The garbage collector tries to provide optimal performance.</span></span>|<span data-ttu-id="e56b6-237">È possibile eseguire una raccolta, a seconda dello stato del Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="e56b6-237">A collection may be performed, depending on the state of the garbage collector.</span></span> <span data-ttu-id="e56b6-238">Il metodo <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> richiede una raccolta in background, la cui esecuzione non è comunque garantita. A seconda della situazione, può venire comunque eseguita una raccolta di blocco.</span><span class="sxs-lookup"><span data-stu-id="e56b6-238">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="e56b6-239">Il Garbage Collector tenta di garantire prestazioni ottimali.</span><span class="sxs-lookup"><span data-stu-id="e56b6-239">The garbage collector tries to provide optimal performance.</span></span> <span data-ttu-id="e56b6-240">Se è già in corso una raccolta in background, il metodo viene restituito immediatamente.</span><span class="sxs-lookup"><span data-stu-id="e56b6-240">If a background collection is already in progress, the method returns immediately.</span></span>|  
  
 <span data-ttu-id="e56b6-241">Se una chiamata al metodo <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> esegue una procedura completa di Garbage Collection bloccante, è anche possibile compattare gli heap di oggetti grandi impostando la proprietà <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> su <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> prima di chiamare il metodo <xref:System.GC.Collect%2A>.</span><span class="sxs-lookup"><span data-stu-id="e56b6-241">If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-242">
            <paramref name="generation" /> non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-242">
              <paramref name="generation" /> is not valid.</span>
          </span>
          <span data-ttu-id="e56b6-243">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-243">-or-</span>
          </span>
          <span data-ttu-id="e56b6-244">
            <paramref name="mode" /> non è uno dei valori di <see cref="T:System.GCCollectionMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-244">
              <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="e56b6-245">Numero della generazione meno recente da sottoporre a Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-245">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="e56b6-246">Valore di enumerazione che specifica se l'operazione di Garbage Collection è forzata (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o ottimizzata (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-246">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <param name="blocking">
          <span data-ttu-id="e56b6-247">
            <see langword="true" /> per eseguire una procedura di Garbage Collection; <see langword="false" /> per eseguire una procedura di Garbage Collection in background, se possibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-247">
              <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          </span>
        </param>
        <param name="compacting">
          <span data-ttu-id="e56b6-248">
            <see langword="true" /> per comprimere l'heap degli oggetti piccoli; <see langword="false" /> per la sola organizzazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-248">
              <see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-249">Forza un'operazione di Garbage Collection dalla generazione 0 fino a una determinata generazione, in un momento specificato dal valore di <see cref="T:System.GCCollectionMode" />, con valori che specificano se la raccolta deve essere bloccante e compattante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-249">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-250">Se `blocking` è `false`, il Garbage Collector decide se eseguire una procedura di garbage collection o uno sfondo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-250">If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection.</span></span> <span data-ttu-id="e56b6-251">Se `compacting` è `true`, esegue una procedura di garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e56b6-251">If `compacting` is `true`, it performs a blocking garbage collection.</span></span>  
  
 <span data-ttu-id="e56b6-252">Se `compacting` è `true`, il runtime comprime l'heap oggetti piccoli (SOH).</span><span class="sxs-lookup"><span data-stu-id="e56b6-252">If `compacting` is `true`, the runtime compacts the small object heap (SOH).</span></span> <span data-ttu-id="e56b6-253">L'heap oggetti grandi (LOH) non viene compattato a meno che il <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> è impostata su <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e56b6-253">The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e56b6-254">Si noti che questa includa tutti i blocchi di garbage collection, non appena completa di garbage collection di blocco.</span><span class="sxs-lookup"><span data-stu-id="e56b6-254">Note that this includes all blocking garbage collections, not just full blocking garbage collections.</span></span>  
  
 <span data-ttu-id="e56b6-255">È possibile chiamare il <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> metodo per ridurre l'heap gestito a dimensioni più piccole possibili, come illustrato nel seguente frammento di codice seguente.</span><span class="sxs-lookup"><span data-stu-id="e56b6-255">You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</span></span>  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 <span data-ttu-id="e56b6-256">Che specifica `true` per il `compacting` argomento garantisce una compattazione, completa di garbage collection bloccante.</span><span class="sxs-lookup"><span data-stu-id="e56b6-256">Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection.</span></span> <span data-ttu-id="e56b6-257">Impostando il <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> proprietà <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> assicura che il rapporto di integrità sia l'heap oggetti grandi vengono compattate.</span><span class="sxs-lookup"><span data-stu-id="e56b6-257">Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> ensures that both the LOH and SOH are compacted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="e56b6-258">Generazione di oggetti per la quale viene determinato il conteggio delle operazioni di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-258">The generation of objects for which the garbage collection count is to be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-259">Restituisce il numero di volte che è stata effettuata la procedura di Garbage Collection per la generazione specificata di oggetti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-259">Returns the number of times garbage collection has occurred for the specified generation of objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-260">Numero di esecuzioni del Garbage Collection per la generazione specificata dall'avvio del processo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-260">The number of times garbage collection has occurred for the specified generation since the process was started.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-261">Se si implementa la gestione delle proprie risorse, potrebbe essere necessario forzare periodicamente operazioni di garbage collection chiamando il <xref:System.GC.Collect%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-261">If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="e56b6-262">Poiché si tratta di un'operazione dispendiosa, è possibile migliorare le prestazioni ignorando la chiamata durante un'operazione di garbage collection si è verificata di recente.</span><span class="sxs-lookup"><span data-stu-id="e56b6-262">Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</span></span> <span data-ttu-id="e56b6-263">Salvare il valore restituito da <xref:System.GC.CollectionCount%2A> immediatamente dopo la chiamata <xref:System.GC.Collect%2A>.</span><span class="sxs-lookup"><span data-stu-id="e56b6-263">Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>.</span></span> <span data-ttu-id="e56b6-264">La volta successiva, è necessario chiamare <xref:System.GC.Collect%2A>, confrontare il valore corrente restituito dalla <xref:System.GC.CollectionCount%2A> con il valore salvato.</span><span class="sxs-lookup"><span data-stu-id="e56b6-264">The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value.</span></span> <span data-ttu-id="e56b6-265">Se i due valori sono uguali, si è verificato alcun insieme nel frattempo e a diminuire è ragionevole chiamare <xref:System.GC.Collect%2A> nuovamente.</span><span class="sxs-lookup"><span data-stu-id="e56b6-265">If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-266">
            <paramref name="generation" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-266">
              <paramref name="generation" /> is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-267">Termina la modalità di eliminazione della latenza delle aree GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-267">Ends the no GC region latency mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-268">Il <xref:System.GC.EndNoGCRegion%2A> metodo genera un <xref:System.InvalidOperationException> se il garbage collector non è disponibile in alcuna modalità di latenza delle aree GC.</span><span class="sxs-lookup"><span data-stu-id="e56b6-268">The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode.</span></span> <span data-ttu-id="e56b6-269">Ciò si verifica in presenza delle condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="e56b6-269">This occurs under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="e56b6-270">Il <xref:System.GC.TryStartNoGCRegion%2A> (metodo) non è stato chiamato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="e56b6-270">The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.</span></span>  
  
-   <span data-ttu-id="e56b6-271">La chiamata per il <xref:System.GC.TryStartNoGCRegion%2A> metodo restituito `false`.</span><span class="sxs-lookup"><span data-stu-id="e56b6-271">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.</span></span>  
  
-   <span data-ttu-id="e56b6-272">La chiamata al <xref:System.GC.TryStartNoGCRegion%2A> metodo genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="e56b6-272">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.</span></span>  
  
 <span data-ttu-id="e56b6-273">È possibile impedire un'eccezione per i motivi seguenti usando codice simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="e56b6-273">You can prevent an exception for any of these reasons by using code such as the following:</span></span>  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="e56b6-274">Il Garbage Collector non è in modalità di assenza di latenza dell'area di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-274">The garbage collector is not in no GC region latency mode.</span>
          </span>
          <span data-ttu-id="e56b6-275">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-275">-or-</span>
          </span>
          <span data-ttu-id="e56b6-276">La modalità di assenza di latenza dell'area di Garbage Collection è stata terminata in precedenza perché è stata attivata un'operazione di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-276">The no GC region latency mode was ended previously because a garbage collection was induced.</span>
          </span>
          <span data-ttu-id="e56b6-277">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-277">-or-</span>
          </span>
          <span data-ttu-id="e56b6-278">Un'allocazione di memoria ha superato la quantità specificata nella chiamata al metodo <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-278">A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="http://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="e56b6-279">Modalità di latenza</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-279">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-280">Restituisce il numero corrente di generazione di un oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-280">Returns the current generation number of an object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="e56b6-281">Oggetto per cui vengono recuperate le informazioni sulla generazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-281">The object that generation information is retrieved for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-282">Restituisce il numero corrente di generazione dell'oggetto specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-282">Returns the current generation number of the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-283">Numero corrente di generazione di <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-283">The current generation number of <paramref name="obj" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-284">Usare questo metodo per determinare la validità di un oggetto e quindi usare tali informazioni con il <xref:System.GC.Collect%2A> metodo per forzare il garbage collector di raccogliere gli oggetti nella generazione stessa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-284">Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation.</span></span> <span data-ttu-id="e56b6-285">Ad esempio, usare questo metodo quando si dispone di un set di oggetti che vengono creati come un gruppo e che diventano inaccessibili nello stesso momento.</span><span class="sxs-lookup"><span data-stu-id="e56b6-285">For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-286">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.GC.GetGeneration%2A> metodo per determinare la validità di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="e56b6-286">The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object.</span></span> <span data-ttu-id="e56b6-287">Nell'esempio viene quindi eseguito operazioni di garbage collection per pulire la memoria e confrontare pre e post raccolta totali della memoria nella console.</span><span class="sxs-lookup"><span data-stu-id="e56b6-287">The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">
          <span data-ttu-id="e56b6-288">Oggetto <see cref="T:System.WeakReference" /> che fa riferimento all'oggetto di destinazione di cui determinare il numero di generazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-288">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-289">Restituisce il numero corrente di generazione della destinazione di uno specifico riferimento debole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-289">Returns the current generation number of the target of a specified weak reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-290">Numero di generazione corrente della destinazione di <paramref name="wo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-290">The current generation number of the target of <paramref name="wo" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e56b6-291">Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.GC.GetGeneration%2A> metodo per determinare la validità di un oggetto di riferimento debole.</span><span class="sxs-lookup"><span data-stu-id="e56b6-291">The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.</span></span>  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e56b6-292">La procedura di Garbage Collection è già stata effettuata su <paramref name="wo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-292">Garbage collection has already been performed on <paramref name="wo" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          <span data-ttu-id="e56b6-293">
            <see langword="true" /> per indicare che questo metodo può attendere l'esecuzione dell'operazione di Garbage Collection prima di restituire un risultato; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-293">
              <see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-294">Recupera il numero di byte correntemente considerati allocabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-294">Retrieves the number of bytes currently thought to be allocated.</span>
          </span>
          <span data-ttu-id="e56b6-295">Un parametro indica se questo metodo può attendere un breve intervallo prima di restituire un risultato per consentire l'esecuzione della procedura di Garbage Collection e la finalizzazione degli oggetti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-295">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-296">Numero che rappresenta la migliore approssimazione disponibile del numero di byte correntemente allocati nella memoria gestita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-296">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-297">Se il `forceFullCollection` parametro è `true`, questo metodo attende un breve periodo di tempo prima della restituzione, mentre il sistema di Garbage Collection e il completamento degli oggetti.</span><span class="sxs-lookup"><span data-stu-id="e56b6-297">If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects.</span></span> <span data-ttu-id="e56b6-298">La durata dell'intervallo è un limite specificato internamente dipende dal numero di cicli di garbage collection completata e la modifica della quantità di memoria recuperata tra i cicli.</span><span class="sxs-lookup"><span data-stu-id="e56b6-298">The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</span></span> <span data-ttu-id="e56b6-299">Il garbage collector non garantisce che tutta la memoria non accessibile verrà raccolti.</span><span class="sxs-lookup"><span data-stu-id="e56b6-299">The garbage collector does not guarantee that all inaccessible memory is collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-300">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.GC.GetTotalMemory%2A> metodo per ottenere e visualizzare il numero di byte correntemente allocati nella memoria gestita.</span><span class="sxs-lookup"><span data-stu-id="e56b6-300">The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="e56b6-301">Oggetto a cui fare riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-301">The object to reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-302">Fa riferimento all'oggetto specificato, rendendolo inadatto per il Garbage Collection dall'inizio della routine corrente fino al momento in cui viene chiamato il metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-302">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-303">Lo scopo del <xref:System.GC.KeepAlive%2A> metodo consiste nel verificare l'esistenza di un riferimento a un oggetto che è soggetta a rischi derivanti in modo anomalo viene recuperato dal garbage collector.</span><span class="sxs-lookup"><span data-stu-id="e56b6-303">The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</span></span> <span data-ttu-id="e56b6-304">Uno scenario comune in cui questo può verificarsi è quando non sono presenti riferimenti all'oggetto nel codice gestito o dati, ma l'oggetto è ancora in uso nel codice non gestito, ad esempio le API Win32, le DLL non gestite, o i metodi tramite COM.</span><span class="sxs-lookup"><span data-stu-id="e56b6-304">A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</span></span>  
  
 <span data-ttu-id="e56b6-305">Questo metodo fa riferimento il `obj` parametro, rendendo questo oggetto non idonea per garbage collection dall'inizio della routine per il punto, in ordine di esecuzione, in cui questo metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="e56b6-305">This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</span></span> <span data-ttu-id="e56b6-306">Questo metodo alla fine, non all'inizio, dell'intervallo di istruzioni di codice in cui `obj` deve essere disponibile.</span><span class="sxs-lookup"><span data-stu-id="e56b6-306">Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.</span></span>  
  
 <span data-ttu-id="e56b6-307">Il <xref:System.GC.KeepAlive%2A> metodo non esegue alcuna operazione e non produce effetti collaterali diverso da prolungare la durata dell'oggetto passato come parametro.</span><span class="sxs-lookup"><span data-stu-id="e56b6-307">The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-308">Esempio di codice seguente crea un oggetto all'inizio del relativo `Main` metodo e non fa riferimento all'oggetto fino alla fine, quando il <xref:System.GC.KeepAlive%2A> viene chiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-308">The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called.</span></span> <span data-ttu-id="e56b6-309">L'oggetto viene mantenuto per la durata di 30 secondi del `Main` metodo, nonostante le chiamate per il <xref:System.GC.Collect%2A> e <xref:System.GC.WaitForPendingFinalizers%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="e56b6-309">The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.</span></span>  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-310">Ottiene il numero massimo di generazioni supportate correntemente dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-310">Gets the maximum number of generations that the system currently supports.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e56b6-311">Valore compreso tra zero e il numero massimo di generazioni supportate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-311">A value that ranges from zero to the maximum number of supported generations.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-312">Il numero di generazione o età, di un oggetto è una misura relativa della durata di un oggetto definito dall'implementazione.</span><span class="sxs-lookup"><span data-stu-id="e56b6-312">The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</span></span> <span data-ttu-id="e56b6-313">Gli oggetti creati più di recente appartengono alla generazione 0, mentre quelli più vecchi rientrano in una generazione minore o uguale a quella restituita dalla proprietà <xref:System.GC.MaxGeneration%2A>.</span><span class="sxs-lookup"><span data-stu-id="e56b6-313">The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.</span></span>  
  
 <span data-ttu-id="e56b6-314">Il garbage collector si presuppone che più recente memoria maggiori probabilità di essere idonea per garbage collection rispetto alla memoria meno recente.</span><span class="sxs-lookup"><span data-stu-id="e56b6-314">The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</span></span> <span data-ttu-id="e56b6-315">Pertanto, il garbage collector migliora le prestazioni regolando i numeri di generazione ogni volta che recupera la memoria, e il <xref:System.GC.MaxGeneration%2A> valore della proprietà può aumentare nel corso del tempo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-315">Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.</span></span>  
  
 <span data-ttu-id="e56b6-316">Se viene implementata la durata dell'oggetto, il <xref:System.GC.MaxGeneration%2A> proprietà restituisce il numero massimo di generazione utilizzato dal sistema; in caso contrario, questa proprietà restituisce zero.</span><span class="sxs-lookup"><span data-stu-id="e56b6-316">If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-317">Nell'esempio seguente viene illustrato come utilizzare la proprietà MaxGeneration per visualizzare il numero di generazione più grande attualmente in uso.</span><span class="sxs-lookup"><span data-stu-id="e56b6-317">The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e56b6-318">Per questa implementazione, il valore restituito dal <see cref="P:System.GC.MaxGeneration" /> proprietà è garantito che rimane costante per la durata di un'applicazione in esecuzione.</span>
            <span class="sxs-lookup">
              <span data-stu-id="e56b6-318">For this implementation, the value returned by the <see cref="P:System.GC.MaxGeneration" /> property is guaranteed to remain constant for the lifetime of an executing application.</span>
            </span>
            <span data-ttu-id="e56b6-319">Usare la <see cref="P:System.GC.MaxGeneration" /> proprietà per determinare il valore massimo è possibile specificare quando si chiama il <see cref="M:System.GC.Collect(System.Int32)" /> metodo che accetta un parametro di generazione.</span>
            <span class="sxs-lookup">
              <span data-stu-id="e56b6-319">Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum value you can specify when calling the <see cref="M:System.GC.Collect(System.Int32)" /> method that takes a generation parameter.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">
          <span data-ttu-id="e56b6-320">Numero compreso tra 1 e 99 che specifica se la notifica deve essere generata in base agli oggetti allocati nella generazione 2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-320">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span>
          </span>
        </param>
        <param name="largeObjectHeapThreshold">
          <span data-ttu-id="e56b6-321">Numero compreso tra 1 e 99 che specifica quando generare la notifica in base agli oggetti allocati nell'heap degli oggetti grandi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-321">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-322">Specifica che deve essere generata una notifica di un'operazione di Garbage Collection quando le condizioni favoriscono l'operazione di Garbage Collection completa e quando la raccolta è stata completata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-322">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-323">Per ogni generazione, il garbage collector non imposta una soglia per le allocazioni in quella generazione.</span><span class="sxs-lookup"><span data-stu-id="e56b6-323">For each generation, the garbage collector sets a threshold for allocations into that generation.</span></span> <span data-ttu-id="e56b6-324">Quando le dimensioni delle allocazioni superano questa soglia, viene attivata una garbage collection sulla generazione interessata.</span><span class="sxs-lookup"><span data-stu-id="e56b6-324">When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</span></span> <span data-ttu-id="e56b6-325">Per esempio, se la soglia di generazione 2 è 20MB (ovvero continua a funzionare, le raccolte di generazione 1 e 20MB viene promosso alla generazione 2) e più di 20MB è sopravvissuto alla generazione 1 e viene richiesto nella generazione 2, verrà tentata la successiva garbage collection come una raccolta di generazione 2.</span><span class="sxs-lookup"><span data-stu-id="e56b6-325">For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</span></span> <span data-ttu-id="e56b6-326">Analogamente, se l'heap oggetti grandi (LOH) soglia è 20MB e l'app ha allocato più di 20MB di oggetti di grandi dimensioni, la successiva garbage collection verrà tentata anche come una raccolta di generazione 2 (dal momento che l'heap oggetti grandi viene raccolto solo in operazioni di garbage collection gen2).</span><span class="sxs-lookup"><span data-stu-id="e56b6-326">Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</span></span>  
  
 <span data-ttu-id="e56b6-327">Il `maxGenerationThreshold` e `largeObjectHeapThreshold` le soglie di controllano la quantità in anticipo riceverà una notifica prima che venga eseguita una garbage collection completa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-327">The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs.</span></span> <span data-ttu-id="e56b6-328">Maggiore è la soglia, le allocazioni di più che possono verificarsi tra la notifica e la successiva garbage collection completa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-328">The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</span></span>  
  
 <span data-ttu-id="e56b6-329">Se si dispone di situazioni in cui una completa di garbage collection da common language runtime potrebbe influire negativamente sulle prestazioni dell'applicazione, è possibile richiedere una notifica quando il runtime sta per eseguire operazioni di garbage collection completa e aggirare tale raccolta in base al provocare manualmente una raccolta (usando il <xref:System.GC.Collect%2A> metodo) quando le condizioni sono comunque vantaggiose.</span><span class="sxs-lookup"><span data-stu-id="e56b6-329">If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable.</span></span> <span data-ttu-id="e56b6-330">Oltre a modificare la pianificazione di garbage collection, notifica di Garbage Collection completa è utile nei seguenti scenari:</span><span class="sxs-lookup"><span data-stu-id="e56b6-330">In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</span></span>  
  
-   <span data-ttu-id="e56b6-331">Esegue il monitoraggio l'approccio di garbage collection completa e, quando si riceve una notifica che uno è quasi raggiunto, si riducono le dimensioni dei dati in tempo reale (ad esempio, rilasciando alcune voci di cache).</span><span class="sxs-lookup"><span data-stu-id="e56b6-331">You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</span></span> <span data-ttu-id="e56b6-332">Di conseguenza, quando si verifica la garbage collection, è in grado di recuperare più memoria.</span><span class="sxs-lookup"><span data-stu-id="e56b6-332">As a result, when the garbage collection occurs, it is able to reclaim more memory.</span></span>  
  
-   <span data-ttu-id="e56b6-333">Esegue il monitoraggio il completamento di una garbage collection completa in modo che è possibile raccogliere alcune statistiche.</span><span class="sxs-lookup"><span data-stu-id="e56b6-333">You monitor for the completion of a full garbage collection so that you can collect some statistics.</span></span>  <span data-ttu-id="e56b6-334">Ad esempio, è possibile misurare le dimensioni dell'heap al completamento del Garbage Collector in modo che si conosce la dimensione dei dati in tempo reale.</span><span class="sxs-lookup"><span data-stu-id="e56b6-334">For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</span></span> <span data-ttu-id="e56b6-335">(Dopo una Garbage Collection completa, l'heap è la dimensione più piccola).</span><span class="sxs-lookup"><span data-stu-id="e56b6-335">(After a full GC, the heap is at its smallest size.)</span></span>  
  
 <span data-ttu-id="e56b6-336">Per altre informazioni su ciò che rappresenta una garbage collection completa, vedere [notifiche di Garbage Collection](~/docs/standard/garbage-collection/notifications.md).</span><span class="sxs-lookup"><span data-stu-id="e56b6-336">For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).</span></span>  
  
 <span data-ttu-id="e56b6-337">Quando si registra per una notifica di garbage collection, è possibile ricevere notifiche quando sta per raggiungere una garbage collection completa e quando viene completata.</span><span class="sxs-lookup"><span data-stu-id="e56b6-337">When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</span></span> <span data-ttu-id="e56b6-338">Questo modello è simile al modo in cui il sistema operativo consente di monitorare le notifiche di memoria insufficiente.</span><span class="sxs-lookup"><span data-stu-id="e56b6-338">This pattern resembles how the operating system monitors for low memory notifications.</span></span>  
  
 <span data-ttu-id="e56b6-339">Usare le linee guida seguenti per specificare il `maxGenerationThreshold` e `largeObjectHeapThreshold` parametri:</span><span class="sxs-lookup"><span data-stu-id="e56b6-339">Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:</span></span>  
  
-   <span data-ttu-id="e56b6-340">Maggiore è il valore di soglia, le allocazioni di più verificherà tra la notifica e la garbage collection completa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-340">The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</span></span>  
  
     <span data-ttu-id="e56b6-341">Un valore di soglia maggiore offre altre opportunità per il runtime verificare la presenza di una raccolta di poco inferiori.</span><span class="sxs-lookup"><span data-stu-id="e56b6-341">A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</span></span> <span data-ttu-id="e56b6-342">In questo modo si aumenta la probabilità che riceverà una notifica.</span><span class="sxs-lookup"><span data-stu-id="e56b6-342">This increases the likelihood that you will be notified.</span></span> <span data-ttu-id="e56b6-343">Tuttavia, è consigliabile non impostare la soglia troppo alta perché risultante in delle altre allocazioni prima che il runtime provoca la raccolta successiva.</span><span class="sxs-lookup"><span data-stu-id="e56b6-343">However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</span></span>  
  
     <span data-ttu-id="e56b6-344">Quando si indurre manualmente una raccolta dopo la notifica usando un valore di soglia superiore, meno oggetti vengono recuperati più verrebbe recuperato dalla raccolta successiva del runtime.</span><span class="sxs-lookup"><span data-stu-id="e56b6-344">When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</span></span>  
  
-   <span data-ttu-id="e56b6-345">Minore è il valore soglia, meno le allocazioni tra la notifica e la garbage collection completa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-345">The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-346">Nell'esempio seguente viene illustrato come registrare una notifica di garbage collection e avviare un thread per monitorare lo stato della notifica di garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e56b6-346">The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</span></span> <span data-ttu-id="e56b6-347">Questo esempio di codice è parte di un esempio più esaustivo disponibile per [notifiche di Garbage Collection](~/docs/standard/garbage-collection/notifications.md) argomento.</span><span class="sxs-lookup"><span data-stu-id="e56b6-347">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-348">
            <paramref name="maxGenerationThreshold" /> o <paramref name="largeObjectHeapThreshold" /> non è compreso tra 1 e 99.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-348">
              <paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e56b6-349">per un'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-349">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-350">Impossibile usare questo membro in codice parzialmente attendibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-350">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e56b6-351">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-351">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-352">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-352">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="e56b6-353">Notifiche di Garbage Collection</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-353">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">
          <span data-ttu-id="e56b6-354">Quantità di memoria non gestita che è stata rilasciata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-354">The amount of unmanaged memory that has been released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-355">Informa il runtime che è stata rilasciata memoria non gestita di cui non occorre più tenere conto durante la pianificazione della procedura di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-355">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-356">Nella determinazione della necessità di pianificare l'operazione di garbage collection, il runtime prende in considerazione la quantità di memoria gestito viene allocato.</span><span class="sxs-lookup"><span data-stu-id="e56b6-356">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="e56b6-357">Se un oggetto gestito di piccole dimensioni viene allocata una grande quantità di memoria non gestita, il runtime tiene in considerazione solo la memoria gestita e viene pertanto sottovalutata l'urgenza della pianificazione della garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e56b6-357">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="e56b6-358">Il <xref:System.GC.AddMemoryPressure%2A> metodo informa il runtime di questa aggiuntiva pressione sulla memoria di sistema e il <xref:System.GC.RemoveMemoryPressure%2A> metodo informa il runtime che è stato rilasciato la pressione aggiuntiva.</span><span class="sxs-lookup"><span data-stu-id="e56b6-358">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.</span></span>  
  
 <span data-ttu-id="e56b6-359">Nel modello di utilizzo più semplice, un oggetto gestito alloca memoria non gestita nel costruttore e lo rilascia nel `Dispose` o `Finalize` (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-359">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="e56b6-360">Chiamare il <xref:System.GC.AddMemoryPressure%2A> metodo dopo avere allocato memoria non gestita e chiamare il <xref:System.GC.RemoveMemoryPressure%2A> metodo dopo averlo rilasciato.</span><span class="sxs-lookup"><span data-stu-id="e56b6-360">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="e56b6-361">In scenari più complessi, in cui l'allocazione di memoria non gestita in modo sostanziale cambia nel corso della durata dell'oggetto gestito, è possibile chiamare il <xref:System.GC.AddMemoryPressure%2A> e <xref:System.GC.RemoveMemoryPressure%2A> metodi per comunicare le modifiche incrementali al runtime.</span><span class="sxs-lookup"><span data-stu-id="e56b6-361">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e56b6-362">È necessario assicurarsi di rimuovere esattamente la quantità di pressione che si aggiunge.</span><span class="sxs-lookup"><span data-stu-id="e56b6-362">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="e56b6-363">Se non si esegue questa operazione può influire negativamente sulle prestazioni del sistema in applicazioni in esecuzione per lunghi periodi di tempo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-363">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-364">
            <paramref name="bytesAllocated" /> è minore o uguale a 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-364">
              <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          </span>
          <span data-ttu-id="e56b6-365">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-365">-or-</span>
          </span>
          <span data-ttu-id="e56b6-366">Su un computer a 32 bit, <paramref name="bytesAllocated" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-366">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e56b6-367">la possibilità di chiamare codice non gestito durante la modifica delle priorità di garbage collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-367">for the ability to call unmanaged code when manipulating garbage-collection priority.</span>
          </span>
          <span data-ttu-id="e56b6-368">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-368">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e56b6-369">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-369">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-370">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-370">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="e56b6-371">Oggetto per cui è necessario chiamare un finalizzatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-371">The object that a finalizer must be called for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-372">Richiede che il sistema chiami il finalizzatore per l'oggetto specificato, per il quale è stato precedentemente chiamato il metodo <see cref="M:System.GC.SuppressFinalize(System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-372">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-373">Il <xref:System.GC.ReRegisterForFinalize%2A> metodo aggiunge il `obj` parametro all'elenco di oggetti che richiedono il completamento prima che il garbage collector libera l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="e56b6-373">The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object.</span></span> <span data-ttu-id="e56b6-374">Il `obj` parametro deve essere il chiamante di questo metodo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-374">The `obj` parameter must be the caller of this method.</span></span>  
  
 <span data-ttu-id="e56b6-375">La chiamata di <xref:System.GC.ReRegisterForFinalize%2A> (metodo) non garantisce che il garbage collector chiamerà un finalizzatore dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="e56b6-375">Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.</span></span>  
  
 <span data-ttu-id="e56b6-376">Per impostazione predefinita, tutti gli oggetti che implementano i finalizzatori vengono aggiunti all'elenco di oggetti che richiedono la finalizzazione. Tuttavia, un oggetto potrebbe essere già stato finalizzato o potrebbe essere stato disabilitato la finalizzazione chiamando il <xref:System.GC.SuppressFinalize%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-376">By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="e56b6-377">Un finalizzatore può utilizzare questo metodo per ripristinare se stesso o un oggetto a cui fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="e56b6-377">A finalizer can use this method to resurrect itself or an object that it references.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-378">Nell'esempio seguente viene illustrato come utilizzare il metodo ReRegisterForFinalize per rendere effettive di un oggetto una seconda volta dopo l'operazione di garbage collection.</span><span class="sxs-lookup"><span data-stu-id="e56b6-378">The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</span></span>  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e56b6-379">
            <paramref name="obj" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-379">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="e56b6-380">Oggetto di cui non è necessario eseguire il finalizzatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-380">The object whose finalizer must not be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-381">Richiede che Common Language Runtime non chiami il finalizzatore per l'oggetto specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-381">Requests that the common language runtime not call the finalizer for the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-382">Questo metodo imposta un bit nell'intestazione dell'oggetto `obj`, il quale viene verificato dal runtime quando vengono chiamati i finalizzatori.</span><span class="sxs-lookup"><span data-stu-id="e56b6-382">This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers.</span></span> <span data-ttu-id="e56b6-383">Un finalizzatore, che è rappresentato dal metodo <xref:System.Object.Finalize%2A?displayProperty=nameWithType>, viene utilizzato per rilasciare le risorse non gestite prima che un oggetto venga raccolto dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="e56b6-383">A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method, is used to release unmanaged resources before an object is garbage-collected.</span></span> <span data-ttu-id="e56b6-384">Se `obj` non dispone di un finalizzatore, la chiamata al metodo <xref:System.GC.SuppressFinalize%2A> non avrà alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="e56b6-384">If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.</span></span>  
  
 <span data-ttu-id="e56b6-385">Gli oggetti che implementano l'interfaccia <xref:System.IDisposable> possono chiamare questo metodo dall'implementazione <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> dell'oggetto per impedire al Garbage Collector di chiamare <xref:System.Object.Finalize%2A?displayProperty=nameWithType> su un oggetto che non lo richiede.</span><span class="sxs-lookup"><span data-stu-id="e56b6-385">Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=nameWithType> on an object that does not require it.</span></span> <span data-ttu-id="e56b6-386">Tale operazione viene in genere eseguita per impedire al finalizzatore di rilasciare le risorse non gestite già liberate dall'implementazione <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e56b6-386">Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-387">Nell'esempio riportato di seguito viene illustrato come utilizzare il metodo <xref:System.GC.SuppressFinalize%2A> in una classe di risorse per impedire la chiamata ridondante di una Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="e56b6-387">The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called.</span></span> <span data-ttu-id="e56b6-388">L'esempio Usa la [modello dispose](~/docs/standard/design-guidelines/dispose-pattern.md) per liberare sia le risorse gestite (vale a dire, gli oggetti che implementano <xref:System.IDisposable>) e le risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="e56b6-388">The example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.</span></span>  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e56b6-389">
            <paramref name="obj" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-389">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="http://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb">
          <span data-ttu-id="e56b6-390">Modello Dispose</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-390">Dispose Pattern</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-391">Prova a impedire l'operazione di Garbage Collection durante l'esecuzione di un percorso critico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-391">Attempts to disallow garbage collection during the execution of a critical path.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="e56b6-392">Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si deve solo chiamare il <xref:System.GC.EndNoGCRegion%2A> metodo, se il runtime è attualmente in alcuna modalità di latenza delle aree GC.</span><span class="sxs-lookup"><span data-stu-id="e56b6-392">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e56b6-393">In altre parole, non chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata al metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo semplicemente perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-393">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="e56b6-394">Quantità di memoria in byte da allocare senza attivare un'operazione di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-394">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="e56b6-395">Deve essere minore o uguale alle dimensioni di un segmento temporaneo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-395">It must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="e56b6-396">Per informazioni sulle dimensioni di un segmento temporaneo, vedere la sezione "Generazioni e segmenti temporanei" nell'articolo [Principi fondamentali di Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-396">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-397">Prova a impedire l'operazione di Garbage Collection durante l'esecuzione di un percorso critico se è disponibile una quantità specificata di memoria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-397">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-398">
            <see langword="true" /> se il runtime è riuscito a eseguire il commit della quantità di memoria richiesta e il Garbage Collector può accedere alla modalità di eliminazione della latenza delle aree di Garbage Collection; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-398">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-399">Il <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> metodo tenta di inserire il garbage collector in alcuna modalità latenza dell'area GC, che non consente operazioni di garbage collection mentre è in esecuzione un'app per un'area critica del codice.</span><span class="sxs-lookup"><span data-stu-id="e56b6-399">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="e56b6-400">Se il runtime non riesce ad allocare inizialmente la quantità di memoria richiesta, il garbage collector esegue una garbage collection bloccante completo nel tentativo di liberare memoria aggiuntiva.</span><span class="sxs-lookup"><span data-stu-id="e56b6-400">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="e56b6-401">Il garbage collector non immette alcuna modalità di latenza delle aree GC se è in grado di allocare la quantità di memoria, che in questo caso è effettivamente 2 \* `totalSize` byte (tenta di allocare `totalSize` byte per l'heap oggetti piccoli e `totalSize` byte per l'heap oggetti grandi).</span><span class="sxs-lookup"><span data-stu-id="e56b6-401">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).</span></span>  
  
 <span data-ttu-id="e56b6-402">`totalSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico.</span><span class="sxs-lookup"><span data-stu-id="e56b6-402">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="e56b6-403">Ciò include le allocazioni dall'app, nonché le allocazioni che il runtime effettua per conto dell'app.</span><span class="sxs-lookup"><span data-stu-id="e56b6-403">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e56b6-404">Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si deve solo chiamare il <xref:System.GC.EndNoGCRegion%2A> metodo, se il runtime è attualmente in alcuna modalità di latenza delle aree GC.</span><span class="sxs-lookup"><span data-stu-id="e56b6-404">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e56b6-405">In altre parole, non chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata al metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo semplicemente perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-405">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="e56b6-406">La latenza modalità delle aree GC si uscire chiamando il <xref:System.GC.EndNoGCRegion%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-406">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-407">
            <paramref name="totalSize" /> supera le dimensioni del segmento temporaneo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-407">
              <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="e56b6-408">Il processo è già in modalità di eliminazione della latenza delle aree di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-408">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="http://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="e56b6-409">Principi fondamentali di Garbage Collection</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-409">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="e56b6-410">Modalità di latenza</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-410">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="e56b6-411">Quantità di memoria in byte da allocare senza attivare un'operazione di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-411">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="e56b6-412">Deve essere minore o uguale alle dimensioni di un segmento temporaneo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-412">It must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="e56b6-413">Per informazioni sulle dimensioni di un segmento temporaneo, vedere la sezione "Generazioni e segmenti temporanei" nell'articolo [Principi fondamentali di Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-413">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="disallowFullBlockingGC">
          <span data-ttu-id="e56b6-414">
            <see langword="true" /> per omettere un'operazione completa di Garbage Collection bloccante se il Garbage Collector non è inizialmente in grado di allocare i byte del parametro <c>totalSize</c>; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-414">
              <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <c>totalSize</c> bytes; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-415">Prova a impedire l'operazione di Garbage Collection durante l'esecuzione di un percorso critico se è disponibile una quantità specificata di memoria; controlla inoltre se il Garbage Collector esegue un'operazione completa di Garbage Collection bloccante se inizialmente non è disponibile memoria sufficiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-415">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-416">
            <see langword="true" /> se il runtime è riuscito a eseguire il commit della quantità di memoria richiesta e il Garbage Collector può accedere alla modalità di eliminazione della latenza delle aree di Garbage Collection; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-416">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-417">Il <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> metodo tenta di inserire il garbage collector in alcuna modalità latenza dell'area GC, che non consente operazioni di garbage collection mentre è in esecuzione un'app per un'area critica del codice.</span><span class="sxs-lookup"><span data-stu-id="e56b6-417">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="e56b6-418">Se il runtime non riesce ad allocare inizialmente la quantità di memoria richiesta e il `disallowFullBlockingGC` argomento è `false`, il garbage collector esegue una garbage collection bloccante completo nel tentativo di liberare memoria aggiuntiva; in caso contrario, l'allocazione ha esito negativo e il metodo restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="e56b6-418">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="e56b6-419">Il garbage collector non immette alcuna modalità di latenza delle aree GC se è in grado di allocare la quantità di memoria, che in questo caso è effettivamente 2 \* `totalSize` (tenta di allocare `totalSize` per l'heap oggetti piccoli e `totalSize` per l'oggetto di grandi dimensioni heap).</span><span class="sxs-lookup"><span data-stu-id="e56b6-419">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).</span></span>  
  
 <span data-ttu-id="e56b6-420">`totalSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico.</span><span class="sxs-lookup"><span data-stu-id="e56b6-420">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="e56b6-421">Ciò include le allocazioni dall'app, nonché le allocazioni che il runtime effettua per conto dell'app.</span><span class="sxs-lookup"><span data-stu-id="e56b6-421">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="e56b6-422">L'impostazione `disallowFullBlockingGC` a `true` per impedire una Garbage Collection bloccante completo insieme, se è inizialmente disponibile insufficiente memoria risulta particolarmente utile in scenari di bilanciamento del carico: un sistema può chiamare questo metodo e segnalare se stesso come pronto per accettare le richieste se il valore restituito `true`, e hanno il servizio di bilanciamento del carico di reindirizzare le richieste ad altri sistemi, se il valore restituito `false`.</span><span class="sxs-lookup"><span data-stu-id="e56b6-422">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="e56b6-423">Quindi possibile effettuare una completa di garbage collection bloccante se non gestisce le richieste chiamando il <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-423">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e56b6-424">Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si deve solo chiamare il <xref:System.GC.EndNoGCRegion%2A> metodo, se il runtime è attualmente in alcuna modalità di latenza delle aree GC.</span><span class="sxs-lookup"><span data-stu-id="e56b6-424">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e56b6-425">In altre parole, non chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata al metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo semplicemente perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-425">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="e56b6-426">La latenza modalità delle aree GC si uscire chiamando il <xref:System.GC.EndNoGCRegion%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-426">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-427">
            <paramref name="totalSize" /> supera le dimensioni del segmento temporaneo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-427">
              <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="e56b6-428">Il processo è già in modalità di eliminazione della latenza delle aree di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-428">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="http://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="e56b6-429">Principi fondamentali di Garbage Collection</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-429">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="e56b6-430">Modalità di latenza</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-430">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="e56b6-431">Quantità di memoria in byte da allocare senza attivare un'operazione di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-431">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="e56b6-432">
            <c>totalSize</c> -<c>lohSize</c> deve essere minore o uguale alle dimensioni di un segmento temporaneo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-432">
              <c>totalSize</c> –<c>lohSize</c> must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="e56b6-433">Per informazioni sulle dimensioni di un segmento temporaneo, vedere la sezione "Generazioni e segmenti temporanei" nell'articolo [Principi fondamentali di Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-433">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="lohSize">
          <span data-ttu-id="e56b6-434">Numero di byte in <c>totalSize</c> da usare per allocazioni di heap di oggetti grandi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-434">The number of bytes in <c>totalSize</c> to use for large object heap (LOH) allocations.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-435">Prova a impedire l'operazione di Garbage Collection durante l'esecuzione di un percorso critico se è disponibile una quantità specificata di memoria per gli heap degli oggetti grandi e degli oggetti piccoli.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-435">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-436">
            <see langword="true" /> se il runtime è riuscito a eseguire il commit della quantità di memoria richiesta e il Garbage Collector può accedere alla modalità di eliminazione della latenza delle aree di Garbage Collection; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-436">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-437">Il <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> metodo tenta di inserire il garbage collector in alcuna modalità latenza dell'area GC, che non consente operazioni di garbage collection mentre è in esecuzione un'app per un'area critica del codice.</span><span class="sxs-lookup"><span data-stu-id="e56b6-437">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="e56b6-438">Se il runtime non riesce ad allocare inizialmente la quantità di memoria richiesta, il garbage collector esegue una garbage collection bloccante completo nel tentativo di liberare memoria aggiuntiva.</span><span class="sxs-lookup"><span data-stu-id="e56b6-438">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="e56b6-439">Il garbage collector non immette alcuna modalità di latenza delle aree GC se è in grado di allocare `lohSize` per l'heap oggetti grandi e `totalSize` – `lohSize` per l'heap oggetti piccoli (SOH).</span><span class="sxs-lookup"><span data-stu-id="e56b6-439">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="e56b6-440">`lohSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico per l'heap oggetti grandi, e `totalSize` – `lohSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico per il rapporto di integrità.</span><span class="sxs-lookup"><span data-stu-id="e56b6-440">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="e56b6-441">Ciò include le allocazioni dall'app, nonché le allocazioni che il runtime effettua per conto dell'app.</span><span class="sxs-lookup"><span data-stu-id="e56b6-441">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e56b6-442">Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si deve solo chiamare il <xref:System.GC.EndNoGCRegion%2A> metodo, se il runtime è attualmente in alcuna modalità di latenza delle aree GC.</span><span class="sxs-lookup"><span data-stu-id="e56b6-442">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e56b6-443">In altre parole, non chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata al metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo semplicemente perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-443">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="e56b6-444">La latenza modalità delle aree GC si uscire chiamando il <xref:System.GC.EndNoGCRegion%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-444">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-445">
            <paramref name="totalSize" /> - <paramref name="lohSize" /> supera le dimensioni del segmento temporaneo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-445">
              <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="e56b6-446">Il processo è già in modalità di eliminazione della latenza delle aree di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-446">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="http://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="e56b6-447">Principi fondamentali di Garbage Collection</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-447">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="e56b6-448">Modalità di latenza</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-448">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="e56b6-449">Quantità di memoria in byte da allocare senza attivare un'operazione di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-449">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="e56b6-450">
            <c>totalSize</c> -<c>lohSize</c> deve essere minore o uguale alle dimensioni di un segmento temporaneo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-450">
              <c>totalSize</c> –<c>lohSize</c> must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="e56b6-451">Per informazioni sulle dimensioni di un segmento temporaneo, vedere la sezione "Generazioni e segmenti temporanei" nell'articolo [Principi fondamentali di Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-451">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="lohSize">
          <span data-ttu-id="e56b6-452">Numero di byte in <c>totalSize</c> da usare per allocazioni di heap di oggetti grandi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-452">The number of bytes in <c>totalSize</c> to use for large object heap (LOH) allocations.</span>
          </span>
        </param>
        <param name="disallowFullBlockingGC">
          <span data-ttu-id="e56b6-453">
            <see langword="true" /> per omettere un'operazione completa di Garbage Collection bloccante se il Garbage Collector non è inizialmente in grado di allocare la memoria specificata nell'heap degli oggetti piccoli (SOH) e degli oggetti grandi (LOH); in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-453">
              <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-454">Prova a impedire l'operazione di Garbage Collection durante l'esecuzione di un percorso critico se è disponibile una quantità specificata di memoria per gli heap degli oggetti grandi e degli oggetti piccoli; controlla inoltre se il Garbage Collector esegue un'operazione completa di Garbage Collection bloccante se inizialmente non è disponibile memoria sufficiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-454">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-455">
            <see langword="true" /> se il runtime è riuscito a eseguire il commit della quantità di memoria richiesta e il Garbage Collector può accedere alla modalità di eliminazione della latenza delle aree di Garbage Collection; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-455">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-456">Il <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> metodo tenta di inserire il garbage collector in alcuna modalità latenza dell'area GC, che non consente operazioni di garbage collection mentre è in esecuzione un'app per un'area critica del codice.</span><span class="sxs-lookup"><span data-stu-id="e56b6-456">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="e56b6-457">Se il runtime non riesce ad allocare inizialmente la quantità di memoria richiesta e il `disallowFullBlockingGC` argomento è `false`, il garbage collector esegue una garbage collection bloccante completo nel tentativo di liberare memoria aggiuntiva; in caso contrario, l'allocazione ha esito negativo e il metodo restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="e56b6-457">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="e56b6-458">Il garbage collector non immette alcuna modalità di latenza delle aree GC se è in grado di allocare `lohSize` per l'heap oggetti grandi e `totalSize` – `lohSize` per l'heap oggetti piccoli (SOH).</span><span class="sxs-lookup"><span data-stu-id="e56b6-458">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="e56b6-459">`lohSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico per l'heap oggetti grandi, e `totalSize` – `lohSize` deve essere sufficiente per gestire tutte le allocazioni di memoria che si verificano in un percorso critico per il rapporto di integrità.</span><span class="sxs-lookup"><span data-stu-id="e56b6-459">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="e56b6-460">Ciò include le allocazioni dall'app, nonché le allocazioni che il runtime effettua per conto dell'app.</span><span class="sxs-lookup"><span data-stu-id="e56b6-460">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="e56b6-461">L'impostazione `disallowFullBlockingGC` a `true` per impedire una Garbage Collection bloccante completo insieme, se è inizialmente disponibile insufficiente memoria risulta particolarmente utile in scenari di bilanciamento del carico: un sistema può chiamare questo metodo e segnalare se stesso come pronto per accettare le richieste se il valore restituito `true`, e hanno il servizio di bilanciamento del carico di reindirizzare le richieste ad altri sistemi, se il valore restituito `false`.</span><span class="sxs-lookup"><span data-stu-id="e56b6-461">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="e56b6-462">Quindi possibile effettuare una completa di garbage collection bloccante se non gestisce le richieste chiamando il <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-462">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e56b6-463">Non è possibile annidare le chiamate al <xref:System.GC.TryStartNoGCRegion%2A> metodo e si deve solo chiamare il <xref:System.GC.EndNoGCRegion%2A> metodo, se il runtime è attualmente in alcuna modalità di latenza delle aree GC.</span><span class="sxs-lookup"><span data-stu-id="e56b6-463">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="e56b6-464">In altre parole, non chiamare <xref:System.GC.TryStartNoGCRegion%2A> più volte (dopo la prima chiamata al metodo, le chiamate successive non avrà esito positivo), e non è necessario attendere le chiamate a <xref:System.GC.EndNoGCRegion%2A> abbia esito positivo semplicemente perché la prima chiamata a <xref:System.GC.TryStartNoGCRegion%2A> ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-464">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="e56b6-465">La latenza modalità delle aree GC si uscire chiamando il <xref:System.GC.EndNoGCRegion%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-465">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-466">
            <paramref name="totalSize" /> - <paramref name="lohSize" /> supera le dimensioni del segmento temporaneo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-466">
              <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="e56b6-467">Il processo è già in modalità di eliminazione della latenza delle aree di Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-467">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="http://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="e56b6-468">Principi fondamentali di Garbage Collection</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-468">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="e56b6-469">Modalità di latenza</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-469">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-470">Restituisce lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante tramite Common Language Runtime sia imminente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-470">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-471">Restituisce lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante tramite Common Language Runtime sia imminente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-471">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-472">Stato della notifica dell'operazione di Garbage Collection registrata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-472">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-473">Usare la <xref:System.GCNotificationStatus> enumerazione restituita da questo metodo per determinare lo stato della notifica raccolta garbage corrente che è stato registrato usando il <xref:System.GC.RegisterForFullGCNotification%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-473">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="e56b6-474">È anche possibile usare il <xref:System.GC.WaitForFullGCComplete%2A> metodo per determinare se la garbage collection completa è stata completata.</span><span class="sxs-lookup"><span data-stu-id="e56b6-474">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="e56b6-475">Quando viene restituito l'enumerazione <xref:System.GCNotificationStatus.Succeeded>, è possibile eseguire attività quali oggetti aggiuntivi impediscono viene allocata e provocare una raccolta con il <xref:System.GC.Collect%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-475">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="e56b6-476">Si noti che la notifica non garantisce che una garbage collection completa verificherà, solo che le condizioni hanno raggiunto la soglia che sono favorevole per una garbage collection completa a verificarsi.</span><span class="sxs-lookup"><span data-stu-id="e56b6-476">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="e56b6-477">Questo metodo attende all'infinito per una notifica di garbage collection devono essere ottenuti.</span><span class="sxs-lookup"><span data-stu-id="e56b6-477">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="e56b6-478">Se si desidera specificare un periodo di timeout per il metodo da restituire se non è possibile ottenere la notifica, utilizzare il <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-478">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="e56b6-479">Se si chiama questo metodo senza specificare un periodo di timeout, è possibile chiamare il <xref:System.GC.CancelFullGCNotification%2A> metodo se si è in attesa più a lungo del preferito.</span><span class="sxs-lookup"><span data-stu-id="e56b6-479">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="e56b6-480">È consigliabile seguire questo metodo con una chiamata al <xref:System.GC.WaitForFullGCComplete%2A> metodo per assicurarsi che si sia verificata una garbage collection completa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-480">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="e56b6-481">Chiamare questo metodo solo comporta risultati indeterminati.</span><span class="sxs-lookup"><span data-stu-id="e56b6-481">Calling this method alone causes indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-482">Nell'esempio riportato di seguito viene illustrato come utilizzare questo metodo per determinare se è imminente una procedura completa di Garbage Collection bloccante.</span><span class="sxs-lookup"><span data-stu-id="e56b6-482">The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</span></span> <span data-ttu-id="e56b6-483">Ogni volta che lo stato della notifica viene <xref:System.GCNotificationStatus.Succeeded>, il metodo utente `OnFullGCApproachNotify` viene chiamato per eseguire azioni in risposta alla raccolta di poco inferiori.</span><span class="sxs-lookup"><span data-stu-id="e56b6-483">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection.</span></span> <span data-ttu-id="e56b6-484">Questo esempio di codice è parte di un esempio più esaustivo disponibile per [notifiche di Garbage Collection](~/docs/standard/garbage-collection/notifications.md) argomento.</span><span class="sxs-lookup"><span data-stu-id="e56b6-484">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e56b6-485">per un'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-485">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-486">Impossibile usare questo membro in codice parzialmente attendibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-486">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e56b6-487">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-487">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-488">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-488">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="e56b6-489">Notifiche di Garbage Collection</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-489">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="e56b6-490">Tempo di attesa prima di poter ottenere lo stato di una notifica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-490">The length of time to wait before a notification status can be obtained.</span>
          </span>
          <span data-ttu-id="e56b6-491">Specificare -1 per restare in attesa in modo indefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-491">Specify -1 to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-492">Restituisce, in un periodo di timeout specificato, lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante tramite Common Language Runtime sia imminente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-492">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-493">Stato della notifica dell'operazione di Garbage Collection registrata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-493">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-494">Usare la <xref:System.GCNotificationStatus> enumerazione restituita da questo metodo per determinare lo stato della notifica raccolta garbage corrente che è stato registrato usando il <xref:System.GC.RegisterForFullGCNotification%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-494">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="e56b6-495">È anche possibile usare il <xref:System.GC.WaitForFullGCComplete%2A> metodo per determinare se la garbage collection completa è stata completata.</span><span class="sxs-lookup"><span data-stu-id="e56b6-495">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="e56b6-496">Si noti che questo metodo restituisce immediatamente ogni volta che viene ottenuto un stato di notifica di garbage collection, indipendentemente dal valore specificato da `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="e56b6-496">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="e56b6-497">Se lo stato di notifica un'operazione di garbage collection non viene ottenuto prima `millisecondsTimeout` volte, questo metodo viene restituito <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="e56b6-497">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="e56b6-498">Quando viene restituito l'enumerazione <xref:System.GCNotificationStatus.Succeeded>, è possibile eseguire attività quali oggetti aggiuntivi impediscono viene allocata e provocare una raccolta con il <xref:System.GC.Collect%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-498">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="e56b6-499">Si noti che la notifica non garantisce che una garbage collection completa verificherà, solo che le condizioni hanno raggiunto la soglia che sono favorevole per una garbage collection completa a verificarsi.</span><span class="sxs-lookup"><span data-stu-id="e56b6-499">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="e56b6-500">È possibile chiamare il <xref:System.GC.CancelFullGCNotification%2A> metodo quando non è possibile attendere il termine del periodo di timeout.</span><span class="sxs-lookup"><span data-stu-id="e56b6-500">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="e56b6-501">È consigliabile seguire questo metodo con una chiamata al <xref:System.GC.WaitForFullGCComplete%2A> metodo per assicurarsi che si sia verificata una garbage collection completa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-501">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="e56b6-502">Chiamare questo metodo solo comporta risultati indeterminati.</span><span class="sxs-lookup"><span data-stu-id="e56b6-502">Calling this method alone causes indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e56b6-503">
            <paramref name="millisecondsTimeout" /> deve essere non negativo oppure minore o uguale a <see cref="F:System.Int32.MaxValue" /> o a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-503">
              <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e56b6-504">per un'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-504">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-505">Impossibile usare questo membro in codice parzialmente attendibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-505">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e56b6-506">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-506">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-507">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-507">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="e56b6-508">Notifiche di Garbage Collection</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-508">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-509">Restituisce lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante è stata portata a termine da Common Language Runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-509">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-510">Restituisce lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante è stata portata a termine da Common Language Runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-510">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-511">Stato della notifica dell'operazione di Garbage Collection registrata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-511">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-512">Usare la <xref:System.GCNotificationStatus> enumerazione restituita da questo metodo per determinare lo stato della notifica raccolta garbage corrente che è stato registrato usando il <xref:System.GC.RegisterForFullGCNotification%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-512">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="e56b6-513">È anche possibile usare il <xref:System.GC.WaitForFullGCApproach%2A> metodo per determinare se è imminente una garbage collection completa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-513">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="e56b6-514">Quando viene restituito l'enumerazione <xref:System.GCNotificationStatus.Succeeded>, è possibile eseguire attività quali la ripresa del lavoro e ottenere un conteggio delle raccolte con il <xref:System.GC.CollectionCount%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="e56b6-514">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="e56b6-515">Questo metodo attende all'infinito per una notifica di garbage collection devono essere ottenuti.</span><span class="sxs-lookup"><span data-stu-id="e56b6-515">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="e56b6-516">Se si desidera specificare un periodo di timeout per il metodo da restituire se non è possibile ottenere la notifica, utilizzare il <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="e56b6-516">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="e56b6-517">Se si chiama questo metodo senza specificare un periodo di timeout, è possibile chiamare il <xref:System.GC.CancelFullGCNotification%2A> metodo se si è in attesa più a lungo del preferito.</span><span class="sxs-lookup"><span data-stu-id="e56b6-517">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="e56b6-518">Questa chiamata al metodo deve essere preceduta da una chiamata al <xref:System.GC.WaitForFullGCApproach%2A> metodo per assicurarsi che si sia verificata una garbage collection completa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-518">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="e56b6-519">Chiamare questo metodo solo può produrre risultati imprevisti.</span><span class="sxs-lookup"><span data-stu-id="e56b6-519">Calling this method alone can produce indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-520">Nell'esempio seguente viene illustrato come utilizzare questo metodo per determinare se garbage collection completa è stata completata.</span><span class="sxs-lookup"><span data-stu-id="e56b6-520">The following example shows how to use this method to determine whether a full garbage collection has completed.</span></span> <span data-ttu-id="e56b6-521">Ogni volta che lo stato della notifica viene <xref:System.GCNotificationStatus.Succeeded>, il metodo utente `OnFullGCCompletedNotify` viene chiamato per eseguire azioni in risposta alla raccolta completata.</span><span class="sxs-lookup"><span data-stu-id="e56b6-521">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection.</span></span> <span data-ttu-id="e56b6-522">Questo esempio di codice è parte di un esempio più esaustivo disponibile per [notifiche di Garbage Collection](~/docs/standard/garbage-collection/notifications.md) argomento.</span><span class="sxs-lookup"><span data-stu-id="e56b6-522">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e56b6-523">per un'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-523">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-524">Impossibile usare questo membro in codice parzialmente attendibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-524">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e56b6-525">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-525">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-526">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-526">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="e56b6-527">Notifiche di Garbage Collection</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-527">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="e56b6-528">Tempo di attesa prima di poter ottenere lo stato di una notifica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-528">The length of time to wait before a notification status can be obtained.</span>
          </span>
          <span data-ttu-id="e56b6-529">Specificare -1 per restare in attesa in modo indefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-529">Specify -1 to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e56b6-530">Restituisce, in un periodo di timeout specificato, lo stato di una notifica registrata per determinare se una procedura completa di Garbage Collection bloccante tramite Common Language Runtime sia stata completata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-530">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e56b6-531">Stato della notifica dell'operazione di Garbage Collection registrata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-531">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-532">Usare la <xref:System.GCNotificationStatus> enumerazione restituita da questo metodo per determinare lo stato della notifica raccolta garbage corrente che è stato registrato usando il <xref:System.GC.RegisterForFullGCNotification%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="e56b6-532">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="e56b6-533">È anche possibile usare il <xref:System.GC.WaitForFullGCApproach%2A> metodo per determinare se è imminente una garbage collection completa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-533">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="e56b6-534">Si noti che questo metodo restituisce immediatamente ogni volta che viene ottenuto un stato di notifica di garbage collection, indipendentemente dal valore specificato da `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="e56b6-534">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="e56b6-535">Se lo stato di notifica un'operazione di garbage collection non viene ottenuto prima `millisecondsTimeout` volte, questo metodo viene restituito <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="e56b6-535">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="e56b6-536">Quando viene restituito l'enumerazione <xref:System.GCNotificationStatus.Succeeded>, è possibile eseguire attività quali la ripresa del lavoro e ottenere un conteggio delle raccolte con il <xref:System.GC.CollectionCount%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="e56b6-536">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="e56b6-537">È possibile chiamare il <xref:System.GC.CancelFullGCNotification%2A> metodo quando non è possibile attendere il termine del periodo di timeout.</span><span class="sxs-lookup"><span data-stu-id="e56b6-537">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="e56b6-538">Questa chiamata al metodo deve essere preceduta da una chiamata al <xref:System.GC.WaitForFullGCApproach%2A> metodo per assicurarsi che si sia verificata una garbage collection completa.</span><span class="sxs-lookup"><span data-stu-id="e56b6-538">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="e56b6-539">Chiamare questo metodo solo può produrre risultati imprevisti.</span><span class="sxs-lookup"><span data-stu-id="e56b6-539">Calling this method alone can produce indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="e56b6-540">
            <paramref name="millisecondsTimeout" /> deve essere non negativo oppure minore o uguale a <see cref="F:System.Int32.MaxValue" /> o a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-540">
              <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e56b6-541">per un'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-541">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-542">Impossibile usare questo membro in codice parzialmente attendibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-542">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e56b6-543">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-543">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e56b6-544">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-544">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="http://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="e56b6-545">Notifiche di Garbage Collection</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-545">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e56b6-546">Sospende il thread corrente fino a quando la coda di finalizzatori non sarà stata svuotata dal thread che la elabora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e56b6-546">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e56b6-547">Quando il garbage collector rileva che gli oggetti che possono essere recuperati, controlla ogni oggetto per determinare i requisiti di finalizzazione dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="e56b6-547">When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</span></span> <span data-ttu-id="e56b6-548">Se un oggetto implementa un finalizzatore e non ha disabilitato la finalizzazione chiamando <xref:System.GC.SuppressFinalize%2A>, l'oggetto viene inserito in un elenco di oggetti che sono contrassegnati come pronti per la finalizzazione.</span><span class="sxs-lookup"><span data-stu-id="e56b6-548">If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization.</span></span> <span data-ttu-id="e56b6-549">Il garbage collector chiama la <xref:System.Object.Finalize%2A> metodi per gli oggetti in questo elenco e rimuove le voci dall'elenco.</span><span class="sxs-lookup"><span data-stu-id="e56b6-549">The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list.</span></span> <span data-ttu-id="e56b6-550">Questo metodo si blocca finché tutti i finalizzatori è eseguite fino al completamento.</span><span class="sxs-lookup"><span data-stu-id="e56b6-550">This method blocks until all finalizers have run to completion.</span></span>  
  
 <span data-ttu-id="e56b6-551">Il thread su cui vengono eseguiti i finalizzatori non è specificato, in modo che non c'è garanzia che il metodo verrà terminato.</span><span class="sxs-lookup"><span data-stu-id="e56b6-551">The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</span></span> <span data-ttu-id="e56b6-552">Tuttavia, questo thread può essere interrotta da un altro thread durante il <xref:System.GC.WaitForPendingFinalizers%2A> metodo è in corso.</span><span class="sxs-lookup"><span data-stu-id="e56b6-552">However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress.</span></span> <span data-ttu-id="e56b6-553">Ad esempio, è possibile avviare un altro thread che attende un periodo di tempo e quindi interrompa il thread corrente, se il thread è ancora in sospeso.</span><span class="sxs-lookup"><span data-stu-id="e56b6-553">For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e56b6-554">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.GC.WaitForPendingFinalizers%2A> metodo per sospendere il thread corrente fino al completamento di tutti gli oggetti raccolti.</span><span class="sxs-lookup"><span data-stu-id="e56b6-554">The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.</span></span>  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>