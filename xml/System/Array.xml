<Type Name="Array" FullName="System.Array">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="930914b33f5750628300f900292f1f758dfe2bb4" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52613009" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce metodi per creare, manipolare, ordinare ed eseguire ricerche all'interno di matrici, diventando così la classe base per tutte le matrici in Common Language Runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array> classe non è in parte il <xref:System.Collections> gli spazi dei nomi. Tuttavia, questo viene considerato come una raccolta perché si basa sul <xref:System.Collections.IList> interfaccia.  
  
 Il <xref:System.Array> classe è la classe base per le implementazioni del linguaggio che supporta le matrici. Tuttavia, solo il sistema e i compilatori possono derivare in modo esplicito il <xref:System.Array> classe. Gli utenti devono utilizzare i costrutti di matrice specificati dal linguaggio.  
  
 Un elemento è un valore in un <xref:System.Array>. La lunghezza di un <xref:System.Array> è il numero totale di elementi che può contenere. Il limite inferiore di un <xref:System.Array> è l'indice del primo elemento. Un <xref:System.Array> può avere qualsiasi limite inferiore, ma presenta un limite inferiore pari a zero per impostazione predefinita. Può definire un limite inferiore differente durante la creazione di un'istanza del <xref:System.Array> classe usando <xref:System.Array.CreateInstance%2A>. Multidimensionale <xref:System.Array> può avere diversi limiti per ogni dimensione. Una matrice può avere un massimo di 32 dimensioni.  
  
 A differenza delle classi nel <xref:System.Collections> spazi dei nomi, <xref:System.Array> ha una capacità fissa. Per aumentare la capacità, è necessario creare una nuova <xref:System.Array> dell'oggetto con la capacità richiesta, copiare gli elementi dalla vecchia <xref:System.Array> dell'oggetto a quello nuovo ed eliminare la vecchia <xref:System.Array>.  
  
 Per impostazione predefinita, le dimensioni massime di un <xref:System.Array> è 2 gigabyte (GB). In un ambiente a 64 bit, è possibile evitare la limitazione delle dimensioni impostando il `enabled` attributo del [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elemento di configurazione `true` nell'ambiente di runtime. Tuttavia, la matrice continuerà a essere limitata a un totale di 4 miliardi di elementi e per un indice massimo della 0X7FEFFFFF in alcuna dimensione specificata (0X7FFFFFC7 per le matrici di byte e matrici di strutture a byte singolo).  
  
 Matrici unidimensionali implementano il <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> e <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> interfacce generiche. Le implementazioni sono fornite per le matrici in fase di esecuzione e di conseguenza, le interfacce generiche non vengono visualizzati nella sintassi della dichiarazione per il <xref:System.Array> classe. Inoltre, non sono disponibili argomenti di riferimento per i membri di interfaccia che sono accessibili solo tramite il cast di una matrice nel tipo di interfaccia generica (implementazioni di interfacce esplicite). L'aspetto principale da tenere presenti quando si esegue il cast di una matrice a una di queste interfacce è che i membri che aggiungono, inserire o rimuovere elementi generano <xref:System.NotSupportedException>.  
  
 <xref:System.Type> gli oggetti forniscono informazioni sulle dichiarazioni di tipo matrice. <xref:System.Array> gli oggetti con lo stesso tipo di matrice condividono lo stesso <xref:System.Type> oggetto.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> e <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> potrebbe non restituire i risultati previsti <xref:System.Array> poiché se una matrice viene eseguito il cast al tipo <xref:System.Array>, il risultato è un oggetto, non è una matrice. Vale a dire `typeof(System.Array).IsArray` restituisce `false`, e `typeof(System.Array).GetElementType` restituisce `null`.  
  
 Il <xref:System.Array.Copy%2A?displayProperty=nameWithType> metodo copia gli elementi non solo tra le matrici dello stesso tipo, ma anche tra le matrici standard di tipi diversi, gestisce automaticamente del cast dei tipi.  
  
 Alcuni metodi, ad esempio <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, e <xref:System.Array.SetValue%2A>, forniscono overload che accettano numeri interi a 64 bit come parametri per adattare le matrici di grandi dimensioni di capacità. <xref:System.Array.LongLength%2A> e <xref:System.Array.GetLongLength%2A> restituiscono numeri interi a 64 bit che indica la lunghezza della matrice.  
  
 Il <xref:System.Array> non è garantito a essere ordinati.  È necessario ordinare il <xref:System.Array> prima dell'esecuzione di operazioni (ad esempio <xref:System.Array.BinarySearch%2A>) che richiedono il <xref:System.Array> da ordinare.  
  
 Usando un <xref:System.Array> oggetto di puntatori nel codice nativo non è supportata e genererà un <xref:System.NotSupportedException> per diversi metodi.  
  
   
  
## Examples  
 Il codice seguente esempio viene illustrato come <xref:System.Array.Copy%2A?displayProperty=nameWithType> consente di copiare elementi tra una matrice di tipo integer e una matrice di tipo <xref:System.Object>.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 Esempio di codice seguente crea e Inizializza un <xref:System.Array> e visualizza le relative proprietà e i relativi elementi.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) membri di questo tipo sono thread-safe. I membri di istanza non sono garantiti come thread-safe.  
  
Questa implementazione non fornisce un oggetto sincronizzato wrapper (thread-safe) per un <see cref="T:System.Array" />; tuttavia, le classi di .NET Framework in base <see cref="T:System.Array" /> forniscono la propria versione sincronizzata della raccolta mediante il <see cref="P:System.Array.SyncRoot" /> proprietà.  
  
L'enumerazione di una raccolta non è di per sé una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">Matrici (Guida per programmatori C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Matrici in Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Matrice in base zero unidimensionale da includere in un wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> in sola lettura.</param>
        <summary>Restituisce un wrapper di sola lettura per la matrice specificata.</summary>
        <returns>Wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di sola lettura per la matrice specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per evitare che eventuali modifiche nella matrice, espongono la matrice solo tramite il wrapper.  
  
 Una raccolta che è di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Nell'esempio seguente esegue il wrapping di una matrice di sola lettura <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Effettua una ricerca in un oggetto <see cref="T:System.Array" /> unidimensionale ordinato per un valore, usando un algoritmo di ricerca binario.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da cercare.</param>
        <summary>Cerca un elemento specifico in un'intera raccolta unidimensionale ordinata, usando l'interfaccia <see cref="T:System.IComparable" /> implementata da ogni elemento della matrice e dall'oggetto specificato.</summary>
        <returns>Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1. Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non supporta la ricerca di matrici che contengono gli indici negativi. `array` deve essere ordinato prima di chiamare questo metodo.  
  
 Se il <xref:System.Array> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operatore di complemento bit per bit (~ nel linguaggio c#, `Not` in Visual Basic) per l'esito negativo per produrre un indice. Se l'indice è una maggiore del limite superiore della matrice, non sono presenti elementi più grandi `value` nella matrice. In caso contrario, si tratta dell'indice del primo elemento maggiore `value`.  
  
 Sia `value` o tutti gli elementi della `array` deve implementare il <xref:System.IComparable> interfaccia, che viene usato per i confronti. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable> implementazione; in caso contrario, il risultato potrebbe essere errato.  
  
> [!NOTE]
>  Se`value` non implementa il <xref:System.IComparable> gli elementi dell'interfaccia `array` non sono testati per <xref:System.IComparable> prima dell'inizio della ricerca. Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <xref:System.IComparable>.  
  
 Gli elementi duplicati sono consentiti. Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice del solo uno dei casi e non necessariamente quella del primo.  
  
 `null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.  
  
> [!NOTE]
>  Per ogni elemento, verificato `value` viene passato nell'oggetto appropriato <xref:System.IComparable> implementazione, anche se `value` è `null`. Vale a dire il <xref:System.IComparable> implementazione determina il modo in cui un determinato elemento Confronta a `null`.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare <xref:System.Array.BinarySearch%2A> per individuare un oggetto specifico in un <xref:System.Array>.  
  
> [!NOTE]
>  La matrice viene creata con i relativi elementi in ordine crescente. Il <xref:System.Array.BinarySearch%2A> metodo richiede la matrice sia ordinata in ordine crescente.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> non implementa l'interfaccia <see cref="T:System.IComparable" /> e la ricerca rileva un elemento che non implementa l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da cercare.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.IComparer" /> da usare quando si confrontano gli elementi.  
  
oppure 
 <see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</param>
        <summary>Usando l'interfaccia <see cref="T:System.Collections.IComparer" /> specificata, effettua la ricerca di un valore all'interno di una matrice unidimensionale e ordinata.</summary>
        <returns>Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1. Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non supporta la ricerca di matrici che contengono gli indici negativi. `array` deve essere ordinato prima di chiamare questo metodo.  
  
 Se il <xref:System.Array> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operatore di complemento bit per bit (~ nel linguaggio c#, `Not` in Visual Basic) per l'esito negativo per produrre un indice. Se l'indice è una maggiore del limite superiore della matrice, non sono presenti elementi più grandi `value` nella matrice. In caso contrario, si tratta dell'indice del primo elemento maggiore `value`.  
  
 L'operatore di confronto consente di personalizzare la modalità di confronto di elementi. Ad esempio, è possibile usare un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> come operatore di confronto da eseguire ricerche di stringhe tra maiuscole e minuscole.  
  
 Se `comparer` non è `null`, gli elementi del `array` vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.IComparer> implementazione. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito da `comparer`; in caso contrario, il risultato potrebbe non essere corretto.  
  
 Se`comparer` viene `null`, il confronto viene eseguito utilizzando il <xref:System.IComparable> implementazione fornita dall'elemento stesso o dal valore specificato. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable> implementazione; in caso contrario, il risultato potrebbe essere errato.  
  
> [!NOTE]
>  Se `comparer` viene `null` e `value` non implementa il <xref:System.IComparable> interfaccia, gli elementi di `array` non viene verificata la <xref:System.IComparable> prima dell'inizio della ricerca. Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <xref:System.IComparable>.  
  
 Gli elementi duplicati sono consentiti. Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice del solo uno dei casi e non necessariamente quella del primo.  
  
 `null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.  
  
> [!NOTE]
>  Per ogni elemento, verificato `value` viene passato nell'oggetto appropriato <xref:System.IComparable> implementazione, anche se `value` è `null`. Vale a dire il <xref:System.IComparable> implementazione determina il modo in cui un determinato elemento Confronta a `null`.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> è <see langword="null" /> e <paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" />, <paramref name="value" /> non implementa l'interfaccia <see cref="T:System.IComparable" /> e la ricerca rileva un elemento che non implementa l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in cui eseguire la ricerca.</param>
        <param name="index">Indice iniziale dell'intervallo in cui eseguire la ricerca.</param>
        <param name="length">Lunghezza dell'intervallo in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da cercare.</param>
        <summary>Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata, usando l'interfaccia <see cref="T:System.IComparable" /> implementata da ogni elemento della matrice e dal valore specificato.</summary>
        <returns>Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1. Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non supporta la ricerca di matrici che contengono gli indici negativi. `array` deve essere ordinato prima di chiamare questo metodo.  
  
 Se il <xref:System.Array> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operatore di complemento bit per bit (~ nel linguaggio c#, `Not` in Visual Basic) per l'esito negativo per produrre un indice. Se l'indice è una maggiore del limite superiore della matrice, non sono presenti elementi più grandi `value` nella matrice. In caso contrario, si tratta dell'indice del primo elemento maggiore `value`.  
  
 Sia `value` o tutti gli elementi della `array` deve implementare il <xref:System.IComparable> interfaccia, che viene usato per i confronti. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable> implementazione; in caso contrario, il risultato potrebbe essere errato.  
  
> [!NOTE]
>  Se `value` non implementa il <xref:System.IComparable> gli elementi dell'interfaccia `array` non sono testati per <xref:System.IComparable> prima dell'inizio della ricerca. Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <xref:System.IComparable>.  
  
 Gli elementi duplicati sono consentiti. Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice del solo uno dei casi e non necessariamente quella del primo.  
  
 `null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.  
  
> [!NOTE]
>  Per ogni elemento, verificato `value` viene passato nell'oggetto appropriato <xref:System.IComparable> implementazione, anche se `value` è `null`. Vale a dire il <xref:System.IComparable> implementazione determina il modo in cui un determinato elemento Confronta a `null`.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.  
  
oppure 
 <paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> non implementa l'interfaccia <see cref="T:System.IComparable" /> e la ricerca rileva un elemento che non implementa l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in cui eseguire la ricerca.</param>
        <param name="index">Indice iniziale dell'intervallo in cui eseguire la ricerca.</param>
        <param name="length">Lunghezza dell'intervallo in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da cercare.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.IComparer" /> da usare quando si confrontano gli elementi.  
  
oppure 
 <see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</param>
        <summary>Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata mediante l'interfaccia <see cref="T:System.Collections.IComparer" /> specificata.</summary>
        <returns>Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1. Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non supporta la ricerca di matrici che contengono gli indici negativi. `array` deve essere ordinato prima di chiamare questo metodo.  
  
 Se il <xref:System.Array> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operatore di complemento bit per bit (~ nel linguaggio c#, `Not` in Visual Basic) per l'esito negativo per produrre un indice. Se l'indice è una maggiore del limite superiore della matrice, non sono presenti elementi più grandi `value` nella matrice. In caso contrario, si tratta dell'indice del primo elemento maggiore `value`.  
  
 L'operatore di confronto consente di personalizzare la modalità di confronto di elementi. Ad esempio, è possibile usare un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> come operatore di confronto da eseguire ricerche di stringhe tra maiuscole e minuscole.  
  
 Se `comparer` non è `null`, gli elementi del `array` vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.IComparer> implementazione. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito da `comparer`; in caso contrario, il risultato potrebbe non essere corretto.  
  
 Se `comparer` viene `null`, il confronto viene eseguito utilizzando il <xref:System.IComparable> implementazione fornita dall'elemento stesso o dal valore specificato. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable> implementazione; in caso contrario, il risultato potrebbe essere errato.  
  
> [!NOTE]
>  Se `comparer` viene `null` e `value` non implementa il <xref:System.IComparable> interfaccia, gli elementi di `array` non viene verificata la <xref:System.IComparable> prima dell'inizio della ricerca. Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <xref:System.IComparable>.  
  
 Gli elementi duplicati sono consentiti. Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice del solo uno dei casi e non necessariamente quella del primo.  
  
 `null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione quando si usa <xref:System.IComparable>.  
  
> [!NOTE]
>  Per ogni elemento, verificato `value` viene passato nell'oggetto appropriato <xref:System.IComparable> implementazione, anche se `value` è `null`. Vale a dire il <xref:System.IComparable> implementazione determina il modo in cui un determinato elemento Confronta a `null`.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.  
  
oppure 
 <paramref name="comparer" /> è <see langword="null" /> e <paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" />, <paramref name="value" /> non implementa l'interfaccia <see cref="T:System.IComparable" /> e la ricerca rileva un elemento che non implementa l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in base zero da cercare.</param>
        <param name="value">Oggetto da cercare.</param>
        <summary>Effettua una ricerca in un'intera matrice unidimensionale ordinata per un elemento specifico, usando l'interfaccia generica <see cref="T:System.IComparable`1" /> implementata da ogni elemento di <see cref="T:System.Array" /> e dall'oggetto specificato.</summary>
        <returns>Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1. Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non supporta la ricerca di matrici che contengono gli indici negativi. `array` deve essere ordinato prima di chiamare questo metodo.  
  
 Se `array` non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operatore di complemento bit per bit (~ nel linguaggio c#, `Not` in Visual Basic) per l'esito negativo per produrre un indice. Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi più grande `value` nella matrice. In caso contrario, si tratta dell'indice del primo elemento maggiore `value`.  
  
 `T` deve implementare il <xref:System.IComparable%601> generico interfaccia, che viene usato per i confronti. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable%601> implementazione; in caso contrario, il risultato potrebbe essere errato.  
  
 Gli elementi duplicati sono consentiti. Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice del solo uno dei casi e non necessariamente quella del primo.  
  
 `null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.  
  
> [!NOTE]
>  Per ogni elemento, verificato `value` viene passato nell'oggetto appropriato <xref:System.IComparable%601> implementazione, anche se `value` è `null`. Vale a dire il <xref:System.IComparable%601> implementazione determina il modo in cui un determinato elemento Confronta a `null`.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> overload del metodo generico e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo generico. Viene creata una matrice di stringhe, senza alcun ordine specifico.  
  
 La matrice viene visualizzata, ordinata e visualizzata di nuovo. Le matrici devono essere ordinate per poter utilizzare il <xref:System.Array.BinarySearch%2A> (metodo).  
  
> [!NOTE]
>  Le chiamate per il <xref:System.Array.Sort%2A> e <xref:System.Array.BinarySearch%2A> metodi generici non presenta alcuna differenza dalle chiamate alle relative controparti non generiche, poiché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento. Se si usa la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.  
  
 Il <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo generico viene quindi usato per eseguire la ricerca di due stringhe, che non sia nella matrice e uno che è. La matrice e il valore restituito del <xref:System.Array.BinarySearch%2A> metodo vengono passati al `ShowWhere` metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario, gli elementi della stringa di ricerca rientrerebbero tra se fosse nella matrice. L'indice è un valore negativo se la stringa non è presente nella matrice, in modo che il `ShowWhere` metodo accetta il complemento bit per bit (di ~ operatore in c# e Visual C++, `Xor`-1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore della ricerca str operazione.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> non implementa l'interfaccia generica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in base zero da cercare.</param>
        <param name="value">Oggetto da cercare.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare quando si confrontano gli elementi.  
  
oppure 
 <see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable`1" /> di ciascun elemento.</param>
        <summary>Mediante l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata, esegue la ricerca di un valore all'interno di una matrice unidimensionale e ordinata.</summary>
        <returns>Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1. Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non supporta la ricerca di matrici che contengono gli indici negativi. `array` deve essere ordinato prima di chiamare questo metodo.  
  
 Se il <xref:System.Array> non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operatore di complemento bit per bit (~ nel linguaggio c#, `Not` in Visual Basic) per l'esito negativo per produrre un indice. Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi più grande `value` nella matrice. In caso contrario, si tratta dell'indice del primo elemento maggiore `value`.  
  
 L'operatore di confronto consente di personalizzare la modalità di confronto di elementi. Ad esempio, è possibile usare un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> come operatore di confronto da eseguire ricerche di stringhe tra maiuscole e minuscole.  
  
 Se `comparer` non è `null`, gli elementi del `array` vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.Generic.IComparer%601> implementazione dell'interfaccia generica. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito da `comparer`; in caso contrario, il risultato potrebbe non essere corretto.  
  
 Se `comparer` viene `null`, il confronto viene eseguito utilizzando il <xref:System.IComparable%601> fornito dall'implementazione dell'interfaccia generica `T`. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable%601> implementazione; in caso contrario, il risultato potrebbe essere errato.  
  
> [!NOTE]
>  Se `comparer` viene `null` e `value` non implementa il <xref:System.IComparable%601> generico interfaccia, gli elementi di `array` non viene verificata la <xref:System.IComparable%601> prima dell'inizio della ricerca. Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <xref:System.IComparable%601>.  
  
 Gli elementi duplicati sono consentiti. Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice del solo uno dei casi e non necessariamente quella del primo.  
  
 `null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.  
  
> [!NOTE]
>  Per ogni elemento, verificato `value` viene passato nell'oggetto appropriato <xref:System.IComparable%601> implementazione, anche se `value` è `null`. Vale a dire il <xref:System.IComparable%601> implementazione determina il modo in cui un determinato elemento Confronta a `null`.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico.  
  
 L'esempio di codice definisce un operatore alternativo per le stringhe, denominato `ReverseCompare`, che implementa le `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. La chiama comparer il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini in modo che le stringhe ordinate elevata verso il basso, anziché basso verso l'alto.  
  
 La matrice viene visualizzata, ordinata e visualizzata di nuovo. Le matrici devono essere ordinate per poter utilizzare il <xref:System.Array.BinarySearch%2A> (metodo).  
  
> [!NOTE]
>  Le chiamate per il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodi generici non presenta alcuna differenza dalle chiamate alle relative controparti non generiche, poiché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento. Se si usa la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.  
  
 Il <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico viene quindi usato per eseguire la ricerca di due stringhe, che non sia nella matrice e uno che è. La matrice e il valore restituito del <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodo vengono passati al `ShowWhere` metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario, gli elementi della stringa di ricerca rientrerebbero tra se fosse nella matrice. L'indice è un valore negativo se la stringa non è inclusa nella matrice, in modo che il `ShowWhere` metodo accetta il complemento bit per bit (di ~ operatore in c# e Visual C++, `Xor` -1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore di stri ricerca NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> è <see langword="null" /> e <paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e <paramref name="T" /> non implementa l'interfaccia generica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="index">Indice iniziale dell'intervallo in cui eseguire la ricerca.</param>
        <param name="length">Lunghezza dell'intervallo in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da cercare.</param>
        <summary>Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata, usando l'interfaccia generica <see cref="T:System.IComparable`1" /> implementata da ogni elemento dell'oggetto <see cref="T:System.Array" /> e dal valore specificato.</summary>
        <returns>Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1. Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non supporta la ricerca di matrici che contengono gli indici negativi. `array` deve essere ordinato prima di chiamare questo metodo.  
  
 Se la matrice non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operatore di complemento bit per bit (~ nel linguaggio c#, `Not` in Visual Basic) per l'esito negativo per produrre un indice. Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi più grande `value` nella matrice. In caso contrario, si tratta dell'indice del primo elemento maggiore `value`.  
  
 `T` deve implementare il <xref:System.IComparable%601> generico interfaccia, che viene usato per i confronti. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable%601> implementazione; in caso contrario, il risultato potrebbe essere errato.  
  
 Gli elementi duplicati sono consentiti. Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice del solo uno dei casi e non necessariamente quella del primo.  
  
 `null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.  
  
> [!NOTE]
>  Per ogni elemento, verificato `value` viene passato nell'oggetto appropriato <xref:System.IComparable%601> implementazione, anche se `value` è `null`. Vale a dire il <xref:System.IComparable%601> implementazione determina il modo in cui un determinato elemento Confronta a `null`.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.  
  
oppure 
 <paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> non implementa l'interfaccia generica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="index">Indice iniziale dell'intervallo in cui eseguire la ricerca.</param>
        <param name="length">Lunghezza dell'intervallo in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da cercare.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare quando si confrontano gli elementi.  
  
oppure 
 <see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable`1" /> di ciascun elemento.</param>
        <summary>Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata mediante l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</summary>
        <returns>Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />. Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1. Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non supporta la ricerca di matrici che contengono gli indici negativi. `array` deve essere ordinato prima di chiamare questo metodo.  
  
 Se la matrice non contiene il valore specificato, il metodo restituisce un numero intero negativo. È possibile applicare l'operatore di complemento bit per bit (~ nel linguaggio c#, `Not` in Visual Basic) per l'esito negativo per produrre un indice. Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi più grande `value` nella matrice. In caso contrario, si tratta dell'indice del primo elemento maggiore `value`.  
  
 L'operatore di confronto consente di personalizzare la modalità di confronto di elementi. Ad esempio, è possibile usare un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> come operatore di confronto da eseguire ricerche di stringhe tra maiuscole e minuscole.  
  
 Se `comparer` non è `null`, gli elementi del `array` vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.Generic.IComparer%601> implementazione dell'interfaccia generica. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito da `comparer`; in caso contrario, il risultato potrebbe non essere corretto.  
  
 Se `comparer` viene `null`, il confronto viene eseguito utilizzando il <xref:System.IComparable%601> fornito per il tipo di implementazione dell'interfaccia generica `T`. Gli elementi della `array` devono già essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable%601> implementazione; in caso contrario, il risultato potrebbe essere errato.  
  
 Gli elementi duplicati sono consentiti. Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice del solo uno dei casi e non necessariamente quella del primo.  
  
 `null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione quando si usa <xref:System.IComparable%601>.  
  
> [!NOTE]
>  Per ogni elemento, verificato `value` viene passato nell'oggetto appropriato <xref:System.IComparable%601> implementazione, anche se `value` è `null`. Vale a dire il <xref:System.IComparable%601> implementazione determina il modo in cui un determinato elemento Confronta a `null`.  
  
 Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.  
  
oppure 
 <paramref name="comparer" /> è <see langword="null" /> e <paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e <paramref name="T" /> non implementa l'interfaccia generica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice i cui elementi devono essere cancellati.</param>
        <param name="index">Indice iniziale dell'intervallo di elementi da cancellare.</param>
        <param name="length">Numero di elementi da cancellare.</param>
        <summary>Imposta un intervallo di elementi in una matrice sul valore predefinito di ogni tipo di elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo reimposta ogni elemento in una matrice sul valore predefinito del tipo di elemento. Imposta gli elementi dei tipi di riferimento (incluso <xref:System.String> elementi) per `null`e imposta gli elementi dei tipi di valore per i valori predefiniti illustrati nella tabella seguente.  
  
|Tipo|Valore|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Tutti i tipi numerici integrali e a virgola mobile|0 (zero)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Altri tipi di valore|Valore predefinito di campi del tipo.|  
  
 L'intervallo di elementi cancellati da una riga per riga in una matrice multidimensionale.  
  
 Questo metodo cancella solo i valori degli elementi; non elimina gli elementi stessi. Una matrice ha dimensioni fisse. Pertanto, non è possibile aggiungere o rimuovere elementi.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Array.Clear%2A> per reimpostare i valori interi in una matrice unidimensionale, bidimensionale e tridimensionale.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 L'esempio seguente definisce una `TimeZoneTime` struttura che include un <xref:System.TimeZoneInfo> campo e un <xref:System.DateTimeOffset> campo. Chiama poi il <xref:System.Array.Clear%2A> metodo per eliminare un elemento in una matrice di due elementi di `TimeZoneTime` valori. Il metodo imposta il valore dell'elemento cancellata per il valore predefinito di un <xref:System.TimeZoneInfo> oggetto, ovvero `null`e il valore predefinito di un <xref:System.DateTimeOffset> oggetto, ovvero <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.  
  
oppure 
La somma di <paramref name="index" /> e <paramref name="length" /> è maggiore della dimensione di <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficiale di <see cref="T:System.Array" />.</summary>
        <returns>Copia superficiale di <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia superficiale di un <xref:System.Array> copia solo gli elementi del <xref:System.Array>, se sono tipi riferimento o tipi di valore, ma non copia gli oggetti che fanno riferimento i riferimenti. I riferimenti nel nuovo <xref:System.Array> puntano allo stesso oggetti da cui i riferimenti nell'originale <xref:System.Array> scegliere.  
  
 Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente fa riferimento gli elementi.  
  
 Il clone è dello stesso <xref:System.Type> dell'originale <xref:System.Array>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene cloni un <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> della matrice e viene illustrato il comportamento di una copia superficiale.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Oggetto <see cref="T:System.Array" /> che contiene i dati da copiare.</param>
        <param name="sourceIndex">Intero a 32 bit che rappresenta l'indice in <paramref name="sourceArray" /> da cui viene avviata la copia.</param>
        <param name="destinationArray">Oggetto <see cref="T:System.Array" /> che riceve i dati.</param>
        <param name="destinationIndex">Intero a 32 bit che rappresenta l'indice in <paramref name="destinationArray" /> da cui viene avviata l'archiviazione.</param>
        <param name="length">Intero a 32 bit che rappresenta il numero degli elementi da copiare.</param>
        <summary>Copia un intervallo di elementi da un oggetto <see cref="T:System.Array" /> a partire dall'indice di origine specificato e lo incolla in un altro oggetto <see cref="T:System.Array" /> a partire dall'indice di destinazione specificato.  Garantisce che tutte le modifiche vengano annullate se la copia non riesce completamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `sourceArray` e `destinationArray` parametri devono avere lo stesso numero di dimensioni.  Il `sourceArray` tipo deve essere uguale o derivato dal `destinationArray` tipo; in caso contrario, un <xref:System.ArrayTypeMismatchException> viene generata un'eccezione.  A differenza <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> verifica la compatibilità dei tipi di matrice prima di eseguire qualsiasi operazione.  
  
 Copiare dati tra le matrici multidimensionali, se la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o colonne) sono concettualmente laid end-to-end. Ad esempio, se una matrice con tre righe (o colonne) con quattro elementi, ogni copia sei elementi dall'inizio della matrice copiava tutti i quattro elementi della prima riga (o colonna) e i primi due elementi della seconda riga (o colonna). Per avviare la copia dal secondo elemento della terza riga (o colonna), `sourceIndex` deve essere il limite superiore della prima riga (o colonna) e della lunghezza della seconda riga (o colonna) più due.  
  
 Se `sourceArray` e `destinationArray` si sovrappongono, questo metodo si comporta come se i valori originali delle `sourceArray` siano stati conservati in un percorso temporaneo prima `destinationArray` viene sovrascritto.  
  
 [C++]  
  
 Questo metodo è equivalente alla funzione standard C/C++ `memmove`, non `memcpy`.  
  
 Le matrici possono essere matrici di tipo riferimento o matrici di tipo di valore.  Se `sourceArray` e `destinationArray` sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <xref:System.Object>, viene eseguita una copia superficiale. Una copia superficiale di un <xref:System.Array> è una nuova <xref:System.Array> che contiene riferimenti agli stessi elementi dell'originale <xref:System.Array>. Gli elementi stessi o a qualsiasi elemento a cui fanno riferimento gli elementi non vengono copiati. Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente fa riferimento gli elementi.  
  
 Se questo metodo genera un'eccezione durante la copia, il `destinationArray` rimane invariata; pertanto <xref:System.Array.ConstrainedCopy%2A> possono essere usati in un'area a esecuzione vincolata (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> è <see langword="null" />.  
  
oppure 
 <paramref name="destinationArray" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> hanno classificazioni diverse.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Il tipo <paramref name="sourceArray" /> non è né lo stesso né derivato dal tipo <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di almeno un elemento in <paramref name="sourceArray" /> al tipo di <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> è minore del limite inferiore della prima dimensione di <paramref name="sourceArray" />.  
  
oppure 
 <paramref name="destinationIndex" /> è minore del limite inferiore della prima dimensione di <paramref name="destinationArray" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="sourceIndex" /> e la fine di <paramref name="sourceArray" />.  
  
oppure 
 <paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="destinationIndex" /> e la fine di <paramref name="destinationArray" />.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Tipo degli elementi della matrice di origine.</typeparam>
        <typeparam name="TOutput">Tipo degli elementi della matrice di destinazione.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero da convertire in un tipo di destinazione.</param>
        <param name="converter">Oggetto <see cref="T:System.Converter`2" /> che converte ogni elemento da un tipo a un altro.</param>
        <summary>Converte una matrice di un tipo in una matrice di un altro tipo.</summary>
        <returns>Matrice del tipo di destinazione contenente gli elementi convertiti dalla matrice di origine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Converter%602> è un delegato a un metodo che converte un oggetto nel tipo di destinazione.  Gli elementi della `array` vengono passati singolarmente al <xref:System.Converter%602>, e gli elementi convertiti vengono salvati nella nuova matrice.  
  
 L'origine `array` rimane invariato.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio di codice seguente definisce un metodo denominato `PointFToPoint` che converte un <xref:System.Drawing.PointF> struttura per un <xref:System.Drawing.Point> struttura. L'esempio crea quindi una matrice di <xref:System.Drawing.PointF> strutture, crea un `Converter<PointF, Point>` delegare (`Converter(Of PointF, Point)` in Visual Basic) per rappresentare il `PointFToPoint` metodo e passa il delegato per il <xref:System.Array.ConvertAll%2A> (metodo). Il <xref:System.Array.ConvertAll%2A> metodo passa ogni elemento dell'elenco di input per il `PointFToPoint` metodo e inserisce gli elementi convertiti in un nuovo elenco di <xref:System.Drawing.Point> strutture. Entrambi gli elenchi vengono visualizzati.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="converter" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia un intervallo di elementi di un oggetto <see cref="T:System.Array" /> in un altro oggetto <see cref="T:System.Array" /> ed esegue il cast e il boxing del tipo secondo le necessità.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Oggetto <see cref="T:System.Array" /> che contiene i dati da copiare.</param>
        <param name="destinationArray">Oggetto <see cref="T:System.Array" /> che riceve i dati.</param>
        <param name="length">Intero a 32 bit che rappresenta il numero degli elementi da copiare.</param>
        <summary>Copia un intervallo di elementi da un oggetto <see cref="T:System.Array" /> a partire dal primo elemento e lo incolla in un altro oggetto <see cref="T:System.Array" /> a partire dal primo elemento. La lunghezza viene specificata come intero a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `sourceArray` e `destinationArray` parametri devono avere lo stesso numero di dimensioni. Inoltre, `destinationArray` deve già dimensionata e deve avere un numero sufficiente di elementi da includere tutti i dati copiati.  
  
 Copiare dati tra le matrici multidimensionali, se la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o colonne) sono concettualmente laid to end. Ad esempio, se una matrice con tre righe (o colonne) con quattro elementi, ogni copia sei elementi dall'inizio della matrice copiava tutti i quattro elementi della prima riga (o colonna) e i primi due elementi della seconda riga (o colonna).  
  
 Se `sourceArray` e `destinationArray` si sovrappongono, questo metodo si comporta come se i valori originali delle `sourceArray` siano stati conservati in un percorso temporaneo prima `destinationArray` viene sovrascritto.  
  
 [C++]  
  
 Questo metodo è equivalente alla funzione standard C/C++ `memmove`, non `memcpy`.  
  
 Le matrici possono essere matrici di tipo riferimento o matrici di tipo di valore. Viene eseguito il downcast del tipo, in base alle necessità.  
  
-   Durante la copia da una matrice di tipo riferimento in una matrice di tipo di valore, ogni elemento viene eseguita la conversione unboxing e quindi copiato. Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.  
  
-   Quando si copia da una matrice di tipo riferimento o tipo di valore a un <xref:System.Object> matrice, un <xref:System.Object> viene creato per contenere ogni valore o riferimento e quindi copiati. Durante la copia da un <xref:System.Object> matrice da una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <xref:System.InvalidCastException> viene generata un'eccezione.  
  
-   Se `sourceArray` e `destinationArray` sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <xref:System.Object>, viene eseguita una copia superficiale. Una copia superficiale di un <xref:System.Array> è una nuova <xref:System.Array> che contiene riferimenti agli stessi elementi dell'originale <xref:System.Array>. Gli elementi stessi o a qualsiasi elemento a cui fanno riferimento gli elementi non vengono copiati. Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente fa riferimento gli elementi.  
  
 Un <xref:System.ArrayTypeMismatchException> viene generata un'eccezione se le matrici sono tipi incompatibili. Compatibilità dei tipi viene definita come segue:  
  
-   Un tipo è compatibile con se stesso.  
  
-   Un tipo di valore è compatibile con <xref:System.Object> e con un tipo di interfaccia implementati da tale tipo di valore. Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa tale interfaccia direttamente. I tipi disconnessi non sono compatibili.  
  
-   Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine nel tipo di destinazione è una conversione di ampliamento. Una conversione verso un mai perde le informazioni sulla, mentre una conversione di narrowing può perdere informazioni. Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e conversione di un intero con segno a 64 bit in un intero con segno a 32 bit viene eseguita una conversione narrowing. Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
-   Un tipo non intrinseco (valore definito dall'utente) è compatibile solo con se stesso.  
  
-   Le enumerazioni dispongono di una conversione implicita a <xref:System.Enum> e al tipo sottostante.  
  
 Se ogni elemento in `sourceArray` richiede un downcast (ad esempio, da una classe di base a una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in `destinationArray`, un <xref:System.InvalidCastException> viene generata un'eccezione.  
  
 Se questo metodo genera un'eccezione durante la copia, lo stato di `destinationArray` è definito.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> è <see langword="null" />.  
  
oppure 
 <paramref name="destinationArray" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> hanno classificazioni diverse.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">I tipi di <paramref name="sourceArray" /> e <paramref name="destinationArray" /> sono incompatibili.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di almeno un elemento in <paramref name="sourceArray" /> al tipo di <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> è maggiore del numero di elementi in <paramref name="sourceArray" />.  
  
oppure 
 <paramref name="length" /> è maggiore del numero di elementi in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Oggetto <see cref="T:System.Array" /> che contiene i dati da copiare.</param>
        <param name="destinationArray">Oggetto <see cref="T:System.Array" /> che riceve i dati.</param>
        <param name="length">Intero a 64 bit che rappresenta il numero di elementi da copiare. L'intero deve essere compreso tra zero e <see cref="F:System.Int32.MaxValue" />, inclusi.</param>
        <summary>Copia un intervallo di elementi da un oggetto <see cref="T:System.Array" /> a partire dal primo elemento e lo incolla in un altro oggetto <see cref="T:System.Array" /> a partire dal primo elemento. La lunghezza viene specificata come intero a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `sourceArray` e `destinationArray` parametri devono avere lo stesso numero di dimensioni. Inoltre, `destinationArray` deve già dimensionata e deve avere un numero sufficiente di elementi da includere tutti i dati copiati.  
  
 Copiare dati tra le matrici multidimensionali, se la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o colonne) sono concettualmente laid to end. Ad esempio, se una matrice con tre righe (o colonne) con quattro elementi, ogni copia sei elementi dall'inizio della matrice copiava tutti i quattro elementi della prima riga (o colonna) e i primi due elementi della seconda riga (o colonna).  
  
 Se `sourceArray` e `destinationArray` si sovrappongono, questo metodo si comporta come se i valori originali delle `sourceArray` siano stati conservati in un percorso temporaneo prima `destinationArray` viene sovrascritto.  
  
 [C++]  
  
 Questo metodo è equivalente alla funzione standard C/C++ `memmove`, non `memcpy`.  
  
 Le matrici possono essere matrici di tipo riferimento o matrici di tipo di valore. Viene eseguito il downcast del tipo, in base alle necessità.  
  
-   Durante la copia da una matrice di tipo riferimento in una matrice di tipo di valore, ogni elemento viene eseguita la conversione unboxing e quindi copiato. Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.  
  
-   Quando si copia da una matrice di tipo riferimento o tipo di valore a un <xref:System.Object> matrice, un <xref:System.Object> viene creato per contenere ogni valore o riferimento e quindi copiati. Durante la copia da un <xref:System.Object> matrice da una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <xref:System.InvalidCastException> viene generata un'eccezione.  
  
-   Se `sourceArray` e `destinationArray` sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <xref:System.Object>, viene eseguita una copia superficiale. Una copia superficiale di un <xref:System.Array> è una nuova <xref:System.Array> che contiene riferimenti agli stessi elementi dell'originale <xref:System.Array>. Gli elementi stessi o a qualsiasi elemento a cui fanno riferimento gli elementi non vengono copiati. Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente fa riferimento gli elementi.  
  
 Un <xref:System.ArrayTypeMismatchException> viene generata un'eccezione se le matrici sono tipi incompatibili. Compatibilità dei tipi viene definita come segue:  
  
-   Un tipo è compatibile con se stesso.  
  
-   Un tipo di valore è compatibile con <xref:System.Object> e con un tipo di interfaccia implementati da tale tipo di valore. Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa tale interfaccia direttamente. I tipi disconnessi non sono compatibili.  
  
-   Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine nel tipo di destinazione è una conversione di ampliamento. Una conversione verso un mai perde le informazioni sulla, mentre una conversione di narrowing può perdere informazioni. Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e conversione di un intero con segno a 64 bit in un intero con segno a 32 bit viene eseguita una conversione narrowing. Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
-   Un tipo non intrinseco (valore definito dall'utente) è compatibile solo con se stesso.  
  
-   Le enumerazioni dispongono di una conversione implicita a <xref:System.Enum> e al tipo sottostante.  
  
 Se ogni elemento in `sourceArray` richiede un downcast (ad esempio, da una classe di base a una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in `destinationArray`, un <xref:System.InvalidCastException> viene generata un'eccezione.  
  
 Se questo metodo genera un'eccezione durante la copia, lo stato di `destinationArray` è definito.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> è <see langword="null" />.  
  
oppure 
 <paramref name="destinationArray" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> hanno classificazioni diverse.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">I tipi di <paramref name="sourceArray" /> e <paramref name="destinationArray" /> sono incompatibili.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di almeno un elemento in <paramref name="sourceArray" /> al tipo di <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> è minore di 0 o maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> è maggiore del numero di elementi in <paramref name="sourceArray" />.  
  
oppure 
 <paramref name="length" /> è maggiore del numero di elementi in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Oggetto <see cref="T:System.Array" /> che contiene i dati da copiare.</param>
        <param name="sourceIndex">Intero a 32 bit che rappresenta l'indice in <paramref name="sourceArray" /> da cui viene avviata la copia.</param>
        <param name="destinationArray">Oggetto <see cref="T:System.Array" /> che riceve i dati.</param>
        <param name="destinationIndex">Intero a 32 bit che rappresenta l'indice in <paramref name="destinationArray" /> da cui viene avviata l'archiviazione.</param>
        <param name="length">Intero a 32 bit che rappresenta il numero degli elementi da copiare.</param>
        <summary>Copia un intervallo di elementi da un oggetto <see cref="T:System.Array" /> a partire dall'indice di origine specificato e lo incolla in un altro oggetto <see cref="T:System.Array" /> a partire dall'indice di destinazione specificato. La lunghezza e gli indici vengono specificati come interi a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `sourceArray` e `destinationArray` parametri devono avere lo stesso numero di dimensioni. È inoltre `destinationArray` deve già dimensionata e deve avere un numero sufficiente di elementi a partire dal `destinationIndex` posizione per contenere i dati copiati.  
  
 Copiare dati tra le matrici multidimensionali, se la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o colonne) sono concettualmente laid end-to-end. Ad esempio, se una matrice con tre righe (o colonne) con quattro elementi, ogni copia sei elementi dall'inizio della matrice copiava tutti i quattro elementi della prima riga (o colonna) e i primi due elementi della seconda riga (o colonna). Per avviare la copia dal secondo elemento della terza riga (o colonna), `sourceIndex` deve essere il limite superiore della prima riga (o colonna) e della lunghezza della seconda riga (o colonna) più due.  
  
 Se `sourceArray` e `destinationArray` si sovrappongono, questo metodo si comporta come se i valori originali delle `sourceArray` siano stati conservati in un percorso temporaneo prima `destinationArray` viene sovrascritto.  
  
 [C++]  
  
 Questo metodo è equivalente alla funzione standard C/C++ `memmove`, non `memcpy`.  
  
 Le matrici possono essere matrici di tipo riferimento o matrici di tipo di valore. Viene eseguito il downcast del tipo, in base alle necessità.  
  
-   Durante la copia da una matrice di tipo riferimento in una matrice di tipo di valore, ogni elemento viene eseguita la conversione unboxing e quindi copiato. Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.  
  
-   Quando si copia da una matrice di tipo riferimento o tipo di valore a un <xref:System.Object> matrice, un <xref:System.Object> viene creato per contenere ogni valore o riferimento e quindi copiati. Durante la copia da un <xref:System.Object> matrice da una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <xref:System.InvalidCastException> viene generata un'eccezione.  
  
-   Se `sourceArray` e `destinationArray` sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <xref:System.Object>, viene eseguita una copia superficiale. Una copia superficiale di un <xref:System.Array> è una nuova <xref:System.Array> che contiene riferimenti agli stessi elementi dell'originale <xref:System.Array>. Gli elementi stessi o a qualsiasi elemento a cui fanno riferimento gli elementi non vengono copiati. Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente fa riferimento gli elementi.  
  
 Un <xref:System.ArrayTypeMismatchException> viene generata un'eccezione se le matrici sono tipi incompatibili. Compatibilità dei tipi viene definita come segue:  
  
-   Un tipo è compatibile con se stesso.  
  
-   Un tipo di valore è compatibile con <xref:System.Object> e con un tipo di interfaccia implementati da tale tipo di valore. Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa tale interfaccia direttamente. I tipi disconnessi non sono compatibili.  
  
-   Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine nel tipo di destinazione è una conversione di ampliamento. Una conversione verso un mai perde le informazioni sulla, mentre una conversione di narrowing può perdere informazioni. Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e conversione di un intero con segno a 64 bit in un intero con segno a 32 bit viene eseguita una conversione narrowing. Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
-   Un tipo non intrinseco (valore definito dall'utente) è compatibile solo con se stesso.  
  
-   Le enumerazioni dispongono di una conversione implicita a <xref:System.Enum> e al tipo sottostante.  
  
 Se ogni elemento in `sourceArray` richiede un downcast (ad esempio, da una classe di base a una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in `destinationArray`, un <xref:System.InvalidCastException> viene generata un'eccezione.  
  
 Se questo metodo genera un'eccezione durante la copia, lo stato di `destinationArray` è definito.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 Esempio di codice seguente illustra come copiare uno <xref:System.Array> typu <xref:System.Object> a un altro <xref:System.Array> di tipo integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> è <see langword="null" />.  
  
oppure 
 <paramref name="destinationArray" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> hanno classificazioni diverse.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">I tipi di <paramref name="sourceArray" /> e <paramref name="destinationArray" /> sono incompatibili.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di almeno un elemento in <paramref name="sourceArray" /> al tipo di <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> è minore del limite inferiore della prima dimensione di <paramref name="sourceArray" />.  
  
oppure 
 <paramref name="destinationIndex" /> è minore del limite inferiore della prima dimensione di <paramref name="destinationArray" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="sourceIndex" /> e la fine di <paramref name="sourceArray" />.  
  
oppure 
 <paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="destinationIndex" /> e la fine di <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Oggetto <see cref="T:System.Array" /> che contiene i dati da copiare.</param>
        <param name="sourceIndex">Intero a 64 bit che rappresenta l'indice in <paramref name="sourceArray" /> da cui viene avviata la copia.</param>
        <param name="destinationArray">Oggetto <see cref="T:System.Array" /> che riceve i dati.</param>
        <param name="destinationIndex">Intero a 64 bit che rappresenta l'indice in <paramref name="destinationArray" /> da cui viene avviata l'archiviazione.</param>
        <param name="length">Intero a 64 bit che rappresenta il numero di elementi da copiare. L'intero deve essere compreso tra zero e <see cref="F:System.Int32.MaxValue" />, inclusi.</param>
        <summary>Copia un intervallo di elementi da un oggetto <see cref="T:System.Array" /> a partire dall'indice di origine specificato e lo incolla in un altro oggetto <see cref="T:System.Array" /> a partire dall'indice di destinazione specificato. La lunghezza e gli indici vengono specificati come interi a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `sourceArray` e `destinationArray` parametri devono avere lo stesso numero di dimensioni. È inoltre `destinationArray` deve già dimensionata e deve avere un numero sufficiente di elementi a partire dal `destinationIndex` posizione per contenere i dati copiati.  
  
 Copiare dati tra le matrici multidimensionali, se la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o colonne) sono concettualmente laid end-to-end. Ad esempio, se una matrice con tre righe (o colonne) con quattro elementi, ogni copia sei elementi dall'inizio della matrice copiava tutti i quattro elementi della prima riga (o colonna) e i primi due elementi della seconda riga (o colonna). Per avviare la copia dal secondo elemento della terza riga (o colonna), `sourceIndex` deve essere il limite superiore della prima riga (o colonna) e della lunghezza della seconda riga (o colonna) più due.  
  
 Se `sourceArray` e `destinationArray` si sovrappongono, questo metodo si comporta come se i valori originali delle `sourceArray` siano stati conservati in un percorso temporaneo prima `destinationArray` viene sovrascritto.  
  
 [C++]  
  
 Questo metodo è equivalente alla funzione standard C/C++ `memmove`, non `memcpy`.  
  
 Le matrici possono essere matrici di tipo riferimento o matrici di tipo di valore. Viene eseguito il downcast del tipo, in base alle necessità.  
  
-   Durante la copia da una matrice di tipo riferimento in una matrice di tipo di valore, ogni elemento viene eseguita la conversione unboxing e quindi copiato. Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.  
  
-   Quando si copia da una matrice di tipo riferimento o tipo di valore a un <xref:System.Object> matrice, un <xref:System.Object> viene creato per contenere ogni valore o riferimento e quindi copiati. Durante la copia da un <xref:System.Object> matrice da una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <xref:System.InvalidCastException> viene generata un'eccezione.  
  
-   Se `sourceArray` e `destinationArray` sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <xref:System.Object>, viene eseguita una copia superficiale. Una copia superficiale di un <xref:System.Array> è una nuova <xref:System.Array> che contiene riferimenti agli stessi elementi dell'originale <xref:System.Array>. Gli elementi stessi o a qualsiasi elemento a cui fanno riferimento gli elementi non vengono copiati. Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente fa riferimento gli elementi.  
  
 Un <xref:System.ArrayTypeMismatchException> viene generata un'eccezione se le matrici sono tipi incompatibili. Compatibilità dei tipi viene definita come segue:  
  
-   Un tipo è compatibile con se stesso.  
  
-   Un tipo di valore è compatibile con <xref:System.Object> e con un tipo di interfaccia implementati da tale tipo di valore. Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa tale interfaccia direttamente. I tipi disconnessi non sono compatibili.  
  
-   Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine nel tipo di destinazione è una conversione di ampliamento. Una conversione verso un mai perde le informazioni sulla, mentre una conversione di narrowing può perdere informazioni. Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e conversione di un intero con segno a 64 bit in un intero con segno a 32 bit viene eseguita una conversione narrowing. Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
-   Un tipo non intrinseco (valore definito dall'utente) è compatibile solo con se stesso.  
  
-   Le enumerazioni dispongono di una conversione implicita a <xref:System.Enum> e al tipo sottostante.  
  
 Se ogni elemento in `sourceArray` richiede un downcast (ad esempio, da una classe di base a una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in `destinationArray`, un <xref:System.InvalidCastException> viene generata un'eccezione.  
  
 Se questo metodo genera un'eccezione durante la copia, lo stato di `destinationArray` è definito.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 Esempio di codice seguente illustra come copiare uno <xref:System.Array> typu <xref:System.Object> a un altro <xref:System.Array> di tipo integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> è <see langword="null" />.  
  
oppure 
 <paramref name="destinationArray" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> hanno classificazioni diverse.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">I tipi di <paramref name="sourceArray" /> e <paramref name="destinationArray" /> sono incompatibili.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di almeno un elemento in <paramref name="sourceArray" /> al tipo di <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="sourceArray" />.  
  
oppure 
 <paramref name="destinationIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="destinationArray" />.  
  
oppure 
 <paramref name="length" /> è minore di 0 o maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="sourceIndex" /> e la fine di <paramref name="sourceArray" />.  
  
oppure 
 <paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="destinationIndex" /> e la fine di <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia tutti gli elementi dell'attuale matrice unidimensionale nella matrice unidimensionale specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice unidimensionale che costituisce la destinazione degli elementi copiati dalla matrice corrente.</param>
        <param name="index">Intero a 32 bit che rappresenta l'indice in <paramref name="array" /> da cui viene avviata la copia.</param>
        <summary>Copia tutti gli elementi dell'attuale matrice unidimensionale nella matrice unidimensionale specificata a partire dall'indice della matrice di destinazione indicato. L'indice viene specificato come intero a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo copia tutti gli elementi dell'istanza della matrice corrente per il `array` matrice di destinazione, iniziando in corrispondenza dell'indice `index`. Il `array` matrice di destinazione devono già dimensionata e deve avere un numero sufficiente di elementi per contenere gli elementi copiati. In caso contrario, il metodo genererà un'eccezione.  
  
 Questo metodo supporta il <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaccia. Se l'implementazione <xref:System.Collections.ICollection?displayProperty=nameWithType> è obbligatorio in modo non esplicito, usare <xref:System.Array.Copy%2A> per evitare un ulteriore riferimento indiretto.  
  
 Se questo metodo genera un'eccezione durante la copia, lo stato di `array` è definito.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Array.Length%2A>. Esegue solo una copia superficiale.  
  
   
  
## Examples  
 Esempio di codice seguente illustra come copiare un' <xref:System.Array> a un altro <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Esempio di codice seguente illustra come copiare un' <xref:System.Array> a un altro <xref:System.Array> con limite inferiore diverso da zero. Si noti che l'origine intera <xref:System.Array> viene copiato, inclusi gli elementi vuoti che sovrascrivono gli elementi esistenti nella destinazione <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  
  
oppure 
Il numero di elementi nella matrice di origine è maggiore del numero disponibile di elementi da <paramref name="index" /> alla fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Non è possibile eseguire il cast automatico del tipo dell'oggetto <see cref="T:System.Array" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <exception cref="T:System.RankException">La matrice di origine è multidimensionale.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di almeno un elemento nell'oggetto <see cref="T:System.Array" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">Matrice unidimensionale che costituisce la destinazione degli elementi copiati dalla matrice corrente.</param>
        <param name="index">Intero a 64 bit che rappresenta l'indice in <paramref name="array" /> da cui viene avviata la copia.</param>
        <summary>Copia tutti gli elementi dell'attuale matrice unidimensionale nella matrice unidimensionale specificata a partire dall'indice della matrice di destinazione indicato. L'indice viene specificato come intero a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo copia tutti gli elementi dell'istanza della matrice corrente per il `array` matrice di destinazione, iniziando in corrispondenza dell'indice `index`. Il `array` matrice di destinazione devono già dimensionata e deve avere un numero sufficiente di elementi per contenere gli elementi copiati. In caso contrario, il metodo genererà un'eccezione.  
  
 Questo metodo supporta il <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaccia. Se l'implementazione <xref:System.Collections.ICollection?displayProperty=nameWithType> è obbligatorio in modo non esplicito, usare <xref:System.Array.Copy%2A> per evitare un ulteriore riferimento indiretto.  
  
 Se questo metodo genera un'eccezione durante la copia, lo stato di `array` è definito.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Array.Length%2A>. Esegue solo una copia superficiale.  
  
   
  
## Examples  
 Esempio di codice seguente illustra come copiare un' <xref:System.Array> a un altro <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Esempio di codice seguente illustra come copiare un' <xref:System.Array> a un altro <xref:System.Array> con limite inferiore diverso da zero. Si noti che l'origine intera <xref:System.Array> viene copiato, inclusi gli elementi vuoti che sovrascrivono gli elementi esistenti nella destinazione <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> è multidimensionale.  
  
oppure 
Il numero di elementi nella matrice di origine è maggiore del numero disponibile di elementi da <paramref name="index" /> alla fine dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Non è possibile eseguire il cast automatico del tipo dell'oggetto <see cref="T:System.Array" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <exception cref="T:System.RankException">L'origine <see cref="T:System.Array" /> è multidimensionale.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di almeno un elemento nell'oggetto <see cref="T:System.Array" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <param name="length">Dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <summary>Crea un oggetto <see cref="T:System.Array" /> unidimensionale dell'oggetto <see cref="T:System.Type" /> specificato e della lunghezza, con indice in base zero.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Array" /> unidimensionale dell'oggetto <see cref="T:System.Type" /> specificato con la lunghezza indicata e con indice in base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> metodo, invece di costruttori pubblici, per consentire l'accesso di associazione tardiva.  
  
 Elementi di tipo riferimento vengono inizializzati `null`. Gli elementi di tipo di valore vengono inizializzati a zero.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare e inizializzare una matrice unidimensionale <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> non è supportato. Ad esempio, <see cref="T:System.Void" /> non è supportato.  
  
oppure 
 <paramref name="elementType" /> è un tipo generico aperto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <param name="lengths">Matrice di interi a 32 bit che rappresentano le grandezze di ciascuna dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <summary>Crea un oggetto <see cref="T:System.Array" /> multidimensionale dell'oggetto <see cref="T:System.Type" /> specificato e delle lunghezze della dimensione, con indicizzazione in base zero. Le lunghezze vengono specificate in una matrice di interi a 32 bit.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Array" /> multidimensionale dell'oggetto <see cref="T:System.Type" /> specificato, con la lunghezza specificata per ogni dimensione, usando l'indicizzazione in base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> metodo, invece di costruttori pubblici, per consentire l'accesso di associazione tardiva.  
  
 Il numero di elementi nel `lengths` matrice deve essere uguale al numero di dimensioni nel nuovo <xref:System.Array>. Ogni elemento della `lengths` matrice debba specificare la lunghezza della dimensione corrispondente nel nuovo <xref:System.Array>.  
  
 Elementi di tipo riferimento vengono inizializzati `null`. Gli elementi di tipo di valore vengono inizializzati a zero.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il prodotto di tutti i valori `lengths`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto multidimensionale <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> è <see langword="null" />.  
  
oppure 
 <paramref name="lengths" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.  
  
oppure 
La matrice di <paramref name="lengths" /> contiene meno di un elemento.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> non è supportato. Ad esempio, <see cref="T:System.Void" /> non è supportato.  
  
oppure 
 <paramref name="elementType" /> è un tipo generico aperto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualsiasi valore in <paramref name="lengths" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <param name="lengths">Matrice di interi a 64 bit che rappresentano le grandezze di ciascuna dimensione dell'oggetto <see cref="T:System.Array" /> da creare. Ogni intero nella matrice deve essere compreso tra zero e <see cref="F:System.Int32.MaxValue" />, inclusi.</param>
        <summary>Crea un oggetto <see cref="T:System.Array" /> multidimensionale dell'oggetto <see cref="T:System.Type" /> specificato e delle lunghezze della dimensione, con indicizzazione in base zero. Le lunghezze delle dimensioni vengono specificate in una matrice di interi a 64 bit.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Array" /> multidimensionale dell'oggetto <see cref="T:System.Type" /> specificato, con la lunghezza specificata per ogni dimensione, usando l'indicizzazione in base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> metodo, invece di costruttori pubblici, per consentire l'accesso di associazione tardiva.  
  
 Il numero di elementi nel `lengths` matrice deve essere uguale al numero di dimensioni nel nuovo <xref:System.Array>. Ogni elemento della `lengths` matrice debba specificare la lunghezza della dimensione corrispondente nel nuovo <xref:System.Array>.  
  
 Elementi di tipo riferimento vengono inizializzati `null`. Gli elementi di tipo di valore vengono inizializzati a zero.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il prodotto di tutti i valori `lengths`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto multidimensionale <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> è <see langword="null" />.  
  
oppure 
 <paramref name="lengths" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.  
  
oppure 
La matrice di <paramref name="lengths" /> contiene meno di un elemento.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> non è supportato. Ad esempio, <see cref="T:System.Void" /> non è supportato.  
  
oppure 
 <paramref name="elementType" /> è un tipo generico aperto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualsiasi valore in <paramref name="lengths" /> è minore di zero o maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <param name="length1">Dimensioni della prima dimensione di <see cref="T:System.Array" /> da creare.</param>
        <param name="length2">Dimensioni della seconda dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <summary>Crea un oggetto <see cref="T:System.Array" /> bidimensionale dell'oggetto <see cref="T:System.Type" /> specificato e delle lunghezze delle dimensioni specificate, con indice in base zero.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Array" /> bidimensionale dell'oggetto <see cref="T:System.Type" /> specificato con la lunghezza specificata per ciascuna dimensione, con indice in base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> metodo, invece di costruttori pubblici, per consentire l'accesso di associazione tardiva.  
  
 Elementi di tipo riferimento vengono inizializzati `null`. Gli elementi di tipo di valore vengono inizializzati a zero.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il prodotto delle `length1` e `length2`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto bidimensionale <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> non è supportato. Ad esempio, <see cref="T:System.Void" /> non è supportato.  
  
oppure 
 <paramref name="elementType" /> è un tipo generico aperto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> è minore di zero.  
  
oppure 
 <paramref name="length2" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <param name="lengths">Matrice unidimensionale che contiene la grandezza di ciascuna dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <param name="lowerBounds">Matrice unidimensionale che contiene il limite inferiore (indice iniziale) di ciascuna dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <summary>Crea una matrice <see cref="T:System.Array" /> multidimensionale con il valore <see cref="T:System.Type" /> e lunghezze della dimensione specificati, con i limiti inferiori specificati.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Array" /> multidimensionale con il valore <see cref="T:System.Type" /> specificato, con la lunghezza e il limite inferiore specificati per ogni dimensione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> metodo, invece di costruttori pubblici, per consentire l'accesso di associazione tardiva.  
  
 Il `lengths` e `lowerBounds` matrici deve essere lo stesso numero di elementi. Il numero di elementi nel `lengths` matrice deve essere uguale al numero di dimensioni nel nuovo <xref:System.Array>.  
  
 Ogni elemento della `lengths` matrice debba specificare la lunghezza della dimensione corrispondente nel nuovo <xref:System.Array>.  
  
 Ogni elemento della `lowerBounds` matrice debba specificare il limite inferiore della dimensione corrispondente nel nuovo <xref:System.Array>. In generale, la libreria di classi .NET Framework e numerosi linguaggi di programmazione non gestiscono i limiti inferiori diversi da zero.  
  
 Elementi di tipo riferimento vengono inizializzati `null`. Gli elementi di tipo di valore vengono inizializzati a zero.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il prodotto di tutti i valori `lengths`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto multidimensionale <xref:System.Array> con limiti inferiori specificati.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> è <see langword="null" />.  
  
oppure 
 <paramref name="lengths" /> è <see langword="null" />.  
  
oppure 
 <paramref name="lowerBounds" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.  
  
oppure 
La matrice di <paramref name="lengths" /> contiene meno di un elemento.  
  
oppure 
Le matrici <paramref name="lengths" /> e <paramref name="lowerBounds" /> non contengono lo stesso numero di elementi.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> non è supportato. Ad esempio, <see cref="T:System.Void" /> non è supportato.  
  
oppure 
 <paramref name="elementType" /> è un tipo generico aperto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualsiasi valore in <paramref name="lengths" /> è minore di zero.  
  
oppure 
Qualsiasi valore in <paramref name="lowerBounds" /> è tanto grande che la somma del limite inferiore e della lunghezza di una dimensione risulta essere maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <param name="length1">Dimensioni della prima dimensione di <see cref="T:System.Array" /> da creare.</param>
        <param name="length2">Dimensioni della seconda dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <param name="length3">Dimensioni della terza dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</param>
        <summary>Crea un oggetto <see cref="T:System.Array" /> tridimensionale dell'oggetto <see cref="T:System.Type" /> specificato e le lunghezze della dimensione, con indice in base zero.</summary>
        <returns>Nuovo oggetto <see cref="T:System.Array" /> tridimensionale dell'oggetto <see cref="T:System.Type" /> specificato con la lunghezza specificata per ciascuna dimensione, con indice in base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> metodo, invece di costruttori pubblici, per consentire l'accesso di associazione tardiva.  
  
 Elementi di tipo riferimento vengono inizializzati `null`. Gli elementi di tipo di valore vengono inizializzati a zero.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il prodotto delle `length1`, `length2`, e `length3`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto tridimensionale <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> non è supportato. Ad esempio, <see cref="T:System.Void" /> non è supportato.  
  
oppure 
 <paramref name="elementType" /> è un tipo generico aperto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> è minore di zero.  
  
oppure 
 <paramref name="length2" /> è minore di zero.  
  
oppure 
 <paramref name="length3" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <summary>Restituisce una matrice vuota.</summary>
        <returns>Restituisce un oggetto <see cref="T:System.Array" /> vuoto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="match">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni degli elementi da cercare.</param>
        <summary>Determina se la matrice indicata contiene elementi che soddisfano le condizioni definite nel predicato specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="array" /> contiene uno o più elementi che soddisfano le condizioni definite dal predicato specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi della `array` vengono passati singolarmente al <xref:System.Predicate%601>, e l'elaborazione viene arrestata quando viene trovata una corrispondenza.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il <xref:System.Predicate%601> delegare in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio seguente specifica le condizioni di corrispondenza per il <xref:System.Array.Exists%2A> espressioni usinglambda metodo per verificare se un pianeta inizia con una determinata lettera o indica se il pianeta viene trovato nella matrice specificata.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 L'esempio seguente usa il <xref:System.Array.Exists%2A> metodo per indicare se i nomi in una matrice di stringhe iniziano con un carattere specificato. L'esempio crea un'istanza un `StringSearcher` passando la stringa di ricerca al costruttore della classe. Il `StringSearcher.StartsWith` metodo ha stessa firma il <xref:System.Predicate%601> delegare. Quando la <xref:System.Array.Exists%2A> viene chiamato il metodo, ogni membro della matrice viene passato al delegato finché non viene ripristinata `true` o esegue l'iterazione di tutti gli elementi nella matrice.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 È possibile anche usare un'espressione lambda anziché definire in modo esplicito un metodo la cui firma corrisponde a quello del delegato. Nell'esempio seguente sostituisce la `StringSearcher` classi e i relativi `StartsWith` metodo con un'espressione lambda.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Espressioni lambda (Guida per programmatori C#)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Espressioni lambda (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Matrice unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="match">Predicato che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite nel predicato specificato e restituisce la prima occorrenza all'interno dell'intero oggetto <see cref="T:System.Array" />.</summary>
        <returns>Primo elemento che soddisfa le condizioni definite dal predicato specificato, se trovato; in caso contrario, viene restituito il valore predefinito del tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo o un'espressione lambda che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato o un'espressione lambda.  Gli elementi della `array` vengono passati singolarmente al <xref:System.Predicate%601>, inizia il primo elemento e termina con l'ultimo elemento.  L'elaborazione viene arrestata quando viene trovata una corrispondenza.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio seguente usa un' <xref:System.Predicate%601> delegato con il <xref:System.Array.Find%2A> metodo generico per la ricerca di una matrice di <xref:System.Drawing.Point> strutture. Il metodo rappresentato dal delegato, `ProductGT10`, restituisce `true` se il prodotto dei campi di X e Y è maggiore di 100.000. Il <xref:System.Array.Find%2A> metodo chiama il delegato per ogni elemento della matrice, restituendo il primo punto che soddisfa la condizione di test.  
  
> [!NOTE]
>  Gli utenti di c# e Visual Basic non sono necessario creare in modo esplicito il delegato o specificare l'argomento di tipo del metodo generico. I compilatori di determinano i tipi necessari da argomenti del metodo che è fornire.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Invece di definire in modo esplicito un metodo con la firma necessario, creare un'istanza di un <xref:System.Predicate%601> delegare e passa il delegato per il <xref:System.Array.Find%2A> metodo, è facoltativa per usare un'espressione lambda. Nell'esempio seguente è identico a quello precedente, ad eccezione del fatto che usa un'espressione lambda come il `match` argomento.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="match">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni degli elementi da cercare.</param>
        <summary>Recupera tutti gli elementi che soddisfano le condizioni definite nel predicato specificato.</summary>
        <returns>Oggetto <see cref="T:System.Array" /> contenente tutti gli elementi che corrispondono alle condizioni definite dal predicato specificato, se presente; in caso contrario, un oggetto <see cref="T:System.Array" /> vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi della `array` vengono passati singolarmente al <xref:System.Predicate%601>, e vengono salvati gli elementi che soddisfano le condizioni nella matrice restituita.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio seguente crea una matrice di numeri casuali 50 con i valori che possono variare da 0 a 1.000. Chiama quindi il <xref:System.Array.FindAll%2A> metodo con un'espressione lambda che restituisce i valori di intervallo da 300 a 600. Si noti che l'espressione lambda viene passata un parametro denominato `x`;  rappresenta il membro della matrice singoli che viene passato per il <xref:System.Predicate%601>. Si noti anche che locale `lBound` e `uBound` variabili sono accessibili all'interno dell'espressione lambda.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 L'esempio di codice seguente illustra il <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, e <xref:System.Array.FindAll%2A> metodi generici. Viene creata una matrice di stringhe, che contiene 8 nomi divorasse, due dei quali (in corrispondenza delle posizioni di 1 e 5) terminano con "saurus". L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Array.Find%2A> metodo generico consente di scorrere la matrice dall'inizio, passaggio a sua volta a ogni elemento di `EndsWithSaurus` (metodo). La ricerca termina quando la `EndsWithSaurus` restituzione del metodo `true` per l'elemento "Amargasaurus".  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 Il <xref:System.Array.FindLast%2A> metodo generico utilizzato per la ricerca con le versioni precedenti dalla fine della matrice. Trova l'elemento "Dilophosaurus" nella posizione 5. Il <xref:System.Array.FindAll%2A> metodo generico viene utilizzato per restituire una matrice contenente tutti gli elementi che terminano con "saurus". Gli elementi vengono visualizzati.  
  
 L'esempio di codice dimostra anche il <xref:System.Array.Exists%2A> e <xref:System.Array.TrueForAll%2A> metodi generici.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cerca un elemento che soddisfi le condizioni definite in un predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno di un oggetto <see cref="T:System.Array" /> o in parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="match">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che corrisponda alle condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno di <see cref="T:System.Array" />.</summary>
        <returns>Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array> avanti al primo elemento fino all'ultimo elemento, viene eseguita la ricerca.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi della `array` vengono passati singolarmente al <xref:System.Predicate%601>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra tutti e tre gli overload del <xref:System.Array.FindIndex%2A> metodo generico. Viene creata una matrice di stringhe, che contiene 8 nomi divorasse, due dei quali (in corrispondenza delle posizioni di 1 e 5) terminano con "saurus". L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo attraversa la matrice dall'inizio, passando ogni elemento, a sua volta la `EndsWithSaurus` (metodo). La ricerca termina quando la `EndsWithSaurus` restituzione del metodo `true` per l'elemento nella posizione 1.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo viene usato per cercare la matrice a partire dalla posizione 2 e continuando fino alla fine della matrice. Trova l'elemento nella posizione 5. Infine, il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 2. Restituisce -1 perché non sono presenti nomi divorasse compreso nell'intervallo che terminano con "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="startIndex">Indice iniziale in base zero della ricerca.</param>
        <param name="match">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Array" /> compreso tra l'indice specificato e l'ultimo elemento.</summary>
        <returns>Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array> viene eseguita la ricerca in avanti partire `startIndex` fino all'ultimo elemento.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi della `array` vengono passati singolarmente al <xref:System.Predicate%601>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi da `startIndex` alla fine della `array`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra tutti e tre gli overload del <xref:System.Array.FindIndex%2A> metodo generico. Viene creata una matrice di stringhe, che contiene 8 nomi divorasse, due dei quali (in corrispondenza delle posizioni di 1 e 5) terminano con "saurus". L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo attraversa la matrice dall'inizio, passando ogni elemento, a sua volta la `EndsWithSaurus` (metodo). La ricerca termina quando la `EndsWithSaurus` restituzione del metodo `true` per l'elemento nella posizione 1.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo viene usato per cercare la matrice a partire dalla posizione 2 e continuando fino alla fine della matrice. Trova l'elemento nella posizione 5. Infine, il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 2. Restituisce -1 perché non sono presenti nomi divorasse compreso nell'intervallo che terminano con "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="startIndex">Indice iniziale in base zero della ricerca.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <param name="match">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Array" /> che inizia dall'indice specificato e contiene il numero indicato di elementi.</summary>
        <returns>Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array> viene eseguita la ricerca in avanti partire `startIndex` a `startIndex` plus `count` meno 1, se `count` è maggiore di 0.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi della `array` vengono passati singolarmente al <xref:System.Predicate%601>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra tutti e tre gli overload del <xref:System.Array.FindIndex%2A> metodo generico. Viene creata una matrice di stringhe, che contiene 8 nomi divorasse, due dei quali (in corrispondenza delle posizioni di 1 e 5) terminano con "saurus". L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo attraversa la matrice dall'inizio, passando ogni elemento, a sua volta la `EndsWithSaurus` (metodo). La ricerca termina quando la `EndsWithSaurus` restituzione del metodo `true` per l'elemento nella posizione 1.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo viene usato per cercare la matrice a partire dalla posizione 2 e continuando fino alla fine della matrice. Trova l'elemento nella posizione 5. Infine, il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 2. Restituisce -1 perché non sono presenti nomi divorasse compreso nell'intervallo che terminano con "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.  
  
oppure 
 <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="match">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite nel predicato specificato e restituisce l'ultima occorrenza all'interno dell'intero oggetto <see cref="T:System.Array" />.</summary>
        <returns>Ultimo elemento che soddisfa le condizioni definite dal predicato specificato, se trovato; in caso contrario, viene restituito il valore predefinito del tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi della `array` vengono passati singolarmente per il <xref:System.Predicate%601>, lo spostamento indietro nel <xref:System.Array>, iniziando all'ultimo elemento e terminando con il primo elemento.  L'elaborazione viene arrestata quando viene trovata una corrispondenza.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, e <xref:System.Array.FindAll%2A> metodi generici. Viene creata una matrice di stringhe, che contiene 8 nomi divorasse, due dei quali (in corrispondenza delle posizioni di 1 e 5) terminano con "saurus". L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Array.Find%2A> metodo generico consente di scorrere la matrice dall'inizio, passaggio a sua volta a ogni elemento di `EndsWithSaurus` (metodo). La ricerca termina quando la `EndsWithSaurus` restituzione del metodo `true` per l'elemento "Amargasaurus".  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il`Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 Il <xref:System.Array.FindLast%2A> metodo generico utilizzato per la ricerca con le versioni precedenti dalla fine della matrice. Trova l'elemento "Dilophosaurus" nella posizione 5. Il <xref:System.Array.FindAll%2A> metodo generico viene utilizzato per restituire una matrice contenente tutti gli elementi che terminano con "saurus". Gli elementi vengono visualizzati.  
  
 L'esempio di codice dimostra anche il <xref:System.Array.Exists%2A> e <xref:System.Array.TrueForAll%2A> metodi generici.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cerca un elemento che soddisfi le condizioni definite da un predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno di un oggetto <see cref="T:System.Array" /> o in parte di esso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="match">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intero oggetto <see cref="T:System.Array" />.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi della `array` vengono passati singolarmente al <xref:System.Predicate%601>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra tutti e tre gli overload del <xref:System.Array.FindLastIndex%2A> metodo generico. Viene creata una matrice di stringhe, che contiene 8 nomi divorasse, due dei quali (in corrispondenza delle posizioni di 1 e 5) terminano con "saurus". L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo attraversa la matrice con le versioni precedenti dalla fine, passando ogni elemento, a sua volta la `EndsWithSaurus` (metodo). La ricerca termina quando la `EndsWithSaurus` restituzione del metodo `true` dell'elemento in corrispondenza della posizione 5.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo viene usato per cercare la matrice a partire dalla posizione 4 e continua all'indietro all'inizio della matrice. Trova l'elemento nella posizione 1. Infine, il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 4, procedendo a ritroso (vale a dire, gli elementi 2, 3 e 4). Restituisce -1 perché non sono presenti nomi divorasse compreso nell'intervallo che terminano con "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="startIndex">Indice iniziale in base zero della ricerca all'indietro.</param>
        <param name="match">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi in <see cref="T:System.Array" /> compreso tra il primo elemento e l'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e termina in corrispondenza del primo elemento.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi della `array` vengono passati singolarmente al <xref:System.Predicate%601>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi dall'inizio del `array` a `startIndex`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra tutti e tre gli overload del <xref:System.Array.FindLastIndex%2A> metodo generico. Viene creata una matrice di stringhe, che contiene 8 nomi divorasse, due dei quali (in corrispondenza delle posizioni di 1 e 5) terminano con "saurus". L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo attraversa la matrice con le versioni precedenti dalla fine, passando ogni elemento, a sua volta la `EndsWithSaurus` (metodo). La ricerca termina quando la `EndsWithSaurus` restituzione del metodo `true` dell'elemento in corrispondenza della posizione 5.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo viene usato per cercare la matrice a partire dalla posizione 4 e continua all'indietro all'inizio della matrice. Trova l'elemento nella posizione 1. Infine, il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 4, procedendo a ritroso (vale a dire, gli elementi 2, 3 e 4). Restituisce -1 perché non sono presenti nomi divorasse compreso nell'intervallo che terminano con "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="startIndex">Indice iniziale in base zero della ricerca all'indietro.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <param name="match">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</param>
        <summary>Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi in <see cref="T:System.Array" /> che contiene il numero indicato di elementi e termina in corrispondenza dell'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` a `startIndex` meno `count` + 1, se `count` è maggiore di 0.  
  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi della `array` vengono passati singolarmente al <xref:System.Predicate%601>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra tutti e tre gli overload del <xref:System.Array.FindLastIndex%2A> metodo generico. Viene creata una matrice di stringhe, che contiene 8 nomi divorasse, due dei quali (in corrispondenza delle posizioni di 1 e 5) terminano con "saurus". L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".  
  
 Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo attraversa la matrice con le versioni precedenti dalla fine, passando ogni elemento, a sua volta la `EndsWithSaurus` (metodo). La ricerca termina quando la `EndsWithSaurus` restituzione del metodo `true` dell'elemento in corrispondenza della posizione 5.  
  
> [!NOTE]
>  In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo viene usato per cercare la matrice a partire dalla posizione 4 e continua all'indietro all'inizio della matrice. Trova l'elemento nella posizione 1. Infine, il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 4, procedendo a ritroso (vale a dire, gli elementi 2, 3 e 4). Restituisce -1 perché non sono presenti nomi divorasse compreso nell'intervallo che terminano con "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="match" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.  
  
oppure 
 <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero sui cui elementi va eseguita l'azione.</param>
        <param name="action">Oggetto <see cref="T:System.Action`1" /> da eseguire su ogni elemento dell'oggetto <paramref name="array" />.</param>
        <summary>Esegue l'azione specificata su ciascun elemento della matrice indicata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Action%601> viene delegato a un metodo che esegue un'azione nell'oggetto passato al metodo.  Gli elementi della `array` vengono passati singolarmente al <xref:System.Action%601>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare <xref:System.Array.ForEach%2A> per visualizzare i quadrati di ogni elemento nella matrice di interi.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="action" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce <see cref="T:System.Collections.IEnumerator" /> per <see cref="T:System.Array" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> per l'oggetto <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori. Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.  
  
 È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.  
  
 Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta. Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.  In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita. Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.  
  
 Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`. Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`. Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituite `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito. Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche. In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.  
  
 L'enumeratore non dispone di accesso esclusivo alla raccolta, pertanto il processo di enumerazione di una raccolta non è di per sé thread-safe.  Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.  Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare <xref:System.Array.GetEnumerator%2A> per elencare gli elementi della matrice.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimensione in base zero dell'oggetto <see cref="T:System.Array" /> di cui è necessario determinare la lunghezza.</param>
        <summary>Ottiene un intero a 32 bit che rappresenta il numero di elementi nella dimensione specificata dell'oggetto <see cref="T:System.Array" />.</summary>
        <returns>Intero a 32 bit che rappresenta il numero di elementi nella dimensione specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un esempio di <xref:System.Array.GetLength%2A> viene `GetLength(0)`, che restituisce il numero di elementi nella prima dimensione del <xref:System.Array>.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare <xref:System.Array.GetLength%2A> per visualizzare le dimensioni di due matrici con intervalli diversi.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> è minore di zero.  
  
oppure 
 <paramref name="dimension" /> è uguale a o maggiore di <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimensione in base zero dell'oggetto <see cref="T:System.Array" /> di cui è necessario determinare la lunghezza.</param>
        <summary>Ottiene un integer a 64 bit che rappresenta il numero di elementi nella dimensione specificata di <see cref="T:System.Array" />.</summary>
        <returns>Intero a 64 bit che rappresenta il numero di elementi nella dimensione specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un esempio di <xref:System.Array.GetLongLength%2A> viene `GetLongLength(0)`, che restituisce il numero di elementi nella prima dimensione del <xref:System.Array>.  
  
 Questo metodo è un'operazione o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> è minore di zero.  
  
oppure 
 <paramref name="dimension" /> è uguale a o maggiore di <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimensione in base zero della matrice di cui è necessario determinare l'indice iniziale.</param>
        <summary>Ottiene l'indice del primo elemento della dimensione specificata nella matrice.</summary>
        <returns>Indice del primo elemento della dimensione specificata nella matrice.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` Restituisce l'indice iniziale della prima dimensione della matrice, e `GetLowerBound(Rank - 1)` restituisce l'indice iniziale dell'ultima dimensione della matrice.  
  
 Il <xref:System.Array.GetLowerBound%2A> metodo restituisce sempre un valore che indica l'indice del limite inferiore della matrice, anche se la matrice è vuota.  
  
 Si noti che, sebbene la maggior parte delle matrici in .NET Framework sono in base zero (vale a dire il <xref:System.Array.GetLowerBound%2A> metodo restituisce zero per ogni dimensione della matrice), .NET Framework supporta le matrici che non sono in base zero. Tali matrici possono essere creati con la <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> (metodo) e possono essere restituiti dal codice non gestito.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi per visualizzare i limiti di una matrice unidimensionale e bidimensionale e visualizzare i valori dei rispettivi elementi di matrice.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> è minore di zero.  
  
oppure 
 <paramref name="dimension" /> è uguale a o maggiore di <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimensione in base zero della matrice di cui è necessario determinare il limite superiore.</param>
        <summary>Ottiene l'indice dell'ultimo elemento della dimensione specificata nella matrice.</summary>
        <returns>Indice dell'ultimo elemento della dimensione specificata nella matrice oppure -1 se la dimensione specificata è vuota.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` Restituisce l'ultimo indice nella prima dimensione della matrice, e `GetUpperBound(Rank - 1)` restituisce l'ultimo indice dell'ultima dimensione della matrice.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi per visualizzare i limiti di una matrice unidimensionale e bidimensionale e visualizzare i valori dei rispettivi elementi di matrice.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> è minore di zero.  
  
oppure 
 <paramref name="dimension" /> è uguale a o maggiore di <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene il valore dell'elemento specificato nell'oggetto <see cref="T:System.Array" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Intero a 32 bit che rappresenta la posizione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <summary>Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale. L'indice viene specificato come intero a 32 bit.</summary>
        <returns>Valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se il valore di `index` è compreso nell'intervallo.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente una dimensione.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per l'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Matrice unidimensionale di interi a 32 bit che rappresentano gli indici che specificano la posizione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <summary>Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale. Gli indici vengono specificati come una matrice di interi a 32 bit.</summary>
        <returns>Valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il numero di elementi in `indices` deve essere uguale al numero di dimensioni di <xref:System.Array>. Tutti gli elementi di `indices` matrice deve specificare la posizione dell'elemento desiderato collettivamente in multidimensionale <xref:System.Array>.  
  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi degli indici è compreso nell'intervallo.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il numero di dimensioni nell'oggetto <see cref="T:System.Array" /> corrente non è uguale al numero di elementi in <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Qualsiasi elemento in <paramref name="indices" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Integer a 64 bit che rappresenta la posizione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <summary>Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale. L'indice viene specificato come intero a 64 bit.</summary>
        <returns>Valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se il valore di `index` è compreso nell'intervallo.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente una dimensione.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per l'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Matrice unidimensionale di integer a 64 bit che rappresentano gli indici che specificano la posizione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <summary>Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale. Gli indici vengono specificati come una matrice di interi a 64 bit.</summary>
        <returns>Valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il numero di elementi in `indices` deve essere uguale al numero di dimensioni di <xref:System.Array>. Tutti gli elementi di `indices` matrice deve specificare la posizione dell'elemento desiderato collettivamente in multidimensionale <xref:System.Array>.  
  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi degli indici è compreso nell'intervallo.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il numero di dimensioni nell'oggetto <see cref="T:System.Array" /> corrente non è uguale al numero di elementi in <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualsiasi elemento in <paramref name="indices" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">Intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <param name="index2">Intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <summary>Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale. Gli indici vengono specificati come interi a 32 bit.</summary>
        <returns>Valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi degli indici è compreso nell'intervallo.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente due dimensioni.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente del valore di <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">Integer a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <param name="index2">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <summary>Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale. Gli indici vengono specificati come interi a 64 bit.</summary>
        <returns>Valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi degli indici è compreso nell'intervallo.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente due dimensioni.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente del valore di <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">Intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <param name="index2">Intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <param name="index3">Intero a 32 bit che rappresenta l'indice della terza dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <summary>Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale. Gli indici vengono specificati come interi a 32 bit.</summary>
        <returns>Valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi degli indici è compreso nell'intervallo.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente tre dimensioni.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> o <paramref name="index3" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">Integer a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <param name="index2">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <param name="index3">Integer a 64 bit che rappresenta l'indice della terza dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</param>
        <summary>Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale. Gli indici vengono specificati come interi a 64 bit.</summary>
        <returns>Valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi degli indici è compreso nell'intervallo.  
  
 Questo metodo è un'operazione o (1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente tre dimensioni.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> o <paramref name="index3" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in una matrice unidimensionale o in un intervallo di elementi nella matrice.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Matrice unidimensionale da cercare.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice della prima ricorrenza all'interno di una matrice unidimensionale.</summary>
        <returns>Indice della prima occorrenza di <paramref name="value" /> nell'oggetto <paramref name="array" />, se presente; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca tutti gli elementi di un oggetto unidimensionale arrayfor `value`. Per determinare se `value` presente nella `array`, il metodo esegue un confronto di uguaglianza chiamando ogni elemento `Equals` metodo fino a quando non viene trovata una corrispondenza. Ciò significa che se l'elemento esegue l'override di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , che eseguono l'override viene chiamato.  
  
 Poiché la maggior parte delle matrici hanno un limite inferiore pari a zero, questo metodo restituisce -1 in genere se`value` non viene trovato. Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) e `value` non viene trovata, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio chiama i seguenti tre overload del <xref:System.Array.IndexOf%2A> metodo per trovare l'indice di una stringa in una matrice di stringhe:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, per determinare la prima occorrenza della stringa "the" in una matrice di stringhe.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" per la quarta agli ultimi elementi di una matrice di stringhe.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" in una stringa della matrice dall'elemento che segue l'ultima corrispondenza corretta alla fine della matrice.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice unidimensionale da cercare.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <param name="startIndex">Indice iniziale della ricerca. 0 (zero) è valido in una matrice vuota.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale. L'intervallo si estende da un indice specificato fino alla fine della matrice.</summary>
        <returns>Indice della prima occorrenza di <paramref name="value" />, se trovato, all'interno degli elementi nell'oggetto <paramref name="array" /> che si estende da <paramref name="startIndex" /> fino all'ultimo elemento; in caso contrario viene restituito il limite inferiore della matrice meno 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cercherà una matrice unidimensionale dall'elemento in corrispondenza dell'indice `startIndex` fino all'ultimo elemento. Per determinare se `value` presente nella `array`, il metodo esegue un confronto di uguaglianza chiamando il `Equals` metodo di tutti gli elementi fino a quando non viene trovata una corrispondenza. Ciò significa che se l'elemento esegue l'override di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , che eseguono l'override viene chiamato.  
  
 Poiché la maggior parte delle matrici hanno un limite inferiore pari a zero, questo metodo restituisce -1 in genere se `value` non viene trovato. Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) e `value` non viene trovata, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Se `startIndex` è uguale a <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo restituisce -1. Se `startIndex` è maggiore di quella <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo genera un <xref:System.ArgumentOutOfRangeException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi da `startIndex` alla fine della `array`.  
  
   
  
## Examples  
 L'esempio chiama i seguenti tre overload del <xref:System.Array.IndexOf%2A> metodo per trovare l'indice di una stringa in una matrice di stringhe:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, per determinare la prima occorrenza della stringa "the" in una matrice di stringhe.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" per la quarta agli ultimi elementi di una matrice di stringhe.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" in una stringa della matrice dall'elemento che segue l'ultima corrispondenza corretta alla fine della matrice.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matrice unidimensionale da cercare.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <param name="startIndex">Indice iniziale della ricerca. 0 (zero) è valido in una matrice vuota.</param>
        <param name="count">Numero di elementi in cui eseguire la ricerca.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale. L'intervallo si estende da un indice specificato per un numero specificato di elementi.</summary>
        <returns>Indice della prima occorrenza di <paramref name="value" />, se trovato, nell'oggetto <paramref name="array" /> dall'indice <paramref name="startIndex" /> a <paramref name="startIndex" /> + <paramref name="count" /> - 1; in caso contrario viene restituito il limite inferiore della matrice meno 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cercherà gli elementi di un oggetto unidimensionale arrayfrom `startIndex` al `startIndex` plus `count` -1, se `count` è maggiore di 0. Per determinare se `value` presente nella `array`, il metodo esegue un confronto di uguaglianza chiamando il `Equals` metodo di tutti gli elementi fino a quando non viene trovata una corrispondenza. Ciò significa che se l'elemento esegue l'override di <xref:System.Object.Equals%2A?displayProperty=nameWithType> , che eseguono l'override viene chiamato.  
  
 Le matrici Becausemost hanno un limite inferiore pari a zero, in genere, questo metodo restituisce-1 se `value` non viene trovato. Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) e `value` non viene trovata, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Se `startindex` è uguale a <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo restituisce -1. Se `startIndex` è maggiore di quella <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo genera un <xref:System.ArgumentOutOfRangeException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.  
  
   
  
## Examples  
 L'esempio chiama i seguenti tre overload del <xref:System.Array.IndexOf%2A> metodo per trovare l'indice di una stringa in una matrice di stringhe:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, per determinare la prima occorrenza della stringa "the" in una matrice di stringhe.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" per la quarta agli ultimi elementi di una matrice di stringhe.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" in una stringa della matrice dall'elemento che segue l'ultima corrispondenza corretta alla fine della matrice. Per determinare il valore della `count` argomento, sottrae il limite superiore della matrice dall'indice iniziale e aggiunge uno.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.  
  
oppure 
 <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Matrice unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice della prima ricorrenza all'interno di una matrice unidimensionale.</summary>
        <returns>Indice in base zero della prima occorrenza di <paramref name="value" /> all'interno dell'intero oggetto <paramref name="array" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cerca tutti gli elementi di una matrice unidimensionale `value`. Per determinare se `value` presente nella `array`, il metodo esegue un confronto di uguaglianza chiamando il `T.Equals` metodo su ogni elemento. Ciò significa che, se `T` esegue l'override di <xref:System.Object.Equals%2A> , che eseguono l'override viene chiamato.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti i tre overload generici del <xref:System.Array.IndexOf%2A> (metodo). Viene creata una matrice di stringhe, con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca nella matrice a partire dall'inizio e trova la prima occorrenza della stringa. Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione di indice 3 e continuando fino alla fine della matrice e consente di trovare la seconda occorrenza della stringa. Infine, il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 perché non sono presenti istanze della stringa di ricerca in tale intervallo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Matrice unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <param name="startIndex">Indice iniziale in base zero della ricerca. 0 (zero) è valido in una matrice vuota.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale. L'intervallo si estende da un indice specificato fino alla fine della matrice.</summary>
        <returns>Indice in base zero della prima occorrenza di <paramref name="value" /> all'interno dell'intervallo di elementi nell'oggetto <paramref name="array" /> compreso tra <paramref name="startIndex" /> e l'ultimo elemento, se trovato; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo cercherà una matrice unidimensionale dall'elemento in corrispondenza `startIndex` alla fine della matrice. Per determinare se `value` presente nella `array`, il metodo esegue un confronto di uguaglianza chiamando il `T.Equals` metodo su ogni elemento. Ciò significa che, se `T` esegue l'override di <xref:System.Object.Equals%2A> , che eseguono l'override viene chiamato.  
  
 Se `startIndex` è uguale a <xref:System.Array.Length%2A>, il metodo restituisce - 1.If `startIndex` è maggiore di quella <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo genera un <xref:System.ArgumentOutOfRangeException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi da `startIndex` alla fine della `array`.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti i tre overload generici del <xref:System.Array.IndexOf%2A> (metodo). Viene creata una matrice di stringhe, con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca nella matrice a partire dall'inizio e trova la prima occorrenza della stringa. Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione di indice 3 e continuando fino alla fine della matrice e consente di trovare la seconda occorrenza della stringa. Infine, il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 perché non sono presenti istanze della stringa di ricerca in tale intervallo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Matrice unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <param name="startIndex">Indice iniziale in base zero della ricerca. 0 (zero) è valido in una matrice vuota.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale. L'intervallo si estende da un indice specificato per un numero specificato di elementi.</summary>
        <returns>Indice in base zero della prima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intervallo di elementi della matrice <paramref name="array" /> che inizia dall'indice <paramref name="startIndex" /> e contiene il numero di elementi specificato nel parametro <paramref name="count" />, se trovato; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo ricercheI elementi di una matrice unidimensionale da `startIndex` al `startIndex` plus `count` -1, se `count` è maggiore di 0. Per determinare se `value` presente nella `array`, il metodo esegue un confronto di uguaglianza chiamando il `T.Equals` metodo su ogni elemento. Ciò significa che, se `T` esegue l'override di <xref:System.Object.Equals%2A> , che eseguono l'override viene chiamato.  
  
 Se `startIndex` è uguale a <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo restituisce -1.  Se `startIndex` è maggiore di quella <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo genera un <xref:System.ArgumentOutOfRangeException>.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.  
  
   
  
## Examples  
 L'esempio seguente illustra tutti i tre overload generici del <xref:System.Array.IndexOf%2A> (metodo). Viene creata una matrice di stringhe, con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca nella matrice a partire dall'inizio e trova la prima occorrenza della stringa. Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione di indice 3 e continuando fino alla fine della matrice e consente di trovare la seconda occorrenza della stringa. Infine, il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 perché non sono presenti istanze della stringa di ricerca in tale intervallo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.  
  
oppure 
 <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizializza ogni elemento dell'oggetto <see cref="T:System.Array" /> di tipi valore chiamando il costruttore predefinito del tipo valore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è progettato per supportare i compilatori le matrici di tipo di valore. Questo metodo non è necessario maggior parte degli utenti. Non deve essere utilizzato per le matrici di tipo riferimento.  
  
 Se il <xref:System.Array> non è un tipo di valore <xref:System.Array> o se il tipo di valore non ha un costruttore predefinito, il <xref:System.Array> non viene modificato.  
  
 Il tipo di valore <xref:System.Array> può avere qualsiasi limite inferiore e qualsiasi numero di dimensioni.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  È possibile usare questo metodo solo su tipi di valore hanno costruttori di; tipi di valore nativi in c#, tuttavia, non è costruttori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Array" /> ha dimensioni fisse.</summary>
        <value>Questa proprietà è sempre <see langword="true" /> per tutte le matrici.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementa il <xref:System.Array.IsFixedSize%2A> proprietà perché è necessaria per il <xref:System.Collections.IList?displayProperty=nameWithType> interfaccia.  
  
 Una matrice con una dimensione fissa non consente l'aggiunta o rimozione di elementi dopo la creazione della matrice, ma consente la modifica degli elementi esistenti.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Array" /> è di sola lettura.</summary>
        <value>Questa proprietà è sempre <see langword="false" /> per tutte le matrici.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementa il <xref:System.Array.IsReadOnly%2A> proprietà perché è necessaria per il <xref:System.Collections.IList?displayProperty=nameWithType> interfaccia. Una matrice che è di sola lettura non consente l'aggiunta, rimozione o modifica di elementi dopo la creazione della matrice.  
  
 Se è necessaria una raccolta di sola lettura, usare una <xref:System.Collections> classe che implementa il <xref:System.Collections.IList?displayProperty=nameWithType> interfaccia.  
  
 Se il cast o convertire una matrice a un <xref:System.Collections.IList> oggetto di interfaccia, il <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> restituisce proprietà `false`. Tuttavia, se il cast o convertire una matrice a un <xref:System.Collections.Generic.IList%601> interfaccia, il `IsReadOnly` restituisce proprietà `true`.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'accesso a <see cref="T:System.Array" /> è sincronizzato (thread-safe).</summary>
        <value>Questa proprietà è sempre <see langword="false" /> per tutte le matrici.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementa il <xref:System.Array.IsSynchronized%2A> proprietà perché è necessaria per il <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaccia.  
  
 Basano di classi .NET framework <xref:System.Array> forniscono la propria versione sincronizzata della raccolta mediante il <xref:System.Array.SyncRoot%2A> proprietà.  
  
 Le classi che utilizzano le matrici possono anche implementare la propria sincronizzazione utilizzando il <xref:System.Array.SyncRoot%2A> proprietà. Il codice di sincronizzazione deve eseguire operazioni su di `SyncRoot` della raccolta, non direttamente sulla raccolta. In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti. In particolare, mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente la raccolta. Si noti che alcune implementazioni di <xref:System.Array.SyncRoot%2A> potrebbe restituire il <xref:System.Array> stesso.  
  
 Enumerare una raccolta di per sé non è una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come bloccare la matrice durante l'intera enumerazione tramite la <xref:System.Array.SyncRoot%2A> proprietà.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'indice dell'ultima occorrenza di un valore in un oggetto <see cref="T:System.Array" /> unidimensionale o in una parte dell'oggetto <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'oggetto <see cref="T:System.Array" /> unidimensionale intero.</summary>
        <returns>Indice dell'ultima occorrenza di <paramref name="value" /> all'interno dell'intero oggetto <paramref name="array" />, se trovato; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unidimensionale <xref:System.Array> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.  
  
 Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> (metodo). Se il tipo di elemento è un tipo non intrinseco (definita dall'utente), il `Equals` implementazione di tale tipo viene utilizzata.  
  
 Poiché la maggior parte delle matrici disporrà di un limite inferiore pari a zero, questo metodo in genere restituirà-1 se `value` non viene trovato. Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` non viene trovato, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType>, ovvero `System.Int32.MinValue - 1`.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
 In .NET Framework versione 2.0, questo metodo Usa il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi del <xref:System.Array> per determinare se il <xref:System.Object> specificato da di `value` parametro esistente. Nelle versioni precedenti di .NET Framework, questo aspetto è stato effettuato utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi delle `value` <xref:System.Object> stesso.  
  
 <xref:System.IComparable.CompareTo%2A> i metodi del `item` parametro per gli oggetti nella raccolta.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato in una matrice.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <param name="startIndex">Indice iniziale della ricerca all'indietro.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Array" /> unidimensionale compreso tra il primo elemento e l'indice specificato.</summary>
        <returns>Indice della prima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intervallo di elementi della matrice <paramref name="array" /> compreso tra il primo elemento e l'indice <paramref name="startIndex" />, se trovato; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto unidimensionale <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e termina in corrispondenza del primo elemento.  
  
 Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> (metodo). Se il tipo di elemento è un tipo non intrinseco (definita dall'utente), il `Equals` implementazione di tale tipo viene utilizzata.  
  
 Poiché la maggior parte delle matrici disporrà di un limite inferiore pari a zero, questo metodo in genere restituirà-1 se `value` non viene trovato. Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` non viene trovato, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType>, ovvero `System.Int32.MinValue - 1`.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi dall'inizio del `array` a `startIndex`.  
  
 In .NET Framework versione 2.0, questo metodo Usa il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi del <xref:System.Array> per determinare se il <xref:System.Object> specificato da di `value` parametro esistente. Nelle versioni precedenti di .NET Framework, questo aspetto è stato effettuato utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi delle `value` <xref:System.Object> stesso.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato in una matrice.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <param name="startIndex">Indice iniziale della ricerca all'indietro.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Array" /> unidimensionale che contiene il numero di elementi specificato e termina in corrispondenza dell'indice specificato.</summary>
        <returns>Indice dell'ultima occorrenza dell'oggetto <paramref name="value" /> all'interno dell'intervallo di elementi in <paramref name="array" /> che contiene il numero di elementi specificato in <paramref name="count" /> e termina in corrispondenza di <paramref name="startIndex" />, se trovato; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto unidimensionale <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` a `startIndex` meno `count` + 1, se `count` è maggiore di 0.  
  
 Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> (metodo). Se il tipo di elemento è un tipo non intrinseco (definita dall'utente), il`Equals` implementazione di tale tipo viene utilizzata.  
  
 Poiché la maggior parte delle matrici disporrà di un limite inferiore pari a zero, questo metodo in genere restituirà-1 se `value` non viene trovato. Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` non viene trovato, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType>, ovvero `System.Int32.MinValue - 1`.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.  
  
 In .NET Framework versione 2.0, questo metodo Usa il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi del <xref:System.Array> per determinare se il <xref:System.Object> specificato da di `value` parametro esistente. Nelle versioni precedenti di .NET Framework, questo aspetto è stato effettuato utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi delle `value` <xref:System.Object> stesso.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato in una matrice. Si noti che il <xref:System.Array.LastIndexOf%2A> metodo è una ricerca all'indietro, pertanto `count` deve essere minore o uguale a (`startIndex` meno il limite inferiore della matrice più 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.  
  
oppure 
 <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intero oggetto <see cref="T:System.Array" />.</summary>
        <returns>Indice in base zero dell'ultima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intera <paramref name="array" />, se presente; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.  
  
 Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> (metodo). Se il tipo di elemento è un tipo non intrinseco (definita dall'utente), il `Equals` implementazione di tale tipo viene utilizzata.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 Esempio di codice seguente illustra tutti i tre overload generici del <xref:System.Array.LastIndexOf%2A> (metodo). Viene creata una matrice di stringhe, con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca l'intera matrice dalla fine e consente di trovare la seconda occorrenza della stringa. Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca con le versioni precedenti la matrice a partire dalla posizione di indice 3 e continuando fino all'inizio della matrice e trova la prima occorrenza della stringa. Infine, il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1, perché non sono presenti istanze di ricerca stringa in tale intervallo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <param name="startIndex">Indice iniziale in base zero della ricerca all'indietro.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Array" /> compreso tra il primo elemento e l'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza di <paramref name="value" /> all'interno dell'intervallo di elementi dell'oggetto <paramref name="array" /> compreso tra il primo elemento e <paramref name="startIndex" />, se presente; in caso contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e termina in corrispondenza del primo elemento.  
  
 Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> (metodo). Se il tipo di elemento è un tipo non intrinseco (definita dall'utente), il `Equals` implementazione di tale tipo viene utilizzata.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi dall'inizio del `array` a `startIndex`.  
  
   
  
## Examples  
 Esempio di codice seguente illustra tutti i tre overload generici del <xref:System.Array.LastIndexOf%2A> (metodo). Viene creata una matrice di stringhe, con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca l'intera matrice dalla fine e consente di trovare la seconda occorrenza della stringa. Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca con le versioni precedenti la matrice a partire dalla posizione di indice 3 e continuando fino all'inizio della matrice e trova la prima occorrenza della stringa. Infine, il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1, perché non sono presenti istanze di ricerca stringa in tale intervallo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</param>
        <param name="value">Oggetto da trovare in <paramref name="array" />.</param>
        <param name="startIndex">Indice iniziale in base zero della ricerca all'indietro.</param>
        <param name="count">Numero di elementi nella sezione in cui eseguire la ricerca.</param>
        <summary>Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Array" /> che contiene il numero specificato di elementi e termina in corrispondenza dell'indice specificato.</summary>
        <returns>Indice in base zero dell'ultima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intervallo di elementi della matrice <paramref name="array" /> che contiene il numero di elementi specificato nel parametro <paramref name="count" /> e termina in corrispondenza dell'indice <paramref name="startIndex" />, se trovato; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` a `startIndex` meno `count` + 1, se `count` è maggiore di 0.  
  
 Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> (metodo). Se il tipo di elemento è un tipo non intrinseco (definita dall'utente), il `Equals` implementazione di tale tipo viene utilizzata.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.  
  
   
  
## Examples  
 Esempio di codice seguente illustra tutti i tre overload generici del <xref:System.Array.LastIndexOf%2A> (metodo). Viene creata una matrice di stringhe, con una voce visualizzata due volte, nella posizione di indice 0 e la posizione di indice 5. Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca l'intera matrice dalla fine e consente di trovare la seconda occorrenza della stringa. Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca con le versioni precedenti la matrice a partire dalla posizione di indice 3 e continuando fino all'inizio della matrice e trova la prima occorrenza della stringa. Infine, il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1, perché non sono presenti istanze di ricerca stringa in tale intervallo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.  
  
oppure 
 <paramref name="count" /> è minore di zero.  
  
oppure 
 <paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero totale di elementi in tutte le dimensioni di <see cref="T:System.Array" />.</summary>
        <value>Numero totale di elementi in tutte le dimensioni di <see cref="T:System.Array" />; zero se nella matrice non sono presenti elementi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Array.Length%2A> proprietà da ottenere il numero totale di elementi in una matrice. Usa inoltre il <xref:System.Array.GetUpperBound%2A> metodo per determinare il numero di elementi in ogni dimensione di una matrice multidimensionale.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La matrice è multidimensionale e contiene più di <see cref="F:System.Int32.MaxValue" /> elementi.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un integer a 64 bit che rappresenta il numero totale di elementi in tutte le dimensioni di <see cref="T:System.Array" />.</summary>
        <value>Intero a 64 bit che rappresenta il numero totale di elementi in tutte le dimensioni di <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la classificazione (numero di dimensioni) dell'oggetto <see cref="T:System.Array" />. Ad esempio, una matrice unidimensionale restituisce 1, una matrice bidimensionale restituisce 2 e così via.</summary>
        <value>Rango (numero di dimensioni) dell'oggetto <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, il codice Visual Basic  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 e il codice c#  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 creare una matrice di tre dimensioni con un <xref:System.Array.Rank%2A> proprietà il cui valore è 3.  
  
 Una matrice di matrici (una matrice di matrici) è una matrice unidimensionale; il valore della relativa <xref:System.Array.Rank%2A> proprietà è 1.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Nell'esempio seguente consente di inizializzare una matrice unidimensionale, una matrice bidimensionale e una matrice di matrici e recupera il <xref:System.Array.Rank%2A> proprietà di ciascuno.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Matrice in base zero unidimensionale da ridimensionare oppure <see langword="null" /> per creare una nuova matrice della dimensione specificata.</param>
        <param name="newSize">Dimensione della nuova matrice.</param>
        <summary>Modifica il numero di elementi di una matrice unidimensionale in una nuova dimensione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di allocare una nuova matrice con le dimensioni specificate, copia gli elementi dalla matrice precedente a quella nuova e quindi sostituisce quella precedente con quello nuovo. `array` deve essere una matrice unidimensionale.  
  
 Se `array` è `null`, questo metodo crea una nuova matrice con le dimensioni specificate.  
  
 Se `newSize` è maggiore di <xref:System.Array.Length%2A> della matrice precedente, viene allocata una nuova matrice e tutti gli elementi vengono copiati dalla matrice precedente a quello nuovo.  Se `newSize` è minore di <xref:System.Array.Length%2A> della matrice precedente, viene allocata una nuova matrice e gli elementi vengono copiati dalla matrice precedente a quello nuovo fino a quando non viene compilata una nuova; il resto degli elementi nella matrice precedente vengono ignorati.  Se `newSize` è uguale al <xref:System.Array.Length%2A> della matrice precedente, questo metodo non esegue alcuna operazione.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `newSize`.  
  
 Il <xref:System.Array.Resize%2A> metodo consente di ridimensionare solo una matrice unidimensionale. Il <xref:System.Array> classe non include un metodo per il ridimensionamento delle matrici multidimensionali. A tale scopo, è necessario fornire il proprio codice o chiamare un metodo speciale in una libreria di terze parti. Il codice seguente illustra una possibile implementazione per un metodo che viene ridimensionata una matrice di *n* dimensioni.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come il ridimensionamento influisce sulla matrice.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inverte l'ordine degli elementi in un oggetto <see cref="T:System.Array" /> unidimensionale o in una parte dell'oggetto <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale da invertire.</param>
        <summary>Inverte la sequenza degli elementi nell'oggetto <see cref="T:System.Array" /> unidimensionale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo una chiamata a questo metodo, l'elemento in corrispondenza `myArray[i]`, dove `i` è qualsiasi indice nella matrice, sposta `myArray[j]`, dove `j` è uguale a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
 Come illustrato nell'esempio seguente, il <xref:System.Array.Reverse%2A> metodo può essere utilizzato per invertire una matrice di matrici. Inizializza una matrice di matrici con un elemento per ogni mese dell'anno corrente nel calendario di cultura correnti. Ogni elemento contiene una matrice con tutti gli elementi come mese è giorni. L'esempio visualizza il contenuto della matrice, chiama il <xref:System.Array.Reverse%2A> (metodo), quindi viene visualizzato il contenuto della matrice invertita.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come invertire l'ordinamento dei valori in un <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale da invertire.</param>
        <param name="index">Indice iniziale della sezione da invertire.</param>
        <param name="length">Numero di elementi nella sezione da invertire.</param>
        <summary>Inverte la sequenza degli elementi in un intervallo di elementi dell'oggetto <see cref="T:System.Array" /> unidimensionale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo una chiamata a questo metodo, l'elemento in corrispondenza `myArray[i]`, dove `i` è qualsiasi indice nella matrice, sposta `myArray[j]`, dove `j` è uguale a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Il <xref:System.Array.Reverse%2A> metodo può essere utilizzato per invertire una matrice di matrici.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come invertire l'ordinamento dei valori in un intervallo di elementi in un <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Imposta l'elemento specificato nell'oggetto <see cref="T:System.Array" /> corrente sul valore specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nuovo valore per l'elemento specificato.</param>
        <param name="index">Intero a 32 bit che rappresenta la posizione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <summary>Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale. L'indice viene specificato come intero a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se il valore di `index` è compreso nell'intervallo.  
  
 Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
 Questo metodo è un'operazione o (1).  
  
> [!NOTE]
>  Se <xref:System.Array.SetValue%2A> consente di assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero. Il valore dell'elemento non è un riferimento null e non può essere trovato eseguendo una ricerca di un riferimento null.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente una dimensione.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di <paramref name="value" /> al tipo di elemento dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per l'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nuovo valore per l'elemento specificato.</param>
        <param name="indices">Matrice unidimensionale di interi a 32 bit che rappresentano gli indici che specificano la posizione dell'elemento da impostare.</param>
        <summary>Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale. Gli indici vengono specificati come una matrice di interi a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il numero di elementi in `indices` deve essere uguale al numero di dimensioni di <xref:System.Array>. Tutti gli elementi di `indices` matrice deve specificare la posizione dell'elemento desiderato collettivamente in multidimensionale <xref:System.Array>.  
  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi dei valori nel `indices` matrice non compreso nell'intervallo.  
  
 Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
 Questo metodo è un'operazione o (1).  
  
> [!NOTE]
>  Se <xref:System.Array.SetValue%2A> consente di assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero. Il valore dell'elemento non è un riferimento null e non può essere trovato eseguendo una ricerca di un riferimento null.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il numero di dimensioni nell'oggetto <see cref="T:System.Array" /> corrente non è uguale al numero di elementi in <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di <paramref name="value" /> al tipo di elemento dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Qualsiasi elemento in <paramref name="indices" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nuovo valore per l'elemento specificato.</param>
        <param name="index">Integer a 64 bit che rappresenta la posizione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <summary>Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale. L'indice viene specificato come intero a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se il valore di `index` è compreso nell'intervallo.  
  
 Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
 Questo metodo è un'operazione o (1).  
  
> [!NOTE]
>  Se <xref:System.Array.SetValue%2A> consente di assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero. Il valore dell'elemento non è un riferimento null e non può essere trovato eseguendo una ricerca di un riferimento null.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente una dimensione.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di <paramref name="value" /> al tipo di elemento dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è compreso nell'intervallo di indici validi per l'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nuovo valore per l'elemento specificato.</param>
        <param name="indices">Matrice unidimensionale di interi a 64 bit che rappresentano gli indici che specificano la posizione dell'elemento da impostare.</param>
        <summary>Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale. Gli indici vengono specificati come una matrice di interi a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il numero di elementi in `indices` deve essere uguale al numero di dimensioni di <xref:System.Array>. Tutti gli elementi di `indices` matrice deve specificare la posizione dell'elemento desiderato collettivamente in multidimensionale <xref:System.Array>.  
  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi dei valori nel `indices` matrice non compreso nell'intervallo.  
  
 Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
 Questo metodo è un'operazione o (1).  
  
> [!NOTE]
>  Se <xref:System.Array.SetValue%2A> consente di assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero. Il valore dell'elemento non è un riferimento null e non può essere trovato eseguendo una ricerca di un riferimento null.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il numero di dimensioni nell'oggetto <see cref="T:System.Array" /> corrente non è uguale al numero di elementi in <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di <paramref name="value" /> al tipo di elemento dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualsiasi elemento in <paramref name="indices" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nuovo valore per l'elemento specificato.</param>
        <param name="index1">Intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <param name="index2">Intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <summary>Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale. Gli indici vengono specificati come interi a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi degli indici è compreso nell'intervallo.  
  
 Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
 Questo metodo è un'operazione o (1).  
  
> [!NOTE]
>  Se <xref:System.Array.SetValue%2A> consente di assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero. Il valore dell'elemento non è un riferimento null e non può essere trovato eseguendo una ricerca di un riferimento null.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente due dimensioni.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di <paramref name="value" /> al tipo di elemento dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente del valore di <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nuovo valore per l'elemento specificato.</param>
        <param name="index1">Intero a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <param name="index2">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <summary>Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale. Gli indici vengono specificati come interi a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi degli indici è compreso nell'intervallo.  
  
 Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
 Questo metodo è un'operazione o (1).  
  
> [!NOTE]
>  Se <xref:System.Array.SetValue%2A> consente di assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero. Il valore dell'elemento non è un riferimento null e non può essere trovato eseguendo una ricerca di un riferimento null.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente due dimensioni.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di <paramref name="value" /> al tipo di elemento dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente del valore di <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nuovo valore per l'elemento specificato.</param>
        <param name="index1">Intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <param name="index2">Intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <param name="index3">Intero a 32 bit che rappresenta l'indice della terza dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <summary>Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale. Gli indici vengono specificati come interi a 32 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi degli indici è compreso nell'intervallo.  
  
 Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
 Questo metodo è un'operazione o (1).  
  
> [!NOTE]
>  Se <xref:System.Array.SetValue%2A> consente di assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero. Il valore dell'elemento non è un riferimento null e non può essere trovato eseguendo una ricerca di un riferimento null.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente tre dimensioni.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di <paramref name="value" /> al tipo di elemento dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> o <paramref name="index3" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nuovo valore per l'elemento specificato.</param>
        <param name="index1">Intero a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <param name="index2">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <param name="index3">Integer a 64 bit che rappresenta l'indice della terza dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</param>
        <summary>Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale. Gli indici vengono specificati come interi a 64 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno qualsiasi degli indici è compreso nell'intervallo.  
  
 Per altre informazioni sulle conversioni, vedere <xref:System.Convert>.  
  
 Questo metodo è un'operazione o (1).  
  
> [!NOTE]
>  Se <xref:System.Array.SetValue%2A> consente di assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero. Il valore dell'elemento non è un riferimento null e non può essere trovato eseguendo una ricerca di un riferimento null.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente tre dimensioni.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile eseguire il cast di <paramref name="value" /> al tipo di elemento dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> o <paramref name="index3" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordina gli elementi in una matrice unidimensionale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale da ordinare.</param>
        <summary>Ordina gli elementi di un'intera <see cref="T:System.Array" /> unidimensionale usando l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento dell'oggetto <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni elemento della `array` deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ordinare i valori in un <xref:System.Array> usando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento. Si noti che il risultato potrebbe variare in base corrente <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o più elementi in <paramref name="array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene le chiavi da ordinare.</param>
        <param name="items">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <paramref name="keys" /><see cref="T:System.Array" />.  
  
oppure 
 <see langword="null" /> per ordinare solo l'oggetto <see cref="T:System.Array" /> di <paramref name="keys" />.</param>
        <summary>Ordina una coppia di oggetti <see cref="T:System.Array" /> unidimensionali (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Array" /> usando l'implementazione di <see cref="T:System.IComparable" /> di ogni chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave nel `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>. Quando una chiave viene riposizionato in riferimento durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo. Pertanto, il `items` <xref:System.Array> viene ordinato in base alla disposizione delle chiavi corrispondenti nella `keys` <xref:System.Array>.  
  
 Ogni chiave di `keys` <xref:System.Array> deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con tutte le altre chiavi.  
  
 È possibile ordinare se sono presenti più elementi di chiavi, ma non verranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente. Se sono presenti più chiavi di elementi; non è possibile ordinare tale operazione viene generata un' <xref:System.ArgumentException>.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `keys`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori. Ordinamento viene ottenuto usando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento. Si noti che il risultato potrebbe variare in base corrente <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">L'oggetto <see cref="T:System.Array" /> di <paramref name="keys" /> è multidimensionale.  
  
oppure 
L'oggetto <see cref="T:System.Array" /> di <paramref name="items" /> è multidimensionale.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o più elementi nell'oggetto <see cref="T:System.Array" /> di <paramref name="keys" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Matrice unidimensionale da ordinare.</param>
        <param name="comparer">Implementazione da usare quando si confrontano elementi.  
  
oppure 
 <see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</param>
        <summary>Ordina gli elementi in un oggetto <see cref="T:System.Array" /> unidimensionale usando l'oggetto <see cref="T:System.Collections.IComparer" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` viene `null`, ogni elemento della `array` deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.  
  
 .NET Framework include predefiniti <xref:System.Collections.IComparer> implementazioni elencati nella tabella seguente.  
  
|Implementazione|Descrizione|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Confronta due oggetti, ma effettua un confronto tra maiuscole e minuscole delle stringhe.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Confronta due oggetti usando le convenzioni di ordinamento delle impostazioni cultura correnti.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Confronta due oggetti usando le convenzioni di ordinamento della lingua inglese.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Confronta due oggetti di tipo `T` con ordinamento predefinito del tipo.|  
  
 È anche possibile supportare i confronti personalizzati, fornendo un'istanza della propria <xref:System.Collections.IComparer> implementazione di `comparer` parametro. L'esempio esegue questa definendo un `ReverseComparer` classe che consente di invertire l'ordinamento predefinito per le istanze di un tipo e ne esegue il confronto tra maiuscole e minuscole.  
  
   
  
## Examples  
 Nell'esempio seguente Ordina i valori in arrayby una stringa usando l'operatore di confronto predefinito. Definisce anche una classe personalizzata <xref:System.Collections.IComparer> implementazione denominato `ReverseComparer` che inverte l'ordine predefinito dell'oggetto durante l'esecuzione di un confronto tra stringhe tra maiuscole e minuscole. Si noti che l'output potrebbe variare a seconda delle impostazioni cultura correnti.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e uno o più elementi in <paramref name="array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.ArgumentException">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <block subset="none" type="usage">
          <para>Il .NET Framework 4 e versioni precedenti usano solo l'algoritmo Quicksort. QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante. Inizia con la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, perché gli algoritmi di ordinamento e heapsort inserimento non viene rilevano un operatore di confronto non valido. Nella maggior parte, questo vale per le matrici con meno di 16 elementi.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene le chiavi da ordinare.</param>
        <param name="items">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <paramref name="keys" /><see cref="T:System.Array" />.  
  
oppure 
 <see langword="null" /> per ordinare solo l'oggetto <see cref="T:System.Array" /> di <paramref name="keys" />.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.IComparer" /> da usare quando si confrontano gli elementi.  
  
oppure 
 <see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</param>
        <summary>Ordina una coppia di oggetti <see cref="T:System.Array" /> unidimensionali (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Array" /> usando l'interfaccia <see cref="T:System.Collections.IComparer" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave nel `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>. Quando una chiave viene riposizionato in riferimento durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo. Pertanto, il `items` <xref:System.Array> viene ordinato in base alla disposizione delle chiavi corrispondenti nella `keys` <xref:System.Array>.  
  
 Se `comparer` viene `null`, ogni chiave nel `keys` <xref:System.Array> deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con tutte le altre chiavi.  
  
 È possibile ordinare se sono presenti più elementi di chiavi, ma non verranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente. Se sono presenti più chiavi di elementi; non è possibile ordinare tale operazione viene generata un' <xref:System.ArgumentException>.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 .NET Framework include predefiniti <xref:System.Collections.IComparer> implementazioni elencati nella tabella seguente.  
  
|Implementazione|Descrizione|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Confronta due oggetti, ma effettua un confronto tra maiuscole e minuscole delle stringhe.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Confronta due oggetti usando le convenzioni di ordinamento delle impostazioni cultura correnti.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Confronta due oggetti usando le convenzioni di ordinamento della lingua inglese.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Confronta due oggetti di tipo `T` con ordinamento predefinito del tipo.|  
  
 È anche possibile supportare i confronti personalizzati, fornendo un'istanza della propria <xref:System.Collections.IComparer> implementazione di `comparer` parametro. L'esempio esegue questa definendo un <xref:System.Collections.IComparer> implementazione che consente di invertire l'ordinamento predefinito e ne esegue il confronto tra maiuscole e minuscole.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `keys`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori. Ordinamento viene ottenuto usando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento. Si noti che il risultato potrebbe variare in base corrente <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">L'oggetto <see cref="T:System.Array" /> di <paramref name="keys" /> è multidimensionale.  
  
oppure 
L'oggetto <see cref="T:System.Array" /> di <paramref name="items" /> è multidimensionale.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.  
  
oppure 
L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" />, e uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage">
          <para>Il .NET Framework 4 e versioni precedenti usano solo l'algoritmo Quicksort. QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante. Inizia con la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che previouslythrew <see cref="T:System.ArgumentException" /> non genererà un'eccezione, perché gli algoritmi di ordinamento e heapsort inserimento non viene rilevano un operatore di confronto non valido. Nella maggior parte, questo vale per le matrici con meno di 16 elementi.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale da ordinare.</param>
        <param name="index">Indice iniziale dell'intervallo da ordinare.</param>
        <param name="length">Numero di elementi nell'intervallo da ordinare.</param>
        <summary>Ordina un intervallo di elementi di un oggetto <see cref="T:System.Array" /> unidimensionale usando l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento dell'oggetto <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni elemento nell'intervallo specificato di elementi in `array` deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ordinare i valori in un <xref:System.Array> usando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento. Si noti che il risultato potrebbe variare in base corrente <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o più elementi in <paramref name="array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene le chiavi da ordinare.</param>
        <param name="items">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <paramref name="keys" /><see cref="T:System.Array" />.  
  
oppure 
 <see langword="null" /> per ordinare solo l'oggetto <see cref="T:System.Array" /> di <paramref name="keys" />.</param>
        <param name="index">Indice iniziale dell'intervallo da ordinare.</param>
        <param name="length">Numero di elementi nell'intervallo da ordinare.</param>
        <summary>Ordina un intervallo di elementi in una coppia di oggetti <see cref="T:System.Array" /> unidimensionali (uno contenente le chiavi e l'altro gli elementi corrispondenti) in base alle chiavi nel primo oggetto <see cref="T:System.Array" /> usando l'implementazione di <see cref="T:System.IComparable" /> di ogni chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave nel `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>. Quando una chiave viene riposizionato in riferimento durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo. Pertanto, il `items` <xref:System.Array> viene ordinato in base alla disposizione delle chiavi corrispondenti nella `keys` <xref:System.Array>.  
  
 Ogni chiave nell'intervallo specificato di elementi nel `keys` <xref:System.Array> deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con tutte le altre chiavi.  
  
 È possibile ordinare se sono presenti più elementi di chiavi, ma non verranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente. Se sono presenti più chiavi di elementi; non è possibile ordinare tale operazione viene generata un' <xref:System.ArgumentException>.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori. Ordinamento viene ottenuto usando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento. Si noti che il risultato potrebbe variare in base corrente <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">L'oggetto <see cref="T:System.Array" /> di <paramref name="keys" /> è multidimensionale.  
  
oppure 
L'oggetto <paramref name="items" /><see cref="T:System.Array" /> è multidimensionale.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="keys" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.  
  
oppure 
 <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="keys" /><see cref="T:System.Array" />.  
  
oppure 
 <paramref name="items" /> non è <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o più elementi nell'oggetto <see cref="T:System.Array" /> di <paramref name="keys" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale da ordinare.</param>
        <param name="index">Indice iniziale dell'intervallo da ordinare.</param>
        <param name="length">Numero di elementi nell'intervallo da ordinare.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.IComparer" /> da usare quando si confrontano gli elementi.  
  
oppure 
 <see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</param>
        <summary>Ordina gli elementi in un intervallo di elementi di un oggetto <see cref="T:System.Array" /> unidimensionale usando l'oggetto <see cref="T:System.Collections.IComparer" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` viene `null`, ogni elemento nell'intervallo specificato di elementi nel `array` deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 .NET Framework include predefiniti <xref:System.Collections.IComparer> implementazioni elencati nella tabella seguente.  
  
|Implementazione|Descrizione|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Confronta due oggetti, ma effettua un confronto tra maiuscole e minuscole delle stringhe.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Confronta due oggetti usando le convenzioni di ordinamento delle impostazioni cultura correnti.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Confronta due oggetti usando le convenzioni di ordinamento della lingua inglese.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Confronta due oggetti di tipo `T` con ordinamento predefinito del tipo.|  
  
 È anche possibile supportare i confronti personalizzati, fornendo un'istanza della propria <xref:System.Collections.IComparer> implementazione di `comparer` parametro. L'esempio esegue questa definendo un `ReverseComparer` classe che consente di invertire l'ordinamento predefinito per le istanze di un tipo e ne esegue il confronto tra maiuscole e minuscole.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ordinare i valori in un <xref:System.Array> usando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento. Si noti che il risultato potrebbe variare in base corrente <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> è multidimensionale.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.  
  
oppure 
L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e uno o più elementi in <paramref name="array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage">
          <para>Il .NET Framework 4 e versioni precedenti usano solo l'algoritmo Quicksort. QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante. Inizia con la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, perché gli algoritmi di ordinamento e heapsort inserimento non viene rilevano un operatore di confronto non valido. Nella maggior parte, questo vale per le matrici con meno di 16 elementi.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene le chiavi da ordinare.</param>
        <param name="items">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <paramref name="keys" /><see cref="T:System.Array" />.  
  
oppure 
 <see langword="null" /> per ordinare solo l'oggetto <see cref="T:System.Array" /> di <paramref name="keys" />.</param>
        <param name="index">Indice iniziale dell'intervallo da ordinare.</param>
        <param name="length">Numero di elementi nell'intervallo da ordinare.</param>
        <param name="comparer">Implementazione <see cref="T:System.Collections.IComparer" /> da usare quando si confrontano gli elementi.  
  
oppure 
 <see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</param>
        <summary>Ordina un intervallo di elementi in una coppia di oggetti <see cref="T:System.Array" /> unidimensionali (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <see cref="T:System.Array" /> usando l'interfaccia <see cref="T:System.Collections.IComparer" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave nel `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>. Quando una chiave viene riposizionato in riferimento durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo. Pertanto, il `items` <xref:System.Array> viene ordinato in base alla disposizione delle chiavi corrispondenti nella `keys` <xref:System.Array>.  
  
 Se `comparer` viene `null`, ogni chiave nell'intervallo specificato di elementi nel `keys` <xref:System.Array> deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con tutte le altre chiavi.  
  
 È possibile ordinare se sono presenti più elementi di chiavi, ma non verranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente. Se sono presenti più chiavi di elementi; non è possibile ordinare tale operazione viene generata un' <xref:System.ArgumentException>.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 .NET Framework include predefiniti <xref:System.Collections.IComparer> implementazioni elencati nella tabella seguente.  
  
|Implementazione|Descrizione|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Confronta due oggetti, ma effettua un confronto tra maiuscole e minuscole delle stringhe.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Confronta due oggetti usando le convenzioni di ordinamento delle impostazioni cultura correnti.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Confronta due oggetti usando le convenzioni di ordinamento della lingua inglese.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Confronta due oggetti di tipo `T` con ordinamento predefinito del tipo.|  
  
 È anche possibile supportare i confronti personalizzati, fornendo un'istanza della propria <xref:System.Collections.IComparer> implementazione di `comparer` parametro. L'esempio esegue questa definendo una classe personalizzata <xref:System.Collections.IComparer> implementazione che consente di invertire l'ordinamento predefinito e ne esegue il confronto tra maiuscole e minuscole.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori. Ordinamento viene ottenuto usando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento. Si noti che il risultato potrebbe variare in base corrente <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> è <see langword="null" />.</exception>
        <exception cref="T:System.RankException">L'oggetto <see cref="T:System.Array" /> di <paramref name="keys" /> è multidimensionale.  
  
oppure 
L'oggetto <paramref name="items" /><see cref="T:System.Array" /> è multidimensionale.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="keys" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> non è <see langword="null" /> e il limite inferiore di <paramref name="keys" /> non corrisponde al limite inferiore di <paramref name="items" />.  
  
oppure 
 <paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.  
  
oppure 
 <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="keys" /><see cref="T:System.Array" />.  
  
oppure 
 <paramref name="items" /> non è <see langword="null" />, e <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="items" /><see cref="T:System.Array" />.  
  
oppure 
L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" />, e uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage">
          <para>Il .NET Framework 4 e versioni precedenti usano solo l'algoritmo Quicksort. QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante. Inizia con la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, perché gli algoritmi di ordinamento e heapsort inserimento non viene rilevano un operatore di confronto non valido. Nella maggior parte, questo vale per le matrici con meno di 16 elementi.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale e in base zero da ordinare.</param>
        <summary>Ordina gli elementi di un intero oggetto <see cref="T:System.Array" /> usando l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ogni elemento dell'oggetto <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni elemento della `array` deve implementare il <xref:System.IComparable%601> generica interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> overload del metodo generico e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo generico. Viene creata una matrice di stringhe, senza alcun ordine specifico.  
  
 La matrice viene visualizzata, ordinata e visualizzata di nuovo.  
  
> [!NOTE]
>  Le chiamate per il <xref:System.Array.Sort%2A> e <xref:System.Array.BinarySearch%2A> metodi generici non presenta alcuna differenza dalle chiamate alle relative controparti non generiche, poiché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento. Se si usa la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.  
  
 Il <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo generico viene quindi usato per eseguire la ricerca di due stringhe, che non sia nella matrice e uno che è. La matrice e il valore restituito del <xref:System.Array.BinarySearch%2A> metodo vengono passati al `ShowWhere` metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario, gli elementi della stringa di ricerca rientrerebbero tra se fosse nella matrice. L'indice è un valore negativo se la stringa non è inclusa nella matrice, in modo che il `ShowWhere` metodo accetta il complemento bit per bit (di ~ operatore in c# e Visual C++, `Xor` -1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore di stri ricerca NG.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o più elementi in <paramref name="array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero da ordinare.</param>
        <param name="comparer">Implementazione dell'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> da usare per il confronto fra gli elementi oppure <see langword="null" /> per usare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascun elemento.</param>
        <summary>Ordina gli elementi in un oggetto <see cref="T:System.Array" /> usando l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` viene `null`, ogni elemento della `array` deve implementare il <xref:System.IComparable%601> generica interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico.  
  
 L'esempio di codice definisce un operatore alternativo per le stringhe, denominato `ReverseCompare`, che implementa le `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. La chiama comparer il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini in modo che le stringhe ordinate elevata verso il basso, anziché basso verso l'alto.  
  
 La matrice viene visualizzata, ordinata e visualizzata di nuovo. Le matrici devono essere ordinate per poter utilizzare il <xref:System.Array.BinarySearch%2A> (metodo).  
  
> [!NOTE]
>  Le chiamate per il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodi generici non presenta alcuna differenza dalle chiamate alle relative controparti non generiche, poiché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento. Se si usa la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.  
  
 Il <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico viene quindi usato per eseguire la ricerca di due stringhe, che non sia nella matrice e uno che è. La matrice e il valore restituito del <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodo vengono passati al `ShowWhere` metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario, gli elementi della stringa di ricerca rientrerebbero tra se fosse nella matrice. L'indice è un valore negativo se la stringa non è inclusa nella matrice, in modo che il `ShowWhere` metodo accetta il complemento bit per bit (di ~ operatore in c# e Visual C++, `Xor` -1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore di stri ricerca NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e uno o più elementi in <paramref name="array" /> non implementano l'interfaccia generica di <see cref="T:System.IComparable`1" />.</exception>
        <exception cref="T:System.ArgumentException">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <block subset="none" type="usage">
          <para>Il .NET Framework 4 e versioni precedenti usano solo l'algoritmo Quicksort. QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante. Inizia con la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, perché gli algoritmi di ordinamento e heapsort inserimento non viene rilevano un operatore di confronto non valido. Nella maggior parte, questo vale per le matrici con meno di 16 elementi.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero da ordinare.</param>
        <param name="comparison">Oggetto <see cref="T:System.Comparison`1" /> da usare quando si confrontano gli elementi.</param>
        <summary>Ordina gli elementi in un oggetto <see cref="T:System.Array" /> usando l'oggetto <see cref="T:System.Comparison`1" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> overload del metodo.  
  
 L'esempio di codice definisce un metodo alternativo di confronto per le stringhe, denominato `CompareDinosByLength`. Questo metodo funziona nel modo seguente: in primo luogo, verificare il comparandsare`null`, e un riferimento null viene considerato minore rispetto a un diverso da null. In secondo luogo, vengono confrontati con le lunghezze di stringa e la stringa più lunga viene considerata maggiore di. In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.  
  
 Matrice di stringhe viene creata e popolata con quattro stringhe, senza alcun ordine specifico. L'elenco include anche una stringa vuota e un riferimento null. Viene visualizzato l'elenco, ordinato utilizzando un <xref:System.Comparison%601> delegato generico che rappresenta il `CompareDinosByLength` (metodo), quindi viene nuovamente visualizzato.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="comparison" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L'implementazione di <paramref name="comparison" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparison" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <block subset="none" type="usage">
          <para>Il .NET Framework 4 e versioni precedenti usano solo l'algoritmo Quicksort. QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante. Inizia con la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, perché gli algoritmi di ordinamento e heapsort inserimento non viene rilevano un operatore di confronto non valido. Nella maggior parte, questo vale per le matrici con meno di 16 elementi.</para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero da ordinare.</param>
        <param name="index">Indice iniziale dell'intervallo da ordinare.</param>
        <param name="length">Numero di elementi nell'intervallo da ordinare.</param>
        <summary>Ordina un intervallo di elementi di un oggetto <see cref="T:System.Array" /> usando l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascun elemento dell'oggetto <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni elemento nell'intervallo specificato di elementi in `array` deve implementare il <xref:System.IComparable%601> generica interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo generico e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico per l'ordinamento di un intervallo in una matrice.  
  
 L'esempio di codice definisce un operatore alternativo per le stringhe, denominato `ReverseCompare`, che implementa le `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. La chiama comparer il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini in modo che le stringhe ordinate elevata verso il basso, anziché basso verso l'alto.  
  
 L'esempio di codice crea e visualizza una matrice di nomi divorasse, costituito da tre erbivori seguiti da tre carnivori (tyrannosaurids, per essere precisi). Il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo generico viene utilizzato per ordinare gli ultimi tre elementi della matrice, che viene quindi visualizzato. Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico viene usato con `ReverseCompare` per ordinare gli ultimi tre elementi in ordine inverso. Anche in questo caso vengono visualizzati il dinosaurs accuratamente confuso.  
  
> [!NOTE]
>  Le chiamate per il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodi generici non presenta alcuna differenza dalle chiamate alle relative controparti non generiche, poiché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento. Se si usa la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o più elementi in <paramref name="array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto <see cref="T:System.Array" /> unidimensionale e in base zero da ordinare.</param>
        <param name="index">Indice iniziale dell'intervallo da ordinare.</param>
        <param name="length">Numero di elementi nell'intervallo da ordinare.</param>
        <param name="comparer">Implementazione dell'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> da usare per il confronto fra gli elementi oppure <see langword="null" /> per usare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascun elemento.</param>
        <summary>Ordina un intervallo di elementi di un oggetto <see cref="T:System.Array" /> usando l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` viene `null`, ogni elemento nell'intervallo specificato di elementi nel `array` deve implementare il <xref:System.IComparable%601> generica interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo generico e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico per l'ordinamento di un intervallo in una matrice.  
  
 L'esempio di codice definisce un operatore alternativo per le stringhe, denominato `ReverseCompare`, che implementa le `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. La chiama comparer il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini in modo che le stringhe ordinate elevata verso il basso, anziché basso verso l'alto.  
  
 L'esempio di codice crea e visualizza una matrice di nomi divorasse, costituito da tre erbivori seguiti da tre carnivori (tyrannosaurids, per essere precisi). Il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo generico viene utilizzato per ordinare gli ultimi tre elementi della matrice, che viene quindi visualizzato. Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico viene usato con `ReverseCompare` per ordinare gli ultimi tre elementi in ordine inverso. Anche in questo caso vengono visualizzati il dinosaurs accuratamente confuso.  
  
> [!NOTE]
>  Le chiamate per il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodi generici non presenta alcuna differenza dalle chiamate alle relative controparti non generiche, poiché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento. Se si usa la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.  
  
oppure 
L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" /> e uno o più elementi in <paramref name="array" /> non implementano l'interfaccia generica di <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage">
          <para>Il .NET Framework 4 e versioni precedenti usano solo l'algoritmo Quicksort. QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante. Inizia con la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, perché gli algoritmi di ordinamento e heapsort inserimento non viene rilevano un operatore di confronto non valido. Nella maggior parte, questo vale per le matrici con meno di 16 elementi.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Tipo degli elementi della matrice delle chiavi.</typeparam>
        <typeparam name="TValue">Tipo degli elementi della matrice degli elementi.</typeparam>
        <param name="keys">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero che contiene le chiavi da ordinare.</param>
        <param name="items">Oggetto unidimensionale in base zero <see cref="T:System.Array" /> che contiene gli elementi che corrispondono alle chiavi in <paramref name="keys" /> oppure <see langword="null" /> per ordinare solo <paramref name="keys" />.</param>
        <summary>Ordina una coppia di oggetti <see cref="T:System.Array" /> (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Array" /> usando l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ogni chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave nel `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>. Quando una chiave viene riposizionato in riferimento durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo. Pertanto, il `items` <xref:System.Array> viene ordinato in base alla disposizione delle chiavi corrispondenti nella `keys` <xref:System.Array>.  
  
 Ogni chiave di `keys` <xref:System.Array> deve implementare il <xref:System.IComparable%601> generica interfaccia devono essere in grado di eseguire confronti con tutte le altre chiavi.  
  
 È possibile ordinare se sono presenti più elementi di chiavi, ma non verranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente. Se sono presenti più chiavi di elementi; non è possibile ordinare tale operazione viene generata un' <xref:System.ArgumentException>.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload di metodo generico, per l'ordinamento delle coppie di matrici che rappresentano le chiavi e valori.  
  
 L'esempio di codice definisce un operatore alternativo per le stringhe, denominato `ReverseCompare`, che implementa le `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. La chiama comparer il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini in modo che le stringhe ordinate elevata verso il basso, anziché basso verso l'alto.  
  
 L'esempio di codice crea e visualizza una matrice di nomi divorasse (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ogni divorasse in metri (i valori). Le matrici sono quindi ordinate e visualizzate più volte:  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload viene usato per ordinare entrambe le matrici in ordine dei nomi di divorasse nella prima matrice.  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload e un'istanza di `ReverseCompare` vengono utilizzati per invertire l'ordine della coppia di matrici.  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload viene usato per ordinare gli ultimi tre elementi di entrambe le matrici.  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload viene usato per ordinare gli ultimi tre elementi di entrambe le matrici in ordine inverso.  
  
> [!NOTE]
>  Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle relative controparti non generiche, poiché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti. Se si usa la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> non è <see langword="null" /> e il limite inferiore di <paramref name="keys" /> non corrisponde al limite inferiore di <paramref name="items" />.  
  
oppure 
 <paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Tipo degli elementi della matrice delle chiavi.</typeparam>
        <typeparam name="TValue">Tipo degli elementi della matrice degli elementi.</typeparam>
        <param name="keys">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero che contiene le chiavi da ordinare.</param>
        <param name="items">Oggetto unidimensionale in base zero <see cref="T:System.Array" /> che contiene gli elementi che corrispondono alle chiavi in <paramref name="keys" /> oppure <see langword="null" /> per ordinare solo <paramref name="keys" />.</param>
        <param name="comparer">Implementazione dell'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> da usare per il confronto fra gli elementi oppure <see langword="null" /> per usare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascun elemento.</param>
        <summary>Ordina una coppia di oggetti <see cref="T:System.Array" /> (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <see cref="T:System.Array" /> usando l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave nel `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>. Quando una chiave viene riposizionato in riferimento durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo. Pertanto, il `items` <xref:System.Array> viene ordinato in base alla disposizione delle chiavi corrispondenti nella `keys` <xref:System.Array>.  
  
 Se `comparer` viene `null`, ogni chiave nel `keys` <xref:System.Array> deve implementare il <xref:System.IComparable%601> generica interfaccia devono essere in grado di eseguire confronti con tutte le altre chiavi.  
  
 È possibile ordinare se sono presenti più elementi di chiavi, ma non verranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente. Se sono presenti più chiavi di elementi; non è possibile ordinare tale operazione viene generata un' <xref:System.ArgumentException>.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload di metodo generico, per l'ordinamento delle coppie di matrici che rappresentano le chiavi e valori.  
  
 L'esempio di codice definisce un operatore alternativo per le stringhe, denominato `ReverseCompare`, che implementa le `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. La chiama comparer il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini in modo che le stringhe ordinate elevata verso il basso, anziché basso verso l'alto.  
  
 L'esempio di codice crea e visualizza una matrice di nomi divorasse (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ogni divorasse in metri (i valori). Le matrici sono quindi ordinate e visualizzate più volte:  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload viene usato per ordinare entrambe le matrici in ordine dei nomi di divorasse nella prima matrice.  
  
-   Il [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > overload e un'istanza di `ReverseCompare` vengono utilizzati per invertire l'ordinamento della coppia di matrici.  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload viene usato per ordinare gli ultimi tre elementi di entrambe le matrici.  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload viene usato per ordinare gli ultimi tre elementi di entrambe le matrici in ordine inverso.  
  
> [!NOTE]
>  Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle relative controparti non generiche, poiché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti. Se si usa la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> non è <see langword="null" /> e il limite inferiore di <paramref name="keys" /> non corrisponde al limite inferiore di <paramref name="items" />.  
  
oppure 
 <paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.  
  
oppure 
L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" />, e uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage">
          <para>Il .NET Framework 4 e versioni precedenti usano solo l'algoritmo Quicksort. QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante. Inizia con la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, perché gli algoritmi di ordinamento e heapsort inserimento non viene rilevano un operatore di confronto non valido. Nella maggior parte, questo vale per le matrici con meno di 16 elementi.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Tipo degli elementi della matrice delle chiavi.</typeparam>
        <typeparam name="TValue">Tipo degli elementi della matrice degli elementi.</typeparam>
        <param name="keys">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero che contiene le chiavi da ordinare.</param>
        <param name="items">Oggetto unidimensionale in base zero <see cref="T:System.Array" /> che contiene gli elementi che corrispondono alle chiavi in <paramref name="keys" /> oppure <see langword="null" /> per ordinare solo <paramref name="keys" />.</param>
        <param name="index">Indice iniziale dell'intervallo da ordinare.</param>
        <param name="length">Numero di elementi nell'intervallo da ordinare.</param>
        <summary>Ordina un intervallo di elementi in una coppia di oggetti <see cref="T:System.Array" /> (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <see cref="T:System.Array" /> usando l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascuna chiave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave nel `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>. Quando una chiave viene riposizionato in riferimento durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo. Pertanto, il `items` <xref:System.Array> viene ordinato in base alla disposizione delle chiavi corrispondenti nella `keys` <xref:System.Array>.  
  
 Ogni chiave nell'intervallo specificato di elementi nel `keys` <xref:System.Array> deve implementare il <xref:System.IComparable%601> generica interfaccia devono essere in grado di eseguire confronti con tutte le altre chiavi.  
  
 È possibile ordinare se sono presenti più elementi di chiavi, ma non verranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente. Se sono presenti più chiavi di elementi; non è possibile ordinare tale operazione viene generata un' <xref:System.ArgumentException>.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload di metodo generico, per l'ordinamento delle coppie di matrici che rappresentano le chiavi e valori.  
  
 L'esempio di codice definisce un operatore alternativo per le stringhe, denominato `ReverseCompare`, che implementa le `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. La chiama comparer il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini in modo che le stringhe ordinate elevata verso il basso, anziché basso verso l'alto.  
  
 L'esempio di codice crea e visualizza una matrice di nomi divorasse (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ogni divorasse in metri (i valori). Le matrici sono quindi ordinate e visualizzate più volte:  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload viene usato per ordinare entrambe le matrici in ordine dei nomi di divorasse nella prima matrice.  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload e un'istanza di `ReverseCompare` vengono utilizzati per invertire l'ordine della coppia di matrici.  
  
-   Il [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > overload viene usato per ordinare gli ultimi tre elementi di entrambe le matrici.  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload viene usato per ordinare gli ultimi tre elementi di entrambe le matrici in ordine inverso.  
  
> [!NOTE]
>  Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle relative controparti non generiche, poiché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti. Se si usa la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="keys" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> non è <see langword="null" /> e il limite inferiore di <paramref name="keys" /> non corrisponde al limite inferiore di <paramref name="items" />.  
  
oppure 
 <paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.  
  
oppure 
 <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="keys" /><see cref="T:System.Array" />.  
  
oppure 
 <paramref name="items" /> non è <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Tipo degli elementi della matrice delle chiavi.</typeparam>
        <typeparam name="TValue">Tipo degli elementi della matrice degli elementi.</typeparam>
        <param name="keys">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero che contiene le chiavi da ordinare.</param>
        <param name="items">Oggetto unidimensionale in base zero <see cref="T:System.Array" /> che contiene gli elementi che corrispondono alle chiavi in <paramref name="keys" /> oppure <see langword="null" /> per ordinare solo <paramref name="keys" />.</param>
        <param name="index">Indice iniziale dell'intervallo da ordinare.</param>
        <param name="length">Numero di elementi nell'intervallo da ordinare.</param>
        <param name="comparer">Implementazione dell'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> da usare per il confronto fra gli elementi oppure <see langword="null" /> per usare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascun elemento.</param>
        <summary>Ordina un intervallo di elementi in una coppia di oggetti <see cref="T:System.Array" /> (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <see cref="T:System.Array" /> usando l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni chiave nel `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>. Quando una chiave viene riposizionato in riferimento durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo. Pertanto, il `items` <xref:System.Array> viene ordinato in base alla disposizione delle chiavi corrispondenti nella `keys` <xref:System.Array>.  
  
 Se `comparer` viene `null`, ogni chiave nell'intervallo specificato di elementi nel `keys` <xref:System.Array> deve implementare il <xref:System.IComparable%601> generica interfaccia devono essere in grado di eseguire confronti con tutte le altre chiavi.  
  
 È possibile ordinare se sono presenti più elementi di chiavi, ma non verranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente. Se sono presenti più chiavi di elementi; non è possibile ordinare tale operazione viene generata un' <xref:System.ArgumentException>.  
  
 Se l'ordinamento non viene completato correttamente, i risultati sono indefiniti.  
  
 Questo metodo Usa l'algoritmo di ordinamento introspettivo (introsort) come indicato di seguito:  
  
-   Se la dimensione della partizione è inferiore a 16 elementi, Usa un' [ordinamento per inserimento](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se il numero di partizioni superiore a 2 * Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   In caso contrario, Usa un' [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Questa implementazione esegue un ordinamento instabile; vale a dire, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta. Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.  
  
 Per le matrici ordinate usando gli algoritmi Heapsort ed eseguiamo quicksort su, nella peggiore delle ipotesi, questo metodo è un'operazione O (`n` registro `n`) operazione, in cui `n` è `length`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > gli overload di metodo generico, per l'ordinamento delle coppie di matrici che rappresentano le chiavi e valori.  
  
 L'esempio di codice definisce un operatore alternativo per le stringhe, denominato `ReverseCompare`, che implementa le `IComparer<string>`(`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica. La chiama comparer il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini in modo che le stringhe ordinate elevata verso il basso, anziché basso verso l'alto.  
  
 L'esempio di codice crea e visualizza una matrice di nomi divorasse (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ogni divorasse in metri (i valori). Le matrici sono quindi ordinate e visualizzate più volte:  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload viene usato per ordinare entrambe le matrici in ordine dei nomi di divorasse nella prima matrice.  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload e un'istanza di `ReverseCompare` vengono utilizzati per invertire l'ordine della coppia di matrici.  
  
-   Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload viene usato per ordinare gli ultimi tre elementi di entrambe le matrici.  
  
-   Il [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > overload viene usato per ordinare gli ultimi tre gli elementi di entrambe le matrici in ordine inverso.  
  
> [!NOTE]
>  Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle relative controparti non generiche, poiché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti. Se si usa la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore del limite inferiore di <paramref name="keys" />.  
  
oppure 
 <paramref name="length" /> è minore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> non è <see langword="null" /> e il limite inferiore di <paramref name="keys" /> non corrisponde al limite inferiore di <paramref name="items" />.  
  
oppure 
 <paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.  
  
oppure 
 <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="keys" /><see cref="T:System.Array" />.  
  
oppure 
 <paramref name="items" /> non è <see langword="null" />, e <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="items" /><see cref="T:System.Array" />.  
  
oppure 
L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento. Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> è <see langword="null" />, e uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage">
          <para>Il .NET Framework 4 e versioni precedenti usano solo l'algoritmo Quicksort. QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante. Inizia con la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, perché gli algoritmi di ordinamento e heapsort inserimento non viene rilevano un operatore di confronto non valido. Nella maggior parte, questo vale per le matrici con meno di 16 elementi.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Esecuzione di operazioni sulle stringhe indipendenti dalle impostazioni cultura nelle matrici</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Array" />.</summary>
        <value>Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà implementa il <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaccia.  
  
 Basano di classi .NET framework <xref:System.Array> forniscono la propria versione sincronizzata della raccolta mediante il <xref:System.Array.SyncRoot%2A> proprietà.  
  
 Le classi che utilizzano le matrici possono anche implementare la propria sincronizzazione utilizzando il <xref:System.Array.SyncRoot%2A> proprietà. Il codice di sincronizzazione deve eseguire operazioni su di `SyncRoot` della raccolta, non direttamente sulla raccolta. In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti. In particolare, mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente la raccolta. Si noti che alcune implementazioni di <xref:System.Array.SyncRoot%2A> potrebbe restituire il <xref:System.Array> stesso.  
  
 Enumerare una raccolta di per sé non è una procedura thread-safe. Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore. Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.  
  
 Il recupero del valore di questa proprietà è un'operazione O(1).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come bloccare la matrice durante l'intera enumerazione tramite la <xref:System.Array.SyncRoot%2A> proprietà.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di elementi contenuti in <see cref="T:System.Array" />.</summary>
        <value>Numero di elementi contenuti nella raccolta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da aggiungere all'oggetto <see cref="T:System.Collections.IList" />.</param>
        <summary>La chiamata di questo metodo genera sempre un'eccezione <see cref="T:System.NotSupportedException" />.</summary>
        <returns>L'aggiunta di valori alla matrice non è supportata. Non vengono restituiti valori.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, un <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementazione aggiunge un membro a una raccolta. Tuttavia, poiché le matrici hanno una dimensione fissa (il <xref:System.Array.IsFixedSize%2A> proprietà restituisce sempre `true`), questo metodo genera sempre un <xref:System.NotSupportedException> eccezione.  
  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le dimensioni dell'oggetto <see cref="T:System.Collections.IList" /> sono fisse.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli elementi da <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La classe <see cref="T:System.Collections.IList" /> è di sola lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da individuare nell'elenco corrente. L'elemento da individuare può essere <see langword="null" /> per i tipi di riferimento.</param>
        <summary>Determina se un elemento è incluso in <see cref="T:System.Collections.IList" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> è presente in <see cref="T:System.Collections.IList" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da individuare nell'elenco corrente.</param>
        <summary>Determina l'indice di un elemento specifico in <see cref="T:System.Collections.IList" />.</summary>
        <returns>Indice di value, se presente nell'elenco; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Indice in cui <paramref name="value" /> dovrebbe essere inserito.</param>
        <param name="value">Oggetto da inserire.</param>
        <summary>Inserisce un elemento in <see cref="T:System.Collections.IList" /> in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è un indice valido nell'interfaccia <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">La classe <see cref="T:System.Collections.IList" /> è di sola lettura.  
  
oppure 
Le dimensioni dell'oggetto <see cref="T:System.Collections.IList" /> sono fisse.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> è un riferimento Null in <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice dell'elemento da ottenere o impostare.</param>
        <summary>Ottiene o imposta l'elemento in corrispondenza dell'indice specificato.</summary>
        <value>Elemento in corrispondenza dell'indice specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> è uguale a o maggiore di <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente una dimensione.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da rimuovere da <see cref="T:System.Collections.IList" />.</param>
        <summary>Rimuove la prima occorrenza di un oggetto specifico da <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La classe <see cref="T:System.Collections.IList" /> è di sola lettura.  
  
oppure 
Le dimensioni dell'oggetto <see cref="T:System.Collections.IList" /> sono fisse.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice dell'elemento da rimuovere.</param>
        <summary>Rimuove l'elemento <see cref="T:System.Collections.IList" /> in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'indice non è valido nell'oggetto <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">La classe <see cref="T:System.Collections.IList" /> è di sola lettura.  
  
oppure 
Le dimensioni dell'oggetto <see cref="T:System.Collections.IList" /> sono fisse.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Oggetto da confrontare con l'istanza corrente.</param>
        <param name="comparer">Oggetto che confronta l'oggetto corrente e <paramref name="other" />.</param>
        <summary>Determina se l'oggetto raccolta corrente precede, è nella stessa posizione o segue un altro oggetto nell'ordinamento.</summary>
        <returns>Intero che indica la relazione tra l'oggetto raccolta corrente e other, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore restituito 
 </term><description> Descrizione 
 </description></listheader><item><term> -1 
 </term><description> L'istanza corrente precede <paramref name="other" />.  
  
 </description></item><item><term> 0 
 </term><description> L'istanza corrente è uguale a <paramref name="other" />.  
  
 </description></item><item><term> 1 
 </term><description> L'istanza corrente segue <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IStructuralComparable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Oggetto da confrontare con l'istanza corrente.</param>
        <param name="comparer">Oggetto che determina se l'istanza corrente e <paramref name="other" /> sono uguali.</param>
        <summary>Determina se un oggetto è uguale all'istanza corrente.</summary>
        <returns>
          <see langword="true" /> se i due oggetti sono uguali; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Oggetto che calcola il codice hash dell'oggetto corrente.</param>
        <summary>Restituisce un codice hash per l'istanza corrente.</summary>
        <returns>Codice hash per l'istanza corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo degli elementi della matrice.</typeparam>
        <param name="array">Oggetto unidimensionale in base zero <see cref="T:System.Array" /> da verificare rispetto alle condizioni.</param>
        <param name="match">Predicato che definisce le condizioni da verificare negli elementi.</param>
        <summary>Determina se ogni elemento della matrice soddisfa le condizioni definite dal predicato specificato.</summary>
        <returns>
          <see langword="true" /> se ogni elemento in <paramref name="array" /> soddisfa le condizioni definite dal predicato specificato; in caso contrario, <see langword="false" />. Se la matrice non contiene elementi, il valore restituito è <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce`true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.  Gli elementi della `array` vengono passati singolarmente per il <xref:System.Predicate%601>, e l'elaborazione viene arrestata al ritorno del delegato `false` per qualsiasi elemento.  
  
 Questo metodo è un'operazione O (`n`) operazione, in cui `n` è la <xref:System.Array.Length%2A> di `array`.  
  
   
  
## Examples  
 Nell'esempio seguente determina se l'ultimo carattere di ogni elemento in una matrice di stringhe è un numero. Crea due matrici di stringhe. Il primo arrayincludes entrambe le stringhe che terminano con caratteri alfabetici e le stringhe che terminano con caratteri numerici. La seconda matrice è costituito solo da stringhe che terminano con caratteri numerici. L'esempio definisce anche un `EndWithANumber` metodo la cui firma corrisponde il <xref:System.Predicate%601> delegare. Nell'esempio vengono passate ogni matrice per il <xref:System.Array.TrueForAll%2A> metodo insieme a un delegato che rappresenta il `EndsWithANumber` (metodo).  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 Nell'esempio seguente è simile al primo, ad eccezione del fatto che passa la matrice di stringhe per il <xref:System.Array.TrueForAll%2A> metodo insieme a un'espressione lambda che determina se un elemento della matrice particolare termina con la rappresentazione di stringa di un numero.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 In entrambi i casi, il <xref:System.Array.TrueForAll%2A> restituzione del metodo `false` , non appena rileva il primo elemento della matrice che non termina con un numero. In caso contrario, restituisce `true` dopo l'iterazione di tutti gli elementi nella matrice.  
  
> [!NOTE]
>  Come illustrano entrambi gli esempi, in c# e Visual Basic, non è necessario creare il `Predicate<string>` delegare (`Predicate(Of String)` in Visual Basic) in modo esplicito. Questi linguaggi in grado di dedurre il delegato corretto dal contesto e creano automaticamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> è <see langword="null" />.  
  
oppure 
 <paramref name="match" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>