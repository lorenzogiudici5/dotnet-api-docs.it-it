<Type Name="Array" FullName="System.Array">
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="289d7-101">Fornisce metodi per creare, manipolare, ordinare ed eseguire ricerche all'interno di matrici, diventando così la classe base per tutte le matrici in Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="289d7-101">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-102">Il <xref:System.Array> classe non è in parte il <xref:System.Collections> gli spazi dei nomi.</span><span class="sxs-lookup"><span data-stu-id="289d7-102">The <xref:System.Array> class is not part of the <xref:System.Collections> namespaces.</span></span> <span data-ttu-id="289d7-103">Tuttavia, questo viene considerato come una raccolta perché è basato sul <xref:System.Collections.IList> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-103">However, it is still considered a collection because it is based on the <xref:System.Collections.IList> interface.</span></span>  
  
 <span data-ttu-id="289d7-104">La <xref:System.Array> classe è la classe base per le implementazioni di linguaggio che supporta le matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-104">The <xref:System.Array> class is the base class for language implementations that support arrays.</span></span> <span data-ttu-id="289d7-105">Tuttavia, solo il sistema e i compilatori possono derivare in modo esplicito la <xref:System.Array> classe.</span><span class="sxs-lookup"><span data-stu-id="289d7-105">However, only the system and compilers can derive explicitly from the <xref:System.Array> class.</span></span> <span data-ttu-id="289d7-106">Gli utenti devono utilizzare i costrutti di matrice specificati dal linguaggio.</span><span class="sxs-lookup"><span data-stu-id="289d7-106">Users should employ the array constructs provided by the language.</span></span>  
  
 <span data-ttu-id="289d7-107">Un elemento è un valore in un <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-107">An element is a value in an <xref:System.Array>.</span></span> <span data-ttu-id="289d7-108">La lunghezza di un <xref:System.Array> è il numero totale di elementi che può contenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-108">The length of an <xref:System.Array> is the total number of elements it can contain.</span></span> <span data-ttu-id="289d7-109">Il limite inferiore di un <xref:System.Array> è l'indice del primo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-109">The lower bound of an <xref:System.Array> is the index of its first element.</span></span> <span data-ttu-id="289d7-110">Un <xref:System.Array> può avere un limite inferiore qualsiasi, ma dispone di un limite inferiore pari a zero per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="289d7-110">An <xref:System.Array> can have any lower bound, but it has a lower bound of zero by default.</span></span> <span data-ttu-id="289d7-111">Può definire un limite inferiore differente durante la creazione di un'istanza del <xref:System.Array> usando <xref:System.Array.CreateInstance%2A>. Un oggetto multidimensionale <xref:System.Array> può avere diversi limiti per ogni dimensione.</span><span class="sxs-lookup"><span data-stu-id="289d7-111">A different lower bound can be defined when creating an instance of the <xref:System.Array> class using <xref:System.Array.CreateInstance%2A>.A multidimensional <xref:System.Array> can have different bounds for each dimension.</span></span> <span data-ttu-id="289d7-112">Una matrice può avere un massimo di 32 dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-112">An array can have a maximum of 32 dimensions.</span></span>  
  
 <span data-ttu-id="289d7-113">A differenza delle classi nel <xref:System.Collections> spazi dei nomi, <xref:System.Array> ha una capacità fissa.</span><span class="sxs-lookup"><span data-stu-id="289d7-113">Unlike the classes in the <xref:System.Collections> namespaces, <xref:System.Array> has a fixed capacity.</span></span> <span data-ttu-id="289d7-114">Per aumentare la capacità, è necessario creare un nuovo <xref:System.Array> oggetto con la capacità richiesta, copiare gli elementi dal vecchio <xref:System.Array> dell'oggetto a quello nuovo ed eliminare il vecchio <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-114">To increase the capacity, you must create a new <xref:System.Array> object with the required capacity, copy the elements from the old <xref:System.Array> object to the new one, and delete the old <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-115">Per impostazione predefinita, le dimensioni massime di un <xref:System.Array> è 2 gigabyte (GB).</span><span class="sxs-lookup"><span data-stu-id="289d7-115">By default, the maximum size of an <xref:System.Array> is 2 gigabytes (GB).</span></span> <span data-ttu-id="289d7-116">In un ambiente a 64 bit, è possibile evitare la limitazione delle dimensioni impostando il `enabled` attributo del [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elemento di configurazione `true` nell'ambiente di runtime.</span><span class="sxs-lookup"><span data-stu-id="289d7-116">In a 64-bit environment, you can avoid the size restriction by setting the `enabled` attribute of the [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration element to `true` in the run-time environment.</span></span> <span data-ttu-id="289d7-117">Tuttavia, la matrice sarà comunque limitata a un totale di 4 miliardi di elementi e in un indice massimo di 0X7FEFFFFF in ogni dimensione specificato (0X7FFFFFC7 per matrici di byte e matrici di strutture a byte singolo).</span><span class="sxs-lookup"><span data-stu-id="289d7-117">However, the array will still be limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</span></span>  
  
 <span data-ttu-id="289d7-118">Matrici unidimensionali di implementare il <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> e <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> interfacce generiche.</span><span class="sxs-lookup"><span data-stu-id="289d7-118">Single-dimensional arrays implement the <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> generic interfaces.</span></span> <span data-ttu-id="289d7-119">Le implementazioni sono fornite alle matrici in fase di esecuzione e di conseguenza, le interfacce generiche non vengono visualizzati nella sintassi della dichiarazione per il <xref:System.Array> classe.</span><span class="sxs-lookup"><span data-stu-id="289d7-119">The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <xref:System.Array> class.</span></span> <span data-ttu-id="289d7-120">Inoltre, non esistono nessun argomento di riferimento per i membri di interfaccia che sono accessibili solo tramite il cast di una matrice per il tipo di interfaccia generica (implementazioni esplicite dell'interfaccia).</span><span class="sxs-lookup"><span data-stu-id="289d7-120">In addition,  there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations).</span></span> <span data-ttu-id="289d7-121">L'aspetto importante da tenere presenti quando si esegue il cast di una matrice a una di queste interfacce è che i membri che aggiungono, inserire o rimuovere elementi generano <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-121">The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="289d7-122"><xref:System.Type> gli oggetti forniscono informazioni sulle dichiarazioni di tipo matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-122"><xref:System.Type> objects provide information about array type declarations.</span></span> <span data-ttu-id="289d7-123"><xref:System.Array> gli oggetti con lo stesso tipo di matrice condividono lo stesso <xref:System.Type> oggetto.</span><span class="sxs-lookup"><span data-stu-id="289d7-123"><xref:System.Array> objects with the same array type share the same <xref:System.Type> object.</span></span>  
  
 <span data-ttu-id="289d7-124"><xref:System.Type.IsArray%2A?displayProperty=nameWithType> e <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> potrebbe non restituire i risultati previsti con <xref:System.Array> poiché se una matrice di cui viene eseguito il cast al tipo <xref:System.Array>, il risultato è un oggetto, non è una matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-124"><xref:System.Type.IsArray%2A?displayProperty=nameWithType> and <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> might not return the expected results with <xref:System.Array> because if an array is cast to the type <xref:System.Array>, the result is an object, not an array.</span></span> <span data-ttu-id="289d7-125">Vale a dire `typeof(System.Array).IsArray` restituisce `false`, e `typeof(System.Array).GetElementType` restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-125">That is, `typeof(System.Array).IsArray` returns `false`, and `typeof(System.Array).GetElementType` returns `null`.</span></span>  
  
 <span data-ttu-id="289d7-126">Il <xref:System.Array.Copy%2A?displayProperty=nameWithType> metodo copia gli elementi non solo tra matrici dello stesso tipo, ma anche tra matrici standard di tipi diversi, gestisce automaticamente il cast di tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-126">The <xref:System.Array.Copy%2A?displayProperty=nameWithType> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</span></span>  
  
 <span data-ttu-id="289d7-127">Alcuni metodi, ad esempio <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, e <xref:System.Array.SetValue%2A>, forniscono overload che accettano numeri interi a 64 bit come parametri per adattare le matrici di grande capacità.</span><span class="sxs-lookup"><span data-stu-id="289d7-127">Some methods, such as <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, and <xref:System.Array.SetValue%2A>, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays.</span></span> <span data-ttu-id="289d7-128"><xref:System.Array.LongLength%2A> e <xref:System.Array.GetLongLength%2A> restituiscono valori integer a 64 bit che indica la lunghezza della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-128"><xref:System.Array.LongLength%2A> and <xref:System.Array.GetLongLength%2A> return 64-bit integers indicating the length of the array.</span></span>  
  
 <span data-ttu-id="289d7-129">Il <xref:System.Array> non è garantito da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-129">The <xref:System.Array> is not guaranteed to be sorted.</span></span>  <span data-ttu-id="289d7-130">È necessario ordinare il <xref:System.Array> prima dell'esecuzione di operazioni (ad esempio <xref:System.Array.BinarySearch%2A>) che richiedono il <xref:System.Array> da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-130">You must sort the <xref:System.Array> prior to performing operations (such as <xref:System.Array.BinarySearch%2A>) that require the <xref:System.Array> to be sorted.</span></span>  
  
 <span data-ttu-id="289d7-131">Utilizzando un <xref:System.Array> oggetto di puntatori in codice nativo non è supportata e genererà un <xref:System.NotSupportedException> per diversi metodi.</span><span class="sxs-lookup"><span data-stu-id="289d7-131">Using an <xref:System.Array> object of pointers in native code is not supported and will throw a <xref:System.NotSupportedException> for several methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-132">Nell'esempio di codice riportato di seguito viene illustrato come <xref:System.Array.Copy%2A?displayProperty=nameWithType> consente di copiare elementi tra una matrice di tipo integer e una matrice di tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="289d7-132">The following code example shows how <xref:System.Array.Copy%2A?displayProperty=nameWithType> copies elements between an array of type integer and an array of type <xref:System.Object>.</span></span>  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 <span data-ttu-id="289d7-133">Esempio di codice seguente crea e Inizializza un <xref:System.Array> e visualizza le proprietà e i relativi elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-133">The following code example creates and initializes an <xref:System.Array> and displays its properties and its elements.</span></span>  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="289d7-134">Statici pubblici (<see langword="Shared" /> in Visual Basic) di questo tipo sono thread-safe.</span><span class="sxs-lookup"><span data-stu-id="289d7-134">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="289d7-135">I membri di istanza non sono garantiti come thread-safe.</span><span class="sxs-lookup"><span data-stu-id="289d7-135">Any instance members are not guaranteed to be thread safe.</span></span>  
  
 <span data-ttu-id="289d7-136">Questa implementazione non fornisce un oggetto sincronizzato wrapper (thread-safe) per un <see cref="T:System.Array" />; tuttavia, le classi di .NET Framework basate su <see cref="T:System.Array" /> fornire una propria versione sincronizzata della raccolta mediante la <see cref="P:System.Array.SyncRoot" /> proprietà.</span><span class="sxs-lookup"><span data-stu-id="289d7-136">This implementation does not provide a synchronized (thread safe) wrapper for an <see cref="T:System.Array" />; however, .NET Framework classes based on <see cref="T:System.Array" /> provide their own synchronized version of the collection using the <see cref="P:System.Array.SyncRoot" /> property.</span></span>  
  
 <span data-ttu-id="289d7-137">L'enumerazione di una raccolta non è di per sé una procedura thread-safe.</span><span class="sxs-lookup"><span data-stu-id="289d7-137">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="289d7-138">Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore.</span><span class="sxs-lookup"><span data-stu-id="289d7-138">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="289d7-139">Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</span><span class="sxs-lookup"><span data-stu-id="289d7-139">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span></threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-140">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-140">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-141">Matrice in base zero unidimensionale da includere in un wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> in sola lettura.</span><span class="sxs-lookup"><span data-stu-id="289d7-141">The one-dimensional, zero-based array to wrap in a read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper.</span></span></param>
        <summary><span data-ttu-id="289d7-142">Restituisce un wrapper di sola lettura per la matrice specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-142">Returns a read-only wrapper for the specified array.</span></span></summary>
        <returns><span data-ttu-id="289d7-143">Wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di sola lettura per la matrice specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-143">A read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper for the specified array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-144">Per evitare eventuali modifiche alla matrice, espongono la matrice solo tramite il wrapper.</span><span class="sxs-lookup"><span data-stu-id="289d7-144">To prevent any modifications to the array, expose the array only through this wrapper.</span></span>  
  
 <span data-ttu-id="289d7-145">Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.</span><span class="sxs-lookup"><span data-stu-id="289d7-145">A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</span></span>  
  
 <span data-ttu-id="289d7-146">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-146">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-147">Nell'esempio seguente esegue il wrapping di una matrice in sola lettura <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="289d7-147">The following example wraps an array in a read-only <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-148"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-148"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-149">Effettua una ricerca in un oggetto <see cref="T:System.Array" /> unidimensionale ordinato per un valore, usando un algoritmo di ricerca binario.</span><span class="sxs-lookup"><span data-stu-id="289d7-149">Searches a one-dimensional sorted <see cref="T:System.Array" /> for a value, using a binary search algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-150">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-150">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-151">Oggetto da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-151">The object to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-152">Cerca un elemento specifico in un'intera raccolta unidimensionale ordinata, usando l'interfaccia <see cref="T:System.IComparable" /> implementata da ogni elemento della matrice e dall'oggetto specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-152">Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified object.</span></span></summary>
        <returns><span data-ttu-id="289d7-153">Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-153">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="289d7-154">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-154">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="289d7-155">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-155">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="289d7-156">Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-156">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-157">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</span><span class="sxs-lookup"><span data-stu-id="289d7-157">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="289d7-158">`array` devono essere ordinati prima di chiamare questo metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-158">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="289d7-159">Se il <xref:System.Array> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-159">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="289d7-160">È possibile applicare l'operatore di complemento bit per bit (~ in c#, `Not` in Visual Basic) per il risultato per produrre un indice negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-160">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="289d7-161">Se l'indice è maggiore del limite superiore della matrice, non sono presenti elementi maggiori `value` nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-161">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="289d7-162">In caso contrario, è l'indice del primo elemento maggiore di `value`.</span><span class="sxs-lookup"><span data-stu-id="289d7-162">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="289d7-163">Sia `value` o ogni elemento di `array` deve implementare il <xref:System.IComparable> interfaccia, che viene utilizzata per i confronti.</span><span class="sxs-lookup"><span data-stu-id="289d7-163">Either `value` or every element of `array` must implement the <xref:System.IComparable> interface, which is used for comparisons.</span></span> <span data-ttu-id="289d7-164">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable> implementazione; in caso contrario, il risultato potrebbe essere errato.</span><span class="sxs-lookup"><span data-stu-id="289d7-164">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-165">Se`value` non implementa il <xref:System.IComparable> interfaccia, gli elementi di `array` non sono stati testati per <xref:System.IComparable> prima dell'inizio della ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-165">If`value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="289d7-166">Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <xref:System.IComparable>.</span><span class="sxs-lookup"><span data-stu-id="289d7-166">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="289d7-167">Sono consentiti elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="289d7-167">Duplicate elements are allowed.</span></span> <span data-ttu-id="289d7-168">Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</span><span class="sxs-lookup"><span data-stu-id="289d7-168">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="289d7-169">`null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-169">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-170">Per ogni elemento verificato, `value` viene passato a appropriato <xref:System.IComparable> implementazione, anche se `value` è `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-170">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="289d7-171">Vale a dire il <xref:System.IComparable> implementazione determina il modo in cui un determinato elemento Confronta a `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-171">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="289d7-172">Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-172">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-173">Esempio di codice seguente viene illustrato come utilizzare <xref:System.Array.BinarySearch%2A> per individuare un oggetto specifico in un <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-173">The following code example shows how to use <xref:System.Array.BinarySearch%2A> to locate a specific object in an <xref:System.Array>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-174">La matrice viene creata con i relativi elementi in ordine crescente.</span><span class="sxs-lookup"><span data-stu-id="289d7-174">The array is created with its elements in ascending sort order.</span></span> <span data-ttu-id="289d7-175">Il <xref:System.Array.BinarySearch%2A> metodo richiede che la matrice sia ordinata in ordine crescente.</span><span class="sxs-lookup"><span data-stu-id="289d7-175">The <xref:System.Array.BinarySearch%2A> method requires the array to be sorted in ascending order.</span></span>  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-176"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-176"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-177"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-177"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-178"><paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-178"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-179"><paramref name="value" /> non implementa l'interfaccia <see cref="T:System.IComparable" /> e la ricerca rileva un elemento che non implementa l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-179"><paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-180">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-180">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-181">Oggetto da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-181">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-182">Implementazione <see cref="T:System.Collections.IComparer" /> da usare quando si confrontano gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-182">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="289d7-183">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-183">-or-</span></span>  
  
 <span data-ttu-id="289d7-184"><see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-184"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-185">Usando l'interfaccia <see cref="T:System.Collections.IComparer" /> specificata, effettua la ricerca di un valore all'interno di una matrice unidimensionale e ordinata.</span><span class="sxs-lookup"><span data-stu-id="289d7-185">Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.IComparer" /> interface.</span></span></summary>
        <returns><span data-ttu-id="289d7-186">Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-186">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="289d7-187">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-187">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="289d7-188">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-188">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="289d7-189">Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-189">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-190">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</span><span class="sxs-lookup"><span data-stu-id="289d7-190">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="289d7-191">`array` devono essere ordinati prima di chiamare questo metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-191">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="289d7-192">Se il <xref:System.Array> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-192">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="289d7-193">È possibile applicare l'operatore di complemento bit per bit (~ in c#, `Not` in Visual Basic) per il risultato per produrre un indice negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-193">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="289d7-194">Se l'indice è maggiore del limite superiore della matrice, non sono presenti elementi maggiori `value` nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-194">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="289d7-195">In caso contrario, è l'indice del primo elemento maggiore di `value`.</span><span class="sxs-lookup"><span data-stu-id="289d7-195">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="289d7-196">L'operatore di confronto consente di personalizzare la modalità di confronto di elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-196">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="289d7-197">Ad esempio, è possibile utilizzare un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="289d7-197">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="289d7-198">Se `comparer` non `null`, gli elementi di `array` vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.IComparer> implementazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-198">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.IComparer> implementation.</span></span> <span data-ttu-id="289d7-199">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito da `comparer`; in caso contrario, il risultato potrebbe non essere corretto.</span><span class="sxs-lookup"><span data-stu-id="289d7-199">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="289d7-200">Se`comparer` è `null`, il confronto viene eseguito utilizzando il <xref:System.IComparable> implementazione fornita dall'elemento stesso o dal valore specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-200">If`comparer` is `null`, the comparison is done using the <xref:System.IComparable> implementation provided by the element itself or by the specified value.</span></span> <span data-ttu-id="289d7-201">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable> implementazione; in caso contrario, il risultato potrebbe essere errato.</span><span class="sxs-lookup"><span data-stu-id="289d7-201">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-202">Se `comparer` è `null` e `value` non implementa il <xref:System.IComparable> interfaccia, gli elementi di `array` non sono stati testati per <xref:System.IComparable> prima dell'inizio della ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-202">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="289d7-203">Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <xref:System.IComparable>.</span><span class="sxs-lookup"><span data-stu-id="289d7-203">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="289d7-204">Sono consentiti elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="289d7-204">Duplicate elements are allowed.</span></span> <span data-ttu-id="289d7-205">Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</span><span class="sxs-lookup"><span data-stu-id="289d7-205">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="289d7-206">`null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-206">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-207">Per ogni elemento verificato, `value` viene passato a appropriato <xref:System.IComparable> implementazione, anche se `value` è `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-207">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="289d7-208">Vale a dire il <xref:System.IComparable> implementazione determina il modo in cui un determinato elemento Confronta a `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-208">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="289d7-209">Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-209">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-210"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-210"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-211"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-211"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-212"><paramref name="comparer" /> è <see langword="null" /> e <paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-212"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-213"><paramref name="comparer" /> è <see langword="null" />, <paramref name="value" /> non implementa l'interfaccia <see cref="T:System.IComparable" /> e la ricerca rileva un elemento che non implementa l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-213"><paramref name="comparer" /> is <see langword="null" />, <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-214">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-214">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-215">Indice iniziale dell'intervallo in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-215">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-216">Lunghezza dell'intervallo in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-216">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-217">Oggetto da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-217">The object to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-218">Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata, usando l'interfaccia <see cref="T:System.IComparable" /> implementata da ogni elemento della matrice e dal valore specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-218">Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified value.</span></span></summary>
        <returns><span data-ttu-id="289d7-219">Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-219">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="289d7-220">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-220">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="289d7-221">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-221">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="289d7-222">Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-222">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-223">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</span><span class="sxs-lookup"><span data-stu-id="289d7-223">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="289d7-224">`array` devono essere ordinati prima di chiamare questo metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-224">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="289d7-225">Se il <xref:System.Array> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-225">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="289d7-226">È possibile applicare l'operatore di complemento bit per bit (~ in c#, `Not` in Visual Basic) per il risultato per produrre un indice negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-226">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result to produce an index.</span></span> <span data-ttu-id="289d7-227">Se l'indice è maggiore del limite superiore della matrice, non sono presenti elementi maggiori `value` nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-227">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="289d7-228">In caso contrario, è l'indice del primo elemento maggiore di `value`.</span><span class="sxs-lookup"><span data-stu-id="289d7-228">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="289d7-229">Sia `value` o ogni elemento di `array` deve implementare il <xref:System.IComparable> interfaccia, che viene utilizzata per i confronti.</span><span class="sxs-lookup"><span data-stu-id="289d7-229">Either `value` or every element of `array` must implement the <xref:System.IComparable> interface, which is used for comparisons.</span></span> <span data-ttu-id="289d7-230">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable> implementazione; in caso contrario, il risultato potrebbe essere errato.</span><span class="sxs-lookup"><span data-stu-id="289d7-230">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-231">Se `value` non implementa il <xref:System.IComparable> interfaccia, gli elementi di `array` non sono stati testati per <xref:System.IComparable> prima dell'inizio della ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-231">If `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="289d7-232">Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <xref:System.IComparable>.</span><span class="sxs-lookup"><span data-stu-id="289d7-232">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="289d7-233">Sono consentiti elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="289d7-233">Duplicate elements are allowed.</span></span> <span data-ttu-id="289d7-234">Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</span><span class="sxs-lookup"><span data-stu-id="289d7-234">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="289d7-235">`null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-235">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-236">Per ogni elemento verificato, `value` viene passato a appropriato <xref:System.IComparable> implementazione, anche se `value` è `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-236">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="289d7-237">Vale a dire il <xref:System.IComparable> implementazione determina il modo in cui un determinato elemento Confronta a `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-237">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="289d7-238">Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-238">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-239"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-239"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-240"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-240"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-241"><paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-241"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-242">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-242">-or-</span></span>  
  
 <span data-ttu-id="289d7-243"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-243"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-244"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-244"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-245">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-245">-or-</span></span>  
  
 <span data-ttu-id="289d7-246"><paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-246"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-247"><paramref name="value" /> non implementa l'interfaccia <see cref="T:System.IComparable" /> e la ricerca rileva un elemento che non implementa l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-247"><paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-248">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-248">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-249">Indice iniziale dell'intervallo in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-249">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-250">Lunghezza dell'intervallo in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-250">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-251">Oggetto da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-251">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-252">Implementazione <see cref="T:System.Collections.IComparer" /> da usare quando si confrontano gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-252">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="289d7-253">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-253">-or-</span></span>  
  
 <span data-ttu-id="289d7-254"><see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-254"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-255">Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata mediante l'interfaccia <see cref="T:System.Collections.IComparer" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-255">Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.IComparer" /> interface.</span></span></summary>
        <returns><span data-ttu-id="289d7-256">Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-256">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="289d7-257">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-257">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="289d7-258">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-258">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="289d7-259">Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-259">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-260">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</span><span class="sxs-lookup"><span data-stu-id="289d7-260">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="289d7-261">`array` devono essere ordinati prima di chiamare questo metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-261">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="289d7-262">Se il <xref:System.Array> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-262">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="289d7-263">È possibile applicare l'operatore di complemento bit per bit (~ in c#, `Not` in Visual Basic) per il risultato per produrre un indice negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-263">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="289d7-264">Se l'indice è maggiore del limite superiore della matrice, non sono presenti elementi maggiori `value` nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-264">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="289d7-265">In caso contrario, è l'indice del primo elemento maggiore di `value`.</span><span class="sxs-lookup"><span data-stu-id="289d7-265">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="289d7-266">L'operatore di confronto consente di personalizzare la modalità di confronto di elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-266">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="289d7-267">Ad esempio, è possibile utilizzare un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="289d7-267">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="289d7-268">Se `comparer` non `null`, gli elementi di `array` vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.IComparer> implementazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-268">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.IComparer> implementation.</span></span> <span data-ttu-id="289d7-269">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito da `comparer`; in caso contrario, il risultato potrebbe non essere corretto.</span><span class="sxs-lookup"><span data-stu-id="289d7-269">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="289d7-270">Se `comparer` è `null`, il confronto viene eseguito utilizzando il <xref:System.IComparable> implementazione fornita dall'elemento stesso o dal valore specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-270">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable> implementation provided by the element itself or by the specified value.</span></span> <span data-ttu-id="289d7-271">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable> implementazione; in caso contrario, il risultato potrebbe essere errato.</span><span class="sxs-lookup"><span data-stu-id="289d7-271">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-272">Se `comparer` è `null` e `value` non implementa il <xref:System.IComparable> interfaccia, gli elementi di `array` non sono stati testati per <xref:System.IComparable> prima dell'inizio della ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-272">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="289d7-273">Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <xref:System.IComparable>.</span><span class="sxs-lookup"><span data-stu-id="289d7-273">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="289d7-274">Sono consentiti elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="289d7-274">Duplicate elements are allowed.</span></span> <span data-ttu-id="289d7-275">Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</span><span class="sxs-lookup"><span data-stu-id="289d7-275">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="289d7-276">`null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non genera un'eccezione quando si usano <xref:System.IComparable>.</span><span class="sxs-lookup"><span data-stu-id="289d7-276">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception when using <xref:System.IComparable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-277">Per ogni elemento verificato, `value` viene passato a appropriato <xref:System.IComparable> implementazione, anche se `value` è `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-277">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="289d7-278">Vale a dire il <xref:System.IComparable> implementazione determina il modo in cui un determinato elemento Confronta a `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-278">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="289d7-279">Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-279">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-280"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-280"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-281"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-281"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-282"><paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-282"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-283">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-283">-or-</span></span>  
  
 <span data-ttu-id="289d7-284"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-284"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-285"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-285"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-286">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-286">-or-</span></span>  
  
 <span data-ttu-id="289d7-287"><paramref name="comparer" /> è <see langword="null" /> e <paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-287"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-288"><paramref name="comparer" /> è <see langword="null" />, <paramref name="value" /> non implementa l'interfaccia <see cref="T:System.IComparable" /> e la ricerca rileva un elemento che non implementa l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-288"><paramref name="comparer" /> is <see langword="null" />, <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-289">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-289">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-290">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in base zero da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-290">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-291">Oggetto da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-291">The object to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-292">Effettua una ricerca in un'intera matrice unidimensionale ordinata per un elemento specifico, usando l'interfaccia generica <see cref="T:System.IComparable`1" /> implementata da ogni elemento di <see cref="T:System.Array" /> e dall'oggetto specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-292">Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable`1" /> generic interface implemented by each element of the <see cref="T:System.Array" /> and by the specified object.</span></span></summary>
        <returns><span data-ttu-id="289d7-293">Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-293">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="289d7-294">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-294">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="289d7-295">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-295">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="289d7-296">Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-296">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-297">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</span><span class="sxs-lookup"><span data-stu-id="289d7-297">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="289d7-298">`array` devono essere ordinati prima di chiamare questo metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-298">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="289d7-299">Se `array` non contiene il valore specificato, il metodo restituisce un numero intero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-299">If `array` does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="289d7-300">È possibile applicare l'operatore di complemento bit per bit (~ in c#, `Not` in Visual Basic) per il risultato per produrre un indice negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-300">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="289d7-301">Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi maggiore `value` nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-301">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="289d7-302">In caso contrario, è l'indice del primo elemento maggiore di `value`.</span><span class="sxs-lookup"><span data-stu-id="289d7-302">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="289d7-303">`T` deve implementare il <xref:System.IComparable%601> interfaccia generica, che viene utilizzato per i confronti.</span><span class="sxs-lookup"><span data-stu-id="289d7-303">`T` must implement the <xref:System.IComparable%601> generic interface, which is used for comparisons.</span></span> <span data-ttu-id="289d7-304">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable%601> implementazione; in caso contrario, il risultato potrebbe essere errato.</span><span class="sxs-lookup"><span data-stu-id="289d7-304">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="289d7-305">Sono consentiti elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="289d7-305">Duplicate elements are allowed.</span></span> <span data-ttu-id="289d7-306">Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</span><span class="sxs-lookup"><span data-stu-id="289d7-306">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="289d7-307">`null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-307">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-308">Per ogni elemento verificato, `value` viene passato a appropriato <xref:System.IComparable%601> implementazione, anche se `value` è `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-308">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="289d7-309">Vale a dire il <xref:System.IComparable%601> implementazione determina il modo in cui un determinato elemento Confronta a `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-309">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="289d7-310">Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-310">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-311">L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> overload del metodo generico e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo generico.</span><span class="sxs-lookup"><span data-stu-id="289d7-311">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload.</span></span> <span data-ttu-id="289d7-312">Viene creata una matrice di stringhe, in nessun ordine particolare.</span><span class="sxs-lookup"><span data-stu-id="289d7-312">An array of strings is created, in no particular order.</span></span>  
  
 <span data-ttu-id="289d7-313">La matrice è visualizzata, ordinata e visualizzata di nuovo.</span><span class="sxs-lookup"><span data-stu-id="289d7-313">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="289d7-314">Le matrici devono essere ordinate per utilizzare il <xref:System.Array.BinarySearch%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-314">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-315">Le chiamate al <xref:System.Array.Sort%2A> e <xref:System.Array.BinarySearch%2A> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</span><span class="sxs-lookup"><span data-stu-id="289d7-315">The calls to the <xref:System.Array.Sort%2A> and <xref:System.Array.BinarySearch%2A> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="289d7-316">Se si utilizza il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-316">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="289d7-317">Il <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo generico viene quindi utilizzato per eseguire la ricerca di due stringhe, uno che non si trova la matrice e uno che.</span><span class="sxs-lookup"><span data-stu-id="289d7-317">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="289d7-318">La matrice e il valore restituito del <xref:System.Array.BinarySearch%2A> metodo vengono passati al `ShowWhere` metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario gli elementi della stringa di ricerca sarebbe compresa se fosse nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-318">The array and the return value of the <xref:System.Array.BinarySearch%2A> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="289d7-319">L'indice è negativo se la stringa non è incluso nella matrice, pertanto la `ShowWhere` metodo accetta il complemento bit per bit (il ~ (operatore) in c# e Visual C++, `Xor`-1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore della ricerca str sta eseguendo un'operazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-319">The index is negative if the string is not in the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor`-1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-320"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-320"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-321"><paramref name="T" /> non implementa l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-321"><paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-322">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-322">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-323">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in base zero da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-323">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-324">Oggetto da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-324">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-325">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare quando si confrontano gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-325">The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="289d7-326">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-326">-or-</span></span>  
  
 <span data-ttu-id="289d7-327"><see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable`1" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-327"><see langword="null" /> to use the <see cref="T:System.IComparable`1" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-328">Mediante l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata, esegue la ricerca di un valore all'interno di una matrice unidimensionale e ordinata.</span><span class="sxs-lookup"><span data-stu-id="289d7-328">Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="289d7-329">Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-329">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="289d7-330">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-330">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="289d7-331">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-331">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="289d7-332">Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-332">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-333">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</span><span class="sxs-lookup"><span data-stu-id="289d7-333">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="289d7-334">`array` devono essere ordinati prima di chiamare questo metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-334">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="289d7-335">Se il <xref:System.Array> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-335">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="289d7-336">È possibile applicare l'operatore di complemento bit per bit (~ in c#, `Not` in Visual Basic) per il risultato per produrre un indice negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-336">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result to produce an index.</span></span> <span data-ttu-id="289d7-337">Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi maggiore `value` nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-337">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="289d7-338">In caso contrario, è l'indice del primo elemento maggiore di `value`.</span><span class="sxs-lookup"><span data-stu-id="289d7-338">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="289d7-339">L'operatore di confronto consente di personalizzare la modalità di confronto di elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-339">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="289d7-340">Ad esempio, è possibile utilizzare un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="289d7-340">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="289d7-341">Se `comparer` non `null`, gli elementi di `array` vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.Generic.IComparer%601> implementazione dell'interfaccia generica.</span><span class="sxs-lookup"><span data-stu-id="289d7-341">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.Generic.IComparer%601> generic interface implementation.</span></span> <span data-ttu-id="289d7-342">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito da `comparer`; in caso contrario, il risultato potrebbe non essere corretto.</span><span class="sxs-lookup"><span data-stu-id="289d7-342">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="289d7-343">Se `comparer` è `null`, il confronto viene eseguito utilizzando il <xref:System.IComparable%601> fornito dall'implementazione dell'interfaccia generica `T`.</span><span class="sxs-lookup"><span data-stu-id="289d7-343">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable%601> generic interface implementation provided by `T`.</span></span> <span data-ttu-id="289d7-344">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable%601> implementazione; in caso contrario, il risultato potrebbe essere errato.</span><span class="sxs-lookup"><span data-stu-id="289d7-344">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-345">Se `comparer` è `null` e `value` non implementa il <xref:System.IComparable%601> interfaccia generica, gli elementi di `array` non sono stati testati per <xref:System.IComparable%601> prima dell'inizio della ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-345">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable%601> generic interface, the elements of `array` are not tested for <xref:System.IComparable%601> before the search begins.</span></span> <span data-ttu-id="289d7-346">Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <xref:System.IComparable%601>.</span><span class="sxs-lookup"><span data-stu-id="289d7-346">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable%601>.</span></span>  
  
 <span data-ttu-id="289d7-347">Sono consentiti elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="289d7-347">Duplicate elements are allowed.</span></span> <span data-ttu-id="289d7-348">Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</span><span class="sxs-lookup"><span data-stu-id="289d7-348">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="289d7-349">`null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-349">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-350">Per ogni elemento verificato, `value` viene passato a appropriato <xref:System.IComparable%601> implementazione, anche se `value` è `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-350">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="289d7-351">Vale a dire il <xref:System.IComparable%601> implementazione determina il modo in cui un determinato elemento Confronta a `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-351">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="289d7-352">Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-352">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-353">Nell'esempio seguente viene illustrato il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico.</span><span class="sxs-lookup"><span data-stu-id="289d7-353">The following example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload.</span></span>  
  
 <span data-ttu-id="289d7-354">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato `ReverseCompare`, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica.</span><span class="sxs-lookup"><span data-stu-id="289d7-354">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="289d7-355">Operatore di confronto chiama il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</span><span class="sxs-lookup"><span data-stu-id="289d7-355">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="289d7-356">La matrice è visualizzata, ordinata e visualizzata di nuovo.</span><span class="sxs-lookup"><span data-stu-id="289d7-356">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="289d7-357">Le matrici devono essere ordinate per utilizzare il <xref:System.Array.BinarySearch%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-357">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-358">Le chiamate al <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</span><span class="sxs-lookup"><span data-stu-id="289d7-358">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="289d7-359">Se si utilizza il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-359">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="289d7-360">Il <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico viene quindi utilizzato per eseguire la ricerca di due stringhe, uno che non si trova la matrice e uno che.</span><span class="sxs-lookup"><span data-stu-id="289d7-360">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="289d7-361">La matrice e il valore restituito del <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodo vengono passati al `ShowWhere` metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario gli elementi della stringa di ricerca sarebbe compresa se fosse nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-361">The array and the return value of the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="289d7-362">L'indice è negativo se la stringa non è inclusa nella matrice, pertanto la `ShowWhere` metodo accetta il complemento bit per bit (il ~ operatore in c# e Visual C++, `Xor` -1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore di stri di ricerca NG.</span><span class="sxs-lookup"><span data-stu-id="289d7-362">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-363"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-363"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-364"><paramref name="comparer" /> è <see langword="null" /> e <paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-364"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-365"><paramref name="comparer" /> è <see langword="null" /> e <paramref name="T" /> non implementa l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-365"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface</span></span></exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-366">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-366">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-367">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-367">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-368">Indice iniziale dell'intervallo in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-368">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-369">Lunghezza dell'intervallo in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-369">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-370">Oggetto da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-370">The object to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-371">Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata, usando l'interfaccia generica <see cref="T:System.IComparable`1" /> implementata da ogni elemento dell'oggetto <see cref="T:System.Array" /> e dal valore specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-371">Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable`1" /> generic interface implemented by each element of the <see cref="T:System.Array" /> and by the specified value.</span></span></summary>
        <returns><span data-ttu-id="289d7-372">Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-372">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="289d7-373">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-373">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="289d7-374">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-374">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="289d7-375">Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-375">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-376">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</span><span class="sxs-lookup"><span data-stu-id="289d7-376">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="289d7-377">`array` devono essere ordinati prima di chiamare questo metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-377">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="289d7-378">Se la matrice non contiene il valore specificato, il metodo restituisce un numero intero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-378">If the array does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="289d7-379">È possibile applicare l'operatore di complemento bit per bit (~ in c#, `Not` in Visual Basic) per il risultato per produrre un indice negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-379">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="289d7-380">Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi maggiore `value` nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-380">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="289d7-381">In caso contrario, è l'indice del primo elemento maggiore di `value`.</span><span class="sxs-lookup"><span data-stu-id="289d7-381">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="289d7-382">`T` deve implementare il <xref:System.IComparable%601> interfaccia generica, che viene utilizzato per i confronti.</span><span class="sxs-lookup"><span data-stu-id="289d7-382">`T` must implement the <xref:System.IComparable%601> generic interface, which is used for comparisons.</span></span> <span data-ttu-id="289d7-383">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable%601> implementazione; in caso contrario, il risultato potrebbe essere errato.</span><span class="sxs-lookup"><span data-stu-id="289d7-383">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="289d7-384">Sono consentiti elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="289d7-384">Duplicate elements are allowed.</span></span> <span data-ttu-id="289d7-385">Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</span><span class="sxs-lookup"><span data-stu-id="289d7-385">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="289d7-386">`null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non generano un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-386">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-387">Per ogni elemento verificato, `value` viene passato a appropriato <xref:System.IComparable%601> implementazione, anche se `value` è `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-387">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="289d7-388">Vale a dire il <xref:System.IComparable%601> implementazione determina il modo in cui un determinato elemento Confronta a `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-388">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="289d7-389">Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-389">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-390"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-390"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-391"><paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-391"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-392">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-392">-or-</span></span>  
  
 <span data-ttu-id="289d7-393"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-393"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-394"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-394"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-395">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-395">-or-</span></span>  
  
 <span data-ttu-id="289d7-396"><paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-396"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-397"><paramref name="T" /> non implementa l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-397"><paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-398">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-398">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-399">Oggetto <see cref="T:System.Array" /> ordinato unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-399">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-400">Indice iniziale dell'intervallo in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-400">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-401">Lunghezza dell'intervallo in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-401">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-402">Oggetto da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-402">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-403">Implementazione <see cref="T:System.Collections.Generic.IComparer`1" /> da usare quando si confrontano gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-403">The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="289d7-404">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-404">-or-</span></span>  
  
 <span data-ttu-id="289d7-405"><see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable`1" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-405"><see langword="null" /> to use the <see cref="T:System.IComparable`1" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-406">Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata mediante l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-406">Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="289d7-407">Indice del parametro <paramref name="value" /> specificato nel parametro <paramref name="array" /> specificato, se viene trovato <paramref name="value" />; in caso contrario, un numero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-407">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="289d7-408">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è minore di uno o più elementi presenti in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-408">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="289d7-409">Se <paramref name="value" /> non viene trovato e <paramref name="value" /> è maggiore di tutti gli elementi in <paramref name="array" />, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-409">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="289d7-410">Se questo metodo viene chiamato con un oggetto <paramref name="array" /> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <paramref name="value" /> è presente in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-410">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-411">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</span><span class="sxs-lookup"><span data-stu-id="289d7-411">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="289d7-412">`array` devono essere ordinati prima di chiamare questo metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-412">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="289d7-413">Se la matrice non contiene il valore specificato, il metodo restituisce un numero intero negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-413">If the array does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="289d7-414">È possibile applicare l'operatore di complemento bit per bit (~ in c#, `Not` in Visual Basic) per il risultato per produrre un indice negativo.</span><span class="sxs-lookup"><span data-stu-id="289d7-414">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="289d7-415">Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi maggiore `value` nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-415">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="289d7-416">In caso contrario, è l'indice del primo elemento maggiore di `value`.</span><span class="sxs-lookup"><span data-stu-id="289d7-416">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="289d7-417">L'operatore di confronto consente di personalizzare la modalità di confronto di elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-417">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="289d7-418">Ad esempio, è possibile utilizzare un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="289d7-418">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="289d7-419">Se `comparer` non `null`, gli elementi di `array` vengono confrontati con il valore specificato utilizzando l'oggetto specificato <xref:System.Collections.Generic.IComparer%601> implementazione dell'interfaccia generica.</span><span class="sxs-lookup"><span data-stu-id="289d7-419">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.Generic.IComparer%601> generic interface implementation.</span></span> <span data-ttu-id="289d7-420">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito da `comparer`; in caso contrario, il risultato potrebbe non essere corretto.</span><span class="sxs-lookup"><span data-stu-id="289d7-420">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="289d7-421">Se `comparer` è `null`, il confronto viene eseguito utilizzando il <xref:System.IComparable%601> fornito per il tipo di implementazione dell'interfaccia generica `T`.</span><span class="sxs-lookup"><span data-stu-id="289d7-421">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable%601> generic interface implementation provided for type `T`.</span></span> <span data-ttu-id="289d7-422">Gli elementi di `array` già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <xref:System.IComparable%601> implementazione; in caso contrario, il risultato potrebbe essere errato.</span><span class="sxs-lookup"><span data-stu-id="289d7-422">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="289d7-423">Sono consentiti elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="289d7-423">Duplicate elements are allowed.</span></span> <span data-ttu-id="289d7-424">Se il <xref:System.Array> contiene più di un elemento uguale a `value`, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</span><span class="sxs-lookup"><span data-stu-id="289d7-424">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="289d7-425">`null` può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con `null` non genera un'eccezione quando si usano <xref:System.IComparable%601>.</span><span class="sxs-lookup"><span data-stu-id="289d7-425">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception when using <xref:System.IComparable%601>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-426">Per ogni elemento verificato, `value` viene passato a appropriato <xref:System.IComparable%601> implementazione, anche se `value` è `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-426">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="289d7-427">Vale a dire il <xref:System.IComparable%601> implementazione determina il modo in cui un determinato elemento Confronta a `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-427">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="289d7-428">Questo metodo è un'operazione O (log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-428">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-429"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-429"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-430"><paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-430"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-431">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-431">-or-</span></span>  
  
 <span data-ttu-id="289d7-432"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-432"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-433"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-433"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-434">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-434">-or-</span></span>  
  
 <span data-ttu-id="289d7-435"><paramref name="comparer" /> è <see langword="null" /> e <paramref name="value" /> è di un tipo non compatibile con gli elementi di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-435"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-436"><paramref name="comparer" /> è <see langword="null" /> e <paramref name="T" /> non implementa l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-436"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-437">Matrice i cui elementi devono essere cancellati.</span><span class="sxs-lookup"><span data-stu-id="289d7-437">The array whose elements need to be cleared.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-438">Indice iniziale dell'intervallo di elementi da cancellare.</span><span class="sxs-lookup"><span data-stu-id="289d7-438">The starting index of the range of elements to clear.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-439">Numero di elementi da cancellare.</span><span class="sxs-lookup"><span data-stu-id="289d7-439">The number of elements to clear.</span></span></param>
        <summary><span data-ttu-id="289d7-440">Imposta un intervallo di elementi in una matrice sul valore predefinito di ogni tipo di elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-440">Sets a range of elements in an array to the default value of each element type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-441">Questo metodo viene reimpostato ogni elemento in una matrice sul valore predefinito del tipo di elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-441">This method resets each element in an array to the element type's default value.</span></span> <span data-ttu-id="289d7-442">Imposta gli elementi dei tipi di riferimento (inclusi <xref:System.String> elementi) per `null`e imposta gli elementi di tipi di valore per i valori predefiniti illustrati nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="289d7-442">It sets elements of reference types (including <xref:System.String> elements) to `null`, and sets elements of value types to the default values shown in the following table.</span></span>  
  
|<span data-ttu-id="289d7-443">Tipo</span><span class="sxs-lookup"><span data-stu-id="289d7-443">Type</span></span>|<span data-ttu-id="289d7-444">Valore</span><span class="sxs-lookup"><span data-stu-id="289d7-444">Value</span></span>|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|<span data-ttu-id="289d7-445">Tutti i tipi numerici integrali e a virgola mobile</span><span class="sxs-lookup"><span data-stu-id="289d7-445">All integral and floating point numeric types</span></span>|<span data-ttu-id="289d7-446">0 (zero)</span><span class="sxs-lookup"><span data-stu-id="289d7-446">0 (zero)</span></span>|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|<span data-ttu-id="289d7-447">Altri tipi di valore</span><span class="sxs-lookup"><span data-stu-id="289d7-447">Other value types</span></span>|<span data-ttu-id="289d7-448">Valore predefinito di campi del tipo</span><span class="sxs-lookup"><span data-stu-id="289d7-448">Default value of the type's fields</span></span>|  
  
 <span data-ttu-id="289d7-449">L'intervallo di elementi cancellati dalla riga per riga in una matrice multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-449">The range of cleared elements wrap from row to row in a multi-dimensional array.</span></span>  
  
 <span data-ttu-id="289d7-450">Questo metodo cancella solo i valori di elementi. non elimina gli elementi stessi.</span><span class="sxs-lookup"><span data-stu-id="289d7-450">This method only clears the values of the elements; it does not delete the elements themselves.</span></span> <span data-ttu-id="289d7-451">Una matrice ha dimensioni fisse. di conseguenza, non è possibile aggiungere o rimuovere elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-451">An array has a fixed size; therefore, elements cannot be added or removed.</span></span>  
  
 <span data-ttu-id="289d7-452">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-452">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-453">L'esempio seguente usa il <xref:System.Array.Clear%2A> per reimpostare i valori interi in una matrice unidimensionale, bidimensionale e tridimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-453">The following example uses the <xref:System.Array.Clear%2A> method to reset integer values in a one-dimensional, two-dimensional, and three-dimensional array.</span></span>  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 <span data-ttu-id="289d7-454">L'esempio seguente definisce un `TimeZoneTime` struttura che include un <xref:System.TimeZoneInfo> campo e un <xref:System.DateTimeOffset> campo.</span><span class="sxs-lookup"><span data-stu-id="289d7-454">The following example defines a `TimeZoneTime` structure that includes a <xref:System.TimeZoneInfo> field and a <xref:System.DateTimeOffset> field.</span></span> <span data-ttu-id="289d7-455">Chiama quindi il <xref:System.Array.Clear%2A> metodo per eliminare un elemento in una matrice di due elementi di `TimeZoneTime` valori.</span><span class="sxs-lookup"><span data-stu-id="289d7-455">It then calls the <xref:System.Array.Clear%2A> method to clear one element in a two-element array of `TimeZoneTime` values.</span></span> <span data-ttu-id="289d7-456">Il metodo imposta il valore dell'elemento cancellata per il valore predefinito di un <xref:System.TimeZoneInfo> oggetto, ovvero `null`e il valore predefinito di un <xref:System.DateTimeOffset> oggetto, ovvero <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="289d7-456">The method sets the value of the cleared element to the default value of a <xref:System.TimeZoneInfo> object, which is `null`, and the default value of a <xref:System.DateTimeOffset> object, which is <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-457"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-457"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="289d7-458"><paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-458"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-459">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-459">-or-</span></span>  
  
 <span data-ttu-id="289d7-460"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-460"><paramref name="length" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-461">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-461">-or-</span></span>  
  
 <span data-ttu-id="289d7-462">La somma di <paramref name="index" /> e <paramref name="length" /> è maggiore della dimensione di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-462">The sum of <paramref name="index" /> and <paramref name="length" /> is greater than the size of <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="289d7-463">Crea una copia superficiale di <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-463">Creates a shallow copy of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="289d7-464">Copia superficiale di <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-464">A shallow copy of the <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-465">Una copia superficiale di un <xref:System.Array> copia solo gli elementi del <xref:System.Array>, indipendentemente che siano tipi riferimento o tipi di valore, ma non copia gli oggetti che fanno riferimento i riferimenti a.</span><span class="sxs-lookup"><span data-stu-id="289d7-465">A shallow copy of an <xref:System.Array> copies only the elements of the <xref:System.Array>, whether they are reference types or value types, but it does not copy the objects that the references refer to.</span></span> <span data-ttu-id="289d7-466">I riferimenti nel nuovo <xref:System.Array> puntano allo stesso gli oggetti che i riferimenti nell'originale <xref:System.Array> scegliere.</span><span class="sxs-lookup"><span data-stu-id="289d7-466">The references in the new <xref:System.Array> point to the same objects that the references in the original <xref:System.Array> point to.</span></span>  
  
 <span data-ttu-id="289d7-467">Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-467">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="289d7-468">Il clone è dello stesso <xref:System.Type> dell'originale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-468">The clone is of the same <xref:System.Type> as the original <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-469">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Array.Length%2A>.</span><span class="sxs-lookup"><span data-stu-id="289d7-469">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-470">Nell'esempio di codice riportato di seguito viene cloni un <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> di matrice e viene illustrato il comportamento di una copia superficiale.</span><span class="sxs-lookup"><span data-stu-id="289d7-470">The following code example clones a <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> array and demonstrates the behavior of a shallow copy.</span></span>  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="289d7-471">Oggetto <see cref="T:System.Array" /> che contiene i dati da copiare.</span><span class="sxs-lookup"><span data-stu-id="289d7-471">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="289d7-472">Integer a 32 bit che rappresenta l'indice in <c>sourceArray</c> da cui viene avviata la copia.</span><span class="sxs-lookup"><span data-stu-id="289d7-472">A 32-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="289d7-473">Oggetto <see cref="T:System.Array" /> che riceve i dati.</span><span class="sxs-lookup"><span data-stu-id="289d7-473">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="289d7-474">Integer a 32 bit che rappresenta l'indice in <c>destinationArray</c> da cui viene avviata la copia.</span><span class="sxs-lookup"><span data-stu-id="289d7-474">A 32-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-475">Intero a 32 bit che rappresenta il numero degli elementi da copiare.</span><span class="sxs-lookup"><span data-stu-id="289d7-475">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="289d7-476">Copia un intervallo di elementi da un oggetto <see cref="T:System.Array" /> a partire dall'indice di origine specificato e lo incolla in un altro oggetto <see cref="T:System.Array" /> a partire dall'indice di destinazione specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-476">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span>  <span data-ttu-id="289d7-477">Garantisce che tutte le modifiche vengano annullate se la copia non riesce completamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-477">Guarantees that all changes are undone if the copy does not succeed completely.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-478">Il `sourceArray` e `destinationArray` i parametri devono contenere lo stesso numero di dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-478">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span>  <span data-ttu-id="289d7-479">Il `sourceArray` tipo deve essere uguale o derivato dal `destinationArray` tipo; in caso contrario, un <xref:System.ArrayTypeMismatchException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-479">The `sourceArray` type must be the same as or derived from the `destinationArray` type; otherwise, an <xref:System.ArrayTypeMismatchException> is thrown.</span></span>  <span data-ttu-id="289d7-480">A differenza di <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> verifica la compatibilità dei tipi di matrice prima di eseguire qualsiasi operazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-480">Unlike <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> verifies the compatibility of the array types before performing any operation.</span></span>  
  
 <span data-ttu-id="289d7-481">Durante la copia tra le matrici multidimensionali, la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o le colonne) sono concettualmente disposte end-to-end.</span><span class="sxs-lookup"><span data-stu-id="289d7-481">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="289d7-482">Ad esempio, se una matrice dispone di tre righe (o le colonne) con quattro elementi, ogni copiando sei elementi dall'inizio della matrice copiava tutti e quattro gli elementi della prima riga (o della colonna) e i primi due elementi della seconda riga (o colonna).</span><span class="sxs-lookup"><span data-stu-id="289d7-482">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="289d7-483">Per avviare la copia dal secondo elemento della terza riga (o colonna), `sourceIndex` deve essere il limite superiore della prima riga (o colonna) più la lunghezza della seconda riga (o colonna) più due.</span><span class="sxs-lookup"><span data-stu-id="289d7-483">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="289d7-484">Se `sourceArray` e `destinationArray` si sovrappongono, questo metodo si comporta come se i valori originali di `sourceArray` siano stati conservati in un percorso temporaneo prima `destinationArray` viene sovrascritto.</span><span class="sxs-lookup"><span data-stu-id="289d7-484">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="289d7-485">[C++]</span><span class="sxs-lookup"><span data-stu-id="289d7-485">[C++]</span></span>  
  
 <span data-ttu-id="289d7-486">Questo metodo è equivalente alla funzione standard C/C++ `memmove`, non `memcpy`.</span><span class="sxs-lookup"><span data-stu-id="289d7-486">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="289d7-487">Le matrici possono essere matrici di tipo riferimento o matrici di tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="289d7-487">The arrays can be reference-type arrays or value-type arrays.</span></span>  <span data-ttu-id="289d7-488">Se `sourceArray` e `destinationArray` sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <xref:System.Object>, viene eseguita una copia superficiale.</span><span class="sxs-lookup"><span data-stu-id="289d7-488">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="289d7-489">Una copia superficiale di un <xref:System.Array> è una nuova <xref:System.Array> contenenti riferimenti agli stessi elementi originale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-489">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="289d7-490">Gli elementi stessi o qualsiasi elemento a cui fa riferimento gli elementi non vengono copiati.</span><span class="sxs-lookup"><span data-stu-id="289d7-490">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="289d7-491">Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-491">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="289d7-492">Se questo metodo genera un'eccezione durante la copia, il `destinationArray` rimane invariata; pertanto, <xref:System.Array.ConstrainedCopy%2A> può essere utilizzato all'interno di un'area a esecuzione vincolata (<xref:System.Runtime.ConstrainedExecution.Cer>).</span><span class="sxs-lookup"><span data-stu-id="289d7-492">If this method throws an exception while copying, the `destinationArray` remains unchanged; therefore, <xref:System.Array.ConstrainedCopy%2A> can be used within a constrained execution region (<xref:System.Runtime.ConstrainedExecution.Cer>).</span></span>  
  
 <span data-ttu-id="289d7-493">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-493">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-494"><paramref name="sourceArray" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-494"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-495">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-495">-or-</span></span>  
  
 <span data-ttu-id="289d7-496"><paramref name="destinationArray" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-496"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-497"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> hanno classificazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="289d7-497"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="289d7-498">Il tipo <paramref name="sourceArray" /> non è né lo stesso né derivato dal tipo <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-498">The <paramref name="sourceArray" /> type is neither the same as nor derived from the <paramref name="destinationArray" /> type.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="289d7-499">Non è possibile eseguire il cast di almeno un elemento in <paramref name="sourceArray" /> al tipo di <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-499">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-500"><paramref name="sourceIndex" /> è minore del limite inferiore della prima dimensione di <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-500"><paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="289d7-501">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-501">-or-</span></span>  
  
 <span data-ttu-id="289d7-502"><paramref name="destinationIndex" /> è minore del limite inferiore della prima dimensione di <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-502"><paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.</span></span>  
  
 <span data-ttu-id="289d7-503">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-503">-or-</span></span>  
  
 <span data-ttu-id="289d7-504"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-504"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-505"><paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="sourceIndex" /> e la fine di <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-505"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="289d7-506">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-506">-or-</span></span>  
  
 <span data-ttu-id="289d7-507"><paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="destinationIndex" /> e la fine di <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-507"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput"><span data-ttu-id="289d7-508">Tipo degli elementi della matrice di origine.</span><span class="sxs-lookup"><span data-stu-id="289d7-508">The type of the elements of the source array.</span></span></typeparam>
        <typeparam name="TOutput"><span data-ttu-id="289d7-509">Tipo degli elementi della matrice di destinazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-509">The type of the elements of the target array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-510">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero da convertire in un tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-510">The one-dimensional, zero-based <see cref="T:System.Array" /> to convert to a target type.</span></span></param>
        <param name="converter"><span data-ttu-id="289d7-511">Oggetto <see cref="T:System.Converter`2" /> che converte ogni elemento da un tipo a un altro.</span><span class="sxs-lookup"><span data-stu-id="289d7-511">A <see cref="T:System.Converter`2" /> that converts each element from one type to another type.</span></span></param>
        <summary><span data-ttu-id="289d7-512">Converte una matrice di un tipo in una matrice di un altro tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-512">Converts an array of one type to an array of another type.</span></span></summary>
        <returns><span data-ttu-id="289d7-513">Matrice del tipo di destinazione contenente gli elementi convertiti dalla matrice di origine.</span><span class="sxs-lookup"><span data-stu-id="289d7-513">An array of the target type containing the converted elements from the source array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-514">Il <xref:System.Converter%602> è un delegato a un metodo che converte un oggetto per il tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-514">The <xref:System.Converter%602> is a delegate to a method that converts an object to the target type.</span></span>  <span data-ttu-id="289d7-515">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Converter%602>, e gli elementi convertiti vengono salvati nella nuova matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-515">The elements of `array` are individually passed to the <xref:System.Converter%602>, and the converted elements are saved in the new array.</span></span>  
  
 <span data-ttu-id="289d7-516">L'origine `array` rimane invariato.</span><span class="sxs-lookup"><span data-stu-id="289d7-516">The source `array` remains unchanged.</span></span>  
  
 <span data-ttu-id="289d7-517">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-517">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-518">Esempio di codice seguente definisce un metodo denominato `PointFToPoint` che converte un <xref:System.Drawing.PointF> struttura in un <xref:System.Drawing.Point> struttura.</span><span class="sxs-lookup"><span data-stu-id="289d7-518">The following code example defines a method named `PointFToPoint` that converts a <xref:System.Drawing.PointF> structure to a <xref:System.Drawing.Point> structure.</span></span> <span data-ttu-id="289d7-519">Viene quindi creata una matrice di <xref:System.Drawing.PointF> strutture, crea un `Converter<PointF, Point>` delegato (`Converter(Of PointF, Point)` in Visual Basic) per rappresentare il `PointFToPoint` metodo e passa il delegato per il <xref:System.Array.ConvertAll%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-519">The example then creates an array of <xref:System.Drawing.PointF> structures, creates a `Converter<PointF, Point>` delegate (`Converter(Of PointF, Point)` in Visual Basic) to represent the `PointFToPoint` method, and passes the delegate to the <xref:System.Array.ConvertAll%2A> method.</span></span> <span data-ttu-id="289d7-520">Il <xref:System.Array.ConvertAll%2A> metodo passa ogni elemento dell'elenco di input per il `PointFToPoint` (metodo) e inserisce gli elementi convertiti in un nuovo elenco di <xref:System.Drawing.Point> strutture.</span><span class="sxs-lookup"><span data-stu-id="289d7-520">The <xref:System.Array.ConvertAll%2A> method passes each element of the input list to the `PointFToPoint` method and puts the converted elements into a new list of <xref:System.Drawing.Point> structures.</span></span> <span data-ttu-id="289d7-521">Entrambi gli elenchi vengono visualizzati.</span><span class="sxs-lookup"><span data-stu-id="289d7-521">Both lists are displayed.</span></span>  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-522"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-522"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-523">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-523">-or-</span></span>  
  
 <span data-ttu-id="289d7-524"><paramref name="converter" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-524"><paramref name="converter" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-525">Copia un intervallo di elementi di un oggetto <see cref="T:System.Array" /> in un altro oggetto <see cref="T:System.Array" /> ed esegue il cast e il boxing del tipo secondo le necessità.</span><span class="sxs-lookup"><span data-stu-id="289d7-525">Copies a range of elements in one <see cref="T:System.Array" /> to another <see cref="T:System.Array" /> and performs type casting and boxing as required.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="289d7-526">Oggetto <see cref="T:System.Array" /> che contiene i dati da copiare.</span><span class="sxs-lookup"><span data-stu-id="289d7-526">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="289d7-527">Oggetto <see cref="T:System.Array" /> che riceve i dati.</span><span class="sxs-lookup"><span data-stu-id="289d7-527">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-528">Intero a 32 bit che rappresenta il numero degli elementi da copiare.</span><span class="sxs-lookup"><span data-stu-id="289d7-528">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="289d7-529">Copia un intervallo di elementi da un oggetto <see cref="T:System.Array" /> a partire dal primo elemento e lo incolla in un altro oggetto <see cref="T:System.Array" /> a partire dal primo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-529">Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element.</span></span> <span data-ttu-id="289d7-530">La lunghezza viene specificata come intero a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-530">The length is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-531">Il `sourceArray` e `destinationArray` i parametri devono contenere lo stesso numero di dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-531">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="289d7-532">Inoltre, `destinationArray` deve già dimensionata e deve avere un numero sufficiente di elementi da includere tutti i dati copiati.</span><span class="sxs-lookup"><span data-stu-id="289d7-532">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="289d7-533">Durante la copia tra le matrici multidimensionali, la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o le colonne) sono concettualmente disposte end-to-end.</span><span class="sxs-lookup"><span data-stu-id="289d7-533">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</span></span> <span data-ttu-id="289d7-534">Ad esempio, se una matrice dispone di tre righe (o le colonne) con quattro elementi, ogni copiando sei elementi dall'inizio della matrice copiava tutti e quattro gli elementi della prima riga (o della colonna) e i primi due elementi della seconda riga (o colonna).</span><span class="sxs-lookup"><span data-stu-id="289d7-534">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span>  
  
 <span data-ttu-id="289d7-535">Se `sourceArray` e `destinationArray` si sovrappongono, questo metodo si comporta come se i valori originali di `sourceArray` siano stati conservati in un percorso temporaneo prima `destinationArray` viene sovrascritto.</span><span class="sxs-lookup"><span data-stu-id="289d7-535">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="289d7-536">[C++]</span><span class="sxs-lookup"><span data-stu-id="289d7-536">[C++]</span></span>  
  
 <span data-ttu-id="289d7-537">Questo metodo è equivalente alla funzione standard C/C++ `memmove`, non `memcpy`.</span><span class="sxs-lookup"><span data-stu-id="289d7-537">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="289d7-538">Le matrici possono essere matrici di tipo riferimento o matrici di tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="289d7-538">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="289d7-539">Viene eseguito il downcast del tipo, come richiesto.</span><span class="sxs-lookup"><span data-stu-id="289d7-539">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="289d7-540">Durante la copia da una matrice di tipo riferimento a una matrice di tipo di valore, ogni elemento è unboxed e quindi copiata.</span><span class="sxs-lookup"><span data-stu-id="289d7-540">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="289d7-541">Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.</span><span class="sxs-lookup"><span data-stu-id="289d7-541">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="289d7-542">Quando si copia da una matrice di tipo riferimento o tipo di valore a un <xref:System.Object> matrice, un <xref:System.Object> viene creata per contenere ogni valore o riferimento e quindi copiata.</span><span class="sxs-lookup"><span data-stu-id="289d7-542">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="289d7-543">Durante la copia da un <xref:System.Object> matrice a una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <xref:System.InvalidCastException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-543">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="289d7-544">Se `sourceArray` e `destinationArray` sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <xref:System.Object>, viene eseguita una copia superficiale.</span><span class="sxs-lookup"><span data-stu-id="289d7-544">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="289d7-545">Una copia superficiale di un <xref:System.Array> è una nuova <xref:System.Array> contenenti riferimenti agli stessi elementi originale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-545">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="289d7-546">Gli elementi stessi o qualsiasi elemento a cui fa riferimento gli elementi non vengono copiati.</span><span class="sxs-lookup"><span data-stu-id="289d7-546">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="289d7-547">Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-547">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="289d7-548">Un <xref:System.ArrayTypeMismatchException> viene generato se le matrici di tipi incompatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-548">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="289d7-549">Compatibilità del tipo viene definita come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-549">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="289d7-550">Un tipo è compatibile con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-550">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="289d7-551">È compatibile con un tipo di valore <xref:System.Object> e con un'interfaccia implementata dal tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="289d7-551">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="289d7-552">Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa l'interfaccia direttamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-552">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="289d7-553">I tipi disconnessi non sono compatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-553">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="289d7-554">Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine al tipo di destinazione è una conversione di ampliamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-554">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="289d7-555">Una conversione widening mai perdite di informazioni, mentre una conversione di narrowing può provocare la perdita di informazioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-555">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="289d7-556">Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e la conversione di un intero con segno a 64 bit in un intero con segno a 32 bit è una conversione di narrowing.</span><span class="sxs-lookup"><span data-stu-id="289d7-556">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="289d7-557">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-557">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="289d7-558">Un tipo di valore (definita dall'utente) non intrinseco è compatibile solo con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-558">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="289d7-559">Le enumerazioni dispongono di una conversione implicita a <xref:System.Enum> e al tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="289d7-559">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="289d7-560">Se ogni elemento in `sourceArray` richiede un downcast (ad esempio, da una classe base per una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in `destinationArray`, un <xref:System.InvalidCastException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-560">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="289d7-561">Se questo metodo genera un'eccezione durante la copia, lo stato di `destinationArray` non è definito.</span><span class="sxs-lookup"><span data-stu-id="289d7-561">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="289d7-562">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-562">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-563"><paramref name="sourceArray" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-563"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-564">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-564">-or-</span></span>  
  
 <span data-ttu-id="289d7-565"><paramref name="destinationArray" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-565"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-566"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> hanno classificazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="289d7-566"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="289d7-567">I tipi di <paramref name="sourceArray" /> e <paramref name="destinationArray" /> sono incompatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-567"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="289d7-568">Non è possibile eseguire il cast di almeno un elemento in <paramref name="sourceArray" /> al tipo di <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-568">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-569"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-569"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-570"><paramref name="length" /> è maggiore del numero di elementi in <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-570"><paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="289d7-571">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-571">-or-</span></span>  
  
 <span data-ttu-id="289d7-572"><paramref name="length" /> è maggiore del numero di elementi in <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-572"><paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="289d7-573">Oggetto <see cref="T:System.Array" /> che contiene i dati da copiare.</span><span class="sxs-lookup"><span data-stu-id="289d7-573">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="289d7-574">Oggetto <see cref="T:System.Array" /> che riceve i dati.</span><span class="sxs-lookup"><span data-stu-id="289d7-574">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-575">Intero a 64 bit che rappresenta il numero di elementi da copiare.</span><span class="sxs-lookup"><span data-stu-id="289d7-575">A 64-bit integer that represents the number of elements to copy.</span></span> <span data-ttu-id="289d7-576">L'intero deve essere compreso tra zero e <see cref="F:System.Int32.MaxValue" />, inclusi.</span><span class="sxs-lookup"><span data-stu-id="289d7-576">The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="289d7-577">Copia un intervallo di elementi da un oggetto <see cref="T:System.Array" /> a partire dal primo elemento e lo incolla in un altro oggetto <see cref="T:System.Array" /> a partire dal primo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-577">Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element.</span></span> <span data-ttu-id="289d7-578">La lunghezza viene specificata come intero a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-578">The length is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-579">Il `sourceArray` e `destinationArray` i parametri devono contenere lo stesso numero di dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-579">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="289d7-580">Inoltre, `destinationArray` deve già dimensionata e deve avere un numero sufficiente di elementi da includere tutti i dati copiati.</span><span class="sxs-lookup"><span data-stu-id="289d7-580">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="289d7-581">Durante la copia tra le matrici multidimensionali, la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o le colonne) sono concettualmente disposte end-to-end.</span><span class="sxs-lookup"><span data-stu-id="289d7-581">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</span></span> <span data-ttu-id="289d7-582">Ad esempio, se una matrice dispone di tre righe (o le colonne) con quattro elementi, ogni copiando sei elementi dall'inizio della matrice copiava tutti e quattro gli elementi della prima riga (o della colonna) e i primi due elementi della seconda riga (o colonna).</span><span class="sxs-lookup"><span data-stu-id="289d7-582">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span>  
  
 <span data-ttu-id="289d7-583">Se `sourceArray` e `destinationArray` si sovrappongono, questo metodo si comporta come se i valori originali di `sourceArray` siano stati conservati in un percorso temporaneo prima `destinationArray` viene sovrascritto.</span><span class="sxs-lookup"><span data-stu-id="289d7-583">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="289d7-584">[C++]</span><span class="sxs-lookup"><span data-stu-id="289d7-584">[C++]</span></span>  
  
 <span data-ttu-id="289d7-585">Questo metodo è equivalente alla funzione standard C/C++ `memmove`, non `memcpy`.</span><span class="sxs-lookup"><span data-stu-id="289d7-585">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="289d7-586">Le matrici possono essere matrici di tipo riferimento o matrici di tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="289d7-586">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="289d7-587">Viene eseguito il downcast del tipo, come richiesto.</span><span class="sxs-lookup"><span data-stu-id="289d7-587">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="289d7-588">Durante la copia da una matrice di tipo riferimento a una matrice di tipo di valore, ogni elemento è unboxed e quindi copiata.</span><span class="sxs-lookup"><span data-stu-id="289d7-588">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="289d7-589">Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.</span><span class="sxs-lookup"><span data-stu-id="289d7-589">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="289d7-590">Quando si copia da una matrice di tipo riferimento o tipo di valore a un <xref:System.Object> matrice, un <xref:System.Object> viene creata per contenere ogni valore o riferimento e quindi copiata.</span><span class="sxs-lookup"><span data-stu-id="289d7-590">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="289d7-591">Durante la copia da un <xref:System.Object> matrice a una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <xref:System.InvalidCastException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-591">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="289d7-592">Se `sourceArray` e `destinationArray` sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <xref:System.Object>, viene eseguita una copia superficiale.</span><span class="sxs-lookup"><span data-stu-id="289d7-592">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="289d7-593">Una copia superficiale di un <xref:System.Array> è una nuova <xref:System.Array> contenenti riferimenti agli stessi elementi originale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-593">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="289d7-594">Gli elementi stessi o qualsiasi elemento a cui fa riferimento gli elementi non vengono copiati.</span><span class="sxs-lookup"><span data-stu-id="289d7-594">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="289d7-595">Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-595">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="289d7-596">Un <xref:System.ArrayTypeMismatchException> viene generato se le matrici di tipi incompatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-596">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="289d7-597">Compatibilità del tipo viene definita come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-597">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="289d7-598">Un tipo è compatibile con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-598">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="289d7-599">È compatibile con un tipo di valore <xref:System.Object> e con un'interfaccia implementata dal tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="289d7-599">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="289d7-600">Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa l'interfaccia direttamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-600">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="289d7-601">I tipi disconnessi non sono compatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-601">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="289d7-602">Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine al tipo di destinazione è una conversione di ampliamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-602">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="289d7-603">Una conversione widening mai perdite di informazioni, mentre una conversione di narrowing può provocare la perdita di informazioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-603">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="289d7-604">Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e la conversione di un intero con segno a 64 bit in un intero con segno a 32 bit è una conversione di narrowing.</span><span class="sxs-lookup"><span data-stu-id="289d7-604">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="289d7-605">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-605">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="289d7-606">Un tipo di valore (definita dall'utente) non intrinseco è compatibile solo con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-606">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="289d7-607">Le enumerazioni dispongono di una conversione implicita a <xref:System.Enum> e al tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="289d7-607">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="289d7-608">Se ogni elemento in `sourceArray` richiede un downcast (ad esempio, da una classe base per una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in `destinationArray`, un <xref:System.InvalidCastException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-608">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="289d7-609">Se questo metodo genera un'eccezione durante la copia, lo stato di `destinationArray` non è definito.</span><span class="sxs-lookup"><span data-stu-id="289d7-609">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="289d7-610">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-610">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-611"><paramref name="sourceArray" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-611"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-612">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-612">-or-</span></span>  
  
 <span data-ttu-id="289d7-613"><paramref name="destinationArray" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-613"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-614"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> hanno classificazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="289d7-614"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="289d7-615">I tipi di <paramref name="sourceArray" /> e <paramref name="destinationArray" /> sono incompatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-615"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="289d7-616">Non è possibile eseguire il cast di almeno un elemento in <paramref name="sourceArray" /> al tipo di <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-616">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-617"><paramref name="length" /> è minore di 0 o maggiore di <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-617"><paramref name="length" /> is less than 0 or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-618"><paramref name="length" /> è maggiore del numero di elementi in <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-618"><paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="289d7-619">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-619">-or-</span></span>  
  
 <span data-ttu-id="289d7-620"><paramref name="length" /> è maggiore del numero di elementi in <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-620"><paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="289d7-621">Oggetto <see cref="T:System.Array" /> che contiene i dati da copiare.</span><span class="sxs-lookup"><span data-stu-id="289d7-621">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="289d7-622">Integer a 32 bit che rappresenta l'indice in <c>sourceArray</c> da cui viene avviata la copia.</span><span class="sxs-lookup"><span data-stu-id="289d7-622">A 32-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="289d7-623">Oggetto <see cref="T:System.Array" /> che riceve i dati.</span><span class="sxs-lookup"><span data-stu-id="289d7-623">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="289d7-624">Integer a 32 bit che rappresenta l'indice in <c>destinationArray</c> da cui viene avviata la copia.</span><span class="sxs-lookup"><span data-stu-id="289d7-624">A 32-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-625">Intero a 32 bit che rappresenta il numero degli elementi da copiare.</span><span class="sxs-lookup"><span data-stu-id="289d7-625">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="289d7-626">Copia un intervallo di elementi da un oggetto <see cref="T:System.Array" /> a partire dall'indice di origine specificato e lo incolla in un altro oggetto <see cref="T:System.Array" /> a partire dall'indice di destinazione specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-626">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span> <span data-ttu-id="289d7-627">La lunghezza e gli indici vengono specificati come interi a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-627">The length and the indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-628">Il `sourceArray` e `destinationArray` i parametri devono contenere lo stesso numero di dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-628">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="289d7-629">Inoltre, `destinationArray` deve già dimensionata e deve avere un numero sufficiente di elementi a partire dal `destinationIndex` posizione per contenere i dati copiati.</span><span class="sxs-lookup"><span data-stu-id="289d7-629">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements starting from the `destinationIndex` position to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="289d7-630">Durante la copia tra le matrici multidimensionali, la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o le colonne) sono concettualmente disposte end-to-end.</span><span class="sxs-lookup"><span data-stu-id="289d7-630">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="289d7-631">Ad esempio, se una matrice dispone di tre righe (o le colonne) con quattro elementi, ogni copiando sei elementi dall'inizio della matrice copiava tutti e quattro gli elementi della prima riga (o della colonna) e i primi due elementi della seconda riga (o colonna).</span><span class="sxs-lookup"><span data-stu-id="289d7-631">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="289d7-632">Per avviare la copia dal secondo elemento della terza riga (o colonna), `sourceIndex` deve essere il limite superiore della prima riga (o colonna) più la lunghezza della seconda riga (o colonna) più due.</span><span class="sxs-lookup"><span data-stu-id="289d7-632">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="289d7-633">Se `sourceArray` e `destinationArray` si sovrappongono, questo metodo si comporta come se i valori originali di `sourceArray` siano stati conservati in un percorso temporaneo prima `destinationArray` viene sovrascritto.</span><span class="sxs-lookup"><span data-stu-id="289d7-633">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="289d7-634">[C++]</span><span class="sxs-lookup"><span data-stu-id="289d7-634">[C++]</span></span>  
  
 <span data-ttu-id="289d7-635">Questo metodo è equivalente alla funzione standard C/C++ `memmove`, non `memcpy`.</span><span class="sxs-lookup"><span data-stu-id="289d7-635">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="289d7-636">Le matrici possono essere matrici di tipo riferimento o matrici di tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="289d7-636">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="289d7-637">Viene eseguito il downcast del tipo, come richiesto.</span><span class="sxs-lookup"><span data-stu-id="289d7-637">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="289d7-638">Durante la copia da una matrice di tipo riferimento a una matrice di tipo di valore, ogni elemento è unboxed e quindi copiata.</span><span class="sxs-lookup"><span data-stu-id="289d7-638">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="289d7-639">Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.</span><span class="sxs-lookup"><span data-stu-id="289d7-639">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="289d7-640">Quando si copia da una matrice di tipo riferimento o tipo di valore a un <xref:System.Object> matrice, un <xref:System.Object> viene creata per contenere ogni valore o riferimento e quindi copiata.</span><span class="sxs-lookup"><span data-stu-id="289d7-640">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="289d7-641">Durante la copia da un <xref:System.Object> matrice a una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <xref:System.InvalidCastException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-641">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="289d7-642">Se `sourceArray` e `destinationArray` sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <xref:System.Object>, viene eseguita una copia superficiale.</span><span class="sxs-lookup"><span data-stu-id="289d7-642">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="289d7-643">Una copia superficiale di un <xref:System.Array> è una nuova <xref:System.Array> contenenti riferimenti agli stessi elementi originale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-643">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="289d7-644">Gli elementi stessi o qualsiasi elemento a cui fa riferimento gli elementi non vengono copiati.</span><span class="sxs-lookup"><span data-stu-id="289d7-644">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="289d7-645">Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-645">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="289d7-646">Un <xref:System.ArrayTypeMismatchException> viene generato se le matrici di tipi incompatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-646">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="289d7-647">Compatibilità del tipo viene definita come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-647">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="289d7-648">Un tipo è compatibile con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-648">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="289d7-649">È compatibile con un tipo di valore <xref:System.Object> e con un'interfaccia implementata dal tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="289d7-649">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="289d7-650">Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa l'interfaccia direttamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-650">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="289d7-651">I tipi disconnessi non sono compatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-651">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="289d7-652">Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine al tipo di destinazione è una conversione di ampliamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-652">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="289d7-653">Una conversione widening mai perdite di informazioni, mentre una conversione di narrowing può provocare la perdita di informazioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-653">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="289d7-654">Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e la conversione di un intero con segno a 64 bit in un intero con segno a 32 bit è una conversione di narrowing.</span><span class="sxs-lookup"><span data-stu-id="289d7-654">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="289d7-655">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-655">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="289d7-656">Un tipo di valore (definita dall'utente) non intrinseco è compatibile solo con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-656">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="289d7-657">Le enumerazioni dispongono di una conversione implicita a <xref:System.Enum> e al tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="289d7-657">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="289d7-658">Se ogni elemento in `sourceArray` richiede un downcast (ad esempio, da una classe base per una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in `destinationArray`, un <xref:System.InvalidCastException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-658">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="289d7-659">Se questo metodo genera un'eccezione durante la copia, lo stato di `destinationArray` non è definito.</span><span class="sxs-lookup"><span data-stu-id="289d7-659">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="289d7-660">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-660">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-661">Esempio di codice seguente viene illustrato come copiare da una <xref:System.Array> di tipo <xref:System.Object> a un altro <xref:System.Array> di tipo integer.</span><span class="sxs-lookup"><span data-stu-id="289d7-661">The following code example shows how to copy from one <xref:System.Array> of type <xref:System.Object> to another <xref:System.Array> of type integer.</span></span>  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-662"><paramref name="sourceArray" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-662"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-663">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-663">-or-</span></span>  
  
 <span data-ttu-id="289d7-664"><paramref name="destinationArray" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-664"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-665"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> hanno classificazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="289d7-665"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="289d7-666">I tipi di <paramref name="sourceArray" /> e <paramref name="destinationArray" /> sono incompatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-666"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="289d7-667">Non è possibile eseguire il cast di almeno un elemento in <paramref name="sourceArray" /> al tipo di <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-667">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-668"><paramref name="sourceIndex" /> è minore del limite inferiore della prima dimensione di <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-668"><paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="289d7-669">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-669">-or-</span></span>  
  
 <span data-ttu-id="289d7-670"><paramref name="destinationIndex" /> è minore del limite inferiore della prima dimensione di <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-670"><paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.</span></span>  
  
 <span data-ttu-id="289d7-671">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-671">-or-</span></span>  
  
 <span data-ttu-id="289d7-672"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-672"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-673"><paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="sourceIndex" /> e la fine di <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-673"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="289d7-674">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-674">-or-</span></span>  
  
 <span data-ttu-id="289d7-675"><paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="destinationIndex" /> e la fine di <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-675"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="289d7-676">Oggetto <see cref="T:System.Array" /> che contiene i dati da copiare.</span><span class="sxs-lookup"><span data-stu-id="289d7-676">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="289d7-677">Integer a 64 bit che rappresenta l'indice in <c>sourceArray</c> da cui viene avviata la copia.</span><span class="sxs-lookup"><span data-stu-id="289d7-677">A 64-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="289d7-678">Oggetto <see cref="T:System.Array" /> che riceve i dati.</span><span class="sxs-lookup"><span data-stu-id="289d7-678">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="289d7-679">Integer a 64 bit che rappresenta l'indice in <c>destinationArray</c> da cui viene avviata la copia.</span><span class="sxs-lookup"><span data-stu-id="289d7-679">A 64-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-680">Intero a 64 bit che rappresenta il numero di elementi da copiare.</span><span class="sxs-lookup"><span data-stu-id="289d7-680">A 64-bit integer that represents the number of elements to copy.</span></span> <span data-ttu-id="289d7-681">L'intero deve essere compreso tra zero e <see cref="F:System.Int32.MaxValue" />, inclusi.</span><span class="sxs-lookup"><span data-stu-id="289d7-681">The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="289d7-682">Copia un intervallo di elementi da un oggetto <see cref="T:System.Array" /> a partire dall'indice di origine specificato e lo incolla in un altro oggetto <see cref="T:System.Array" /> a partire dall'indice di destinazione specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-682">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span> <span data-ttu-id="289d7-683">La lunghezza e gli indici vengono specificati come interi a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-683">The length and the indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-684">Il `sourceArray` e `destinationArray` i parametri devono contenere lo stesso numero di dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-684">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="289d7-685">Inoltre, `destinationArray` deve già dimensionata e deve avere un numero sufficiente di elementi a partire dal `destinationIndex` posizione per contenere i dati copiati.</span><span class="sxs-lookup"><span data-stu-id="289d7-685">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements starting from the `destinationIndex` position to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="289d7-686">Durante la copia tra le matrici multidimensionali, la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o le colonne) sono concettualmente disposte end-to-end.</span><span class="sxs-lookup"><span data-stu-id="289d7-686">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="289d7-687">Ad esempio, se una matrice dispone di tre righe (o le colonne) con quattro elementi, ogni copiando sei elementi dall'inizio della matrice copiava tutti e quattro gli elementi della prima riga (o della colonna) e i primi due elementi della seconda riga (o colonna).</span><span class="sxs-lookup"><span data-stu-id="289d7-687">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="289d7-688">Per avviare la copia dal secondo elemento della terza riga (o colonna), `sourceIndex` deve essere il limite superiore della prima riga (o colonna) più la lunghezza della seconda riga (o colonna) più due.</span><span class="sxs-lookup"><span data-stu-id="289d7-688">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="289d7-689">Se `sourceArray` e `destinationArray` si sovrappongono, questo metodo si comporta come se i valori originali di `sourceArray` siano stati conservati in un percorso temporaneo prima `destinationArray` viene sovrascritto.</span><span class="sxs-lookup"><span data-stu-id="289d7-689">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="289d7-690">[C++]</span><span class="sxs-lookup"><span data-stu-id="289d7-690">[C++]</span></span>  
  
 <span data-ttu-id="289d7-691">Questo metodo è equivalente alla funzione standard C/C++ `memmove`, non `memcpy`.</span><span class="sxs-lookup"><span data-stu-id="289d7-691">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="289d7-692">Le matrici possono essere matrici di tipo riferimento o matrici di tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="289d7-692">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="289d7-693">Viene eseguito il downcast del tipo, come richiesto.</span><span class="sxs-lookup"><span data-stu-id="289d7-693">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="289d7-694">Durante la copia da una matrice di tipo riferimento a una matrice di tipo di valore, ogni elemento è unboxed e quindi copiata.</span><span class="sxs-lookup"><span data-stu-id="289d7-694">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="289d7-695">Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.</span><span class="sxs-lookup"><span data-stu-id="289d7-695">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="289d7-696">Quando si copia da una matrice di tipo riferimento o tipo di valore a un <xref:System.Object> matrice, un <xref:System.Object> viene creata per contenere ogni valore o riferimento e quindi copiata.</span><span class="sxs-lookup"><span data-stu-id="289d7-696">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="289d7-697">Durante la copia da un <xref:System.Object> matrice a una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <xref:System.InvalidCastException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-697">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="289d7-698">Se `sourceArray` e `destinationArray` sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <xref:System.Object>, viene eseguita una copia superficiale.</span><span class="sxs-lookup"><span data-stu-id="289d7-698">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="289d7-699">Una copia superficiale di un <xref:System.Array> è una nuova <xref:System.Array> contenenti riferimenti agli stessi elementi originale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-699">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="289d7-700">Gli elementi stessi o qualsiasi elemento a cui fa riferimento gli elementi non vengono copiati.</span><span class="sxs-lookup"><span data-stu-id="289d7-700">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="289d7-701">Al contrario, una copia completa di un <xref:System.Array> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-701">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="289d7-702">Un <xref:System.ArrayTypeMismatchException> viene generato se le matrici di tipi incompatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-702">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="289d7-703">Compatibilità del tipo viene definita come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-703">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="289d7-704">Un tipo è compatibile con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-704">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="289d7-705">È compatibile con un tipo di valore <xref:System.Object> e con un'interfaccia implementata dal tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="289d7-705">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="289d7-706">Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa l'interfaccia direttamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-706">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="289d7-707">I tipi disconnessi non sono compatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-707">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="289d7-708">Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine al tipo di destinazione è una conversione di ampliamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-708">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="289d7-709">Una conversione widening mai perdite di informazioni, mentre una conversione di narrowing può provocare la perdita di informazioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-709">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="289d7-710">Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e la conversione di un intero con segno a 64 bit in un intero con segno a 32 bit è una conversione di narrowing.</span><span class="sxs-lookup"><span data-stu-id="289d7-710">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="289d7-711">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-711">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="289d7-712">Un tipo di valore (definita dall'utente) non intrinseco è compatibile solo con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-712">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="289d7-713">Le enumerazioni dispongono di una conversione implicita a <xref:System.Enum> e al tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="289d7-713">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="289d7-714">Se ogni elemento in `sourceArray` richiede un downcast (ad esempio, da una classe base per una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in `destinationArray`, un <xref:System.InvalidCastException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-714">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="289d7-715">Se questo metodo genera un'eccezione durante la copia, lo stato di `destinationArray` non è definito.</span><span class="sxs-lookup"><span data-stu-id="289d7-715">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="289d7-716">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-716">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-717">Esempio di codice seguente viene illustrato come copiare da una <xref:System.Array> di tipo <xref:System.Object> a un altro <xref:System.Array> di tipo integer.</span><span class="sxs-lookup"><span data-stu-id="289d7-717">The following code example shows how to copy from one <xref:System.Array> of type <xref:System.Object> to another <xref:System.Array> of type integer.</span></span>  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-718"><paramref name="sourceArray" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-718"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-719">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-719">-or-</span></span>  
  
 <span data-ttu-id="289d7-720"><paramref name="destinationArray" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-720"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-721"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> hanno classificazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="289d7-721"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="289d7-722">I tipi di <paramref name="sourceArray" /> e <paramref name="destinationArray" /> sono incompatibili.</span><span class="sxs-lookup"><span data-stu-id="289d7-722"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="289d7-723">Non è possibile eseguire il cast di almeno un elemento in <paramref name="sourceArray" /> al tipo di <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-723">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-724"><paramref name="sourceIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-724"><paramref name="sourceIndex" /> is outside the range of valid indexes for the <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="289d7-725">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-725">-or-</span></span>  
  
 <span data-ttu-id="289d7-726"><paramref name="destinationIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-726"><paramref name="destinationIndex" /> is outside the range of valid indexes for the <paramref name="destinationArray" />.</span></span>  
  
 <span data-ttu-id="289d7-727">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-727">-or-</span></span>  
  
 <span data-ttu-id="289d7-728"><paramref name="length" /> è minore di 0 o maggiore di <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-728"><paramref name="length" /> is less than 0 or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-729"><paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="sourceIndex" /> e la fine di <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-729"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="289d7-730">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-730">-or-</span></span>  
  
 <span data-ttu-id="289d7-731"><paramref name="length" /> è maggiore del numero di elementi compresi tra <paramref name="destinationIndex" /> e la fine di <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-731"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-732">Copia tutti gli elementi dell'attuale matrice unidimensionale nella matrice unidimensionale specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-732">Copies all the elements of the current one-dimensional array to the specified one-dimensional array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-733">Matrice unidimensionale che costituisce la destinazione degli elementi copiati dalla matrice corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-733">The one-dimensional array that is the destination of the elements copied from the current array.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-734">Integer a 32 bit che rappresenta l'indice in <c>array</c> da cui viene avviata la copia.</span><span class="sxs-lookup"><span data-stu-id="289d7-734">A 32-bit integer that represents the index in <c>array</c> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="289d7-735">Copia tutti gli elementi dell'attuale matrice unidimensionale nella matrice unidimensionale specificata a partire dall'indice della matrice di destinazione indicato.</span><span class="sxs-lookup"><span data-stu-id="289d7-735">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</span></span> <span data-ttu-id="289d7-736">L'indice viene specificato come intero a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-736">The index is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-737">Questo metodo copia tutti gli elementi dell'istanza corrente di matrice per la `array` matrice di destinazione, a partire dall'indice `index`.</span><span class="sxs-lookup"><span data-stu-id="289d7-737">This method copies all the elements of the current array instance to the `array` destination array, starting at index `index`.</span></span> <span data-ttu-id="289d7-738">Il `array` matrice di destinazione deve già dimensionata e deve avere un numero sufficiente di elementi per contenere gli elementi copiati.</span><span class="sxs-lookup"><span data-stu-id="289d7-738">The `array` destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</span></span> <span data-ttu-id="289d7-739">In caso contrario, il metodo genererà un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-739">Otherwise, the method throws an exception.</span></span>  
  
 <span data-ttu-id="289d7-740">Questo metodo supporta il <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-740">This method supports the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="289d7-741">Se l'implementazione <xref:System.Collections.ICollection?displayProperty=nameWithType> è necessario non in modo esplicito, utilizzare <xref:System.Array.Copy%2A> per evitare un riferimento indiretto aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="289d7-741">If implementing <xref:System.Collections.ICollection?displayProperty=nameWithType> is not explicitly required, use <xref:System.Array.Copy%2A> to avoid an extra indirection.</span></span>  
  
 <span data-ttu-id="289d7-742">Se questo metodo genera un'eccezione durante la copia, lo stato di `array` non è definito.</span><span class="sxs-lookup"><span data-stu-id="289d7-742">If this method throws an exception while copying, the state of `array` is undefined.</span></span>  
  
 <span data-ttu-id="289d7-743">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Array.Length%2A>. Consente di eseguire solo una copia superficiale.</span><span class="sxs-lookup"><span data-stu-id="289d7-743">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.It performs a shallow copy only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-744">Esempio di codice seguente viene illustrato come copiare un <xref:System.Array> a un altro <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-744">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 <span data-ttu-id="289d7-745">Esempio di codice seguente viene illustrato come copiare un <xref:System.Array> a un altro <xref:System.Array> con limite inferiore diverso da zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-745">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array> with a nonzero lower bound.</span></span> <span data-ttu-id="289d7-746">Si noti che l'intera origine <xref:System.Array> viene copiato, inclusi gli elementi vuoti che sovrascrivono gli elementi esistenti nella destinazione <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-746">Note that the entire source <xref:System.Array> is copied, including empty elements that overwrite existing elements in the target <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-747"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-747"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-748"><paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-748"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-749"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-749"><paramref name="array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="289d7-750">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-750">-or-</span></span>  
  
 <span data-ttu-id="289d7-751">Il numero di elementi nella matrice di origine è maggiore del numero disponibile di elementi da <paramref name="index" /> alla fine dell'oggetto <paramref name="array" /> di destinazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-751">The number of elements in the source array is greater than the available number of elements from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="289d7-752">Non è possibile eseguire il cast automatico del tipo dell'oggetto <see cref="T:System.Array" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-752">The type of the source <see cref="T:System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="289d7-753">La matrice di origine è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-753">The source array is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="289d7-754">Non è possibile eseguire il cast di almeno un elemento nell'oggetto <see cref="T:System.Array" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-754">At least one element in the source <see cref="T:System.Array" /> cannot be cast to the type of destination <paramref name="array" />.</span></span></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-755">Matrice unidimensionale che costituisce la destinazione degli elementi copiati dalla matrice corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-755">The one-dimensional array that is the destination of the elements copied from the current array.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-756">Integer a 64 bit che rappresenta l'indice in <c>array</c> da cui viene avviata la copia.</span><span class="sxs-lookup"><span data-stu-id="289d7-756">A 64-bit integer that represents the index in <c>array</c> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="289d7-757">Copia tutti gli elementi dell'attuale matrice unidimensionale nella matrice unidimensionale specificata a partire dall'indice della matrice di destinazione indicato.</span><span class="sxs-lookup"><span data-stu-id="289d7-757">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</span></span> <span data-ttu-id="289d7-758">L'indice viene specificato come intero a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-758">The index is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-759">Questo metodo copia tutti gli elementi dell'istanza corrente di matrice per la `array` matrice di destinazione, a partire dall'indice `index`.</span><span class="sxs-lookup"><span data-stu-id="289d7-759">This method copies all the elements of the current array instance to the `array` destination array, starting at index `index`.</span></span> <span data-ttu-id="289d7-760">Il `array` matrice di destinazione deve già dimensionata e deve avere un numero sufficiente di elementi per contenere gli elementi copiati.</span><span class="sxs-lookup"><span data-stu-id="289d7-760">The `array` destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</span></span> <span data-ttu-id="289d7-761">In caso contrario, il metodo genererà un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-761">Otherwise, the method throws an exception.</span></span>  
  
 <span data-ttu-id="289d7-762">Questo metodo supporta il <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-762">This method supports the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="289d7-763">Se l'implementazione <xref:System.Collections.ICollection?displayProperty=nameWithType> è necessario non in modo esplicito, utilizzare <xref:System.Array.Copy%2A> per evitare un riferimento indiretto aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="289d7-763">If implementing <xref:System.Collections.ICollection?displayProperty=nameWithType> is not explicitly required, use <xref:System.Array.Copy%2A> to avoid an extra indirection.</span></span>  
  
 <span data-ttu-id="289d7-764">Se questo metodo genera un'eccezione durante la copia, lo stato di `array` non è definito.</span><span class="sxs-lookup"><span data-stu-id="289d7-764">If this method throws an exception while copying, the state of `array` is undefined.</span></span>  
  
 <span data-ttu-id="289d7-765">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Array.Length%2A>. Consente di eseguire solo una copia superficiale.</span><span class="sxs-lookup"><span data-stu-id="289d7-765">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.It performs a shallow copy only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-766">Esempio di codice seguente viene illustrato come copiare un <xref:System.Array> a un altro <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-766">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 <span data-ttu-id="289d7-767">Esempio di codice seguente viene illustrato come copiare un <xref:System.Array> a un altro <xref:System.Array> con limite inferiore diverso da zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-767">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array> with a nonzero lower bound.</span></span> <span data-ttu-id="289d7-768">Si noti che l'intera origine <xref:System.Array> viene copiato, inclusi gli elementi vuoti che sovrascrivono gli elementi esistenti nella destinazione <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-768">Note that the entire source <xref:System.Array> is copied, including empty elements that overwrite existing elements in the target <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-769"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-769"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-770"><paramref name="index" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-770"><paramref name="index" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-771"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-771"><paramref name="array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="289d7-772">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-772">-or-</span></span>  
  
 <span data-ttu-id="289d7-773">Il numero di elementi nella matrice di origine è maggiore del numero disponibile di elementi da <paramref name="index" /> alla fine dell'oggetto <paramref name="array" /> di destinazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-773">The number of elements in the source array is greater than the available number of elements from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="289d7-774">Non è possibile eseguire il cast automatico del tipo dell'oggetto <see cref="T:System.Array" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-774">The type of the source <see cref="T:System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="289d7-775">L'origine <see cref="T:System.Array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-775">The source <see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="289d7-776">Non è possibile eseguire il cast di almeno un elemento nell'oggetto <see cref="T:System.Array" /> di origine al tipo dell'oggetto <paramref name="array" /> di destinazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-776">At least one element in the source <see cref="T:System.Array" /> cannot be cast to the type of destination <paramref name="array" />.</span></span></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-777">Inizializza una nuova istanza della classe <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-777">Initializes a new instance of the <see cref="T:System.Array" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="289d7-778">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-778">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-779">Dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-779">The size of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="289d7-780">Crea un oggetto <see cref="T:System.Array" /> unidimensionale dell'oggetto <see cref="T:System.Type" /> specificato e della lunghezza, con indice in base zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-780">Creates a one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and length, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="289d7-781">Nuovo oggetto <see cref="T:System.Array" /> unidimensionale dell'oggetto <see cref="T:System.Type" /> specificato con la lunghezza indicata e con indice in base zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-781">A new one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-782">A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</span><span class="sxs-lookup"><span data-stu-id="289d7-782">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="289d7-783">Gli elementi di tipo di riferimento vengono inizializzati `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-783">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="289d7-784">Gli elementi di tipo di valore vengono inizializzati a zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-784">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="289d7-785">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-785">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-786">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto unidimensionale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-786">The following code example shows how to create and initialize a one-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-787"><paramref name="elementType" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-787"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-788"><paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-788"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="289d7-789"><paramref name="elementType" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-789"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="289d7-790">Ad esempio, <see cref="T:System.Void" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-790">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="289d7-791">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-791">-or-</span></span>  
  
 <span data-ttu-id="289d7-792"><paramref name="elementType" /> è un tipo generico aperto.</span><span class="sxs-lookup"><span data-stu-id="289d7-792"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-793"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-793"><paramref name="length" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="289d7-794">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-794">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="289d7-795">Matrice di interi a 32 bit che rappresentano le grandezze di ciascuna dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-795">An array of 32-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="289d7-796">Crea un oggetto <see cref="T:System.Array" /> multidimensionale dell'oggetto <see cref="T:System.Type" /> specificato e delle lunghezze della dimensione, con indicizzazione in base zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-796">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span> <span data-ttu-id="289d7-797">Le lunghezze vengono specificate in una matrice di interi a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-797">The dimension lengths are specified in an array of 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="289d7-798">Nuovo oggetto <see cref="T:System.Array" /> multidimensionale dell'oggetto <see cref="T:System.Type" /> specificato, con la lunghezza specificata per ogni dimensione, usando l'indicizzazione in base zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-798">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-799">A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</span><span class="sxs-lookup"><span data-stu-id="289d7-799">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="289d7-800">Il numero di elementi di `lengths` matrice deve essere uguale al numero di dimensioni nel nuovo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-800">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span> <span data-ttu-id="289d7-801">Ogni elemento del `lengths` matrice debba specificare la lunghezza della dimensione corrispondente nel nuovo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-801">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-802">Gli elementi di tipo di riferimento vengono inizializzati `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-802">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="289d7-803">Gli elementi di tipo di valore vengono inizializzati a zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-803">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="289d7-804">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il prodotto di tutti i valori `lengths`.</span><span class="sxs-lookup"><span data-stu-id="289d7-804">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-805">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto multidimensionale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-805">The following code example shows how to create and initialize a multidimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-806"><paramref name="elementType" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-806"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-807">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-807">-or-</span></span>  
  
 <span data-ttu-id="289d7-808"><paramref name="lengths" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-808"><paramref name="lengths" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-809"><paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-809"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
 <span data-ttu-id="289d7-810">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-810">-or-</span></span>  
  
 <span data-ttu-id="289d7-811">La matrice di <paramref name="lengths" /> contiene meno di un elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-811">The <paramref name="lengths" /> array contains less than one element.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="289d7-812"><paramref name="elementType" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-812"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="289d7-813">Ad esempio, <see cref="T:System.Void" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-813">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="289d7-814">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-814">-or-</span></span>  
  
 <span data-ttu-id="289d7-815"><paramref name="elementType" /> è un tipo generico aperto.</span><span class="sxs-lookup"><span data-stu-id="289d7-815"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="289d7-816">Qualsiasi valore in <paramref name="lengths" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-816">Any value in <paramref name="lengths" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="289d7-817">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-817">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="289d7-818">Matrice di interi a 64 bit che rappresentano le grandezze di ciascuna dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-818">An array of 64-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span> <span data-ttu-id="289d7-819">Ogni intero nella matrice deve essere compreso tra zero e <see cref="F:System.Int32.MaxValue" />, inclusi.</span><span class="sxs-lookup"><span data-stu-id="289d7-819">Each integer in the array must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="289d7-820">Crea un oggetto <see cref="T:System.Array" /> multidimensionale dell'oggetto <see cref="T:System.Type" /> specificato e delle lunghezze della dimensione, con indicizzazione in base zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-820">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span> <span data-ttu-id="289d7-821">Le lunghezze delle dimensioni vengono specificate in una matrice di interi a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-821">The dimension lengths are specified in an array of 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="289d7-822">Nuovo oggetto <see cref="T:System.Array" /> multidimensionale dell'oggetto <see cref="T:System.Type" /> specificato, con la lunghezza specificata per ogni dimensione, usando l'indicizzazione in base zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-822">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-823">A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</span><span class="sxs-lookup"><span data-stu-id="289d7-823">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="289d7-824">Il numero di elementi di `lengths` matrice deve essere uguale al numero di dimensioni nel nuovo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-824">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span> <span data-ttu-id="289d7-825">Ogni elemento del `lengths` matrice debba specificare la lunghezza della dimensione corrispondente nel nuovo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-825">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-826">Gli elementi di tipo di riferimento vengono inizializzati `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-826">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="289d7-827">Gli elementi di tipo di valore vengono inizializzati a zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-827">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="289d7-828">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il prodotto di tutti i valori `lengths`.</span><span class="sxs-lookup"><span data-stu-id="289d7-828">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-829">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto multidimensionale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-829">The following code example shows how to create and initialize a multidimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-830"><paramref name="elementType" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-830"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-831">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-831">-or-</span></span>  
  
 <span data-ttu-id="289d7-832"><paramref name="lengths" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-832"><paramref name="lengths" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-833"><paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-833"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
 <span data-ttu-id="289d7-834">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-834">-or-</span></span>  
  
 <span data-ttu-id="289d7-835">La matrice di <paramref name="lengths" /> contiene meno di un elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-835">The <paramref name="lengths" /> array contains less than one element.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="289d7-836"><paramref name="elementType" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-836"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="289d7-837">Ad esempio, <see cref="T:System.Void" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-837">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="289d7-838">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-838">-or-</span></span>  
  
 <span data-ttu-id="289d7-839"><paramref name="elementType" /> è un tipo generico aperto.</span><span class="sxs-lookup"><span data-stu-id="289d7-839"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="289d7-840">Qualsiasi valore in <paramref name="lengths" /> è minore di zero o maggiore di <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-840">Any value in <paramref name="lengths" /> is less than zero or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="289d7-841">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-841">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length1"><span data-ttu-id="289d7-842">Dimensioni della prima dimensione di <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-842">The size of the first dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length2"><span data-ttu-id="289d7-843">Dimensioni della seconda dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-843">The size of the second dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="289d7-844">Crea un oggetto <see cref="T:System.Array" /> bidimensionale dell'oggetto <see cref="T:System.Type" /> specificato e delle lunghezze delle dimensioni specificate, con indice in base zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-844">Creates a two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="289d7-845">Nuovo oggetto <see cref="T:System.Array" /> bidimensionale dell'oggetto <see cref="T:System.Type" /> specificato con la lunghezza specificata per ciascuna dimensione, con indice in base zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-845">A new two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-846">A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</span><span class="sxs-lookup"><span data-stu-id="289d7-846">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="289d7-847">Gli elementi di tipo di riferimento vengono inizializzati `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-847">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="289d7-848">Gli elementi di tipo di valore vengono inizializzati a zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-848">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="289d7-849">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il prodotto di `length1` e `length2`.</span><span class="sxs-lookup"><span data-stu-id="289d7-849">This method is an O(`n`) operation, where `n` is the product of `length1` and `length2`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-850">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto bidimensionale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-850">The following code example shows how to create and initialize a two-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-851"><paramref name="elementType" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-851"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-852"><paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-852"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="289d7-853"><paramref name="elementType" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-853"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="289d7-854">Ad esempio, <see cref="T:System.Void" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-854">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="289d7-855">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-855">-or-</span></span>  
  
 <span data-ttu-id="289d7-856"><paramref name="elementType" /> è un tipo generico aperto.</span><span class="sxs-lookup"><span data-stu-id="289d7-856"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-857"><paramref name="length1" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-857"><paramref name="length1" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-858">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-858">-or-</span></span>  
  
 <span data-ttu-id="289d7-859"><paramref name="length2" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-859"><paramref name="length2" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="289d7-860">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-860">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="289d7-861">Matrice unidimensionale che contiene la grandezza di ciascuna dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-861">A one-dimensional array that contains the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lowerBounds"><span data-ttu-id="289d7-862">Matrice unidimensionale che contiene il limite inferiore (indice iniziale) di ciascuna dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-862">A one-dimensional array that contains the lower bound (starting index) of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="289d7-863">Crea una matrice <see cref="T:System.Array" /> multidimensionale con il valore <see cref="T:System.Type" /> e lunghezze della dimensione specificati, con i limiti inferiori specificati.</span><span class="sxs-lookup"><span data-stu-id="289d7-863">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with the specified lower bounds.</span></span></summary>
        <returns><span data-ttu-id="289d7-864">Nuovo oggetto <see cref="T:System.Array" /> multidimensionale con il valore <see cref="T:System.Type" /> specificato, con la lunghezza e il limite inferiore specificati per ogni dimensione.</span><span class="sxs-lookup"><span data-stu-id="289d7-864">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length and lower bound for each dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-865">A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</span><span class="sxs-lookup"><span data-stu-id="289d7-865">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="289d7-866">Il `lengths` e `lowerBounds` matrici devono avere lo stesso numero di elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-866">The `lengths` and `lowerBounds` arrays must have the same number of elements.</span></span> <span data-ttu-id="289d7-867">Il numero di elementi di `lengths` matrice deve essere uguale al numero di dimensioni nel nuovo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-867">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-868">Ogni elemento del `lengths` matrice debba specificare la lunghezza della dimensione corrispondente nel nuovo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-868">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-869">Ogni elemento del `lowerBounds` matrice è necessario specificare il limite inferiore della dimensione corrispondente nel nuovo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-869">Each element of the `lowerBounds` array must specify the lower bound of the corresponding dimension in the new <xref:System.Array>.</span></span> <span data-ttu-id="289d7-870">In genere, la libreria di classi .NET Framework e molti linguaggi di programmazione non gestiscono i limiti inferiori diversi da zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-870">Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</span></span>  
  
 <span data-ttu-id="289d7-871">Gli elementi di tipo di riferimento vengono inizializzati `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-871">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="289d7-872">Gli elementi di tipo di valore vengono inizializzati a zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-872">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="289d7-873">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il prodotto di tutti i valori `lengths`.</span><span class="sxs-lookup"><span data-stu-id="289d7-873">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-874">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto multidimensionale <xref:System.Array> con limiti inferiori specificati.</span><span class="sxs-lookup"><span data-stu-id="289d7-874">The following code example shows how to create and initialize a multidimensional <xref:System.Array> with specified lower bounds.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-875"><paramref name="elementType" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-875"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-876">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-876">-or-</span></span>  
  
 <span data-ttu-id="289d7-877"><paramref name="lengths" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-877"><paramref name="lengths" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-878">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-878">-or-</span></span>  
  
 <span data-ttu-id="289d7-879"><paramref name="lowerBounds" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-879"><paramref name="lowerBounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-880"><paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-880"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
 <span data-ttu-id="289d7-881">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-881">-or-</span></span>  
  
 <span data-ttu-id="289d7-882">La matrice di <paramref name="lengths" /> contiene meno di un elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-882">The <paramref name="lengths" /> array contains less than one element.</span></span>  
  
 <span data-ttu-id="289d7-883">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-883">-or-</span></span>  
  
 <span data-ttu-id="289d7-884">Le matrici <paramref name="lengths" /> e <paramref name="lowerBounds" /> non contengono lo stesso numero di elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-884">The <paramref name="lengths" /> and <paramref name="lowerBounds" /> arrays do not contain the same number of elements.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="289d7-885"><paramref name="elementType" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-885"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="289d7-886">Ad esempio, <see cref="T:System.Void" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-886">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="289d7-887">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-887">-or-</span></span>  
  
 <span data-ttu-id="289d7-888"><paramref name="elementType" /> è un tipo generico aperto.</span><span class="sxs-lookup"><span data-stu-id="289d7-888"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="289d7-889">Qualsiasi valore in <paramref name="lengths" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-889">Any value in <paramref name="lengths" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-890">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-890">-or-</span></span>  
  
 <span data-ttu-id="289d7-891">Qualsiasi valore in <paramref name="lowerBounds" /> è tanto grande che la somma del limite inferiore e della lunghezza di una dimensione risulta essere maggiore di <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-891">Any value in <paramref name="lowerBounds" /> is very large, such that the sum of a dimension's lower bound and length is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="289d7-892">Oggetto <see cref="T:System.Type" /> dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-892">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length1"><span data-ttu-id="289d7-893">Dimensioni della prima dimensione di <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-893">The size of the first dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length2"><span data-ttu-id="289d7-894">Dimensioni della seconda dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-894">The size of the second dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length3"><span data-ttu-id="289d7-895">Dimensioni della terza dimensione dell'oggetto <see cref="T:System.Array" /> da creare.</span><span class="sxs-lookup"><span data-stu-id="289d7-895">The size of the third dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="289d7-896">Crea un oggetto <see cref="T:System.Array" /> tridimensionale dell'oggetto <see cref="T:System.Type" /> specificato e le lunghezze della dimensione, con indice in base zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-896">Creates a three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="289d7-897">Nuovo oggetto <see cref="T:System.Array" /> tridimensionale dell'oggetto <see cref="T:System.Type" /> specificato con la lunghezza specificata per ciascuna dimensione, con indice in base zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-897">A new three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-898">A differenza della maggior parte delle classi, <xref:System.Array> fornisce il <xref:System.Array.CreateInstance%2A> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</span><span class="sxs-lookup"><span data-stu-id="289d7-898">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="289d7-899">Gli elementi di tipo di riferimento vengono inizializzati `null`.</span><span class="sxs-lookup"><span data-stu-id="289d7-899">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="289d7-900">Gli elementi di tipo di valore vengono inizializzati a zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-900">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="289d7-901">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il prodotto di `length1`, `length2`, e `length3`.</span><span class="sxs-lookup"><span data-stu-id="289d7-901">This method is an O(`n`) operation, where `n` is the product of `length1`, `length2`, and `length3`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-902">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto tridimensionale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-902">The following code example shows how to create and initialize a three-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-903"><paramref name="elementType" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-903"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-904"><paramref name="elementType" /> non è un oggetto <see cref="T:System.Type" /> valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-904"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="289d7-905"><paramref name="elementType" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-905"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="289d7-906">Ad esempio, <see cref="T:System.Void" /> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="289d7-906">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="289d7-907">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-907">-or-</span></span>  
  
 <span data-ttu-id="289d7-908"><paramref name="elementType" /> è un tipo generico aperto.</span><span class="sxs-lookup"><span data-stu-id="289d7-908"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-909"><paramref name="length1" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-909"><paramref name="length1" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-910">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-910">-or-</span></span>  
  
 <span data-ttu-id="289d7-911"><paramref name="length2" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-911"><paramref name="length2" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-912">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-912">-or-</span></span>  
  
 <span data-ttu-id="289d7-913"><paramref name="length3" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-913"><paramref name="length3" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-914">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-914">The type of the elements of the array.</span></span></typeparam>
        <summary><span data-ttu-id="289d7-915">Restituisce una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="289d7-915">Returns an empty array.</span></span></summary>
        <returns><span data-ttu-id="289d7-916">Restituisce un oggetto <see cref="T:System.Array" /> vuoto.</span><span class="sxs-lookup"><span data-stu-id="289d7-916">Returns an empty <see cref="T:System.Array" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-917">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-917">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-918">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-918">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="289d7-919">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni degli elementi da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-919">The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-920">Determina se la matrice indicata contiene elementi che soddisfano le condizioni definite nel predicato specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-920">Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</span></span></summary>
        <returns>
          <span data-ttu-id="289d7-921"><see langword="true" /> se <paramref name="array" /> contiene uno o più elementi che soddisfano le condizioni definite dal predicato specificato; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-921"><see langword="true" /> if <paramref name="array" /> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-922">Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-922">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="289d7-923">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Predicate%601>, e l'elaborazione viene arrestata quando viene trovata una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="289d7-923">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and processing is stopped when a match is found.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-924">In c# e Visual Basic, non è necessario creare il <xref:System.Predicate%601> delegare in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="289d7-924">In C# and Visual Basic, it is not necessary to create the <xref:System.Predicate%601> delegate explicitly.</span></span> <span data-ttu-id="289d7-925">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-925">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="289d7-926">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-926">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-927">Nell'esempio seguente specifica le condizioni di corrispondenza per il <xref:System.Array.Exists%2A> espressioni usinglambda metodo per verificare se un pianeta inizia con una lettera specificata o meno il pianeta individuato nella matrice specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-927">The following example specifies the match conditions for the <xref:System.Array.Exists%2A> method usinglambda expressions to check whether a planet starts with a given letter or whether the planet is found on the given array.</span></span>  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 <span data-ttu-id="289d7-928">L'esempio seguente usa il <xref:System.Array.Exists%2A> metodo per indicare se i nomi in una matrice di stringhe iniziano con un carattere specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-928">The following example uses the <xref:System.Array.Exists%2A> method to indicate whether any names in a string array begin with a specified character.</span></span> <span data-ttu-id="289d7-929">Nell'esempio viene creata un'istanza di un `StringSearcher` oggetto passando la stringa di ricerca al costruttore della classe.</span><span class="sxs-lookup"><span data-stu-id="289d7-929">The example instantiates a `StringSearcher` object by passing the string to search for to its class constructor.</span></span> <span data-ttu-id="289d7-930">Il `StringSearcher.StartsWith` metodo ha stessa firma di <xref:System.Predicate%601> delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-930">The `StringSearcher.StartsWith` method has same signature as the <xref:System.Predicate%601> delegate.</span></span> <span data-ttu-id="289d7-931">Quando il <xref:System.Array.Exists%2A> metodo viene chiamato, ogni membro della matrice viene passato al delegato fino a quando non viene restituito `true` o esegue l'iterazione di tutti gli elementi nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-931">When the <xref:System.Array.Exists%2A> method is called, each member of the array is passed to the delegate until it returns `true` or iterates all the elements in the array.</span></span>  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 <span data-ttu-id="289d7-932">È possibile inoltre utilizzare un'espressione lambda anziché definire in modo esplicito un metodo la cui firma corrisponde a quella del delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-932">You can also use a lambda expression rather than explicitly define a method whose signature corresponds to that of the delegate.</span></span> <span data-ttu-id="289d7-933">Nell'esempio seguente sostituisce il `StringSearcher` classe e il relativo `StartsWith` (metodo) con un'espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="289d7-933">The following example replaces the `StringSearcher` class and its `StartsWith` method with a lambda expression.</span></span>  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-934"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-934"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-935">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-935">-or-</span></span>  
  
 <span data-ttu-id="289d7-936"><paramref name="match" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-936"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-937">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-937">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-938">Matrice unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-938">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="match"><span data-ttu-id="289d7-939">Predicato che definisce le condizioni dell'elemento da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-939">The predicate that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-940">Cerca un elemento che soddisfi le condizioni definite nel predicato specificato e restituisce la prima occorrenza all'interno dell'intero oggetto <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-940">Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="289d7-941">Primo elemento che soddisfa le condizioni definite dal predicato specificato, se trovato; in caso contrario, viene restituito il valore predefinito del tipo <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-941">The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-942">Il <xref:System.Predicate%601> è un delegato di un metodo o un'espressione lambda che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato o un'espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="289d7-942">The <xref:System.Predicate%601> is a delegate to a method or a lambda expression that returns `true` if the object passed to it matches the conditions defined in the delegate or lambda expression.</span></span>  <span data-ttu-id="289d7-943">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Predicate%601>, a partire dal primo elemento e terminando con l'ultimo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-943">The elements of `array` are individually passed to the <xref:System.Predicate%601>, starting with the first element and ending with the last element.</span></span>  <span data-ttu-id="289d7-944">L'elaborazione viene arrestata quando viene trovata una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="289d7-944">Processing is stopped when a match is found.</span></span>  
  
 <span data-ttu-id="289d7-945">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-945">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-946">Nell'esempio seguente viene utilizzato un <xref:System.Predicate%601> delegato con il <xref:System.Array.Find%2A> un metodo generico per cercare una matrice di <xref:System.Drawing.Point> strutture.</span><span class="sxs-lookup"><span data-stu-id="289d7-946">The following example uses a <xref:System.Predicate%601> delegate with the <xref:System.Array.Find%2A> generic method to search an array of <xref:System.Drawing.Point> structures.</span></span> <span data-ttu-id="289d7-947">Il metodo rappresentato dal delegato, `ProductGT10`, restituisce `true` se il prodotto dei campi X e Y è maggiore di 100.000.</span><span class="sxs-lookup"><span data-stu-id="289d7-947">The method the delegate represents, `ProductGT10`, returns `true` if the product of the X and Y fields is greater than 100,000.</span></span> <span data-ttu-id="289d7-948">Il <xref:System.Array.Find%2A> metodo chiama il delegato per ogni elemento della matrice, restituendo il primo punto che soddisfa la condizione di test.</span><span class="sxs-lookup"><span data-stu-id="289d7-948">The <xref:System.Array.Find%2A> method calls the delegate for each element of the array, returning the first point that meets the test condition.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-949">Gli utenti di c# e Visual Basic non dispone di creare il delegato in modo esplicito o specificare l'argomento di tipo del metodo generico.</span><span class="sxs-lookup"><span data-stu-id="289d7-949">Visual Basic and C# users do not have to create the delegate explicitly or specify the type argument of the generic method.</span></span> <span data-ttu-id="289d7-950">I compilatori determinano i tipi necessari dagli argomenti del metodo che è fornito.</span><span class="sxs-lookup"><span data-stu-id="289d7-950">The compilers determine the necessary types from the method arguments you supply.</span></span>  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 <span data-ttu-id="289d7-951">Anziché definire in modo esplicito un metodo con la firma necessaria, creare un'istanza di un <xref:System.Predicate%601> delegare e passa il delegato per il <xref:System.Array.Find%2A> (metodo), è solitamente si utilizza un'espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="289d7-951">Rather than explicitly defining a method with the necessary signature, instantiating a <xref:System.Predicate%601> delegate, and passing the delegate to the <xref:System.Array.Find%2A> method, it is customary to use a lambda expression.</span></span> <span data-ttu-id="289d7-952">L'esempio seguente è identico a quello precedente, ad eccezione del fatto che viene utilizzata un'espressione lambda come il `match` argomento.</span><span class="sxs-lookup"><span data-stu-id="289d7-952">The following example is identical to the previous one, except that it uses a lambda expression as the `match` argument.</span></span>  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-953"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-953"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-954">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-954">-or-</span></span>  
  
 <span data-ttu-id="289d7-955"><paramref name="match" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-955"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-956">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-956">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-957">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-957">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="289d7-958">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni degli elementi da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-958">The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-959">Recupera tutti gli elementi che soddisfano le condizioni definite nel predicato specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-959">Retrieves all the elements that match the conditions defined by the specified predicate.</span></span></summary>
        <returns><span data-ttu-id="289d7-960">Oggetto <see cref="T:System.Array" /> contenente tutti gli elementi che soddisfano le condizioni definite nel predicato specificato, se trovati; in caso contrario, verrà restituito un oggetto <see cref="T:System.Array" /> vuoto.</span><span class="sxs-lookup"><span data-stu-id="289d7-960">An <see cref="T:System.Array" /> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-961">Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-961">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="289d7-962">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Predicate%601>, e gli elementi che soddisfano le condizioni vengono salvati nella matrice restituita.</span><span class="sxs-lookup"><span data-stu-id="289d7-962">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and the elements that match the conditions are saved in the returned array.</span></span>  
  
 <span data-ttu-id="289d7-963">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-963">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-964">Nell'esempio seguente crea una matrice di numeri casuali 50 con i valori sono compresi tra 0 e 1000.</span><span class="sxs-lookup"><span data-stu-id="289d7-964">The following example creates an array of 50 random numbers with values that can range from 0 to 1,000.</span></span> <span data-ttu-id="289d7-965">Chiama quindi il <xref:System.Array.FindAll%2A> (metodo) con un'espressione lambda che restituisce i valori di intervallo compreso tra 300 su 600.</span><span class="sxs-lookup"><span data-stu-id="289d7-965">It then calls the <xref:System.Array.FindAll%2A> method with a lambda expression that returns the values that range from 300 to 600.</span></span> <span data-ttu-id="289d7-966">Si noti che l'espressione lambda viene passata un parametro denominato `x`;  rappresenta il membro di matrice singoli che viene passato per il <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="289d7-966">Note that the lambda expression is passed a parameter named `x`;  this represents the individual array member that is passed to the <xref:System.Predicate%601>.</span></span> <span data-ttu-id="289d7-967">Si noti inoltre che locale `lBound` e `uBound` le variabili sono accessibili all'interno dell'espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="289d7-967">Also note that the local `lBound` and `uBound` variables are accessible within the lambda expression.</span></span>  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 <span data-ttu-id="289d7-968">L'esempio di codice seguente illustra il <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, e <xref:System.Array.FindAll%2A> metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-968">The following code example demonstrates the <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, and <xref:System.Array.FindAll%2A> generic methods.</span></span> <span data-ttu-id="289d7-969">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-969">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="289d7-970">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-970">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="289d7-971">Il <xref:System.Array.Find%2A> metodo generico consente di scorrere la matrice dall'inizio, passando a sua volta a ogni elemento di `EndsWithSaurus` metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-971">The <xref:System.Array.Find%2A> generic method traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="289d7-972">La ricerca si interrompe quando il `EndsWithSaurus` restituisce `true` per l'elemento "Amargasaurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-972">The search stops when the `EndsWithSaurus` method returns `true` for the element "Amargasaurus".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-973">In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="289d7-973">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="289d7-974">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-974">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="289d7-975">Il <xref:System.Array.FindLast%2A> metodo generico utilizzato per la ricerca della matrice con le versioni precedenti dalla fine.</span><span class="sxs-lookup"><span data-stu-id="289d7-975">The <xref:System.Array.FindLast%2A> generic method is used to search the array backward from the end.</span></span> <span data-ttu-id="289d7-976">Trova l'elemento "Dilophosaurus" nella posizione 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-976">It finds the element "Dilophosaurus" at position 5.</span></span> <span data-ttu-id="289d7-977">Il <xref:System.Array.FindAll%2A> metodo generico viene utilizzato per restituire una matrice contenente tutti gli elementi che terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-977">The <xref:System.Array.FindAll%2A> generic method is used to return an array containing all the elements that end in "saurus".</span></span> <span data-ttu-id="289d7-978">Gli elementi vengono visualizzati.</span><span class="sxs-lookup"><span data-stu-id="289d7-978">The elements are displayed.</span></span>  
  
 <span data-ttu-id="289d7-979">L'esempio di codice viene inoltre illustrato il <xref:System.Array.Exists%2A> e <xref:System.Array.TrueForAll%2A> metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-979">The code example also demonstrates the <xref:System.Array.Exists%2A> and <xref:System.Array.TrueForAll%2A> generic methods.</span></span>  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-980"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-980"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-981">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-981">-or-</span></span>  
  
 <span data-ttu-id="289d7-982"><paramref name="match" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-982"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-983">Cerca un elemento che soddisfi le condizioni definite in un predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno di un oggetto <see cref="T:System.Array" /> o in parte di esso.</span><span class="sxs-lookup"><span data-stu-id="289d7-983">Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within an <see cref="T:System.Array" /> or a portion of it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-984">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-984">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-985">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-985">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="289d7-986">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-986">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-987">Cerca un elemento che corrisponda alle condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno di <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-987">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="289d7-988">Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, -1.</span><span class="sxs-lookup"><span data-stu-id="289d7-988">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-989">Il <xref:System.Array> avanti al primo elemento fino all'ultimo elemento, viene eseguita la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-989">The <xref:System.Array> is searched forward starting at the first element and ending at the last element.</span></span>  
  
 <span data-ttu-id="289d7-990">Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-990">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="289d7-991">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="289d7-991">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="289d7-992">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-992">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-993">Esempio di codice seguente illustra i tre overload del <xref:System.Array.FindIndex%2A> metodo generico.</span><span class="sxs-lookup"><span data-stu-id="289d7-993">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="289d7-994">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-994">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="289d7-995">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-995">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="289d7-996">Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo consente di scorrere la matrice dall'inizio, passando a sua volta a ogni elemento di `EndsWithSaurus` metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-996">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="289d7-997">La ricerca si interrompe quando il `EndsWithSaurus` restituisce `true` per l'elemento nella posizione 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-997">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-998">In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="289d7-998">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="289d7-999">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-999">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="289d7-1000">Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 2 e continuando fino alla fine della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1000">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="289d7-1001">Trova l'elemento in corrispondenza della posizione 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1001">It finds the element at position 5.</span></span> <span data-ttu-id="289d7-1002">Infine, il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 2.</span><span class="sxs-lookup"><span data-stu-id="289d7-1002">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="289d7-1003">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1003">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1004"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1004"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-1005">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1005">-or-</span></span>  
  
 <span data-ttu-id="289d7-1006"><paramref name="match" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1006"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1007">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1007">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1008">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1008">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1009">Indice iniziale in base zero della ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1009">The zero-based starting index of the search.</span></span></param>
        <param name="match"><span data-ttu-id="289d7-1010">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1010">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-1011">Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Array" /> compreso tra l'indice specificato e l'ultimo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1011">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the specified index to the last element.</span></span></summary>
        <returns><span data-ttu-id="289d7-1012">Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, -1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1012">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1013">Il <xref:System.Array> viene eseguita la ricerca in avanti a partire da `startIndex` e termina con l'ultimo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1013">The <xref:System.Array> is searched forward starting at `startIndex` and ending at the last element.</span></span>  
  
 <span data-ttu-id="289d7-1014">Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1014">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="289d7-1015">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1015">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="289d7-1016">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi da `startIndex` alla fine di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1016">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1017">Esempio di codice seguente illustra i tre overload del <xref:System.Array.FindIndex%2A> metodo generico.</span><span class="sxs-lookup"><span data-stu-id="289d7-1017">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="289d7-1018">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1018">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="289d7-1019">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1019">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="289d7-1020">Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo consente di scorrere la matrice dall'inizio, passando a sua volta a ogni elemento di `EndsWithSaurus` metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1020">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="289d7-1021">La ricerca si interrompe quando il `EndsWithSaurus` restituisce `true` per l'elemento nella posizione 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1021">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1022">In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="289d7-1022">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="289d7-1023">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1023">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="289d7-1024">Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 2 e continuando fino alla fine della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1024">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="289d7-1025">Trova l'elemento in corrispondenza della posizione 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1025">It finds the element at position 5.</span></span> <span data-ttu-id="289d7-1026">Infine, il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 2.</span><span class="sxs-lookup"><span data-stu-id="289d7-1026">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="289d7-1027">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1027">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1028"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1028"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-1029">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1029">-or-</span></span>  
  
 <span data-ttu-id="289d7-1030"><paramref name="match" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1030"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1031"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1031"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1032">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1032">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1033">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1033">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1034">Indice iniziale in base zero della ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1034">The zero-based starting index of the search.</span></span></param>
        <param name="count"><span data-ttu-id="289d7-1035">Numero di elementi nella sezione in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1035">The number of elements in the section to search.</span></span></param>
        <param name="match"><span data-ttu-id="289d7-1036">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1036">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-1037">Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <see cref="T:System.Array" /> che inizia dall'indice specificato e contiene il numero indicato di elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1037">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that starts at the specified index and contains the specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="289d7-1038">Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <paramref name="match" />, se presente; in caso contrario, -1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1038">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1039">Il <xref:System.Array> viene eseguita la ricerca in avanti a partire da `startIndex` e fine `startIndex` più `count` -1, se `count` è maggiore di 0.</span><span class="sxs-lookup"><span data-stu-id="289d7-1039">The <xref:System.Array> is searched forward starting at `startIndex` and ending at `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="289d7-1040">Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1040">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="289d7-1041">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1041">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="289d7-1042">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1042">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1043">Esempio di codice seguente illustra i tre overload del <xref:System.Array.FindIndex%2A> metodo generico.</span><span class="sxs-lookup"><span data-stu-id="289d7-1043">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="289d7-1044">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1044">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="289d7-1045">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1045">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="289d7-1046">Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo consente di scorrere la matrice dall'inizio, passando a sua volta a ogni elemento di `EndsWithSaurus` metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1046">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="289d7-1047">La ricerca si interrompe quando il `EndsWithSaurus` restituisce `true` per l'elemento nella posizione 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1047">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1048">In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="289d7-1048">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="289d7-1049">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1049">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="289d7-1050">Il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 2 e continuando fino alla fine della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1050">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="289d7-1051">Trova l'elemento in corrispondenza della posizione 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1051">It finds the element at position 5.</span></span> <span data-ttu-id="289d7-1052">Infine, il <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 2.</span><span class="sxs-lookup"><span data-stu-id="289d7-1052">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="289d7-1053">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1053">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1054"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1054"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-1055">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1055">-or-</span></span>  
  
 <span data-ttu-id="289d7-1056"><paramref name="match" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1056"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1057"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1057"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-1058">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1058">-or-</span></span>  
  
 <span data-ttu-id="289d7-1059"><paramref name="count" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1059"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-1060">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1060">-or-</span></span>  
  
 <span data-ttu-id="289d7-1061"><paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1061"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1062">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1062">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1063">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1063">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="289d7-1064">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1064">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-1065">Cerca un elemento che soddisfi le condizioni definite nel predicato specificato e restituisce l'ultima occorrenza all'interno dell'intero oggetto <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1065">Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="289d7-1066">Ultimo elemento che soddisfa le condizioni definite dal predicato specificato, se trovato; in caso contrario, viene restituito il valore predefinito del tipo <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1066">The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1067">Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1067">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="289d7-1068">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Predicate%601>, lo spostamento indietro nel <xref:System.Array>, a partire dall'ultimo elemento e terminando con il primo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1068">The elements of `array` are individually passed to the <xref:System.Predicate%601>, moving backward in the <xref:System.Array>, starting with the last element and ending with the first element.</span></span>  <span data-ttu-id="289d7-1069">L'elaborazione viene arrestata quando viene trovata una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="289d7-1069">Processing is stopped when a match is found.</span></span>  
  
 <span data-ttu-id="289d7-1070">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1070">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1071">L'esempio di codice seguente illustra il <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, e <xref:System.Array.FindAll%2A> metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-1071">The following code example demonstrates the <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, and <xref:System.Array.FindAll%2A> generic methods.</span></span> <span data-ttu-id="289d7-1072">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1072">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="289d7-1073">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1073">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="289d7-1074">Il <xref:System.Array.Find%2A> metodo generico consente di scorrere la matrice dall'inizio, passando a sua volta a ogni elemento di `EndsWithSaurus` metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1074">The <xref:System.Array.Find%2A> generic method traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="289d7-1075">La ricerca si interrompe quando il `EndsWithSaurus` restituisce `true` per l'elemento "Amargasaurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1075">The search stops when the `EndsWithSaurus` method returns `true` for the element "Amargasaurus".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1076">In c# e Visual Basic, non è necessario creare il`Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="289d7-1076">In C# and Visual Basic, it is not necessary to create the`Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="289d7-1077">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1077">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="289d7-1078">Il <xref:System.Array.FindLast%2A> metodo generico utilizzato per la ricerca della matrice con le versioni precedenti dalla fine.</span><span class="sxs-lookup"><span data-stu-id="289d7-1078">The <xref:System.Array.FindLast%2A> generic method is used to search the array backward from the end.</span></span> <span data-ttu-id="289d7-1079">Trova l'elemento "Dilophosaurus" nella posizione 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1079">It finds the element "Dilophosaurus" at position 5.</span></span> <span data-ttu-id="289d7-1080">Il <xref:System.Array.FindAll%2A> metodo generico viene utilizzato per restituire una matrice contenente tutti gli elementi che terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1080">The <xref:System.Array.FindAll%2A> generic method is used to return an array containing all the elements that end in "saurus".</span></span> <span data-ttu-id="289d7-1081">Gli elementi vengono visualizzati.</span><span class="sxs-lookup"><span data-stu-id="289d7-1081">The elements are displayed.</span></span>  
  
 <span data-ttu-id="289d7-1082">L'esempio di codice viene inoltre illustrato il <xref:System.Array.Exists%2A> e <xref:System.Array.TrueForAll%2A> metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-1082">The code example also demonstrates the <xref:System.Array.Exists%2A> and <xref:System.Array.TrueForAll%2A> generic methods.</span></span>  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1083"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1083"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-1084">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1084">-or-</span></span>  
  
 <span data-ttu-id="289d7-1085"><paramref name="match" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1085"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-1086">Cerca un elemento che soddisfi le condizioni definite in un predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno di un oggetto <see cref="T:System.Array" /> o in parte di esso.</span><span class="sxs-lookup"><span data-stu-id="289d7-1086">Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within an <see cref="T:System.Array" /> or a portion of it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1087">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1087">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1088">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1088">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="289d7-1089">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1089">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-1090">Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intero oggetto <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1090">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="289d7-1091">Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, –1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1091">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1092">Il <xref:System.Array> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1092">The <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="289d7-1093">Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1093">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="289d7-1094">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1094">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="289d7-1095">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1095">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1096">Esempio di codice seguente illustra i tre overload del <xref:System.Array.FindLastIndex%2A> metodo generico.</span><span class="sxs-lookup"><span data-stu-id="289d7-1096">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="289d7-1097">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1097">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="289d7-1098">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1098">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="289d7-1099">Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo consente di scorrere la matrice con le versioni precedenti alla fine, passando a sua volta a ogni elemento di `EndsWithSaurus` metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1099">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="289d7-1100">La ricerca si interrompe quando il `EndsWithSaurus` restituisce `true` per l'elemento in corrispondenza della posizione 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1100">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1101">In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="289d7-1101">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="289d7-1102">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1102">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="289d7-1103">Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 4, continuando all'indietro fino all'inizio della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1103">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="289d7-1104">Trova l'elemento nella posizione 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1104">It finds the element at position 1.</span></span> <span data-ttu-id="289d7-1105">Infine, il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 4 e procedendo a ritroso (vale a dire, 2, 3 e 4).</span><span class="sxs-lookup"><span data-stu-id="289d7-1105">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="289d7-1106">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1106">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1107"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1107"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-1108">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1108">-or-</span></span>  
  
 <span data-ttu-id="289d7-1109"><paramref name="match" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1109"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1110">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1110">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1111">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1111">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1112">Indice iniziale in base zero della ricerca all'indietro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1112">The zero-based starting index of the backward search.</span></span></param>
        <param name="match"><span data-ttu-id="289d7-1113">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1113">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-1114">Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi in <see cref="T:System.Array" /> compreso tra il primo elemento e l'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1114">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="289d7-1115">Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, –1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1115">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1116">Il <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e termina in corrispondenza del primo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1116">The <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="289d7-1117">Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1117">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="289d7-1118">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1118">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="289d7-1119">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi dall'inizio del `array` a `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1119">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1120">Esempio di codice seguente illustra i tre overload del <xref:System.Array.FindLastIndex%2A> metodo generico.</span><span class="sxs-lookup"><span data-stu-id="289d7-1120">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="289d7-1121">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1121">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="289d7-1122">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1122">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="289d7-1123">Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo consente di scorrere la matrice con le versioni precedenti alla fine, passando a sua volta a ogni elemento di `EndsWithSaurus` metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1123">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="289d7-1124">La ricerca si interrompe quando il `EndsWithSaurus` restituisce `true` per l'elemento in corrispondenza della posizione 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1124">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1125">In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="289d7-1125">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="289d7-1126">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1126">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="289d7-1127">Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 4, continuando all'indietro fino all'inizio della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1127">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="289d7-1128">Trova l'elemento nella posizione 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1128">It finds the element at position 1.</span></span> <span data-ttu-id="289d7-1129">Infine, il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 4 e procedendo a ritroso (vale a dire, 2, 3 e 4).</span><span class="sxs-lookup"><span data-stu-id="289d7-1129">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="289d7-1130">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1130">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1131"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1131"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-1132">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1132">-or-</span></span>  
  
 <span data-ttu-id="289d7-1133"><paramref name="match" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1133"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1134"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1134"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1135">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1135">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1136">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1136">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1137">Indice iniziale in base zero della ricerca all'indietro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1137">The zero-based starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="289d7-1138">Numero di elementi nella sezione in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1138">The number of elements in the section to search.</span></span></param>
        <param name="match"><span data-ttu-id="289d7-1139">Oggetto <see cref="T:System.Predicate`1" /> che definisce le condizioni dell'elemento da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1139">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="289d7-1140">Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi in <see cref="T:System.Array" /> che contiene il numero indicato di elementi e termina in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1140">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="289d7-1141">Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <paramref name="match" />, se presente; in caso contrario, –1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1141">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1142">Il <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e fine `startIndex` meno `count` + 1, se `count` è maggiore di 0.</span><span class="sxs-lookup"><span data-stu-id="289d7-1142">The <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="289d7-1143">Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce `true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1143">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="289d7-1144">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1144">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="289d7-1145">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1145">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1146">Esempio di codice seguente illustra i tre overload del <xref:System.Array.FindLastIndex%2A> metodo generico.</span><span class="sxs-lookup"><span data-stu-id="289d7-1146">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="289d7-1147">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1147">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="289d7-1148">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato `EndsWithSaurus`, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1148">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="289d7-1149">Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo consente di scorrere la matrice con le versioni precedenti alla fine, passando a sua volta a ogni elemento di `EndsWithSaurus` metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1149">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="289d7-1150">La ricerca si interrompe quando il `EndsWithSaurus` restituisce `true` per l'elemento in corrispondenza della posizione 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1150">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1151">In c# e Visual Basic, non è necessario creare il `Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="289d7-1151">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="289d7-1152">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1152">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="289d7-1153">Il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 4, continuando all'indietro fino all'inizio della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1153">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="289d7-1154">Trova l'elemento nella posizione 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1154">It finds the element at position 1.</span></span> <span data-ttu-id="289d7-1155">Infine, il <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 4 e procedendo a ritroso (vale a dire, 2, 3 e 4).</span><span class="sxs-lookup"><span data-stu-id="289d7-1155">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="289d7-1156">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</span><span class="sxs-lookup"><span data-stu-id="289d7-1156">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1157"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1157"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-1158">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1158">-or-</span></span>  
  
 <span data-ttu-id="289d7-1159"><paramref name="match" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1159"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1160"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1160"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-1161">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1161">-or-</span></span>  
  
 <span data-ttu-id="289d7-1162"><paramref name="count" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1162"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-1163">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1163">-or-</span></span>  
  
 <span data-ttu-id="289d7-1164"><paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1164"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1165">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1165">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1166">Oggetto <see cref="T:System.Array" /> unidimensionale e in base zero sui cui elementi si desidera eseguire l'azione.</span><span class="sxs-lookup"><span data-stu-id="289d7-1166">The one-dimensional, zero-based <see cref="T:System.Array" /> on whose elements the action is to be performed.</span></span></param>
        <param name="action"><span data-ttu-id="289d7-1167"><see cref="T:System.Action`1" /> da eseguire su ogni elemento di <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1167">The <see cref="T:System.Action`1" /> to perform on each element of <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="289d7-1168">Esegue l'azione specificata su ciascun elemento della matrice indicata.</span><span class="sxs-lookup"><span data-stu-id="289d7-1168">Performs the specified action on each element of the specified array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1169">Il <xref:System.Action%601> un delegato a un metodo che esegue un'azione per l'oggetto passato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1169">The <xref:System.Action%601> is a delegate to a method that performs an action on the object passed to it.</span></span>  <span data-ttu-id="289d7-1170">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Action%601>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1170">The elements of `array` are individually passed to the <xref:System.Action%601>.</span></span>  
  
 <span data-ttu-id="289d7-1171">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1171">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1172">Nell'esempio seguente viene illustrato come utilizzare <xref:System.Array.ForEach%2A> per visualizzare i quadrati di ogni elemento in una matrice di interi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1172">The following example shows how to use <xref:System.Array.ForEach%2A> to display the squares of each element in an integer array.</span></span>  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1173"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1173"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-1174">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1174">-or-</span></span>  
  
 <span data-ttu-id="289d7-1175"><paramref name="action" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1175"><paramref name="action" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="289d7-1176">Restituisce <see cref="T:System.Collections.IEnumerator" /> per <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1176">Returns an <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="289d7-1177"><see cref="T:System.Collections.IEnumerator" /> per l'oggetto <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1177">An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1178">[Visual Basic, c#]</span><span class="sxs-lookup"><span data-stu-id="289d7-1178">[Visual Basic, C#]</span></span>  
  
 <span data-ttu-id="289d7-1179">Il `foreach` istruzione del linguaggio c# (`for each` in C++, `For Each` in Visual Basic) nasconde la complessità degli enumeratori.</span><span class="sxs-lookup"><span data-stu-id="289d7-1179">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of the enumerators.</span></span> <span data-ttu-id="289d7-1180">Pertanto, si consiglia l'utilizzo di `foreach`, anziché la modifica diretta dell'enumeratore.</span><span class="sxs-lookup"><span data-stu-id="289d7-1180">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="289d7-1181">È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.</span><span class="sxs-lookup"><span data-stu-id="289d7-1181">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="289d7-1182">Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta.</span><span class="sxs-lookup"><span data-stu-id="289d7-1182">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="289d7-1183">Anche il metodo <xref:System.Collections.IEnumerator.Reset%2A> riporta l'enumeratore in questa posizione.</span><span class="sxs-lookup"><span data-stu-id="289d7-1183"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="289d7-1184">In questa posizione, la proprietà <xref:System.Collections.IEnumerator.Current%2A> è indefinita.</span><span class="sxs-lookup"><span data-stu-id="289d7-1184">At this position, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="289d7-1185">Pertanto, è necessario chiamare il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1185">Therefore, you must call <xref:System.Collections.IEnumerator.MoveNext%2A> to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="289d7-1186"><xref:System.Collections.IEnumerator.Current%2A> restituisce lo stesso oggetto finché non viene chiamato il metodo <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1186"><xref:System.Collections.IEnumerator.Current%2A> returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="289d7-1187"><xref:System.Collections.IEnumerator.MoveNext%2A> imposta <xref:System.Collections.IEnumerator.Current%2A> sull'elemento successivo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1187"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="289d7-1188">Se <xref:System.Collections.IEnumerator.MoveNext%2A> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <xref:System.Collections.IEnumerator.MoveNext%2A> restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1188">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="289d7-1189">Quando l'enumeratore si trova in questa posizione, le chiamate successive a <xref:System.Collections.IEnumerator.MoveNext%2A> restituire anche `false`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1189">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="289d7-1190">Se l'ultima chiamata a <xref:System.Collections.IEnumerator.MoveNext%2A> restituito `false`, <xref:System.Collections.IEnumerator.Current%2A> è definito.</span><span class="sxs-lookup"><span data-stu-id="289d7-1190">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="289d7-1191">Per impostare nuovamente la proprietà <xref:System.Collections.IEnumerator.Current%2A> sul primo elemento della raccolta, è possibile chiamare il metodo <xref:System.Collections.IEnumerator.Reset%2A> seguito da <xref:System.Collections.IEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1191">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="289d7-1192">Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche.</span><span class="sxs-lookup"><span data-stu-id="289d7-1192">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="289d7-1193">In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.</span><span class="sxs-lookup"><span data-stu-id="289d7-1193">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="289d7-1194">L'enumeratore non dispone di accesso esclusivo alla raccolta, pertanto il processo di enumerazione di una raccolta non è di per sé thread-safe.</span><span class="sxs-lookup"><span data-stu-id="289d7-1194">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</span></span>  <span data-ttu-id="289d7-1195">Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-1195">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="289d7-1196">Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-1196">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="289d7-1197">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1197">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1198">Esempio di codice seguente viene illustrato come utilizzare <xref:System.Array.GetEnumerator%2A> per elencare gli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1198">The following code example shows how to use <xref:System.Array.GetEnumerator%2A> to list the elements of an array.</span></span>  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="289d7-1199">Dimensione con inizio zero di <see cref="T:System.Array" /> di cui è necessario determinare la lunghezza.</span><span class="sxs-lookup"><span data-stu-id="289d7-1199">A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</span></span></param>
        <summary><span data-ttu-id="289d7-1200">Ottiene un valore intero a 32 bit che rappresenta il numero di elementi nella dimensione specificata di <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1200">Gets a 32-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="289d7-1201">Intero a 32 bit che rappresenta il numero di elementi nella dimensione specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-1201">A 32-bit integer that represents the number of elements in the specified dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1202">Un esempio di <xref:System.Array.GetLength%2A> è `GetLength(0)`, che restituisce il numero di elementi nella prima dimensione del <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1202">An example of <xref:System.Array.GetLength%2A> is `GetLength(0)`, which returns the number of elements in the first dimension of the <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-1203">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1203">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1204">Nell'esempio seguente viene illustrato come utilizzare <xref:System.Array.GetLength%2A> per visualizzare le dimensioni di due matrici con intervalli diversi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1204">The following example shows how to use <xref:System.Array.GetLength%2A> to display the dimensions of two arrays with different ranks.</span></span>  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="289d7-1205"><paramref name="dimension" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1205"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-1206">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1206">-or-</span></span>  
  
 <span data-ttu-id="289d7-1207"><paramref name="dimension" /> è uguale a o maggiore di <see cref="P:System.Array.Rank" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1207"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="289d7-1208">Dimensione con inizio zero di <see cref="T:System.Array" /> di cui è necessario determinare la lunghezza.</span><span class="sxs-lookup"><span data-stu-id="289d7-1208">A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</span></span></param>
        <summary><span data-ttu-id="289d7-1209">Ottiene un integer a 64 bit che rappresenta il numero di elementi nella dimensione specificata di <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1209">Gets a 64-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="289d7-1210">Intero a 64 bit che rappresenta il numero di elementi nella dimensione specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-1210">A 64-bit integer that represents the number of elements in the specified dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1211">Un esempio di <xref:System.Array.GetLongLength%2A> è `GetLongLength(0)`, che restituisce il numero di elementi nella prima dimensione del <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1211">An example of <xref:System.Array.GetLongLength%2A> is `GetLongLength(0)`, which returns the number of elements in the first dimension of the <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-1212">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1212">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="289d7-1213"><paramref name="dimension" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1213"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-1214">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1214">-or-</span></span>  
  
 <span data-ttu-id="289d7-1215"><paramref name="dimension" /> è uguale a o maggiore di <see cref="P:System.Array.Rank" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1215"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="289d7-1216">Dimensione in base zero della matrice di cui è necessario determinare l'indice iniziale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1216">A zero-based dimension of the array whose starting index needs to be determined.</span></span></param>
        <summary><span data-ttu-id="289d7-1217">Ottiene l'indice del primo elemento della dimensione specificata nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1217">Gets the index of the first element of the specified dimension in the array.</span></span></summary>
        <returns><span data-ttu-id="289d7-1218">Indice del primo elemento della dimensione specificata nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1218">The index of the first element of the specified dimension in the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1219">`GetLowerBound(0)` Restituisce l'indice inizia della prima dimensione della matrice e `GetLowerBound(Rank - 1)` restituisce l'indice inizia dell'ultima dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1219">`GetLowerBound(0)` returns the starting index of the first dimension of the array, and `GetLowerBound(Rank - 1)` returns the starting index of the last dimension of the array.</span></span>  
  
 <span data-ttu-id="289d7-1220">Il <xref:System.Array.GetLowerBound%2A> metodo restituisce sempre un valore che indica l'indice del limite inferiore della finestra della matrice, anche se la matrice è vuota.</span><span class="sxs-lookup"><span data-stu-id="289d7-1220">The <xref:System.Array.GetLowerBound%2A> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</span></span>  
  
 <span data-ttu-id="289d7-1221">Si noti che, sebbene la maggior parte delle matrici in .NET Framework sono in base zero (ovvero, il <xref:System.Array.GetLowerBound%2A> metodo restituisce zero per ciascuna dimensione della matrice), .NET Framework supporta le matrici che non sono in base zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1221">Note that, although most arrays in the .NET Framework are zero-based (that is, the <xref:System.Array.GetLowerBound%2A> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based.</span></span> <span data-ttu-id="289d7-1222">Tali matrici possono essere creati con il <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> (metodo) e possono essere restituiti dal codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="289d7-1222">Such arrays can be created with the <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> method, and can also be returned from unmanaged code.</span></span>  
  
 <span data-ttu-id="289d7-1223">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1223">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1224">L'esempio seguente usa il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi per visualizzare i limiti di una matrice unidimensionale e bidimensionale e visualizzare i valori dei relativi elementi di matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1224">The following example uses the <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</span></span>  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="289d7-1225"><paramref name="dimension" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1225"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-1226">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1226">-or-</span></span>  
  
 <span data-ttu-id="289d7-1227"><paramref name="dimension" /> è uguale a o maggiore di <see cref="P:System.Array.Rank" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1227"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="289d7-1228">Dimensione in base zero della matrice di cui è necessario determinare il limite superiore.</span><span class="sxs-lookup"><span data-stu-id="289d7-1228">A zero-based dimension of the array whose upper bound needs to be determined.</span></span></param>
        <summary><span data-ttu-id="289d7-1229">Ottiene l'indice dell'ultimo elemento della dimensione specificata nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1229">Gets the index of the last element of the specified dimension in the array.</span></span></summary>
        <returns><span data-ttu-id="289d7-1230">Indice dell'ultimo elemento della dimensione specificata nella matrice oppure -1 se la dimensione specificata è vuota.</span><span class="sxs-lookup"><span data-stu-id="289d7-1230">The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1231">`GetUpperBound(0)` Restituisce l'ultimo indice della prima dimensione della matrice e `GetUpperBound(Rank - 1)` restituisce l'ultimo indice dell'ultima dimensione della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1231">`GetUpperBound(0)` returns the last index in the first dimension of the array, and `GetUpperBound(Rank - 1)` returns the last index of the last dimension of the array.</span></span>  
  
 <span data-ttu-id="289d7-1232">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1232">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1233">L'esempio seguente usa il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi per visualizzare i limiti di una matrice unidimensionale e bidimensionale e visualizzare i valori dei relativi elementi di matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1233">The following example uses the <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</span></span>  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="289d7-1234"><paramref name="dimension" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1234"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-1235">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1235">-or-</span></span>  
  
 <span data-ttu-id="289d7-1236"><paramref name="dimension" /> è uguale a o maggiore di <see cref="P:System.Array.Rank" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1236"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-1237">Ottiene il valore dell'elemento specificato nell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1237">Gets the value of the specified element in the current <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="289d7-1238">Valore intero a 32 bit che rappresenta la posizione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1238">A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="289d7-1239">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1239">Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1240">L'indice viene specificato come intero a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1240">The index is specified as a 32-bit integer.</span></span></summary>
        <returns><span data-ttu-id="289d7-1241">Il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1241">The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1242">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> i metodi possono determinare se il valore di `index` è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1242">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1243">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1243">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1244">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1244">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1245">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente una dimensione.</span><span class="sxs-lookup"><span data-stu-id="289d7-1245">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="289d7-1246"><paramref name="index" /> non è compreso nell'intervallo di indici validi per l'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1246"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices"><span data-ttu-id="289d7-1247">Matrice unidimensionale di valori interi a 32 bit che rappresentano gli indici che specificano la posizione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1247">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="289d7-1248">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1248">Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1249">Gli indici vengono specificati come una matrice di interi a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1249">The indexes are specified as an array of 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="289d7-1250">Valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1250">The value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1251">Il numero di elementi in `indices` sia uguale al numero di dimensioni di <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1251">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="289d7-1252">Tutti gli elementi di `indices` matrice deve specificare collettivamente la posizione dell'elemento desiderato nell'oggetto multidimensionale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1252">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-1253">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1253">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1254">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1254">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1255">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1255">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1256"><paramref name="indices" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1256"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1257">Il numero di dimensioni nell'oggetto <see cref="T:System.Array" /> corrente non è uguale al numero di elementi in <paramref name="indices" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1257">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="289d7-1258">Ogni elemento in <paramref name="indices" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1258">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="289d7-1259">Integer a 64 bit che rappresenta la posizione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1259">A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="289d7-1260">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1260">Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1261">L'indice viene specificato come intero a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1261">The index is specified as a 64-bit integer.</span></span></summary>
        <returns><span data-ttu-id="289d7-1262">Il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1262">The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1263">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> i metodi possono determinare se il valore di `index` è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1263">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1264">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1264">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1265">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1265">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1266">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente una dimensione.</span><span class="sxs-lookup"><span data-stu-id="289d7-1266">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1267"><paramref name="index" /> non è compreso nell'intervallo di indici validi per l'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1267"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices"><span data-ttu-id="289d7-1268">Matrice unidimensionale di integer a 64 bit che rappresentano gli indici che specificano la posizione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1268">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="289d7-1269">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1269">Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1270">Gli indici vengono specificati come una matrice di interi a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1270">The indexes are specified as an array of 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="289d7-1271">Valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1271">The value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1272">Il numero di elementi in `indices` sia uguale al numero di dimensioni di <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1272">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="289d7-1273">Tutti gli elementi di `indices` matrice deve specificare collettivamente la posizione dell'elemento desiderato nell'oggetto multidimensionale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1273">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-1274">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1274">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1275">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1275">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1276">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1276">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1277"><paramref name="indices" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1277"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1278">Il numero di dimensioni nell'oggetto <see cref="T:System.Array" /> corrente non è uguale al numero di elementi in <paramref name="indices" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1278">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="289d7-1279">Ogni elemento in <paramref name="indices" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1279">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="289d7-1280">Valore intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1280">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="289d7-1281">Valore intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1281">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="289d7-1282">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1282">Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1283">Gli indici vengono specificati come interi a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1283">The indexes are specified as 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="289d7-1284">Il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1284">The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1285">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1285">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1286">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1286">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1287">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1287">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1288">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente due dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1288">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="289d7-1289"><paramref name="index1" /> o <paramref name="index2" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1289">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="289d7-1290">Integer a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1290">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="289d7-1291">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1291">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="289d7-1292">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1292">Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1293">Gli indici vengono specificati come interi a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1293">The indexes are specified as 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="289d7-1294">Il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1294">The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1295">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1295">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1296">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1296">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1297">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1297">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1298">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente due dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1298">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="289d7-1299"><paramref name="index1" /> o <paramref name="index2" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1299">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="289d7-1300">Valore intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1300">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="289d7-1301">Valore intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1301">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index3"><span data-ttu-id="289d7-1302">Valore intero a 32 bit che rappresenta l'indice della terza dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1302">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="289d7-1303">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1303">Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1304">Gli indici vengono specificati come interi a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1304">The indexes are specified as 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="289d7-1305">Il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1305">The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1306">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1306">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1307">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1307">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1308">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1308">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1309">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente tre dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1309">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="289d7-1310"><paramref name="index1" /> o <paramref name="index2" /> o <paramref name="index3" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1310"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="289d7-1311">Integer a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1311">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="289d7-1312">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1312">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index3"><span data-ttu-id="289d7-1313">Integer a 64 bit che rappresenta l'indice della terza dimensione dell'elemento <see cref="T:System.Array" /> da ottenere.</span><span class="sxs-lookup"><span data-stu-id="289d7-1313">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="289d7-1314">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1314">Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1315">Gli indici vengono specificati come interi a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1315">The indexes are specified as 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="289d7-1316">Il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1316">The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1317">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1317">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1318">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1318">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1319">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1319">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1320">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente tre dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1320">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1321"><paramref name="index1" /> o <paramref name="index2" /> o <paramref name="index3" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1321"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-1322">Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in una matrice unidimensionale o in un intervallo di elementi nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1322">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array or in a range of elements in the array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1323">Matrice unidimensionale da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1323">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1324">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1324">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="289d7-1325">Cerca l'oggetto specificato e restituisce l'indice della prima ricorrenza all'interno di una matrice unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1325">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="289d7-1326">Indice della prima occorrenza di <paramref name="value" /> nell'oggetto <paramref name="array" />, se presente; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1326">The index of the first occurrence of <paramref name="value" /> in <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1327">Questo metodo cerca tutti gli elementi di un oggetto unidimensionale arrayfor `value`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1327">This method searches all the elements of a one-dimensional arrayfor `value`.</span></span> <span data-ttu-id="289d7-1328">Per determinare se `value` esiste `array`, il metodo esegue un confronto di uguaglianza chiamando ogni elemento `Equals` metodo fino a quando non viene trovata una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="289d7-1328">To determine whether `value` exists in `array`, the method performs an equality comparison by calling each element's `Equals` method until it finds a match.</span></span> <span data-ttu-id="289d7-1329">Ciò significa che se l'elemento esegue l'override di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , tale sostituzione viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1329">This means that if the element overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="289d7-1330">Poiché la maggior parte delle matrici hanno un limite inferiore pari a zero, questo metodo in genere restituisce – 1 se`value` non viene trovato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1330">Because most arrays have a lower bound of zero, this method generally returns –1 if`value` isn’t found.</span></span> <span data-ttu-id="289d7-1331">Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) e `value` non viene trovato, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span><span class="sxs-lookup"><span data-stu-id="289d7-1331">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) and `value` isn’t found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="289d7-1332">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1332">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1333">Nell'esempio viene chiamato tre overload del seguenti il <xref:System.Array.IndexOf%2A> metodo per trovare l'indice di una stringa in una matrice di stringhe:</span><span class="sxs-lookup"><span data-stu-id="289d7-1333">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="289d7-1334"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, per determinare la prima occorrenza della stringa "the" in una matrice di stringhe.</span><span class="sxs-lookup"><span data-stu-id="289d7-1334"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="289d7-1335"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" per la quarta agli ultimi elementi di una matrice di stringhe.</span><span class="sxs-lookup"><span data-stu-id="289d7-1335"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="289d7-1336"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" in una stringa di matrice dall'elemento che segue l'ultima corrispondenza corretta alla fine della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1336"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1337"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1337"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1338"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1338"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1339">Matrice unidimensionale da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1339">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1340">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1340">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1341">Indice iniziale della ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1341">The starting index of the search.</span></span> <span data-ttu-id="289d7-1342">0 (zero) è valido in una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="289d7-1342">0 (zero) is valid in an empty array.</span></span></param>
        <summary><span data-ttu-id="289d7-1343">Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1343">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="289d7-1344">L'intervallo si estende da un indice specificato fino alla fine della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1344">The range extends from a specified index to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="289d7-1345">Indice della prima occorrenza di <paramref name="value" />, se trovato, all'interno degli elementi nell'oggetto <paramref name="array" /> che si estende da <paramref name="startIndex" /> fino all'ultimo elemento; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1345">The index of the first occurrence of <paramref name="value" />, if it’s found, within the range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1346">Questo metodo cerca in una matrice unidimensionale dall'elemento in corrispondenza dell'indice `startIndex` all'ultimo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1346">This method searches a one-dimensional array from the element at index `startIndex` to the last element.</span></span> <span data-ttu-id="289d7-1347">Per determinare se `value` esiste `array`, il metodo esegue un confronto di uguaglianza chiamando il `Equals` metodo di ogni elemento fino a quando non viene trovata una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="289d7-1347">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `Equals` method of every element until it finds a match.</span></span> <span data-ttu-id="289d7-1348">Ciò significa che se l'elemento esegue l'override di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , tale sostituzione viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1348">This means that if the element overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="289d7-1349">Poiché la maggior parte delle matrici hanno un limite inferiore pari a zero, questo metodo in genere restituisce – 1 se `value` non viene trovato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1349">Because most arrays have a lower bound of zero, this method generally returns –1 if `value` isn’t found.</span></span> <span data-ttu-id="289d7-1350">Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) e `value` non viene trovato, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span><span class="sxs-lookup"><span data-stu-id="289d7-1350">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) and `value` isn’t found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="289d7-1351">Se `startIndex` è uguale a <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo restituisce -1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1351">If `startIndex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>,the method returns -1.</span></span> <span data-ttu-id="289d7-1352">Se `startIndex` è maggiore di <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo genera un <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1352">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="289d7-1353">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi da `startIndex` alla fine di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1353">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1354">Nell'esempio viene chiamato tre overload del seguenti il <xref:System.Array.IndexOf%2A> metodo per trovare l'indice di una stringa in una matrice di stringhe:</span><span class="sxs-lookup"><span data-stu-id="289d7-1354">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="289d7-1355"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, per determinare la prima occorrenza della stringa "the" in una matrice di stringhe.</span><span class="sxs-lookup"><span data-stu-id="289d7-1355"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="289d7-1356"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" per la quarta agli ultimi elementi di una matrice di stringhe.</span><span class="sxs-lookup"><span data-stu-id="289d7-1356"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="289d7-1357"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" in una stringa di matrice dall'elemento che segue l'ultima corrispondenza corretta alla fine della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1357"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1358"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1358"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1359"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1359"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1360"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1360"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1361">Matrice unidimensionale da cercare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1361">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1362">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1362">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1363">Indice iniziale della ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1363">The starting index of the search.</span></span> <span data-ttu-id="289d7-1364">0 (zero) è valido in una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="289d7-1364">0 (zero) is valid in an empty array.</span></span></param>
        <param name="count"><span data-ttu-id="289d7-1365">Numero di elementi in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1365">The number of elements to search.</span></span></param>
        <summary><span data-ttu-id="289d7-1366">Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1366">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence.</span></span> <span data-ttu-id="289d7-1367">L'intervallo si estende da un indice specificato per un numero specificato di elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1367">The range extends from a specified index for a specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="289d7-1368">Indice della prima occorrenza di <paramref name="value" />, se trovato, nell'oggetto <paramref name="array" /> dall'indice <paramref name="startIndex" /> a <paramref name="startIndex" /> + <paramref name="count" /> - 1; in caso contrario verrà restituito il limite inferiore della matrice meno 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1368">The index of the first occurrence of <paramref name="value" />, if it’s found in the <paramref name="array" /> from index <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> - 1; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1369">Questo metodo cerca gli elementi di un oggetto unidimensionale arrayfrom `startIndex` a `startIndex` più `count` -1, se `count` è maggiore di 0.</span><span class="sxs-lookup"><span data-stu-id="289d7-1369">This method searches the elements of a one-dimensional arrayfrom `startIndex` to `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span> <span data-ttu-id="289d7-1370">Per determinare se `value` esiste `array`, il metodo esegue un confronto di uguaglianza chiamando il `Equals` metodo di ogni elemento fino a quando non viene trovata una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="289d7-1370">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `Equals` method of every element until it finds a match.</span></span> <span data-ttu-id="289d7-1371">Ciò significa che se l'elemento esegue l'override di <xref:System.Object.Equals%2A?displayProperty=nameWithType> , tale sostituzione viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1371">This means that if the element overrides the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="289d7-1372">Le matrici Becausemost hanno un limite inferiore pari a zero, in genere, questo metodo restituisce-1 se `value` non viene trovato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1372">Becausemost arrays have a lower bound of zero, this method generally returns –1 when `value` isn’t found.</span></span> <span data-ttu-id="289d7-1373">Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) e `value` non viene trovato, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span><span class="sxs-lookup"><span data-stu-id="289d7-1373">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) and `value` isn’t found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="289d7-1374">Se `startindex` è uguale a <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo restituisce -1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1374">If `startindex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method returns -1.</span></span> <span data-ttu-id="289d7-1375">Se `startIndex` è maggiore di <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo genera un <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1375">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="289d7-1376">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1376">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1377">Nell'esempio viene chiamato tre overload del seguenti il <xref:System.Array.IndexOf%2A> metodo per trovare l'indice di una stringa in una matrice di stringhe:</span><span class="sxs-lookup"><span data-stu-id="289d7-1377">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="289d7-1378"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, per determinare la prima occorrenza della stringa "the" in una matrice di stringhe.</span><span class="sxs-lookup"><span data-stu-id="289d7-1378"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="289d7-1379"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" per la quarta agli ultimi elementi di una matrice di stringhe.</span><span class="sxs-lookup"><span data-stu-id="289d7-1379"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="289d7-1380"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, per determinare la prima occorrenza della stringa "the" in una stringa di matrice dall'elemento che segue l'ultima corrispondenza corretta alla fine della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1380"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span> <span data-ttu-id="289d7-1381">Per determinare il valore del `count` argomento, sottrae il limite superiore della matrice dall'indice inizia e viene aggiunto uno.</span><span class="sxs-lookup"><span data-stu-id="289d7-1381">To determine the value of the `count` argument, it subtracts the upper bound of the array from the starting index and adds one.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1382"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1382"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1383"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1383"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-1384">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1384">-or-</span></span>  
  
 <span data-ttu-id="289d7-1385"><paramref name="count" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1385"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-1386">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1386">-or-</span></span>  
  
 <span data-ttu-id="289d7-1387"><paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1387"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1388"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1388"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1389">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1389">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1390">Matrice unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1390">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1391">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1391">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="289d7-1392">Cerca l'oggetto specificato e restituisce l'indice della prima ricorrenza all'interno di una matrice unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1392">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="289d7-1393">Indice in base zero della prima occorrenza di <paramref name="value" /> all'interno dell'intero oggetto <paramref name="array" />, se presente; in caso contrario, -1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1393">The zero-based index of the first occurrence of <paramref name="value" /> in the entire <paramref name="array" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1394">Questo metodo cerca tutti gli elementi di una matrice unidimensionale di `value`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1394">This method searches all the elements of a one-dimensional array for `value`.</span></span> <span data-ttu-id="289d7-1395">Per determinare se `value` esiste `array`, il metodo esegue un confronto di uguaglianza chiamando il `T.Equals` metodo su ogni elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1395">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="289d7-1396">Questo significa che se `T` esegue l'override di <xref:System.Object.Equals%2A> , tale sostituzione viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1396">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="289d7-1397">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1397">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1398">L'esempio seguente illustra i tre overload generico del <xref:System.Array.IndexOf%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1398">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="289d7-1399">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1399">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="289d7-1400">Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca nella matrice dall'inizio e trova la prima occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1400">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="289d7-1401">Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nella matrice a partire dalla posizione dell'indice 3 e continuando fino alla fine della matrice e trova la seconda occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1401">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="289d7-1402">Infine, il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 poiché non siano presenti istanze della stringa di ricerca in tale intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1402">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1403"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1403"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1404">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1404">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1405">Matrice unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1405">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1406">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1406">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1407">Indice iniziale in base zero della ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1407">The zero-based starting index of the search.</span></span> <span data-ttu-id="289d7-1408">0 (zero) è valido in una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="289d7-1408">0 (zero) is valid in an empty array.</span></span></param>
        <summary><span data-ttu-id="289d7-1409">Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1409">Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="289d7-1410">L'intervallo si estende da un indice specificato fino alla fine della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1410">The range extends from a specified index to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="289d7-1411">Indice in base zero della prima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intervallo di elementi della matrice <paramref name="array" /> compreso tra l'indice <paramref name="startIndex" /> e l'ultimo elemento, se trovato; in caso contrario, –1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1411">The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1412">Questo metodo cerca in una matrice unidimensionale rispetto all'elemento `startIndex` alla fine della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1412">This method searches a one-dimensional array from the element at `startIndex` to the end of the array.</span></span> <span data-ttu-id="289d7-1413">Per determinare se `value` esiste `array`, il metodo esegue un confronto di uguaglianza chiamando il `T.Equals` metodo su ogni elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1413">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="289d7-1414">Questo significa che se `T` esegue l'override di <xref:System.Object.Equals%2A> , tale sostituzione viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1414">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="289d7-1415">Se `startIndex` è uguale a <xref:System.Array.Length%2A>, il metodo restituisce - 1.If `startIndex` è maggiore di <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo genera un <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1415">If `startIndex` equals <xref:System.Array.Length%2A>,the method returns -1.If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="289d7-1416">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi da `startIndex` alla fine di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1416">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1417">L'esempio seguente illustra i tre overload generico del <xref:System.Array.IndexOf%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1417">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="289d7-1418">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1418">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="289d7-1419">Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca nella matrice dall'inizio e trova la prima occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1419">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="289d7-1420">Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nella matrice a partire dalla posizione dell'indice 3 e continuando fino alla fine della matrice e trova la seconda occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1420">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="289d7-1421">Infine, il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 poiché non siano presenti istanze della stringa di ricerca in tale intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1421">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1422"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1422"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1423"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1423"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1424">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1424">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1425">Matrice unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1425">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1426">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1426">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1427">Indice iniziale in base zero della ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1427">The zero-based starting index of the search.</span></span> <span data-ttu-id="289d7-1428">0 (zero) è valido in una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="289d7-1428">0 (zero) is valid in an empty array.</span></span></param>
        <param name="count"><span data-ttu-id="289d7-1429">Numero di elementi nella sezione in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1429">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="289d7-1430">Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1430">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="289d7-1431">L'intervallo si estende da un indice specificato per un numero specificato di elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1431">The range extends from a specified index for a specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="289d7-1432">Indice in base zero della prima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intervallo di elementi della matrice <paramref name="array" /> che inizia dall'indice <paramref name="startIndex" /> e contiene il numero di elementi specificato nel parametro <paramref name="count" />, se trovato; in caso contrario, –1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1432">The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that starts at <paramref name="startIndex" /> and contains the number of elements specified in <paramref name="count" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1433">Questo metodo ricercheI elementi di una matrice unidimensionale da `startIndex` a `startIndex` più `count` -1, se `count` è maggiore di 0.</span><span class="sxs-lookup"><span data-stu-id="289d7-1433">This method searchesthe elements of a one-dimensional array from `startIndex` to `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span> <span data-ttu-id="289d7-1434">Per determinare se `value` esiste `array`, il metodo esegue un confronto di uguaglianza chiamando il `T.Equals` metodo su ogni elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1434">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="289d7-1435">Questo significa che se `T` esegue l'override di <xref:System.Object.Equals%2A> , tale sostituzione viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1435">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="289d7-1436">Se `startIndex` è uguale a <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo restituisce -1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1436">If `startIndex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method returns -1.</span></span>  <span data-ttu-id="289d7-1437">Se `startIndex` è maggiore di <xref:System.Array.Length%2A?displayProperty=nameWithType>, il metodo genera un <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1437">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="289d7-1438">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1438">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1439">L'esempio seguente illustra i tre overload generico del <xref:System.Array.IndexOf%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1439">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="289d7-1440">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1440">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="289d7-1441">Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca nella matrice dall'inizio e trova la prima occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1441">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="289d7-1442">Il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nella matrice a partire dalla posizione dell'indice 3 e continuando fino alla fine della matrice e trova la seconda occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1442">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="289d7-1443">Infine, il <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 poiché non siano presenti istanze della stringa di ricerca in tale intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1443">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1444"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1444"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1445"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1445"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-1446">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1446">-or-</span></span>  
  
 <span data-ttu-id="289d7-1447"><paramref name="count" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1447"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-1448">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1448">-or-</span></span>  
  
 <span data-ttu-id="289d7-1449"><paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1449"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="289d7-1450">Inizializza ogni elemento del tipo valore <see cref="T:System.Array" /> tramite chiamate al costruttore predefinito del tipo valore.</span><span class="sxs-lookup"><span data-stu-id="289d7-1450">Initializes every element of the value-type <see cref="T:System.Array" /> by calling the default constructor of the value type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1451">Questo metodo è progettato per supportare le matrici di tipi di valore, compilatori Questo metodo non è necessario maggior parte degli utenti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1451">This method is designed to help compilers support value-type arrays; most users do not need this method.</span></span> <span data-ttu-id="289d7-1452">Non deve essere utilizzato su matrici di tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1452">It must not be used on reference-type arrays.</span></span>  
  
 <span data-ttu-id="289d7-1453">Se il <xref:System.Array> non è un tipo di valore <xref:System.Array> o se il tipo di valore non ha un costruttore predefinito, il <xref:System.Array> non viene modificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1453">If the <xref:System.Array> is not a value-type <xref:System.Array> or if the value type does not have a default constructor, the <xref:System.Array> is not modified.</span></span>  
  
 <span data-ttu-id="289d7-1454">Il tipo di valore <xref:System.Array> può avere un limite inferiore e qualsiasi numero di dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1454">The value-type <xref:System.Array> can have any lower bound and any number of dimensions.</span></span>  
  
 <span data-ttu-id="289d7-1455">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è <xref:System.Array.Length%2A>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1455">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="289d7-1456">È possibile utilizzare questo metodo solo su tipi di valore hanno costruttori; Tuttavia, i tipi di valore native in c# non dispone di costruttori.</span><span class="sxs-lookup"><span data-stu-id="289d7-1456">You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="289d7-1457">Ottiene un valore che indica se <see cref="T:System.Array" /> ha dimensioni fisse.</span><span class="sxs-lookup"><span data-stu-id="289d7-1457">Gets a value indicating whether the <see cref="T:System.Array" /> has a fixed size.</span></span></summary>
        <value><span data-ttu-id="289d7-1458">Questa proprietà è sempre <see langword="true" /> per tutte le matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-1458">This property is always <see langword="true" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1459"><xref:System.Array> implementa il <xref:System.Array.IsFixedSize%2A> proprietà perché è necessaria per il <xref:System.Collections.IList?displayProperty=nameWithType> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-1459"><xref:System.Array> implements the <xref:System.Array.IsFixedSize%2A> property because it is required by the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="289d7-1460">Una matrice con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la creazione della matrice, ma consente la modifica degli elementi esistenti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1460">An array with a fixed size does not allow the addition or removal of elements after the array is created, but it allows the modification of existing elements.</span></span>  
  
 <span data-ttu-id="289d7-1461">Il recupero del valore di questa proprietà è un'operazione O(1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1461">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="289d7-1462">Ottiene un valore che indica se <see cref="T:System.Array" /> è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="289d7-1462">Gets a value indicating whether the <see cref="T:System.Array" /> is read-only.</span></span></summary>
        <value><span data-ttu-id="289d7-1463">Questa proprietà è sempre <see langword="false" /> per tutte le matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-1463">This property is always <see langword="false" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1464"><xref:System.Array> implementa il <xref:System.Array.IsReadOnly%2A> proprietà perché è necessaria per il <xref:System.Collections.IList?displayProperty=nameWithType> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-1464"><xref:System.Array> implements the <xref:System.Array.IsReadOnly%2A> property because it is required by the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="289d7-1465">Matrice che è di sola lettura non consente l'aggiunta, rimozione o modifica di elementi dopo la creazione della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1465">An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</span></span>  
  
 <span data-ttu-id="289d7-1466">Se è necessaria una raccolta di sola lettura, utilizzare un <xref:System.Collections> classe che implementa il <xref:System.Collections.IList?displayProperty=nameWithType> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-1466">If you require a read-only collection, use a <xref:System.Collections> class that implements the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="289d7-1467">Se si esegue il cast dell'o convertire una matrice a un <xref:System.Collections.IList> oggetto dell'interfaccia, il <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> restituisce proprietà `false`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1467">If you cast or convert an array to an <xref:System.Collections.IList> interface object, the <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> property returns `false`.</span></span> <span data-ttu-id="289d7-1468">Tuttavia, se si esegue il cast dell'o convertire una matrice a un <xref:System.Collections.Generic.IList%601> interfaccia, il `IsReadOnly` restituisce proprietà `true`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1468">However, if you cast or convert an array to a <xref:System.Collections.Generic.IList%601> interface, the `IsReadOnly` property returns `true`.</span></span>  
  
 <span data-ttu-id="289d7-1469">Il recupero del valore di questa proprietà è un'operazione O(1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1469">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="289d7-1470">Ottiene un valore che indica se l'accesso a <see cref="T:System.Array" /> è sincronizzato (thread-safe).</span><span class="sxs-lookup"><span data-stu-id="289d7-1470">Gets a value indicating whether access to the <see cref="T:System.Array" /> is synchronized (thread safe).</span></span></summary>
        <value><span data-ttu-id="289d7-1471">Questa proprietà è sempre <see langword="false" /> per tutte le matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-1471">This property is always <see langword="false" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1472"><xref:System.Array> implementa il <xref:System.Array.IsSynchronized%2A> proprietà perché è necessaria per il <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-1472"><xref:System.Array> implements the <xref:System.Array.IsSynchronized%2A> property because it is required by the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="289d7-1473">Classi di .NET framework basate su <xref:System.Array> fornire una propria versione sincronizzata della raccolta mediante la <xref:System.Array.SyncRoot%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="289d7-1473">.NET Framework classes based on <xref:System.Array> provide their own synchronized version of the collection using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 <span data-ttu-id="289d7-1474">Le classi che utilizzano matrici anche possono implementare la propria sincronizzazione utilizzando il <xref:System.Array.SyncRoot%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="289d7-1474">Classes that use arrays can also implement their own synchronization using the <xref:System.Array.SyncRoot%2A> property.</span></span> <span data-ttu-id="289d7-1475">Il codice di sincronizzazione è necessario eseguire operazioni sul `SyncRoot` della raccolta, non direttamente sulla raccolta.</span><span class="sxs-lookup"><span data-stu-id="289d7-1475">The synchronizing code must perform operations on the `SyncRoot` of the collection, not directly on the collection.</span></span> <span data-ttu-id="289d7-1476">In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1476">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="289d7-1477">In particolare, mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente l'insieme.</span><span class="sxs-lookup"><span data-stu-id="289d7-1477">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</span></span> <span data-ttu-id="289d7-1478">Si noti che alcune implementazioni di <xref:System.Array.SyncRoot%2A> potrebbe restituire il <xref:System.Array> stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-1478">Note that some implementations of <xref:System.Array.SyncRoot%2A> might return the <xref:System.Array> itself.</span></span>  
  
 <span data-ttu-id="289d7-1479">L'enumerazione di una raccolta non è quindi una procedura thread-safe.</span><span class="sxs-lookup"><span data-stu-id="289d7-1479">Enumerating through a collection is intrinsically not a thread safe procedure.</span></span> <span data-ttu-id="289d7-1480">Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore.</span><span class="sxs-lookup"><span data-stu-id="289d7-1480">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="289d7-1481">Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</span><span class="sxs-lookup"><span data-stu-id="289d7-1481">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="289d7-1482">Il recupero del valore di questa proprietà è un'operazione O(1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1482">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1483">Esempio di codice seguente viene illustrato come bloccare la matrice durante l'intera enumerazione tramite il <xref:System.Array.SyncRoot%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="289d7-1483">The following code example shows how to lock an array during the entire enumeration by using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-1484">Restituisce l'indice della prima ricorrenza di un valore in un oggetto <see cref="T:System.Array" /> unidimensionale o in una parte di <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1484">Returns the index of the last occurrence of a value in a one-dimensional <see cref="T:System.Array" /> or in a portion of the <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1485">Oggetto <see cref="T:System.Array" /> unidimensionale di cui effettuare la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1485">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1486">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1486">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="289d7-1487">Cerca l'oggetto specificato e restituisce l'indice dell'ultima ricorrenza all'interno dell'oggetto <see cref="T:System.Array" /> unidimensionale intero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1487">Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="289d7-1488">Indice dell'ultima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intera matrice <paramref name="array" />, se trovato; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1488">The index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1489">Oggetto unidimensionale <xref:System.Array> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1489">The one-dimensional <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="289d7-1490">Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1490">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="289d7-1491">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il `Equals` viene utilizzata l'implementazione di tale tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1491">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="289d7-1492">Poiché la maggior parte delle matrici dispone di un limite inferiore pari a zero, questo metodo in genere restituirà-1 se `value` non viene trovato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1492">Since most arrays will have a lower bound of zero, this method would generally return –1 when `value` is not found.</span></span> <span data-ttu-id="289d7-1493">Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` non viene trovato, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType>, ovvero `System.Int32.MinValue - 1`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1493">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="289d7-1494">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1494">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="289d7-1495">In .NET Framework versione 2.0, questo metodo Usa il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi del <xref:System.Array> per determinare se il <xref:System.Object> specificato da di `value` esiste un parametro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1495">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="289d7-1496">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `value` <xref:System.Object> stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-1496">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
 <span data-ttu-id="289d7-1497"><xref:System.IComparable.CompareTo%2A> metodi di `item` parametro per gli oggetti nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="289d7-1497"><xref:System.IComparable.CompareTo%2A> methods of the `item` parameter on the objects in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1498">Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato in una matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1498">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1499"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1499"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1500"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1500"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1501">Oggetto <see cref="T:System.Array" /> unidimensionale di cui effettuare la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1501">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1502">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1502">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1503">Indice iniziale della ricerca all'indietro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1503">The starting index of the backward search.</span></span></param>
        <summary><span data-ttu-id="289d7-1504">Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Array" /> unidimensionale compreso tra il primo elemento e l'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1504">Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="289d7-1505">Indice della prima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intervallo di elementi della matrice <paramref name="array" /> compreso tra il primo elemento e l'indice <paramref name="startIndex" />, se trovato; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1505">The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1506">Oggetto unidimensionale <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e termina in corrispondenza del primo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1506">The one-dimensional <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="289d7-1507">Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1507">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="289d7-1508">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il `Equals` viene utilizzata l'implementazione di tale tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1508">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="289d7-1509">Poiché la maggior parte delle matrici dispone di un limite inferiore pari a zero, questo metodo in genere restituirà-1 se `value` non viene trovato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1509">Since most arrays will have a lower bound of zero, this method would generally return –1 when `value` is not found.</span></span> <span data-ttu-id="289d7-1510">Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` non viene trovato, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType>, ovvero `System.Int32.MinValue - 1`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1510">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="289d7-1511">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi dall'inizio del `array` a `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1511">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
 <span data-ttu-id="289d7-1512">In .NET Framework versione 2.0, questo metodo Usa il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi del <xref:System.Array> per determinare se il <xref:System.Object> specificato da di `value` esiste un parametro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1512">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="289d7-1513">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `value` <xref:System.Object> stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-1513">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1514">Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato in una matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1514">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1515"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1515"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1516"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1516"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1517"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1517"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1518">Oggetto <see cref="T:System.Array" /> unidimensionale di cui effettuare la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1518">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1519">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1519">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1520">Indice iniziale della ricerca all'indietro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1520">The starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="289d7-1521">Numero di elementi nella sezione in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1521">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="289d7-1522">Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Array" /> unidimensionale che contiene il numero specificato di elementi e termina in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1522">Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="289d7-1523">Indice dell'ultima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intervallo di elementi della matrice <paramref name="array" /> che contiene il numero di elementi specificato nel parametro <paramref name="count" /> e termina in corrispondenza dell'indice <paramref name="startIndex" />, se trovato; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1523">The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1524">Oggetto unidimensionale <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e fine `startIndex` meno `count` + 1, se `count` è maggiore di 0.</span><span class="sxs-lookup"><span data-stu-id="289d7-1524">The one-dimensional <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="289d7-1525">Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1525">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="289d7-1526">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il`Equals` viene utilizzata l'implementazione di tale tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1526">If the element type is a nonintrinsic (user-defined) type, the`Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="289d7-1527">Poiché la maggior parte delle matrici dispone di un limite inferiore pari a zero, questo metodo in genere restituirà-1 se `value` non viene trovato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1527">Since most arrays will have a lower bound of zero, this method would generally return –1 when `value` is not found.</span></span> <span data-ttu-id="289d7-1528">Nel raro caso in cui il limite inferiore della matrice è uguale a <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` non viene trovato, questo metodo restituisce <xref:System.Int32.MaxValue?displayProperty=nameWithType>, ovvero `System.Int32.MinValue - 1`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1528">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="289d7-1529">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1529">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 <span data-ttu-id="289d7-1530">In .NET Framework versione 2.0, questo metodo Usa il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi del <xref:System.Array> per determinare se il <xref:System.Object> specificato da di `value` esiste un parametro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1530">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="289d7-1531">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> metodi il `value` <xref:System.Object> stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-1531">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1532">Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato in una matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1532">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span> <span data-ttu-id="289d7-1533">Si noti che il <xref:System.Array.LastIndexOf%2A> metodo è una ricerca con le versioni precedenti, pertanto, `count` deve essere minore o uguale a (`startIndex` meno il limite inferiore della matrice + 1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1533">Note that the <xref:System.Array.LastIndexOf%2A> method is a backward search; therefore, `count` must be less than or equal to (`startIndex` minus the lower bound of the array plus 1).</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1534"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1534"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1535"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1535"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-1536">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1536">-or-</span></span>  
  
 <span data-ttu-id="289d7-1537"><paramref name="count" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1537"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-1538">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1538">-or-</span></span>  
  
 <span data-ttu-id="289d7-1539"><paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1539"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1540"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1540"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1541">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1541">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1542">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1542">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1543">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1543">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="289d7-1544">Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intera matrice <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1544">Searches for the specified object and returns the index of the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="289d7-1545">Indice in base zero dell'ultima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intera matrice <paramref name="array" />, se trovato; in caso contrario, –1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1545">The zero-based index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1546">Il <xref:System.Array> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1546">The <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="289d7-1547">Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1547">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="289d7-1548">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il `Equals` viene utilizzata l'implementazione di tale tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1548">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="289d7-1549">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1549">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1550">Esempio di codice seguente illustra i tre overload generico del <xref:System.Array.LastIndexOf%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1550">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="289d7-1551">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1551">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="289d7-1552">Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca l'intera matrice dalla fine e trova la seconda occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1552">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="289d7-1553">Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nella matrice con le versioni precedenti a partire dalla posizione dell'indice 3 e continuando fino all'inizio della matrice e trova la prima occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1553">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="289d7-1554">Infine, il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, viene eseguita la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1 perché non siano presenti istanze della ricerca stringa in tale intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1554">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1555"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1555"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1556">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1556">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1557">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1557">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1558">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1558">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1559">Indice iniziale in base zero della ricerca all'indietro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1559">The zero-based starting index of the backward search.</span></span></param>
        <summary><span data-ttu-id="289d7-1560">Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Array" /> compreso tra il primo elemento e l'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1560">Searches for the specified object and returns the index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="289d7-1561">Indice in base zero dell'ultima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intervallo di elementi della matrice <paramref name="array" /> compreso tra il primo elemento e l'indice <paramref name="startIndex" />, se trovato; in caso contrario, –1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1561">The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1562">Il <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e termina in corrispondenza del primo elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1562">The <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="289d7-1563">Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1563">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="289d7-1564">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il `Equals` viene utilizzata l'implementazione di tale tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1564">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="289d7-1565">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il numero di elementi dall'inizio del `array` a `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1565">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1566">Esempio di codice seguente illustra i tre overload generico del <xref:System.Array.LastIndexOf%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1566">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="289d7-1567">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1567">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="289d7-1568">Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca l'intera matrice dalla fine e trova la seconda occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1568">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="289d7-1569">Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nella matrice con le versioni precedenti a partire dalla posizione dell'indice 3 e continuando fino all'inizio della matrice e trova la prima occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1569">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="289d7-1570">Infine, il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, viene eseguita la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1 perché non siano presenti istanze della ricerca stringa in tale intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1570">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1571"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1571"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1572"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1572"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1573">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1573">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1574">Oggetto <see cref="T:System.Array" /> unidimensionale in base zero in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1574">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-1575">Oggetto da individuare in <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1575">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="289d7-1576">Indice iniziale in base zero della ricerca all'indietro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1576">The zero-based starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="289d7-1577">Numero di elementi nella sezione in cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="289d7-1577">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="289d7-1578">Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi dell'oggetto <see cref="T:System.Array" /> che contiene il numero specificato di elementi e termina in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1578">Searches for the specified object and returns the index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="289d7-1579">Indice in base zero dell'ultima occorrenza del valore indicato nel parametro <paramref name="value" /> all'interno dell'intervallo di elementi della matrice <paramref name="array" /> che contiene il numero di elementi specificato nel parametro <paramref name="count" /> e termina in corrispondenza dell'indice <paramref name="startIndex" />, se trovato; in caso contrario, –1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1579">The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1580">Il <xref:System.Array> viene eseguita con le versioni precedenti a partire dall'indice `startIndex` e fine `startIndex` meno `count` + 1, se `count` è maggiore di 0.</span><span class="sxs-lookup"><span data-stu-id="289d7-1580">The <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="289d7-1581">Gli elementi vengono confrontati con il valore specificato utilizzando il <xref:System.Object.Equals%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1581">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="289d7-1582">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il `Equals` viene utilizzata l'implementazione di tale tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1582">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="289d7-1583">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `count`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1583">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1584">Esempio di codice seguente illustra i tre overload generico del <xref:System.Array.LastIndexOf%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1584">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="289d7-1585">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</span><span class="sxs-lookup"><span data-stu-id="289d7-1585">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="289d7-1586">Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo cerca l'intera matrice dalla fine e trova la seconda occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1586">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="289d7-1587">Il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca nella matrice con le versioni precedenti a partire dalla posizione dell'indice 3 e continuando fino all'inizio della matrice e trova la prima occorrenza della stringa.</span><span class="sxs-lookup"><span data-stu-id="289d7-1587">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="289d7-1588">Infine, il <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, viene eseguita la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1 perché non siano presenti istanze della ricerca stringa in tale intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1588">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1589"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1589"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1590"><paramref name="startIndex" /> non è compreso nell'intervallo di indici validi per <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1590"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-1591">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1591">-or-</span></span>  
  
 <span data-ttu-id="289d7-1592"><paramref name="count" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1592"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-1593">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1593">-or-</span></span>  
  
 <span data-ttu-id="289d7-1594"><paramref name="startIndex" /> e <paramref name="count" /> non specificano una sezione valida in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1594"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="289d7-1595">Ottiene il numero totale di elementi in tutte le dimensioni di <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1595">Gets the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="289d7-1596">Il numero totale di elementi in tutte le dimensioni del <see cref="T:System.Array" />; zero se non sono presenti elementi nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1596">The total number of elements in all the dimensions of the <see cref="T:System.Array" />; zero if there are no elements in the array.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1597">Il recupero del valore di questa proprietà è un'operazione O(1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1597">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1598">L'esempio seguente usa il <xref:System.Array.Length%2A> proprietà per ottenere il numero totale di elementi in una matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1598">The following example uses the                                 <xref:System.Array.Length%2A> property to get the total number of elements in an array.</span></span> <span data-ttu-id="289d7-1599">Utilizza inoltre il <xref:System.Array.GetUpperBound%2A> metodo per determinare il numero di elementi in ogni dimensione di una matrice multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1599">It also uses the                                 <xref:System.Array.GetUpperBound%2A> method to determine the number of elements in each dimension of a multidimensional array.</span></span>  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="289d7-1600">La matrice è multidimensionale e contiene più di <see cref="F:System.Int32.MaxValue" /> elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1600">The array is multidimensional and contains more than <see cref="F:System.Int32.MaxValue" /> elements.</span></span></exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="289d7-1601">Ottiene un integer a 64 bit che rappresenta il numero totale di elementi in tutte le dimensioni di <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1601">Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="289d7-1602">Valore intero a 64 bit che rappresenta il numero totale di elementi in tutte le dimensioni dell'oggetto <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1602">A 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1603">Il recupero del valore di questa proprietà è un'operazione O(1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1603">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="289d7-1604">Ottiene il rango (numero di dimensioni) dell'oggetto <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1604">Gets the rank (number of dimensions) of the <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1605">Ad esempio, una matrice unidimensionale restituisce 1, una matrice bidimensionale restituisce 2 e così via.</span><span class="sxs-lookup"><span data-stu-id="289d7-1605">For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on.</span></span></summary>
        <value><span data-ttu-id="289d7-1606">Rango (numero di dimensioni) dell'oggetto <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1606">The rank (number of dimensions) of the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1607">Ad esempio, il codice di Visual Basic</span><span class="sxs-lookup"><span data-stu-id="289d7-1607">For example, the Visual Basic code</span></span>  
  
```  
Dim TDArray(0,0,0) As Integer  
```  
  
 <span data-ttu-id="289d7-1608">e il codice c#</span><span class="sxs-lookup"><span data-stu-id="289d7-1608">and the C# code</span></span>  
  
```  
int[,,] TDArray = new int[1,1,1];  
```  
  
 <span data-ttu-id="289d7-1609">creare una matrice di tre dimensioni con un <xref:System.Array.Rank%2A> proprietà il cui valore è 3.</span><span class="sxs-lookup"><span data-stu-id="289d7-1609">create an array of three dimensions with a <xref:System.Array.Rank%2A> property whose value is 3.</span></span>  
  
 <span data-ttu-id="289d7-1610">Una matrice di matrici (una matrice di matrici) è una matrice unidimensionale; il valore della relativa <xref:System.Array.Rank%2A> proprietà è 1.</span><span class="sxs-lookup"><span data-stu-id="289d7-1610">A jagged array (an array of arrays) is a one-dimensional array; the value of its <xref:System.Array.Rank%2A> property is 1.</span></span>  
  
 <span data-ttu-id="289d7-1611">Il recupero del valore di questa proprietà è un'operazione O(1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1611">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1612">Nell'esempio seguente consente di inizializzare una matrice unidimensionale, una matrice bidimensionale e una matrice di matrici e recupera il <xref:System.Array.Rank%2A> proprietà di ogni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1612">The following example initializes a one-dimensional array, a two-dimensional array, and a jagged array, and retrieves the <xref:System.Array.Rank%2A> property of each.</span></span>  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-1613">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1613">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-1614">Matrice in base zero unidimensionale da ridimensionare oppure <see langword="null" /> per creare una nuova matrice della dimensione specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-1614">The one-dimensional, zero-based array to resize, or <see langword="null" /> to create a new array with the specified size.</span></span></param>
        <param name="newSize"><span data-ttu-id="289d7-1615">Dimensione della nuova matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1615">The size of the new array.</span></span></param>
        <summary><span data-ttu-id="289d7-1616">Modifica il numero di elementi di una matrice unidimensionale in una nuova dimensione specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-1616">Changes the number of elements of a one-dimensional array to the specified new size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1617">Questo metodo consente di allocare una nuova matrice con la dimensione specificata, copia gli elementi dalla matrice precedente a quello nuovo e quindi sostituisce quella precedente con quello nuovo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1617">This method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one.</span></span> <span data-ttu-id="289d7-1618">`array` deve essere una matrice unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1618">`array` must be a one-dimensional array.</span></span>  
  
 <span data-ttu-id="289d7-1619">Se `array` è `null`, questo metodo crea una nuova matrice con la dimensione specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-1619">If `array` is `null`, this method creates a new array with the specified size.</span></span>  
  
 <span data-ttu-id="289d7-1620">Se `newSize` è maggiore di <xref:System.Array.Length%2A> della matrice precedente viene allocata una nuova matrice e tutti gli elementi vengono copiati dalla matrice di precedente a quello nuovo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1620">If `newSize` is greater than the <xref:System.Array.Length%2A> of the old array, a new array is allocated and all the elements are copied from the old array to the new one.</span></span>  <span data-ttu-id="289d7-1621">Se `newSize` è inferiore a quello di <xref:System.Array.Length%2A> della matrice precedente viene allocata una nuova matrice e gli elementi vengono copiati dalla matrice precedente a quello nuovo fino a quando non viene compilata una nuova; il resto degli elementi nella matrice precedente viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1621">If `newSize` is less than the <xref:System.Array.Length%2A> of the old array, a new array is allocated and elements are copied from the old array to the new one until the new one is filled; the rest of the elements in the old array are ignored.</span></span>  <span data-ttu-id="289d7-1622">Se `newSize` è uguale al <xref:System.Array.Length%2A> della vecchia matrice, questo metodo non esegue alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="289d7-1622">If `newSize` is equal to the <xref:System.Array.Length%2A> of the old array, this method does nothing.</span></span>  
  
 <span data-ttu-id="289d7-1623">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `newSize`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1623">This method is an O(`n`) operation, where `n` is `newSize`.</span></span>  
  
 <span data-ttu-id="289d7-1624">Il <xref:System.Array.Resize%2A> metodo ridimensiona solo una matrice unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1624">The <xref:System.Array.Resize%2A> method resizes a one-dimensional array only.</span></span> <span data-ttu-id="289d7-1625">Il <xref:System.Array> non include un metodo per ridimensionare le matrici multidimensionali.</span><span class="sxs-lookup"><span data-stu-id="289d7-1625">The <xref:System.Array> class does not include a method for resizing multi-dimensional arrays.</span></span> <span data-ttu-id="289d7-1626">A tale scopo, è necessario fornire il proprio codice o chiamare un metodo speciale in una libreria di terze parti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1626">To do this, you must either provide your own code or call a special-purpose method in a third-party library.</span></span> <span data-ttu-id="289d7-1627">Il codice seguente illustra una possibile implementazione per un metodo che effettui il ridimensionamento di una matrice di *n* dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1627">The following code illustrates one possible implementation for a method that resizes an array of *n* dimensions.</span></span>  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1628">Nell'esempio seguente viene illustrato come il ridimensionamento influisce sulla matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-1628">The following example shows how resizing affects the array.</span></span>  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1629"><paramref name="newSize" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1629"><paramref name="newSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-1630">Inverte l'ordine degli elementi in un oggetto <see cref="T:System.Array" /> unidimensionale o in una parte dell'oggetto <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1630">Reverses the order of the elements in a one-dimensional <see cref="T:System.Array" /> or in a portion of the <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1631">Oggetto <see cref="T:System.Array" /> unidimensionale da invertire.</span><span class="sxs-lookup"><span data-stu-id="289d7-1631">The one-dimensional <see cref="T:System.Array" /> to reverse.</span></span></param>
        <summary><span data-ttu-id="289d7-1632">Inverte la sequenza degli elementi nell'oggetto <see cref="T:System.Array" /> intero unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1632">Reverses the sequence of the elements in the entire one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1633">Dopo una chiamata a questo metodo, l'elemento in corrispondenza `myArray[i]`, dove `i` è un indice nella matrice, viene spostato in `myArray[j]`, dove `j` è uguale a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1633">After a call to this method, the element at `myArray[i]`, where `i` is any index in the array, moves to `myArray[j]`, where `j` equals `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span></span>  
  
 <span data-ttu-id="289d7-1634">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1634">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="289d7-1635">Come illustrato nell'esempio seguente, il <xref:System.Array.Reverse%2A> metodo può essere utilizzato per invertire una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-1635">As the following example shows, the <xref:System.Array.Reverse%2A> method can be used to reverse a jagged array.</span></span> <span data-ttu-id="289d7-1636">Inizializza una matrice di matrici con un elemento per ogni mese dell'anno nel calendario le impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1636">It initializes a jagged array with one element for each month of the current year in the current culture's calendar.</span></span> <span data-ttu-id="289d7-1637">Ogni elemento contiene una matrice con numero di elementi di tale mese è giorni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1637">Each element contains an array with as many elements as that month has days.</span></span> <span data-ttu-id="289d7-1638">Nell'esempio viene visualizzato il contenuto della matrice, chiama il <xref:System.Array.Reverse%2A> (metodo), quindi viene visualizzato il contenuto della matrice invertita.</span><span class="sxs-lookup"><span data-stu-id="289d7-1638">The example displays the contents of the array, calls the <xref:System.Array.Reverse%2A> method, and then displays the contents of the reversed array.</span></span>  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1639">Esempio di codice seguente viene illustrato come invertire l'ordine dei valori in un <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1639">The following code example shows how to reverse the sort of the values in an <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1640"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1640"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1641"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1641"><paramref name="array" /> is multidimensional.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1642">Oggetto <see cref="T:System.Array" /> unidimensionale da invertire.</span><span class="sxs-lookup"><span data-stu-id="289d7-1642">The one-dimensional <see cref="T:System.Array" /> to reverse.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-1643">Indice iniziale della sezione da invertire.</span><span class="sxs-lookup"><span data-stu-id="289d7-1643">The starting index of the section to reverse.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-1644">Numero di elementi nella sezione da invertire.</span><span class="sxs-lookup"><span data-stu-id="289d7-1644">The number of elements in the section to reverse.</span></span></param>
        <summary><span data-ttu-id="289d7-1645">Inverte la sequenza degli elementi in un intervallo di elementi dell'oggetto <see cref="T:System.Array" /> unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1645">Reverses the sequence of the elements in a range of elements in the one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1646">Dopo una chiamata a questo metodo, l'elemento in corrispondenza `myArray[i]`, dove `i` è un indice nella matrice, viene spostato in `myArray[j]`, dove `j` è uguale a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1646">After a call to this method, the element at `myArray[i]`, where `i` is any index in the array, moves to `myArray[j]`, where `j` equals `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span></span>  
  
 <span data-ttu-id="289d7-1647">Il <xref:System.Array.Reverse%2A> metodo può essere utilizzato per invertire una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-1647">The <xref:System.Array.Reverse%2A> method can be used to reverse a jagged array.</span></span>  
  
 <span data-ttu-id="289d7-1648">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1648">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1649">Esempio di codice seguente viene illustrato come invertire l'ordine dei valori in un intervallo di elementi in un <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1649">The following code example shows how to reverse the sort of the values in a range of elements in an <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1650"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1650"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1651"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1651"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1652"><paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1652"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-1653">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1653">-or-</span></span>  
  
 <span data-ttu-id="289d7-1654"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1654"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-1655"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1655"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-1656">Ottiene il valore dell'elemento specificato nell'oggetto <see cref="T:System.Array" /> corrente al valore specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1656">Sets the specified element in the current <see cref="T:System.Array" /> to the specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-1657">Nuovo valore per l'elemento specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1657">The new value for the specified element.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-1658">Valore intero a 32 bit che rappresenta la posizione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1658">A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="289d7-1659">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1659">Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1660">L'indice viene specificato come intero a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1660">The index is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1661">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> i metodi possono determinare se il valore di `index` è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1661">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1662">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1662">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="289d7-1663">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1663">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1664">Se <xref:System.Array.SetValue%2A> viene utilizzata per assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1664">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="289d7-1665">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="289d7-1665">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1666">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1666">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1667">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente una dimensione.</span><span class="sxs-lookup"><span data-stu-id="289d7-1667">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="289d7-1668"><paramref name="value" /> non può essere impostato sul tipo di elemento della <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1668"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="289d7-1669"><paramref name="index" /> non è compreso nell'intervallo di indici validi per l'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1669"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-1670">Nuovo valore per l'elemento specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1670">The new value for the specified element.</span></span></param>
        <param name="indices"><span data-ttu-id="289d7-1671">Matrice unidimensionale di interi a 32 bit che rappresentano gli indici che specificano la posizione dell'elemento da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1671">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</span></span></param>
        <summary><span data-ttu-id="289d7-1672">Imposta il valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1672">Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1673">Gli indici vengono specificati come una matrice di interi a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1673">The indexes are specified as an array of 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1674">Il numero di elementi in `indices` sia uguale al numero di dimensioni di <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1674">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="289d7-1675">Tutti gli elementi di `indices` matrice deve specificare collettivamente la posizione dell'elemento desiderato nell'oggetto multidimensionale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1675">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-1676">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno dei valori di `indices` matrice è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1676">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the values in the `indices` array is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1677">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1677">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="289d7-1678">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1678">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1679">Se <xref:System.Array.SetValue%2A> viene utilizzata per assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1679">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="289d7-1680">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="289d7-1680">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1681">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1681">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1682"><paramref name="indices" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1682"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1683">Il numero di dimensioni nell'oggetto <see cref="T:System.Array" /> corrente non è uguale al numero di elementi in <paramref name="indices" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1683">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="289d7-1684"><paramref name="value" /> non può essere impostato sul tipo di elemento della <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1684"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="289d7-1685">Ogni elemento in <paramref name="indices" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1685">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-1686">Nuovo valore per l'elemento specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1686">The new value for the specified element.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-1687">Integer a 64 bit che rappresenta la posizione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1687">A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="289d7-1688">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1688">Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1689">L'indice viene specificato come intero a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1689">The index is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1690">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> i metodi possono determinare se il valore di `index` è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1690">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1691">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1691">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="289d7-1692">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1692">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1693">Se <xref:System.Array.SetValue%2A> viene utilizzata per assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1693">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="289d7-1694">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="289d7-1694">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1695">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1695">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1696">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente una dimensione.</span><span class="sxs-lookup"><span data-stu-id="289d7-1696">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="289d7-1697"><paramref name="value" /> non può essere impostato sul tipo di elemento della <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1697"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1698"><paramref name="index" /> non è compreso nell'intervallo di indici validi per l'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1698"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-1699">Nuovo valore per l'elemento specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1699">The new value for the specified element.</span></span></param>
        <param name="indices"><span data-ttu-id="289d7-1700">Matrice unidimensionale di interi a 64 bit che rappresentano gli indici che specificano la posizione dell'elemento da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1700">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</span></span></param>
        <summary><span data-ttu-id="289d7-1701">Imposta il valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1701">Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1702">Gli indici vengono specificati come una matrice di interi a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1702">The indexes are specified as an array of 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1703">Il numero di elementi in `indices` sia uguale al numero di dimensioni di <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1703">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="289d7-1704">Tutti gli elementi di `indices` matrice deve specificare collettivamente la posizione dell'elemento desiderato nell'oggetto multidimensionale <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1704">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-1705">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi possono determinare se uno dei valori di `indices` matrice è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1705">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the values in the `indices` array is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1706">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1706">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="289d7-1707">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1707">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1708">Se <xref:System.Array.SetValue%2A> viene utilizzata per assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1708">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="289d7-1709">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="289d7-1709">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1710">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1710">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1711"><paramref name="indices" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1711"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1712">Il numero di dimensioni nell'oggetto <see cref="T:System.Array" /> corrente non è uguale al numero di elementi in <paramref name="indices" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1712">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="289d7-1713"><paramref name="value" /> non può essere impostato sul tipo di elemento della <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1713"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="289d7-1714">Ogni elemento in <paramref name="indices" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1714">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-1715">Nuovo valore per l'elemento specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1715">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="289d7-1716">Valore intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1716">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="289d7-1717">Valore intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1717">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="289d7-1718">Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1718">Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1719">Gli indici vengono specificati come interi a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1719">The indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1720">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1720">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1721">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1721">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="289d7-1722">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1722">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1723">Se <xref:System.Array.SetValue%2A> viene utilizzata per assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1723">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="289d7-1724">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="289d7-1724">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1725">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1725">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1726">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente due dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1726">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="289d7-1727"><paramref name="value" /> non può essere impostato sul tipo di elemento della <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1727"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="289d7-1728"><paramref name="index1" /> o <paramref name="index2" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1728">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-1729">Nuovo valore per l'elemento specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1729">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="289d7-1730">Integer a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1730">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="289d7-1731">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1731">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="289d7-1732">Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> bidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1732">Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1733">Gli indici vengono specificati come interi a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1733">The indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1734">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1734">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1735">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1735">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="289d7-1736">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1736">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1737">Se <xref:System.Array.SetValue%2A> viene utilizzata per assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1737">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="289d7-1738">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="289d7-1738">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1739">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1739">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1740">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente due dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1740">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="289d7-1741"><paramref name="value" /> non può essere impostato sul tipo di elemento della <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1741"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="289d7-1742"><paramref name="index1" /> o <paramref name="index2" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1742">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-1743">Nuovo valore per l'elemento specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1743">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="289d7-1744">Valore intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1744">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="289d7-1745">Valore intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1745">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index3"><span data-ttu-id="289d7-1746">Valore intero a 32 bit che rappresenta l'indice della terza dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1746">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="289d7-1747">Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1747">Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1748">Gli indici vengono specificati come interi a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1748">The indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1749">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1749">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1750">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1750">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="289d7-1751">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1751">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1752">Se <xref:System.Array.SetValue%2A> viene utilizzata per assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1752">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="289d7-1753">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="289d7-1753">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1754">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1754">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1755">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente tre dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1755">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="289d7-1756"><paramref name="value" /> non può essere impostato sul tipo di elemento della <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1756"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="289d7-1757"><paramref name="index1" /> o <paramref name="index2" /> o <paramref name="index3" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1757"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-1758">Nuovo valore per l'elemento specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-1758">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="289d7-1759">Integer a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1759">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="289d7-1760">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1760">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index3"><span data-ttu-id="289d7-1761">Integer a 64 bit che rappresenta l'indice della terza dimensione dell'elemento <see cref="T:System.Array" /> da impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1761">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="289d7-1762">Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <see cref="T:System.Array" /> tridimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1762">Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="289d7-1763">Gli indici vengono specificati come interi a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="289d7-1763">The indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1764">Il <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1764">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="289d7-1765">Per ulteriori informazioni sulle conversioni, vedere <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1765">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="289d7-1766">Questo metodo è un'operazione o (1).</span><span class="sxs-lookup"><span data-stu-id="289d7-1766">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-1767">Se <xref:System.Array.SetValue%2A> viene utilizzata per assegnare `null` a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1767">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="289d7-1768">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="289d7-1768">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1769">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1769">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1770">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente tre dimensioni.</span><span class="sxs-lookup"><span data-stu-id="289d7-1770">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="289d7-1771"><paramref name="value" /> non può essere impostato sul tipo di elemento della <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1771"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1772"><paramref name="index1" /> o <paramref name="index2" /> o <paramref name="index3" /> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <see cref="T:System.Array" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1772"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="289d7-1773">Ordina gli elementi in una matrice unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1773">Sorts the elements in a one-dimensional array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1774">Oggetto <see cref="T:System.Array" /> unidimensionale da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1774">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <summary><span data-ttu-id="289d7-1775">Ordina gli elementi di un'intera matrice <see cref="T:System.Array" /> unidimensionale utilizzando l'implementazione dell'interfaccia <see cref="T:System.IComparable" /> di ciascun elemento dell'oggetto <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1775">Sorts the elements in an entire one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1776">Ogni elemento di `array` deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1776">Each element of `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="289d7-1777">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1777">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-1778">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-1778">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-1779">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un[ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1779">If the partition size is fewer than 16 elements, it uses an[insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1780">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1780">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1781">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1781">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-1782">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-1782">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-1783">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-1783">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-1784">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1784">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1785">Esempio di codice seguente viene illustrato come ordinare i valori in un <xref:System.Array> utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1785">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="289d7-1786">Si noti che il risultato potrebbe variare a seconda di corrente <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1786">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1787"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1787"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1788"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1788"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="289d7-1789">Uno o più elementi in <paramref name="array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1789">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="289d7-1790">L'oggetto <see cref="T:System.Array" /> unidimensionale che contiene le chiavi da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1790">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="289d7-1791">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <c>keys</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1791">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="289d7-1792">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1792">-or-</span></span>  
  
 <span data-ttu-id="289d7-1793"><see langword="null" /> per ordinare solo <c>keys</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1793"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <summary><span data-ttu-id="289d7-1794">Ordina una coppia di oggetti <see cref="T:System.Array" /> unidimensionali (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Array" /> utilizzando l'implementazione dell'interfaccia <see cref="T:System.IComparable" /> di ciascuna chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-1794">Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1795">Ogni chiave di `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1795">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="289d7-1796">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1796">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="289d7-1797">Pertanto, il `items` <xref:System.Array> viene ordinato in base a disposizione delle chiavi corrispondenti nel `keys` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1797">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-1798">Ogni chiave di `keys` <xref:System.Array> deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-1798">Each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="289d7-1799">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1799">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="289d7-1800">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1800">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="289d7-1801">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1801">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-1802">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-1802">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-1803">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1803">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1804">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1804">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1805">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1805">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-1806">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-1806">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-1807">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-1807">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-1808">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `keys`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1808">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `keys`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1809">Nell'esempio seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori.</span><span class="sxs-lookup"><span data-stu-id="289d7-1809">The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="289d7-1810">Ordinamenti vengono eseguiti utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1810">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="289d7-1811">Si noti che il risultato potrebbe variare a seconda di corrente <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1811">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1812"><paramref name="keys" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1812"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="289d7-1813">L'oggetto <paramref name="keys" /><see cref="T:System.Array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1813">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="289d7-1814">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1814">-or-</span></span>  
  
 <span data-ttu-id="289d7-1815">L'oggetto <paramref name="items" /><see cref="T:System.Array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1815">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-1816"><paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1816"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="289d7-1817">Uno o più elementi nell'oggetto <see cref="T:System.Array" /> di <paramref name="keys" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1817">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1818">Matrice unidimensionale da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1818">The one-dimensional array to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-1819">Implementazione da usare quando si confrontano elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1819">The implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="289d7-1820">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1820">-or-</span></span>  
  
 <span data-ttu-id="289d7-1821"><see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1821"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-1822">Ordina gli elementi in un oggetto <see cref="T:System.Array" /> unidimensionale utilizzando l'interfaccia <see cref="T:System.Collections.IComparer" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-1822">Sorts the elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1823">Se `comparer` è `null`, ogni elemento di `array` deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1823">If `comparer` is `null`, each element of `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="289d7-1824">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1824">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-1825">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-1825">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-1826">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1826">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1827">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1827">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1828">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1828">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-1829">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-1829">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-1830">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-1830">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-1831">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1831">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="289d7-1832">.NET Framework include predefiniti <xref:System.Collections.IComparer> implementazioni elencati nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1832">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="289d7-1833">Implementazione</span><span class="sxs-lookup"><span data-stu-id="289d7-1833">Implementation</span></span>|<span data-ttu-id="289d7-1834">Descrizione</span><span class="sxs-lookup"><span data-stu-id="289d7-1834">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="289d7-1835">Confronta due oggetti, ma esegue un confronto tra maiuscole e minuscole delle stringhe.</span><span class="sxs-lookup"><span data-stu-id="289d7-1835">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="289d7-1836">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1836">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="289d7-1837">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura invarianti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1837">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="289d7-1838">Confronta due oggetti di tipo `T` utilizzando l'ordinamento predefinito del tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1838">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="289d7-1839">È anche possibile supportare i confronti personalizzati, fornendo un'istanza personalizzata <xref:System.Collections.IComparer> implementazione per il `comparer` parametro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1839">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="289d7-1840">Nell'esempio viene eseguita la definizione di un `ReverseComparer` classe che consente di invertire l'ordinamento predefinito per le istanze di un tipo ed esegue il confronto tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="289d7-1840">The example does this by defining a `ReverseComparer` class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1841">Nell'esempio seguente Ordina i valori in una stringa di arrayby utilizzando l'operatore di confronto predefinito.</span><span class="sxs-lookup"><span data-stu-id="289d7-1841">The following example sorts the values in a string arrayby using the default comparer.</span></span> <span data-ttu-id="289d7-1842">Definisce inoltre un oggetto personalizzato <xref:System.Collections.IComparer> implementazione denominato `ReverseComparer` che inverte l'ordine predefinito dell'oggetto durante l'esecuzione di un confronto tra stringhe tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="289d7-1842">It also defines a custom <xref:System.Collections.IComparer> implementation named `ReverseComparer` that reverses an object's default sort order while performing a case-insensitive string comparison.</span></span> <span data-ttu-id="289d7-1843">Si noti che l'output potrebbe variare a seconda delle impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1843">Note that the output might vary depending on the current culture.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1844"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1844"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1845"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1845"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-1846"><paramref name="comparer" /> è <see langword="null" /> e uno o più elementi in <paramref name="array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1846"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-1847">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1847">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="289d7-1848">Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-1848">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="289d7-1849">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="289d7-1849">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="289d7-1850">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante.</span><span class="sxs-lookup"><span data-stu-id="289d7-1850">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="289d7-1851">A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-1851">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="289d7-1852">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1852">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="289d7-1853">L'oggetto <see cref="T:System.Array" /> unidimensionale che contiene le chiavi da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1853">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="289d7-1854">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <c>keys</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1854">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="289d7-1855">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1855">-or-</span></span>  
  
 <span data-ttu-id="289d7-1856"><see langword="null" /> per ordinare solo <c>keys</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1856"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-1857">Implementazione <see cref="T:System.Collections.IComparer" /> da usare quando si confrontano gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1857">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="289d7-1858">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1858">-or-</span></span>  
  
 <span data-ttu-id="289d7-1859"><see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1859"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-1860">Ordina una coppia di oggetti <see cref="T:System.Array" /> unidimensionali (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Array" /> utilizzando l'interfaccia <see cref="T:System.Collections.IComparer" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-1860">Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1861">Ogni chiave di `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1861">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="289d7-1862">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1862">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="289d7-1863">Pertanto, il `items` <xref:System.Array> viene ordinato in base a disposizione delle chiavi corrispondenti nel `keys` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1863">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-1864">Se `comparer` è `null`, ogni chiave nel `keys` <xref:System.Array> deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-1864">If `comparer` is `null`, each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="289d7-1865">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1865">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="289d7-1866">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1866">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="289d7-1867">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1867">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-1868">.NET Framework include predefiniti <xref:System.Collections.IComparer> implementazioni elencati nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1868">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="289d7-1869">Implementazione</span><span class="sxs-lookup"><span data-stu-id="289d7-1869">Implementation</span></span>|<span data-ttu-id="289d7-1870">Descrizione</span><span class="sxs-lookup"><span data-stu-id="289d7-1870">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="289d7-1871">Confronta due oggetti, ma esegue un confronto tra maiuscole e minuscole delle stringhe.</span><span class="sxs-lookup"><span data-stu-id="289d7-1871">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="289d7-1872">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1872">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="289d7-1873">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura invarianti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1873">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="289d7-1874">Confronta due oggetti di tipo `T` utilizzando l'ordinamento predefinito del tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1874">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="289d7-1875">È anche possibile supportare i confronti personalizzati, fornendo un'istanza personalizzata <xref:System.Collections.IComparer> implementazione per il `comparer` parametro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1875">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="289d7-1876">Nell'esempio viene eseguita la definizione di un <xref:System.Collections.IComparer> implementazione che consente di invertire l'ordinamento predefinito ed esegue il confronto tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="289d7-1876">The example does this by defining an <xref:System.Collections.IComparer> implementation that reverses the default sort order and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="289d7-1877">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-1877">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-1878">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1878">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1879">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1879">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1880">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1880">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-1881">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-1881">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-1882">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-1882">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-1883">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `keys`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1883">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `keys`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1884">Nell'esempio seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori.</span><span class="sxs-lookup"><span data-stu-id="289d7-1884">The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="289d7-1885">Ordinamenti vengono eseguiti utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1885">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="289d7-1886">Si noti che il risultato potrebbe variare a seconda di corrente <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1886">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1887"><paramref name="keys" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1887"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="289d7-1888">L'oggetto <paramref name="keys" /><see cref="T:System.Array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1888">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="289d7-1889">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1889">-or-</span></span>  
  
 <span data-ttu-id="289d7-1890">L'oggetto <paramref name="items" /><see cref="T:System.Array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1890">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-1891"><paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1891"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="289d7-1892">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1892">-or-</span></span>  
  
 <span data-ttu-id="289d7-1893">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1893">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="289d7-1894">Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-1894">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-1895"><paramref name="comparer" /> è <see langword="null" />, e uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1895"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="289d7-1896">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="289d7-1896">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="289d7-1897">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante.</span><span class="sxs-lookup"><span data-stu-id="289d7-1897">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="289d7-1898">A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che previouslythrew <see cref="T:System.ArgumentException" /> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-1898">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previouslythrew <see cref="T:System.ArgumentException" /> will not throw an exception, becausethe insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="289d7-1899">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1899">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1900">Oggetto <see cref="T:System.Array" /> unidimensionale da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1900">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-1901">Indice iniziale dell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1901">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-1902">Numero di elementi nell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1902">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="289d7-1903">Ordina un intervallo di elementi di un oggetto <see cref="T:System.Array" /> unidimensionale utilizzando l'implementazione dell'interfaccia <see cref="T:System.IComparable" /> di ciascun elemento dell'oggetto <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1903">Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1904">Ogni elemento all'interno dell'intervallo specificato di elementi in `array` deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1904">Each element within the specified range of elements in `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="289d7-1905">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1905">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-1906">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-1906">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-1907">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1907">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1908">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1908">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1909">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1909">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-1910">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-1910">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-1911">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-1911">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-1912">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1912">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1913">Esempio di codice seguente viene illustrato come ordinare i valori in un <xref:System.Array> utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1913">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="289d7-1914">Si noti che il risultato potrebbe variare a seconda di corrente <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1914">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1915"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1915"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1916"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1916"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1917"><paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1917"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-1918">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1918">-or-</span></span>  
  
 <span data-ttu-id="289d7-1919"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1919"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-1920"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1920"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="289d7-1921">Uno o più elementi in <paramref name="array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1921">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="289d7-1922">L'oggetto <see cref="T:System.Array" /> unidimensionale che contiene le chiavi da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1922">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="289d7-1923">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <c>keys</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1923">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="289d7-1924">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1924">-or-</span></span>  
  
 <span data-ttu-id="289d7-1925"><see langword="null" /> per ordinare solo <c>keys</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1925"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-1926">Indice iniziale dell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1926">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-1927">Numero di elementi nell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1927">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="289d7-1928">Ordina un intervallo di elementi in una coppia di oggetti <see cref="T:System.Array" /> unidimensionali (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <see cref="T:System.Array" /> utilizzando l'implementazione dell'interfaccia <see cref="T:System.IComparable" /> di ciascuna chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-1928">Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1929">Ogni chiave di `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1929">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="289d7-1930">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1930">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="289d7-1931">Pertanto, il `items` <xref:System.Array> viene ordinato in base a disposizione delle chiavi corrispondenti nel `keys` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1931">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-1932">Ogni chiave all'interno dell'intervallo specificato di elementi di `keys` <xref:System.Array> deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-1932">Each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="289d7-1933">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1933">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="289d7-1934">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1934">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="289d7-1935">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1935">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-1936">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-1936">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-1937">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1937">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1938">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1938">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1939">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1939">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-1940">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-1940">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-1941">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-1941">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-1942">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1942">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1943">Esempio di codice seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori.</span><span class="sxs-lookup"><span data-stu-id="289d7-1943">The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="289d7-1944">Ordinamenti vengono eseguiti utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1944">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="289d7-1945">Si noti che il risultato potrebbe variare a seconda di corrente <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1945">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1946"><paramref name="keys" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1946"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="289d7-1947">L'oggetto <paramref name="keys" /><see cref="T:System.Array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1947">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="289d7-1948">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1948">-or-</span></span>  
  
 <span data-ttu-id="289d7-1949">L'oggetto <paramref name="items" /><see cref="T:System.Array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1949">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1950"><paramref name="index" /> è minore del limite inferiore di <paramref name="keys" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1950"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="289d7-1951">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1951">-or-</span></span>  
  
 <span data-ttu-id="289d7-1952"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1952"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-1953"><paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1953"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="289d7-1954">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1954">-or-</span></span>  
  
 <span data-ttu-id="289d7-1955"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="keys" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1955"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="289d7-1956">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1956">-or-</span></span>  
  
 <span data-ttu-id="289d7-1957"><paramref name="items" /> non è <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="items" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1957"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="289d7-1958">Uno o più elementi nell'oggetto <see cref="T:System.Array" /> di <paramref name="keys" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1958">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="289d7-1959">Oggetto <see cref="T:System.Array" /> unidimensionale da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1959">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-1960">Indice iniziale dell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1960">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-1961">Numero di elementi nell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-1961">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-1962">Implementazione <see cref="T:System.Collections.IComparer" /> da usare quando si confrontano gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1962">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="289d7-1963">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1963">-or-</span></span>  
  
 <span data-ttu-id="289d7-1964"><see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1964"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-1965">Ordina un intervallo di elementi di un oggetto <see cref="T:System.Array" /> unidimensionale utilizzando l'interfaccia <see cref="T:System.Collections.IComparer" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-1965">Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-1966">Se `comparer` è `null`, ogni elemento all'interno dell'intervallo specificato di elementi in `array` deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1966">If `comparer` is `null`, each element within the specified range of elements in `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="289d7-1967">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1967">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-1968">.NET Framework include predefiniti <xref:System.Collections.IComparer> implementazioni elencati nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="289d7-1968">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="289d7-1969">Implementazione</span><span class="sxs-lookup"><span data-stu-id="289d7-1969">Implementation</span></span>|<span data-ttu-id="289d7-1970">Descrizione</span><span class="sxs-lookup"><span data-stu-id="289d7-1970">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="289d7-1971">Confronta due oggetti, ma esegue un confronto tra maiuscole e minuscole delle stringhe.</span><span class="sxs-lookup"><span data-stu-id="289d7-1971">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="289d7-1972">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1972">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="289d7-1973">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura invarianti.</span><span class="sxs-lookup"><span data-stu-id="289d7-1973">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="289d7-1974">Confronta due oggetti di tipo `T` utilizzando l'ordinamento predefinito del tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1974">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="289d7-1975">È anche possibile supportare i confronti personalizzati, fornendo un'istanza personalizzata <xref:System.Collections.IComparer> implementazione per il `comparer` parametro.</span><span class="sxs-lookup"><span data-stu-id="289d7-1975">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="289d7-1976">Nell'esempio viene eseguita la definizione di un `ReverseComparer` classe che consente di invertire l'ordinamento predefinito per le istanze di un tipo ed esegue il confronto tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="289d7-1976">The example does this by defining a `ReverseComparer` class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="289d7-1977">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-1977">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-1978">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1978">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1979">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1979">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-1980">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-1980">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-1981">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-1981">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-1982">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-1982">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-1983">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-1983">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-1984">Esempio di codice seguente viene illustrato come ordinare i valori in un <xref:System.Array> utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1984">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="289d7-1985">Si noti che il risultato potrebbe variare a seconda di corrente <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="289d7-1985">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-1986"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1986"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="289d7-1987"><paramref name="array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-1987"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-1988"><paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1988"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-1989">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1989">-or-</span></span>  
  
 <span data-ttu-id="289d7-1990"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-1990"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-1991"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1991"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-1992">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-1992">-or-</span></span>  
  
 <span data-ttu-id="289d7-1993">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-1993">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="289d7-1994">Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-1994">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-1995"><paramref name="comparer" /> è <see langword="null" /> e uno o più elementi in <paramref name="array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-1995"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="289d7-1996">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="289d7-1996">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="289d7-1997">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante.</span><span class="sxs-lookup"><span data-stu-id="289d7-1997">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="289d7-1998">A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-1998">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="289d7-1999">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-1999">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="289d7-2000">L'oggetto <see cref="T:System.Array" /> unidimensionale che contiene le chiavi da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2000">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="289d7-2001">Oggetto <see cref="T:System.Array" /> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <c>keys</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2001">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="289d7-2002">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2002">-or-</span></span>  
  
 <span data-ttu-id="289d7-2003"><see langword="null" /> per ordinare solo <c>keys</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2003"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-2004">Indice iniziale dell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2004">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-2005">Numero di elementi nell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2005">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-2006">Implementazione <see cref="T:System.Collections.IComparer" /> da usare quando si confrontano gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2006">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="289d7-2007">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2007">-or-</span></span>  
  
 <span data-ttu-id="289d7-2008"><see langword="null" /> per usare l'implementazione <see cref="T:System.IComparable" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2008"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-2009">Ordina un intervallo di elementi in una coppia di oggetti <see cref="T:System.Array" /> unidimensionali (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <see cref="T:System.Array" /> utilizzando l'interfaccia <see cref="T:System.Collections.IComparer" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-2009">Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2010">Ogni chiave di `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2010">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="289d7-2011">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2011">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="289d7-2012">Pertanto, il `items` <xref:System.Array> viene ordinato in base a disposizione delle chiavi corrispondenti nel `keys` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2012">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-2013">Se `comparer` è `null`, ogni chiave all'interno dell'intervallo specificato di elementi nel `keys` <xref:System.Array> deve implementare il <xref:System.IComparable> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-2013">If `comparer` is `null`, each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="289d7-2014">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2014">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="289d7-2015">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2015">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="289d7-2016">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2016">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-2017">.NET Framework include predefiniti <xref:System.Collections.IComparer> implementazioni elencati nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2017">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="289d7-2018">Implementazione</span><span class="sxs-lookup"><span data-stu-id="289d7-2018">Implementation</span></span>|<span data-ttu-id="289d7-2019">Descrizione</span><span class="sxs-lookup"><span data-stu-id="289d7-2019">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="289d7-2020">Confronta due oggetti, ma esegue un confronto tra maiuscole e minuscole delle stringhe.</span><span class="sxs-lookup"><span data-stu-id="289d7-2020">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="289d7-2021">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2021">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="289d7-2022">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura invarianti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2022">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="289d7-2023">Confronta due oggetti di tipo `T` utilizzando l'ordinamento predefinito del tipo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2023">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="289d7-2024">È anche possibile supportare i confronti personalizzati, fornendo un'istanza personalizzata <xref:System.Collections.IComparer> implementazione per il `comparer` parametro.</span><span class="sxs-lookup"><span data-stu-id="289d7-2024">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="289d7-2025">Nell'esempio viene eseguita la definizione di un oggetto personalizzato <xref:System.Collections.IComparer> implementazione che consente di invertire l'ordinamento predefinito ed esegue il confronto tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="289d7-2025">The example does this by defining a custom <xref:System.Collections.IComparer> implementation that reverses the default sort order and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="289d7-2026">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-2026">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-2027">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2027">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2028">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2028">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2029">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2029">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-2030">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2030">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-2031">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2031">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-2032">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2032">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2033">Esempio di codice seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori.</span><span class="sxs-lookup"><span data-stu-id="289d7-2033">The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="289d7-2034">Ordinamenti vengono eseguiti utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2034">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="289d7-2035">Si noti che il risultato potrebbe variare a seconda di corrente <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2035">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-2036"><paramref name="keys" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2036"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="289d7-2037">L'oggetto <paramref name="keys" /><see cref="T:System.Array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-2037">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="289d7-2038">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2038">-or-</span></span>  
  
 <span data-ttu-id="289d7-2039">L'oggetto <paramref name="items" /><see cref="T:System.Array" /> è multidimensionale.</span><span class="sxs-lookup"><span data-stu-id="289d7-2039">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-2040"><paramref name="index" /> è minore del limite inferiore di <paramref name="keys" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2040"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="289d7-2041">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2041">-or-</span></span>  
  
 <span data-ttu-id="289d7-2042"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-2042"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-2043"><paramref name="items" /> non è <see langword="null" />, e il limite inferiore di <paramref name="keys" /> non corrisponde al limite inferiore di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2043"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="289d7-2044">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2044">-or-</span></span>  
  
 <span data-ttu-id="289d7-2045"><paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2045"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="289d7-2046">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2046">-or-</span></span>  
  
 <span data-ttu-id="289d7-2047"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="keys" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2047"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="289d7-2048">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2048">-or-</span></span>  
  
 <span data-ttu-id="289d7-2049"><paramref name="items" /> non è <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="items" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2049"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="289d7-2050">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2050">-or-</span></span>  
  
 <span data-ttu-id="289d7-2051">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2051">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="289d7-2052">Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2052">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-2053"><paramref name="comparer" /> è <see langword="null" />, e uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2053"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="289d7-2054">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="289d7-2054">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="289d7-2055">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante.</span><span class="sxs-lookup"><span data-stu-id="289d7-2055">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="289d7-2056">A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-2056">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="289d7-2057">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2057">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-2058">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2058">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-2059">Oggetto <see cref="T:System.Array" /> unidimensionale e in base zero da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2059">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort.</span></span></param>
        <summary><span data-ttu-id="289d7-2060">Ordina gli elementi di un'intera matrice <see cref="T:System.Array" /> utilizzando l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascun elemento della matrice <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2060">Sorts the elements in an entire <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2061">Ogni elemento di `array` deve implementare il <xref:System.IComparable%601> interfaccia generica per essere in grado di eseguire confronti con ogni altro elemento `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2061">Each element of `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="289d7-2062">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2062">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-2063">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-2063">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-2064">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2064">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2065">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2065">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2066">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2066">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-2067">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2067">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-2068">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2068">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-2069">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2069">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2070">L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> overload del metodo generico e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo generico.</span><span class="sxs-lookup"><span data-stu-id="289d7-2070">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload.</span></span> <span data-ttu-id="289d7-2071">Viene creata una matrice di stringhe, in nessun ordine particolare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2071">An array of strings is created, in no particular order.</span></span>  
  
 <span data-ttu-id="289d7-2072">La matrice è visualizzata, ordinata e visualizzata di nuovo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2072">The array is displayed, sorted, and displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-2073">Le chiamate al <xref:System.Array.Sort%2A> e <xref:System.Array.BinarySearch%2A> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2073">The calls to the <xref:System.Array.Sort%2A> and <xref:System.Array.BinarySearch%2A> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="289d7-2074">Se si utilizza il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2074">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="289d7-2075">Il <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> overload del metodo generico viene quindi utilizzato per eseguire la ricerca di due stringhe, uno che non si trova la matrice e uno che.</span><span class="sxs-lookup"><span data-stu-id="289d7-2075">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="289d7-2076">La matrice e il valore restituito del <xref:System.Array.BinarySearch%2A> metodo vengono passati al `ShowWhere` metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario gli elementi della stringa di ricerca sarebbe compresa se fosse nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2076">The array and the return value of the <xref:System.Array.BinarySearch%2A> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="289d7-2077">L'indice è negativo se la stringa non è inclusa nella matrice, pertanto la `ShowWhere` metodo accetta il complemento bit per bit (il ~ operatore in c# e Visual C++, `Xor` -1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore di stri di ricerca NG.</span><span class="sxs-lookup"><span data-stu-id="289d7-2077">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-2078"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2078"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="289d7-2079">Uno o più elementi della matrice <paramref name="array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2079">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-2080">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2080">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-2081">Oggetto <see cref="T:System.Array" /> unidimensionale e in base zero da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2081">The one-dimensional, zero-base <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-2082">Implementazione dell'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> da utilizzare per il confronto fra gli elementi; oppure, impostare <see langword="null" /> per utilizzare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2082">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-2083">Ordina gli elementi di un oggetto <see cref="T:System.Array" /> utilizzando l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-2083">Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2084">Se `comparer` è `null`, ogni elemento di `array` deve implementare il <xref:System.IComparable%601> interfaccia generica per essere in grado di eseguire confronti con ogni altro elemento `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2084">If `comparer` is `null`, each element of `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="289d7-2085">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2085">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-2086">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-2086">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-2087">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2087">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2088">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2088">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2089">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2089">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-2090">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2090">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-2091">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2091">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-2092">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2092">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2093">L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico.</span><span class="sxs-lookup"><span data-stu-id="289d7-2093">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload.</span></span>  
  
 <span data-ttu-id="289d7-2094">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato `ReverseCompare`, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica.</span><span class="sxs-lookup"><span data-stu-id="289d7-2094">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="289d7-2095">Operatore di confronto chiama il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</span><span class="sxs-lookup"><span data-stu-id="289d7-2095">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="289d7-2096">La matrice è visualizzata, ordinata e visualizzata di nuovo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2096">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="289d7-2097">Le matrici devono essere ordinate per utilizzare il <xref:System.Array.BinarySearch%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2097">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-2098">Le chiamate al <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2098">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="289d7-2099">Se si utilizza il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2099">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="289d7-2100">Il <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico viene quindi utilizzato per eseguire la ricerca di due stringhe, uno che non si trova la matrice e uno che.</span><span class="sxs-lookup"><span data-stu-id="289d7-2100">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="289d7-2101">La matrice e il valore restituito del <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodo vengono passati al `ShowWhere` metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario gli elementi della stringa di ricerca sarebbe compresa se fosse nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2101">The array and the return value of the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="289d7-2102">L'indice è negativo se la stringa non è inclusa nella matrice, pertanto la `ShowWhere` metodo accetta il complemento bit per bit (il ~ operatore in c# e Visual C++, `Xor` -1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore di stri di ricerca NG.</span><span class="sxs-lookup"><span data-stu-id="289d7-2102">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-2103"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2103"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-2104"><paramref name="comparer" /> è <see langword="null" /> e uno o più elementi nella matrice <paramref name="array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2104"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-2105">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2105">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="289d7-2106">Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2106">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="289d7-2107">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="289d7-2107">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="289d7-2108">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante.</span><span class="sxs-lookup"><span data-stu-id="289d7-2108">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="289d7-2109">A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-2109">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="289d7-2110">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2110">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-2111">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2111">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-2112">Oggetto <see cref="T:System.Array" /> unidimensionale e in base zero da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2112">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="comparison"><span data-ttu-id="289d7-2113">Oggetto <see cref="T:System.Comparison`1" /> da usare quando si confrontano gli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2113">The <see cref="T:System.Comparison`1" /> to use when comparing elements.</span></span></param>
        <summary><span data-ttu-id="289d7-2114">Ordina gli elementi di un oggetto <see cref="T:System.Array" /> utilizzando l'interfaccia <see cref="T:System.Comparison`1" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-2114">Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Comparison`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2115">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2115">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-2116">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="289d7-2116">This method uses introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-2117">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2117">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2118">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2118">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2119">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2119">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-2120">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2120">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-2121">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2121">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-2122">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2122">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2123">L'esempio di codice seguente illustra il <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2123">The following code example demonstrates the <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> method overload.</span></span>  
  
 <span data-ttu-id="289d7-2124">L'esempio di codice definisce un metodo di confronto alternativo per le stringhe, denominato `CompareDinosByLength`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2124">The code example defines an alternative comparison method for strings, named `CompareDinosByLength`.</span></span> <span data-ttu-id="289d7-2125">Questo metodo funziona nel modo seguente: prima di tutto, il comparandsare testato per`null`, e un riferimento null viene considerato minore rispetto a un valore non null.</span><span class="sxs-lookup"><span data-stu-id="289d7-2125">This method works as follows: First, the comparandsare tested for`null`, and a null reference is treated as less than a non-null.</span></span> <span data-ttu-id="289d7-2126">In secondo luogo, vengono confrontate le lunghezze di stringa e la stringa più lunga è considerata maggiore.</span><span class="sxs-lookup"><span data-stu-id="289d7-2126">Second, the string lengths are compared, and the longer string is deemed to be greater.</span></span> <span data-ttu-id="289d7-2127">In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2127">Third, if the lengths are equal, ordinary string comparison is used.</span></span>  
  
 <span data-ttu-id="289d7-2128">Una matrice di stringhe viene creata e popolata con quattro stringhe, in nessun ordine particolare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2128">A array of strings is created and populated with four strings, in no particular order.</span></span> <span data-ttu-id="289d7-2129">L'elenco include anche una stringa vuota e un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="289d7-2129">The list also includes an empty string and a null reference.</span></span> <span data-ttu-id="289d7-2130">Viene visualizzato l'elenco e ordinato utilizzando un <xref:System.Comparison%601> delegato generico che rappresenta il `CompareDinosByLength` (metodo), quindi viene nuovamente visualizzato.</span><span class="sxs-lookup"><span data-stu-id="289d7-2130">The list is displayed, sorted using a <xref:System.Comparison%601> generic delegate representing the `CompareDinosByLength` method, and displayed again.</span></span>  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-2131"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2131"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-2132">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2132">-or-</span></span>  
  
 <span data-ttu-id="289d7-2133"><paramref name="comparison" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2133"><paramref name="comparison" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-2134">L'implementazione di <paramref name="comparison" /> ha causato un errore durante l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2134">The implementation of <paramref name="comparison" /> caused an error during the sort.</span></span> <span data-ttu-id="289d7-2135">Ad esempio, <paramref name="comparison" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2135">For example, <paramref name="comparison" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="289d7-2136">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="289d7-2136">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="289d7-2137">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante.</span><span class="sxs-lookup"><span data-stu-id="289d7-2137">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="289d7-2138">A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-2138">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="289d7-2139">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2139">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-2140">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2140">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-2141">Oggetto <see cref="T:System.Array" /> unidimensionale e in base zero da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2141">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="index"><span data-ttu-id="289d7-2142">Indice iniziale dell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2142">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-2143">Numero di elementi nell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2143">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="289d7-2144">Ordina un intervallo di elementi di un oggetto <see cref="T:System.Array" /> utilizzando l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascun elemento dell'oggetto <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2144">Sorts the elements in a range of elements in an <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2145">Ogni elemento all'interno dell'intervallo specificato di elementi in `array` deve implementare il <xref:System.IComparable%601> interfaccia generica per essere in grado di eseguire confronti con ogni altro elemento `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2145">Each element within the specified range of elements in `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="289d7-2146">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2146">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-2147">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-2147">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-2148">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2148">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2149">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2149">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2150">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2150">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-2151">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2151">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-2152">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2152">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-2153">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2153">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2154">L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo generico e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico per l'ordinamento di un intervallo in una matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2154">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload and the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload for sorting a range in an array.</span></span>  
  
 <span data-ttu-id="289d7-2155">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato `ReverseCompare`, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica.</span><span class="sxs-lookup"><span data-stu-id="289d7-2155">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="289d7-2156">Operatore di confronto chiama il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</span><span class="sxs-lookup"><span data-stu-id="289d7-2156">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="289d7-2157">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro, costituito da tre erbivori seguiti da tre carnivori (precisa tyrannosaurids).</span><span class="sxs-lookup"><span data-stu-id="289d7-2157">The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</span></span> <span data-ttu-id="289d7-2158">Il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo generico viene utilizzato per ordinare gli ultimi tre elementi della matrice, che viene quindi visualizzato.</span><span class="sxs-lookup"><span data-stu-id="289d7-2158">The <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload is used to sort the last three elements of the array, which is then displayed.</span></span> <span data-ttu-id="289d7-2159">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload di metodo generico viene utilizzato con `ReverseCompare` per ordinare gli ultimi tre elementi in ordine inverso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2159">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is used with `ReverseCompare` to sort the last three elements in reverse order.</span></span> <span data-ttu-id="289d7-2160">I dinosauri non vengono visualizzati nuovamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2160">The thoroughly confused dinosaurs are displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-2161">Le chiamate al <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2161">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="289d7-2162">Se si utilizza il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2162">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-2163"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2163"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-2164"><paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2164"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-2165">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2165">-or-</span></span>  
  
 <span data-ttu-id="289d7-2166"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-2166"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-2167"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2167"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="289d7-2168">Uno o più elementi della matrice <paramref name="array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2168">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-2169">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2169">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-2170">Oggetto <see cref="T:System.Array" /> unidimensionale e in base zero da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2170">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-2171">Indice iniziale dell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2171">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-2172">Numero di elementi nell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2172">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-2173">Implementazione dell'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> da utilizzare per il confronto fra gli elementi; oppure, impostare <see langword="null" /> per utilizzare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2173">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-2174">Ordina un intervallo di elementi di un oggetto <see cref="T:System.Array" /> utilizzando l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-2174">Sorts the elements in a range of elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2175">Se `comparer` è `null`, ogni elemento all'interno dell'intervallo specificato di elementi in `array` deve implementare il <xref:System.IComparable%601> interfaccia generica per essere in grado di eseguire confronti con ogni altro elemento `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2175">If `comparer` is `null`, each element within the specified range of elements in `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="289d7-2176">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2176">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-2177">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-2177">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-2178">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2178">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2179">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2179">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2180">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2180">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-2181">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2181">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-2182">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2182">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-2183">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2183">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2184">L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo generico e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload del metodo generico per l'ordinamento di un intervallo in una matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2184">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload and the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload for sorting a range in an array.</span></span>  
  
 <span data-ttu-id="289d7-2185">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato `ReverseCompare`, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica.</span><span class="sxs-lookup"><span data-stu-id="289d7-2185">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="289d7-2186">Operatore di confronto chiama il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</span><span class="sxs-lookup"><span data-stu-id="289d7-2186">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="289d7-2187">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro, costituito da tre erbivori seguiti da tre carnivori (precisa tyrannosaurids).</span><span class="sxs-lookup"><span data-stu-id="289d7-2187">The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</span></span> <span data-ttu-id="289d7-2188">Il <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload del metodo generico viene utilizzato per ordinare gli ultimi tre elementi della matrice, che viene quindi visualizzato.</span><span class="sxs-lookup"><span data-stu-id="289d7-2188">The <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload is used to sort the last three elements of the array, which is then displayed.</span></span> <span data-ttu-id="289d7-2189">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload di metodo generico viene utilizzato con `ReverseCompare` per ordinare gli ultimi tre elementi in ordine inverso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2189">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is used with `ReverseCompare` to sort the last three elements in reverse order.</span></span> <span data-ttu-id="289d7-2190">I dinosauri non vengono visualizzati nuovamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2190">The thoroughly confused dinosaurs are displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-2191">Le chiamate al <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2191">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="289d7-2192">Se si utilizza il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2192">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-2193"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2193"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-2194"><paramref name="index" /> è minore del limite inferiore di <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2194"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-2195">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2195">-or-</span></span>  
  
 <span data-ttu-id="289d7-2196"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-2196"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-2197"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2197"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="289d7-2198">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2198">-or-</span></span>  
  
 <span data-ttu-id="289d7-2199">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2199">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="289d7-2200">Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2200">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-2201"><paramref name="comparer" /> è <see langword="null" /> e uno o più elementi nella matrice <paramref name="array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2201"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="289d7-2202">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="289d7-2202">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="289d7-2203">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante.</span><span class="sxs-lookup"><span data-stu-id="289d7-2203">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="289d7-2204">A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-2204">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="289d7-2205">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2205">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="289d7-2206">Tipo degli elementi della matrice delle chiavi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2206">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="289d7-2207">Tipo degli elementi della matrice degli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2207">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="289d7-2208">L'oggetto <see cref="T:System.Array" /> unidimensionale in base zero che contiene le chiavi da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2208">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="289d7-2209">Oggetto unidimensionale in base zero <see cref="T:System.Array" /> che contiene gli elementi che corrispondono alle chiavi in <c>keys</c> oppure <see langword="null" /> per ordinare solo <c>keys</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2209">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <summary><span data-ttu-id="289d7-2210">Ordina una coppia di oggetti <see cref="T:System.Array" /> (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <see cref="T:System.Array" /> utilizzando l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascuna chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-2210">Sorts a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2211">Ogni chiave di `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2211">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="289d7-2212">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2212">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="289d7-2213">Pertanto, il `items` <xref:System.Array> viene ordinato in base a disposizione delle chiavi corrispondenti nel `keys` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2213">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-2214">Ogni chiave di `keys` <xref:System.Array> deve implementare il <xref:System.IComparable%601> interfaccia generica per essere in grado di eseguire confronti con ogni altra chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-2214">Each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="289d7-2215">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2215">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="289d7-2216">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2216">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="289d7-2217">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2217">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-2218">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-2218">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-2219">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2219">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2220">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2220">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2221">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2221">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-2222">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2222">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-2223">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2223">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-2224">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2224">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2225">L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload di metodo generico, per l'ordinamento di coppie di matrici che rappresentano le chiavi e valori.</span><span class="sxs-lookup"><span data-stu-id="289d7-2225">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="289d7-2226">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato `ReverseCompare`, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica.</span><span class="sxs-lookup"><span data-stu-id="289d7-2226">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="289d7-2227">Operatore di confronto chiama il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</span><span class="sxs-lookup"><span data-stu-id="289d7-2227">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="289d7-2228">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ciascun dinosauro espressa in metri (valori).</span><span class="sxs-lookup"><span data-stu-id="289d7-2228">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="289d7-2229">Le matrici vengono ordinate e visualizzate più volte:</span><span class="sxs-lookup"><span data-stu-id="289d7-2229">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="289d7-2230">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload viene utilizzato per ordinare entrambe le matrici in base ai nomi di dinosauro della prima matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2230">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="289d7-2231">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload e un'istanza di `ReverseCompare` vengono utilizzati per invertire l'ordinamento della coppia di matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2231">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="289d7-2232">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2232">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="289d7-2233">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici in ordine inverso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2233">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-2234">Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2234">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="289d7-2235">Se si utilizza il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2235">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-2236"><paramref name="keys" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2236"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-2237"><paramref name="items" /> non è <see langword="null" />, e il limite inferiore di <paramref name="keys" /> non corrisponde al limite inferiore di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2237"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="289d7-2238">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2238">-or-</span></span>  
  
 <span data-ttu-id="289d7-2239"><paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2239"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="289d7-2240">Uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2240">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="289d7-2241">Tipo degli elementi della matrice delle chiavi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2241">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="289d7-2242">Tipo degli elementi della matrice degli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2242">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="289d7-2243">L'oggetto <see cref="T:System.Array" /> unidimensionale in base zero che contiene le chiavi da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2243">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="289d7-2244">Oggetto unidimensionale in base zero <see cref="T:System.Array" /> che contiene gli elementi che corrispondono alle chiavi in <c>keys</c> oppure <see langword="null" /> per ordinare solo <c>keys</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2244">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-2245">Implementazione dell'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> da utilizzare per il confronto fra gli elementi; oppure, impostare <see langword="null" /> per utilizzare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2245">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-2246">Ordina una coppia di oggetti <see cref="T:System.Array" /> (uno contiene le chiavi e l'altro contiene gli elementi corrispondenti) in base alle chiavi nel primo oggetto <see cref="T:System.Array" /> utilizzando l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-2246">Sorts a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2247">Ogni chiave di `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2247">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="289d7-2248">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2248">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="289d7-2249">Pertanto, il `items` <xref:System.Array> viene ordinato in base a disposizione delle chiavi corrispondenti nel `keys` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2249">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-2250">Se `comparer` è `null`, ogni chiave nel `keys` <xref:System.Array> deve implementare il <xref:System.IComparable%601> interfaccia generica per essere in grado di eseguire confronti con ogni altra chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-2250">If `comparer` is `null`, each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="289d7-2251">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2251">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="289d7-2252">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2252">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="289d7-2253">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2253">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-2254">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-2254">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-2255">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2255">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2256">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2256">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2257">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2257">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-2258">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2258">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-2259">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2259">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-2260">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2260">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2261">L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload di metodo generico, per l'ordinamento di coppie di matrici che rappresentano le chiavi e valori.</span><span class="sxs-lookup"><span data-stu-id="289d7-2261">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="289d7-2262">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato `ReverseCompare`, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica.</span><span class="sxs-lookup"><span data-stu-id="289d7-2262">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="289d7-2263">Operatore di confronto chiama il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</span><span class="sxs-lookup"><span data-stu-id="289d7-2263">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="289d7-2264">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ciascun dinosauro espressa in metri (valori).</span><span class="sxs-lookup"><span data-stu-id="289d7-2264">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="289d7-2265">Le matrici vengono ordinate e visualizzate più volte:</span><span class="sxs-lookup"><span data-stu-id="289d7-2265">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="289d7-2266">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload viene utilizzato per ordinare entrambe le matrici in base ai nomi di dinosauro della prima matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2266">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="289d7-2267">Il [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > overload e un'istanza di `ReverseCompare` vengono utilizzati per invertire l'ordinamento della coppia di matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2267">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="289d7-2268">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2268">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="289d7-2269">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici in ordine inverso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2269">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-2270">Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2270">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="289d7-2271">Se si utilizza il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2271">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-2272"><paramref name="keys" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2272"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-2273"><paramref name="items" /> non è <see langword="null" />, e il limite inferiore di <paramref name="keys" /> non corrisponde al limite inferiore di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2273"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="289d7-2274">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2274">-or-</span></span>  
  
 <span data-ttu-id="289d7-2275"><paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2275"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="289d7-2276">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2276">-or-</span></span>  
  
 <span data-ttu-id="289d7-2277">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2277">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="289d7-2278">Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2278">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-2279"><paramref name="comparer" /> è <see langword="null" />, e uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2279"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="289d7-2280">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="289d7-2280">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="289d7-2281">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante.</span><span class="sxs-lookup"><span data-stu-id="289d7-2281">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="289d7-2282">A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-2282">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="289d7-2283">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2283">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="289d7-2284">Tipo degli elementi della matrice delle chiavi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2284">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="289d7-2285">Tipo degli elementi della matrice degli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2285">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="289d7-2286">L'oggetto <see cref="T:System.Array" /> unidimensionale in base zero che contiene le chiavi da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2286">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="289d7-2287">Oggetto unidimensionale in base zero <see cref="T:System.Array" /> che contiene gli elementi che corrispondono alle chiavi in <c>keys</c> oppure <see langword="null" /> per ordinare solo <c>keys</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2287">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-2288">Indice iniziale dell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2288">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-2289">Numero di elementi nell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2289">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="289d7-2290">Ordina un intervallo di elementi in una coppia di oggetti <see cref="T:System.Array" /> (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <see cref="T:System.Array" /> utilizzando l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascuna chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-2290">Sorts a range of elements in a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2291">Ogni chiave di `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2291">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="289d7-2292">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2292">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="289d7-2293">Pertanto, il `items` <xref:System.Array> viene ordinato in base a disposizione delle chiavi corrispondenti nel `keys` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2293">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-2294">Ogni chiave all'interno dell'intervallo specificato di elementi di `keys` <xref:System.Array> deve implementare il <xref:System.IComparable%601> interfaccia generica per essere in grado di eseguire confronti con ogni altra chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-2294">Each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="289d7-2295">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2295">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="289d7-2296">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2296">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="289d7-2297">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2297">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-2298">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-2298">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-2299">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2299">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2300">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2300">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2301">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2301">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-2302">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2302">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-2303">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2303">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-2304">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2304">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2305">L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload di metodo generico, per l'ordinamento di coppie di matrici che rappresentano le chiavi e valori.</span><span class="sxs-lookup"><span data-stu-id="289d7-2305">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="289d7-2306">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato `ReverseCompare`, che implementa il `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica.</span><span class="sxs-lookup"><span data-stu-id="289d7-2306">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="289d7-2307">Operatore di confronto chiama il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</span><span class="sxs-lookup"><span data-stu-id="289d7-2307">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="289d7-2308">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ciascun dinosauro espressa in metri (valori).</span><span class="sxs-lookup"><span data-stu-id="289d7-2308">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="289d7-2309">Le matrici vengono ordinate e visualizzate più volte:</span><span class="sxs-lookup"><span data-stu-id="289d7-2309">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="289d7-2310">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload viene utilizzato per ordinare entrambe le matrici in base ai nomi di dinosauro della prima matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2310">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="289d7-2311">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload e un'istanza di `ReverseCompare` vengono utilizzati per invertire l'ordinamento della coppia di matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2311">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="289d7-2312">Il [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2312">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="289d7-2313">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici in ordine inverso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2313">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-2314">Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2314">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="289d7-2315">Se si utilizza il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2315">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-2316"><paramref name="keys" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2316"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-2317"><paramref name="index" /> è minore del limite inferiore di <paramref name="keys" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2317"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="289d7-2318">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2318">-or-</span></span>  
  
 <span data-ttu-id="289d7-2319"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-2319"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-2320"><paramref name="items" /> non è <see langword="null" />, e il limite inferiore di <paramref name="keys" /> non corrisponde al limite inferiore di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2320"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="289d7-2321">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2321">-or-</span></span>  
  
 <span data-ttu-id="289d7-2322"><paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2322"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="289d7-2323">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2323">-or-</span></span>  
  
 <span data-ttu-id="289d7-2324"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="keys" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2324"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="289d7-2325">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2325">-or-</span></span>  
  
 <span data-ttu-id="289d7-2326"><paramref name="items" /> non è <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="items" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2326"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="289d7-2327">Uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2327">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="289d7-2328">Tipo degli elementi della matrice delle chiavi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2328">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="289d7-2329">Tipo degli elementi della matrice degli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2329">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="289d7-2330">L'oggetto <see cref="T:System.Array" /> unidimensionale in base zero che contiene le chiavi da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2330">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="289d7-2331">Oggetto unidimensionale in base zero <see cref="T:System.Array" /> che contiene gli elementi che corrispondono alle chiavi in <c>keys</c> oppure <see langword="null" /> per ordinare solo <c>keys</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2331">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <param name="index"><span data-ttu-id="289d7-2332">Indice iniziale dell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2332">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="289d7-2333">Numero di elementi nell'intervallo da ordinare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2333">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-2334">Implementazione dell'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> da utilizzare per il confronto fra gli elementi; oppure, impostare <see langword="null" /> per utilizzare l'implementazione dell'interfaccia generica <see cref="T:System.IComparable`1" /> di ciascun elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2334">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="289d7-2335">Ordina un intervallo di elementi in una coppia di oggetti <see cref="T:System.Array" /> (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <see cref="T:System.Array" /> utilizzando l'interfaccia generica <see cref="T:System.Collections.Generic.IComparer`1" /> specificata.</span><span class="sxs-lookup"><span data-stu-id="289d7-2335">Sorts a range of elements in a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2336">Ogni chiave di `keys` <xref:System.Array> dispone di un elemento corrispondente `items` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2336">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="289d7-2337">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella `items` <xref:System.Array> viene riposizionato in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2337">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="289d7-2338">Pertanto, il `items` <xref:System.Array> viene ordinato in base a disposizione delle chiavi corrispondenti nel `keys` <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2338">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="289d7-2339">Se `comparer` è `null`, ogni chiave all'interno dell'intervallo specificato di elementi di `keys` <xref:System.Array> deve implementare il <xref:System.IComparable%601> interfaccia generica per essere in grado di eseguire confronti con ogni altra chiave.</span><span class="sxs-lookup"><span data-stu-id="289d7-2339">If `comparer` is `null`, each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="289d7-2340">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2340">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="289d7-2341">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2341">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="289d7-2342">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2342">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="289d7-2343">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</span><span class="sxs-lookup"><span data-stu-id="289d7-2343">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="289d7-2344">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un [ordinamento inserimento](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2344">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2345">Se il numero di partizioni superiore a 2 \* Log<sup>N</sup>, dove *N* è l'intervallo della matrice di input, viene utilizzato un [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2345">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="289d7-2346">In caso contrario, viene utilizzato un [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2346">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="289d7-2347">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2347">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="289d7-2348">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2348">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="289d7-2349">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (`n` log `n`) operazione, in cui `n` è `length`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2349">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2350">L'esempio di codice seguente illustra il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > overload di metodo generico, per l'ordinamento di coppie di matrici che rappresentano le chiavi e valori.</span><span class="sxs-lookup"><span data-stu-id="289d7-2350">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="289d7-2351">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato `ReverseCompare`, che implementa il `IComparer<string>`(`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) dell'interfaccia generica.</span><span class="sxs-lookup"><span data-stu-id="289d7-2351">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>`(`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="289d7-2352">Operatore di confronto chiama il <xref:System.String.CompareTo%28System.String%29> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</span><span class="sxs-lookup"><span data-stu-id="289d7-2352">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="289d7-2353">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ciascun dinosauro espressa in metri (valori).</span><span class="sxs-lookup"><span data-stu-id="289d7-2353">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="289d7-2354">Le matrici vengono ordinate e visualizzate più volte:</span><span class="sxs-lookup"><span data-stu-id="289d7-2354">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="289d7-2355">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload viene utilizzato per ordinare entrambe le matrici in base ai nomi di dinosauro della prima matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2355">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="289d7-2356">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload e un'istanza di `ReverseCompare` vengono utilizzati per invertire l'ordinamento della coppia di matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2356">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="289d7-2357">Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2357">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="289d7-2358">Il [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > overload viene utilizzato per ordinare gli ultimi tre gli elementi di entrambe le matrici in ordine inverso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2358">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-2359">Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2359">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="289d7-2360">Se si utilizza il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2360">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-2361"><paramref name="keys" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2361"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-2362"><paramref name="index" /> è minore del limite inferiore di <paramref name="keys" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2362"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="289d7-2363">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2363">-or-</span></span>  
  
 <span data-ttu-id="289d7-2364"><paramref name="length" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-2364"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="289d7-2365"><paramref name="items" /> non è <see langword="null" />, e il limite inferiore di <paramref name="keys" /> non corrisponde al limite inferiore di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2365"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="289d7-2366">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2366">-or-</span></span>  
  
 <span data-ttu-id="289d7-2367"><paramref name="items" /> non è <see langword="null" /> e la lunghezza di <paramref name="keys" /> è maggiore della lunghezza di <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2367"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="289d7-2368">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2368">-or-</span></span>  
  
 <span data-ttu-id="289d7-2369"><paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="keys" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2369"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="289d7-2370">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2370">-or-</span></span>  
  
 <span data-ttu-id="289d7-2371"><paramref name="items" /> non è <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> non specificano un intervallo valido in <paramref name="items" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2371"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="289d7-2372">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2372">-or-</span></span>  
  
 <span data-ttu-id="289d7-2373">L'implementazione di <paramref name="comparer" /> ha causato un errore durante l'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2373">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="289d7-2374">Ad esempio, <paramref name="comparer" /> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2374">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="289d7-2375"><paramref name="comparer" /> è <see langword="null" />, e uno o più elementi in <paramref name="keys" /><see cref="T:System.Array" /> non implementano l'interfaccia generica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2375"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="289d7-2376">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="289d7-2376">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="289d7-2377">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <see cref="T:System.IndexOutOfRangeException" /> eccezione e genera un <see cref="T:System.ArgumentException" /> eccezione al chiamante.</span><span class="sxs-lookup"><span data-stu-id="289d7-2377">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="289d7-2378">A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile che le operazioni di ordinamento che in precedenza ha generato <see cref="T:System.ArgumentException" /> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</span><span class="sxs-lookup"><span data-stu-id="289d7-2378">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="289d7-2379">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2379">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="289d7-2380">Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2380">Gets an object that can be used to synchronize access to the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="289d7-2381">Oggetto che può essere usato per sincronizzare l'accesso a <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2381">An object that can be used to synchronize access to the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2382">Questa proprietà implementa il <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2382">This property implements the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="289d7-2383">Classi di .NET framework basate su <xref:System.Array> fornire una propria versione sincronizzata della raccolta mediante la <xref:System.Array.SyncRoot%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="289d7-2383">.NET Framework classes based on <xref:System.Array> provide their own synchronized version of the collection using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 <span data-ttu-id="289d7-2384">Le classi che utilizzano matrici anche possono implementare la propria sincronizzazione utilizzando il <xref:System.Array.SyncRoot%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="289d7-2384">Classes that use arrays can also implement their own synchronization using the <xref:System.Array.SyncRoot%2A> property.</span></span> <span data-ttu-id="289d7-2385">Il codice di sincronizzazione è necessario eseguire operazioni sul `SyncRoot` della raccolta, non direttamente sulla raccolta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2385">The synchronizing code must perform operations on the `SyncRoot` of the collection, not directly on the collection.</span></span> <span data-ttu-id="289d7-2386">In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti.</span><span class="sxs-lookup"><span data-stu-id="289d7-2386">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="289d7-2387">In particolare, mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente l'insieme.</span><span class="sxs-lookup"><span data-stu-id="289d7-2387">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</span></span> <span data-ttu-id="289d7-2388">Si noti che alcune implementazioni di <xref:System.Array.SyncRoot%2A> potrebbe restituire il <xref:System.Array> stesso.</span><span class="sxs-lookup"><span data-stu-id="289d7-2388">Note that some implementations of <xref:System.Array.SyncRoot%2A> might return the <xref:System.Array> itself.</span></span>  
  
 <span data-ttu-id="289d7-2389">L'enumerazione di una raccolta non è quindi una procedura thread-safe.</span><span class="sxs-lookup"><span data-stu-id="289d7-2389">Enumerating through a collection is intrinsically not a thread safe procedure.</span></span> <span data-ttu-id="289d7-2390">Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore.</span><span class="sxs-lookup"><span data-stu-id="289d7-2390">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="289d7-2391">Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</span><span class="sxs-lookup"><span data-stu-id="289d7-2391">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="289d7-2392">Il recupero del valore di questa proprietà è un'operazione O(1).</span><span class="sxs-lookup"><span data-stu-id="289d7-2392">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2393">Esempio di codice seguente viene illustrato come bloccare la matrice durante l'intera enumerazione tramite il <xref:System.Array.SyncRoot%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="289d7-2393">The following code example shows how to lock an array during the entire enumeration by using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="289d7-2394">Ottiene il numero di elementi contenuti in <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2394">Gets the number of elements contained in the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="289d7-2395">Numero di elementi contenuti nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2395">The number of elements contained in the collection.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2396">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2396">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2397">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.ICollection>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2397">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.ICollection> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-2398">Oggetto da aggiungere all'oggetto <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2398">The object to be added to the <see cref="T:System.Collections.IList" />.</span></span></param>
        <summary><span data-ttu-id="289d7-2399">La chiamata di questo metodo genera sempre un'eccezione <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2399">Calling this method always throws a <see cref="T:System.NotSupportedException" /> exception.</span></span></summary>
        <returns><span data-ttu-id="289d7-2400">L'aggiunta di valori alla matrice non è supportata.</span><span class="sxs-lookup"><span data-stu-id="289d7-2400">Adding a value to an array is not supported.</span></span> <span data-ttu-id="289d7-2401">Non vengono restituiti valori.</span><span class="sxs-lookup"><span data-stu-id="289d7-2401">No value is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2402">In genere, un <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementazione aggiunge un membro a una raccolta.</span><span class="sxs-lookup"><span data-stu-id="289d7-2402">Ordinarily, an <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementation adds a member to a collection.</span></span> <span data-ttu-id="289d7-2403">Tuttavia, poiché le matrici hanno una dimensione fissa (il <xref:System.Array.IsFixedSize%2A> proprietà restituisce sempre `true`), questo metodo genera sempre un <xref:System.NotSupportedException> eccezione.</span><span class="sxs-lookup"><span data-stu-id="289d7-2403">However, because arrays have a fixed size (the <xref:System.Array.IsFixedSize%2A> property always returns `true`), this method always throws a <xref:System.NotSupportedException> exception.</span></span>  
  
 <span data-ttu-id="289d7-2404">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2404">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2405">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2405">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="289d7-2406">Le dimensioni dell'oggetto <see cref="T:System.Collections.IList" /> sono fisse.</span><span class="sxs-lookup"><span data-stu-id="289d7-2406">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="289d7-2407">Rimuove tutti gli elementi da <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2407">Removes all items from the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2408">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2408">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2409">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2409">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="289d7-2410">La classe <see cref="T:System.Collections.IList" /> è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="289d7-2410">The <see cref="T:System.Collections.IList" /> is read-only.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-2411">Oggetto da individuare nell'elenco corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2411">The object to locate in the current list.</span></span> <span data-ttu-id="289d7-2412">L'elemento da individuare può essere <see langword="null" /> per i tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2412">The element to locate can be <see langword="null" /> for reference types.</span></span></param>
        <summary><span data-ttu-id="289d7-2413">Determina se un elemento è incluso in <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2413">Determines whether an element is in the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <returns>
          <span data-ttu-id="289d7-2414"><see langword="true" /> se <paramref name="value" /> è presente in <see cref="T:System.Collections.IList" />; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2414"><see langword="true" /> if <paramref name="value" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2415">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2415">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2416">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2416">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-2417">Oggetto da individuare nell'elenco corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2417">The object to locate in the current list.</span></span></param>
        <summary><span data-ttu-id="289d7-2418">Determina l'indice di un elemento specifico in <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2418">Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <returns><span data-ttu-id="289d7-2419">Indice di value, se presente nell'elenco; in caso contrario, -1.</span><span class="sxs-lookup"><span data-stu-id="289d7-2419">The index of value if found in the list; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2420">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2420">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2421">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2421">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="289d7-2422">Indice in corrispondenza del quale inserire <c>value</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2422">The index at which <c>value</c> should be inserted.</span></span></param>
        <param name="value"><span data-ttu-id="289d7-2423">Oggetto da inserire.</span><span class="sxs-lookup"><span data-stu-id="289d7-2423">The object to insert.</span></span></param>
        <summary><span data-ttu-id="289d7-2424">Inserisce un elemento in <see cref="T:System.Collections.IList" /> in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-2424">Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2425">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2425">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2426">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2426">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-2427"><paramref name="index" /> non è un indice valido nell'interfaccia <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2427"><paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.IList" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="289d7-2428">La classe <see cref="T:System.Collections.IList" /> è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="289d7-2428">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
 <span data-ttu-id="289d7-2429">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2429">-or-</span></span>  
  
 <span data-ttu-id="289d7-2430">Le dimensioni dell'oggetto <see cref="T:System.Collections.IList" /> sono fisse.</span><span class="sxs-lookup"><span data-stu-id="289d7-2430">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="289d7-2431"><paramref name="value" /> è un riferimento null nell'interfaccia <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2431"><paramref name="value" /> is null reference in the <see cref="T:System.Collections.IList" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="289d7-2432">Indice dell'elemento da ottenere o impostare.</span><span class="sxs-lookup"><span data-stu-id="289d7-2432">The index of the element to get or set.</span></span></param>
        <summary><span data-ttu-id="289d7-2433">Ottiene o imposta l'elemento in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-2433">Gets or sets the element at the specified index.</span></span></summary>
        <value><span data-ttu-id="289d7-2434">Elemento in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-2434">The element at the specified index.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2435">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2435">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2436">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2436">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="289d7-2437"><paramref name="index" /> è minore di zero.</span><span class="sxs-lookup"><span data-stu-id="289d7-2437"><paramref name="index" /> is less than zero.</span></span>  
  
 <span data-ttu-id="289d7-2438">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2438">-or-</span></span>  
  
 <span data-ttu-id="289d7-2439"><paramref name="index" /> è uguale a o maggiore di <see cref="P:System.Collections.ICollection.Count" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2439"><paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.ICollection.Count" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="289d7-2440">L'oggetto <see cref="T:System.Array" /> corrente non ha esattamente una dimensione.</span><span class="sxs-lookup"><span data-stu-id="289d7-2440">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="289d7-2441">Oggetto da rimuovere da <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2441">The object to remove from the <see cref="T:System.Collections.IList" />.</span></span></param>
        <summary><span data-ttu-id="289d7-2442">Rimuove la prima occorrenza di un oggetto specifico da <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2442">Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2443">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2443">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2444">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2444">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="289d7-2445">La classe <see cref="T:System.Collections.IList" /> è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="289d7-2445">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
 <span data-ttu-id="289d7-2446">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2446">-or-</span></span>  
  
 <span data-ttu-id="289d7-2447">Le dimensioni dell'oggetto <see cref="T:System.Collections.IList" /> sono fisse.</span><span class="sxs-lookup"><span data-stu-id="289d7-2447">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="289d7-2448">Indice dell'elemento da rimuovere.</span><span class="sxs-lookup"><span data-stu-id="289d7-2448">The index of the element to remove.</span></span></param>
        <summary><span data-ttu-id="289d7-2449">Rimuove l'elemento <see cref="T:System.Collections.IList" /> in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-2449">Removes the <see cref="T:System.Collections.IList" /> item at the specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2450">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2450">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2451">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2451">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="289d7-2452">non è un indice valido in <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2452">index is not a valid index in the <see cref="T:System.Collections.IList" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="289d7-2453">La classe <see cref="T:System.Collections.IList" /> è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="289d7-2453">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
 <span data-ttu-id="289d7-2454">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2454">-or-</span></span>  
  
 <span data-ttu-id="289d7-2455">Le dimensioni dell'oggetto <see cref="T:System.Collections.IList" /> sono fisse.</span><span class="sxs-lookup"><span data-stu-id="289d7-2455">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="289d7-2456">Oggetto da confrontare con l'istanza corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2456">The object to compare with the current instance.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-2457">Oggetto che confronta l'oggetto corrente e <c>other</c>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2457">An object that compares the current object and <c>other</c>.</span></span></param>
        <summary><span data-ttu-id="289d7-2458">Determina se l'oggetto raccolta corrente precede, è nella stessa posizione o segue un altro oggetto nell'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2458">Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</span></span></summary>
        <returns><span data-ttu-id="289d7-2459">Intero che indica la relazione tra l'oggetto raccolta corrente e other, come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2459">An integer that indicates the relationship of the current collection object to other, as shown in the following table.</span></span>  
  
 <span data-ttu-id="289d7-2460"><list type="table"><listheader><term> Valore restituito</span><span class="sxs-lookup"><span data-stu-id="289d7-2460"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="289d7-2461"></term><description> Descrizione</span><span class="sxs-lookup"><span data-stu-id="289d7-2461"></term><description> Description</span></span>  
  
 <span data-ttu-id="289d7-2462"></description></listheader><item><term> -1</span><span class="sxs-lookup"><span data-stu-id="289d7-2462"></description></listheader><item><term> -1</span></span>  
  
 <span data-ttu-id="289d7-2463"></term><description> L'istanza corrente precede <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2463"></term><description> The current instance precedes <paramref name="other" />.</span></span>  
  
 <span data-ttu-id="289d7-2464"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="289d7-2464"></description></item><item><term> 0</span></span>  
  
 <span data-ttu-id="289d7-2465"></term><description> L'istanza corrente è uguale a <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2465"></term><description> The current instance and <paramref name="other" /> are equal.</span></span>  
  
 <span data-ttu-id="289d7-2466"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="289d7-2466"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="289d7-2467"></term><description> L'istanza corrente segue <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2467"></term><description> The current instance follows <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2468">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2468">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2469">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IStructuralComparable>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2469">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralComparable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="289d7-2470">Oggetto da confrontare con l'istanza corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2470">The object to compare with the current instance.</span></span></param>
        <param name="comparer"><span data-ttu-id="289d7-2471">Oggetto che determina se l'istanza corrente e <c>other</c> sono uguali.</span><span class="sxs-lookup"><span data-stu-id="289d7-2471">An object that determines whether the current instance and <c>other</c> are equal.</span></span></param>
        <summary><span data-ttu-id="289d7-2472">Determina se un oggetto è uguale all'istanza corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2472">Determines whether an object is equal to the current instance.</span></span></summary>
        <returns>
          <span data-ttu-id="289d7-2473"><see langword="true" /> se i due oggetti sono uguali; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2473"><see langword="true" /> if the two objects are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2474">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2474">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2475">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IStructuralEquatable>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2475">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralEquatable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="289d7-2476">Oggetto che calcola il codice hash dell'oggetto corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2476">An object that computes the hash code of the current object.</span></span></param>
        <summary><span data-ttu-id="289d7-2477">Restituisce un codice hash per l'istanza corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2477">Returns a hash code for the current instance.</span></span></summary>
        <returns><span data-ttu-id="289d7-2478">Codice hash per l'istanza corrente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2478">The hash code for the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2479">Questo membro è un’implementazione esplicita di un membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="289d7-2479">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="289d7-2480">Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Array> a un'interfaccia <xref:System.Collections.IStructuralEquatable>.</span><span class="sxs-lookup"><span data-stu-id="289d7-2480">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralEquatable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="289d7-2481">Tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2481">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="289d7-2482">Oggetto <see cref="T:System.Array" /> unidimensionale e in base zero per cui verificare se le condizioni sono soddisfatte.</span><span class="sxs-lookup"><span data-stu-id="289d7-2482">The one-dimensional, zero-based <see cref="T:System.Array" /> to check against the conditions.</span></span></param>
        <param name="match"><span data-ttu-id="289d7-2483">Predicato che definisce le condizioni da verificare negli elementi.</span><span class="sxs-lookup"><span data-stu-id="289d7-2483">The predicate that defines the conditions to check against the elements.</span></span></param>
        <summary><span data-ttu-id="289d7-2484">Determina se ogni elemento della matrice soddisfa le condizioni definite dal predicato specificato.</span><span class="sxs-lookup"><span data-stu-id="289d7-2484">Determines whether every element in the array matches the conditions defined by the specified predicate.</span></span></summary>
        <returns>
          <span data-ttu-id="289d7-2485"><see langword="true" /> se ogni elemento della matrice <paramref name="array" /> soddisfa le condizioni definite dal predicato specificato; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2485"><see langword="true" /> if every element in <paramref name="array" /> matches the conditions defined by the specified predicate; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="289d7-2486">Se la matrice non contiene elementi, il valore restituito è <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2486">If there are no elements in the array, the return value is <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="289d7-2487">Il <xref:System.Predicate%601> è un delegato a un metodo che restituisce`true` se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-2487">The <xref:System.Predicate%601> is a delegate to a method that returns`true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="289d7-2488">Gli elementi di `array` vengono passati singolarmente per il <xref:System.Predicate%601>, e l'elaborazione viene arrestata quando il delegato restituisce `false` per qualsiasi elemento.</span><span class="sxs-lookup"><span data-stu-id="289d7-2488">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and processing is stopped when the delegate returns `false` for any element.</span></span>  
  
 <span data-ttu-id="289d7-2489">Questo metodo è un'operazione O (`n`) operazione, in cui `n` è il <xref:System.Array.Length%2A> di `array`.</span><span class="sxs-lookup"><span data-stu-id="289d7-2489">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="289d7-2490">Nell'esempio seguente determina se l'ultimo carattere di ogni elemento nella matrice di stringhe è un numero.</span><span class="sxs-lookup"><span data-stu-id="289d7-2490">The following example determines whether the last character of each element in a string array is a number.</span></span> <span data-ttu-id="289d7-2491">Crea due matrici di stringhe.</span><span class="sxs-lookup"><span data-stu-id="289d7-2491">It creates two string arrays.</span></span> <span data-ttu-id="289d7-2492">Il primo arrayincludes entrambe le stringhe che terminano con caratteri alfabetici e le stringhe che terminano con caratteri numerici. Seconda matrice è costituito solo da stringhe che terminano con caratteri numerici.</span><span class="sxs-lookup"><span data-stu-id="289d7-2492">The first arrayincludes both strings that end with alphabetic characters and strings that end with numeric characters.The second array consists only of strings that end with numeric characters.</span></span> <span data-ttu-id="289d7-2493">Viene inoltre definito un `EndWithANumber` metodo la cui firma corrisponde il <xref:System.Predicate%601> delegato.</span><span class="sxs-lookup"><span data-stu-id="289d7-2493">The example also defines an `EndWithANumber` method whose signature matches the <xref:System.Predicate%601> delegate.</span></span> <span data-ttu-id="289d7-2494">Nell'esempio vengono passate ogni matrice di <xref:System.Array.TrueForAll%2A> metodo insieme a un delegato che rappresenta il `EndsWithANumber` metodo.</span><span class="sxs-lookup"><span data-stu-id="289d7-2494">The example passes each array to the <xref:System.Array.TrueForAll%2A> method along with a delegate that represents the `EndsWithANumber` method.</span></span>  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 <span data-ttu-id="289d7-2495">Nell'esempio seguente è simile al primo, ad eccezione del fatto che passa una matrice di stringhe per il <xref:System.Array.TrueForAll%2A> metodo insieme a un'espressione lambda che determina se un elemento specifico della matrice termina con la rappresentazione di stringa di un numero.</span><span class="sxs-lookup"><span data-stu-id="289d7-2495">The following example is similar to the first, except that it passes the string array to the <xref:System.Array.TrueForAll%2A> method along with  a lambda expression that determines whether a particular array element ends with the string representation of a number.</span></span>  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 <span data-ttu-id="289d7-2496">In entrambi i casi, il <xref:System.Array.TrueForAll%2A> restituisce `false` non appena viene rilevato il primo elemento della matrice che non terminano con un numero.</span><span class="sxs-lookup"><span data-stu-id="289d7-2496">In both cases, the <xref:System.Array.TrueForAll%2A> method returns `false` as soon as it encounters the first array element that does not end in a number.</span></span> <span data-ttu-id="289d7-2497">In caso contrario, restituisce `true` dopo l'iterazione di tutti gli elementi nella matrice.</span><span class="sxs-lookup"><span data-stu-id="289d7-2497">Otherwise, it returns `true` after iterating all the elements in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="289d7-2498">Come mostrano in entrambi gli esempi, in c# e Visual Basic, non è necessario creare il `Predicate<string>` delegato (`Predicate(Of String)` in Visual Basic) in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="289d7-2498">As both examples show, in C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="289d7-2499">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</span><span class="sxs-lookup"><span data-stu-id="289d7-2499">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="289d7-2500"><paramref name="array" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2500"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="289d7-2501">oppure</span><span class="sxs-lookup"><span data-stu-id="289d7-2501">-or-</span></span>  
  
 <span data-ttu-id="289d7-2502"><paramref name="match" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="289d7-2502"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>