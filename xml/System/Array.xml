<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Array.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b335c7a4c2bf211f02463ddce0008b2f15f2e6b0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b335c7a4c2bf211f02463ddce0008b2f15f2e6b0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</source>
          <target state="translated">Fornisce metodi per creare, manipolare, ordinare ed eseguire ricerche all'interno di matrici, diventando così la classe base per tutte le matrici in Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is not part of the <ph id="ph2">&lt;xref:System.Collections&gt;</ph> namespaces.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe non è in parte il <ph id="ph2">&lt;xref:System.Collections&gt;</ph> gli spazi dei nomi.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, it is still considered a collection because it is based on the <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Tuttavia, questo viene considerato come una raccolta perché è basato sul <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is the base class for language implementations that support arrays.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe è la classe base per le implementazioni di linguaggio che supporta le matrici.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, only the system and compilers can derive explicitly from the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Tuttavia, solo il sistema e i compilatori possono derivare in modo esplicito la <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Users should employ the array constructs provided by the language.</source>
          <target state="translated">Gli utenti devono utilizzare i costrutti di matrice specificati dal linguaggio.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An element is a value in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Un elemento è un valore in un <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The length of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the total number of elements it can contain.</source>
          <target state="translated">La lunghezza di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> è il numero totale di elementi che può contenere.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The lower bound of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the index of its first element.</source>
          <target state="translated">Il limite inferiore di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> è l'indice del primo elemento.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound, but it has a lower bound of zero by default.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Array&gt;</ph> può avere un limite inferiore qualsiasi, ma dispone di un limite inferiore pari a zero per impostazione predefinita.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>A different lower bound can be defined when creating an instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class using <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>.A multidimensional <ph id="ph3">&lt;xref:System.Array&gt;</ph> can have different bounds for each dimension.</source>
          <target state="translated">Può definire un limite inferiore differente durante la creazione di un'istanza del <ph id="ph1">&lt;xref:System.Array&gt;</ph> usando <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>. Un oggetto multidimensionale <ph id="ph3">&lt;xref:System.Array&gt;</ph> può avere diversi limiti per ogni dimensione.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An array can have a maximum of 32 dimensions.</source>
          <target state="translated">Una matrice può avere un massimo di 32 dimensioni.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Unlike the classes in the <ph id="ph1">&lt;xref:System.Collections&gt;</ph> namespaces, <ph id="ph2">&lt;xref:System.Array&gt;</ph> has a fixed capacity.</source>
          <target state="translated">A differenza delle classi nel <ph id="ph1">&lt;xref:System.Collections&gt;</ph> spazi dei nomi, <ph id="ph2">&lt;xref:System.Array&gt;</ph> ha una capacità fissa.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>To increase the capacity, you must create a new <ph id="ph1">&lt;xref:System.Array&gt;</ph> object with the required capacity, copy the elements from the old <ph id="ph2">&lt;xref:System.Array&gt;</ph> object to the new one, and delete the old <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Per aumentare la capacità, è necessario creare un nuovo <ph id="ph1">&lt;xref:System.Array&gt;</ph> oggetto con la capacità richiesta, copiare gli elementi dal vecchio <ph id="ph2">&lt;xref:System.Array&gt;</ph> dell'oggetto a quello nuovo ed eliminare il vecchio <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>By default, the maximum size of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is 2 gigabytes (GB).</source>
          <target state="translated">Per impostazione predefinita, le dimensioni massime di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> è 2 gigabyte (GB).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>In a 64-bit environment, you can avoid the size restriction by setting the <ph id="ph1">`enabled`</ph> attribute of the <bpt id="p1">[</bpt>gcAllowVeryLargeObjects<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)</ept> configuration element to <ph id="ph2">`true`</ph> in the run-time environment.</source>
          <target state="translated">In un ambiente a 64 bit, è possibile evitare la limitazione delle dimensioni impostando il <ph id="ph1">`enabled`</ph> attributo del <bpt id="p1">[</bpt>gcAllowVeryLargeObjects<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)</ept> elemento di configurazione <ph id="ph2">`true`</ph> nell'ambiente di runtime.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, the array will still be limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</source>
          <target state="translated">Tuttavia, la matrice sarà comunque limitata a un totale di 4 miliardi di elementi e in un indice massimo di 0X7FEFFFFF in ogni dimensione specificato (0X7FFFFFC7 per matrici di byte e matrici di strutture a byte singolo).</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Single-dimensional arrays implement the <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType&gt;</ph> generic interfaces.</source>
          <target state="translated">Matrici unidimensionali di implementare il <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType&gt;</ph> e <ph id="ph5">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType&gt;</ph> interfacce generiche.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Le implementazioni sono fornite alle matrici in fase di esecuzione e di conseguenza, le interfacce generiche non vengono visualizzati nella sintassi della dichiarazione per il <ph id="ph1">&lt;xref:System.Array&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>In addition,  there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations).</source>
          <target state="translated">Inoltre, non esistono nessun argomento di riferimento per i membri di interfaccia che sono accessibili solo tramite il cast di una matrice per il tipo di interfaccia generica (implementazioni esplicite dell'interfaccia).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">L'aspetto importante da tenere presenti quando si esegue il cast di una matrice a una di queste interfacce è che i membri che aggiungono, inserire o rimuovere elementi generano <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects provide information about array type declarations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> gli oggetti forniscono informazioni sulle dichiarazioni di tipo matrice.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> objects with the same array type share the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> gli oggetti con lo stesso tipo di matrice condividono lo stesso <ph id="ph2">&lt;xref:System.Type&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Type.IsArray%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetElementType%2A?displayProperty=nameWithType&gt;</ph> might not return the expected results with <ph id="ph3">&lt;xref:System.Array&gt;</ph> because if an array is cast to the type <ph id="ph4">&lt;xref:System.Array&gt;</ph>, the result is an object, not an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsArray%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Type.GetElementType%2A?displayProperty=nameWithType&gt;</ph> potrebbe non restituire i risultati previsti con <ph id="ph3">&lt;xref:System.Array&gt;</ph> poiché se una matrice di cui viene eseguito il cast al tipo <ph id="ph4">&lt;xref:System.Array&gt;</ph>, il risultato è un oggetto, non è una matrice.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>That is, <ph id="ph1">`typeof(System.Array).IsArray`</ph> returns <ph id="ph2">`false`</ph>, and <ph id="ph3">`typeof(System.Array).GetElementType`</ph> returns <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Vale a dire <ph id="ph1">`typeof(System.Array).IsArray`</ph> restituisce <ph id="ph2">`false`</ph>, e <ph id="ph3">`typeof(System.Array).GetElementType`</ph> restituisce <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> metodo copia gli elementi non solo tra matrici dello stesso tipo, ma anche tra matrici standard di tipi diversi, gestisce automaticamente il cast di tipo.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Some methods, such as <ph id="ph1">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.CopyTo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.GetValue%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.SetValue%2A&gt;</ph>, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays.</source>
          <target state="translated">Alcuni metodi, ad esempio <ph id="ph1">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.CopyTo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.GetValue%2A&gt;</ph>, e <ph id="ph5">&lt;xref:System.Array.SetValue%2A&gt;</ph>, forniscono overload che accettano numeri interi a 64 bit come parametri per adattare le matrici di grande capacità.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Array.LongLength%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> return 64-bit integers indicating the length of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LongLength%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> restituiscono valori integer a 64 bit che indica la lunghezza della matrice.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not guaranteed to be sorted.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> non è garantito da ordinare.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>You must sort the <ph id="ph1">&lt;xref:System.Array&gt;</ph> prior to performing operations (such as <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph>) that require the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to be sorted.</source>
          <target state="translated">È necessario ordinare il <ph id="ph1">&lt;xref:System.Array&gt;</ph> prima dell'esecuzione di operazioni (ad esempio <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph>) che richiedono il <ph id="ph3">&lt;xref:System.Array&gt;</ph> da ordinare.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Using an <ph id="ph1">&lt;xref:System.Array&gt;</ph> object of pointers in native code is not supported and will throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> for several methods.</source>
          <target state="translated">Utilizzando un <ph id="ph1">&lt;xref:System.Array&gt;</ph> oggetto di puntatori in codice nativo non è supportata e genererà un <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> per diversi metodi.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The following code example shows how <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> copies elements between an array of type integer and an array of type <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Nell'esempio di codice riportato di seguito viene illustrato come <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> consente di copiare elementi tra una matrice di tipo integer e una matrice di tipo <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The following code example creates and initializes an <ph id="ph1">&lt;xref:System.Array&gt;</ph> and displays its properties and its elements.</source>
          <target state="translated">Esempio di codice seguente crea e Inizializza un <ph id="ph1">&lt;xref:System.Array&gt;</ph> e visualizza le proprietà e i relativi elementi.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Statici pubblici (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) di questo tipo sono thread-safe.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">I membri di istanza non sono garantiti come thread-safe.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>This implementation does not provide a synchronized (thread safe) wrapper for an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; however, .NET Framework classes based on <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph3">&lt;see cref="P:System.Array.SyncRoot" /&gt;</ph> property.</source>
          <target state="translated">Questa implementazione non fornisce un oggetto sincronizzato wrapper (thread-safe) per un <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; tuttavia, le classi di .NET Framework basate su <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> fornire una propria versione sincronizzata della raccolta mediante la <ph id="ph3">&lt;see cref="P:System.Array.SyncRoot" /&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L'enumerazione di una raccolta non è di per sé una procedura thread-safe.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The one-dimensional, zero-based array to wrap in a read-only <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> wrapper.</source>
          <target state="translated">Matrice in base zero unidimensionale da includere in un wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> in sola lettura.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>Returns a read-only wrapper for the specified array.</source>
          <target state="translated">Restituisce un wrapper di sola lettura per la matrice specificata.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>A read-only <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> wrapper for the specified array.</source>
          <target state="translated">Wrapper <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> di sola lettura per la matrice specificata.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>To prevent any modifications to the array, expose the array only through this wrapper.</source>
          <target state="translated">Per evitare eventuali modifiche alla matrice, espongono la matrice solo tramite il wrapper.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Una raccolta di sola lettura è semplicemente una raccolta con un wrapper che impedisce la modifica. Pertanto, se vengono apportate modifiche alla raccolta sottostante, la raccolta di sola lettura riflette le modifiche.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The following example wraps an array in a read-only <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>.</source>
          <target state="translated">Nell'esempio seguente esegue il wrapping di una matrice in sola lettura <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches a one-dimensional sorted <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> for a value, using a binary search algorithm.</source>
          <target state="translated">Effettua una ricerca in un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale ordinato per un valore, usando un algoritmo di ricerca binario.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ordinato unidimensionale in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The object to search for.</source>
          <target state="translated">Oggetto da cercare.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each element of the array and by the specified object.</source>
          <target state="translated">Cerca un elemento specifico in un'intera raccolta unidimensionale ordinata, usando l'interfaccia <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> implementata da ogni elemento della matrice e dall'oggetto specificato.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Indice del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> specificato nel parametro <ph id="ph2">&lt;paramref name="array" /&gt;</ph> specificato, se viene trovato <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; in caso contrario, un numero negativo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è minore di uno o più elementi presenti in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è maggiore di tutti gli elementi in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Se questo metodo viene chiamato con un oggetto <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è presente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> devono essere ordinati prima di chiamare questo metodo.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">È possibile applicare l'operatore di complemento bit per bit (~ in c#, <ph id="ph1">`Not`</ph> in Visual Basic) per il risultato per produrre un indice negativo.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Se l'indice è maggiore del limite superiore della matrice, non sono presenti elementi maggiori <ph id="ph1">`value`</ph> nella matrice.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">In caso contrario, è l'indice del primo elemento maggiore di <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">Sia <ph id="ph1">`value`</ph> o ogni elemento di <ph id="ph2">`array`</ph> deve implementare il <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaccia, che viene utilizzata per i confronti.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementazione; in caso contrario, il risultato potrebbe essere errato.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If<ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Se<ph id="ph1">`value`</ph> non implementa il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interfaccia, gli elementi di <ph id="ph3">`array`</ph> non sono stati testati per <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> prima dell'inizio della ricerca.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Sono consentiti elementi duplicati.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> contiene più di un elemento uguale a <ph id="ph2">`value`</ph>, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con <ph id="ph2">`null`</ph> non generano un'eccezione.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Per ogni elemento verificato, <ph id="ph1">`value`</ph> viene passato a appropriato <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementazione, anche se <ph id="ph3">`value`</ph> è <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Vale a dire il <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementazione determina il modo in cui un determinato elemento Confronta a <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (log <ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> to locate a specific object in an <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come utilizzare <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> per individuare un oggetto specifico in un <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The array is created with its elements in ascending sort order.</source>
          <target state="translated">La matrice viene creata con i relativi elementi in ordine crescente.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method requires the array to be sorted in ascending order.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metodo richiede che la matrice sia ordinata in ordine crescente.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è di un tipo non compatibile con gli elementi di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non implementa l'interfaccia <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> e la ricerca rileva un elemento che non implementa l'interfaccia <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ordinato unidimensionale in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The object to search for.</source>
          <target state="translated">Oggetto da cercare.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementazione <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'implementazione <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">Usando l'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> specificata, effettua la ricerca di un valore all'interno di una matrice unidimensionale e ordinata.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Indice del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> specificato nel parametro <ph id="ph2">&lt;paramref name="array" /&gt;</ph> specificato, se viene trovato <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; in caso contrario, un numero negativo.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è minore di uno o più elementi presenti in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è maggiore di tutti gli elementi in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Se questo metodo viene chiamato con un oggetto <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è presente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> devono essere ordinati prima di chiamare questo metodo.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">È possibile applicare l'operatore di complemento bit per bit (~ in c#, <ph id="ph1">`Not`</ph> in Visual Basic) per il risultato per produrre un indice negativo.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Se l'indice è maggiore del limite superiore della matrice, non sono presenti elementi maggiori <ph id="ph1">`value`</ph> nella matrice.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">In caso contrario, è l'indice del primo elemento maggiore di <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">L'operatore di confronto consente di personalizzare la modalità di confronto di elementi.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Ad esempio, è possibile utilizzare un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> non <ph id="ph2">`null`</ph>, gli elementi di <ph id="ph3">`array`</ph> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementazione.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito da <ph id="ph2">`comparer`</ph>; in caso contrario, il risultato potrebbe non essere corretto.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If<ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Se<ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, il confronto viene eseguito utilizzando il <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementazione fornita dall'elemento stesso o dal valore specificato.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementazione; in caso contrario, il risultato potrebbe essere errato.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph> e <ph id="ph3">`value`</ph> non implementa il <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interfaccia, gli elementi di <ph id="ph5">`array`</ph> non sono stati testati per <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> prima dell'inizio della ricerca.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Sono consentiti elementi duplicati.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> contiene più di un elemento uguale a <ph id="ph2">`value`</ph>, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con <ph id="ph2">`null`</ph> non generano un'eccezione.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Per ogni elemento verificato, <ph id="ph1">`value`</ph> viene passato a appropriato <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementazione, anche se <ph id="ph3">`value`</ph> è <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Vale a dire il <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementazione determina il modo in cui un determinato elemento Confronta a <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (log <ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="value" /&gt;</ph> è di un tipo non compatibile con gli elementi di <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> non implementa l'interfaccia <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> e la ricerca rileva un elemento che non implementa l'interfaccia <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ordinato unidimensionale in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Indice iniziale dell'intervallo in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The length of the range to search.</source>
          <target state="translated">Lunghezza dell'intervallo in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The object to search for.</source>
          <target state="translated">Oggetto da cercare.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each element of the array and by the specified value.</source>
          <target state="translated">Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata, usando l'interfaccia <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> implementata da ogni elemento della matrice e dal valore specificato.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Indice del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> specificato nel parametro <ph id="ph2">&lt;paramref name="array" /&gt;</ph> specificato, se viene trovato <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; in caso contrario, un numero negativo.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è minore di uno o più elementi presenti in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è maggiore di tutti gli elementi in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Se questo metodo viene chiamato con un oggetto <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è presente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> devono essere ordinati prima di chiamare questo metodo.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
          <target state="translated">È possibile applicare l'operatore di complemento bit per bit (~ in c#, <ph id="ph1">`Not`</ph> in Visual Basic) per il risultato per produrre un indice negativo.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Se l'indice è maggiore del limite superiore della matrice, non sono presenti elementi maggiori <ph id="ph1">`value`</ph> nella matrice.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">In caso contrario, è l'indice del primo elemento maggiore di <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">Sia <ph id="ph1">`value`</ph> o ogni elemento di <ph id="ph2">`array`</ph> deve implementare il <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaccia, che viene utilizzata per i confronti.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementazione; in caso contrario, il risultato potrebbe essere errato.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> non implementa il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interfaccia, gli elementi di <ph id="ph3">`array`</ph> non sono stati testati per <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> prima dell'inizio della ricerca.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Sono consentiti elementi duplicati.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> contiene più di un elemento uguale a <ph id="ph2">`value`</ph>, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con <ph id="ph2">`null`</ph> non generano un'eccezione.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Per ogni elemento verificato, <ph id="ph1">`value`</ph> viene passato a appropriato <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementazione, anche se <ph id="ph3">`value`</ph> è <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Vale a dire il <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementazione determina il modo in cui un determinato elemento Confronta a <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (log <ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è di un tipo non compatibile con gli elementi di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non implementa l'interfaccia <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> e la ricerca rileva un elemento che non implementa l'interfaccia <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ordinato unidimensionale in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Indice iniziale dell'intervallo in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The length of the range to search.</source>
          <target state="translated">Lunghezza dell'intervallo in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The object to search for.</source>
          <target state="translated">Oggetto da cercare.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementazione <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'implementazione <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata mediante l'interfaccia <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Indice del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> specificato nel parametro <ph id="ph2">&lt;paramref name="array" /&gt;</ph> specificato, se viene trovato <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; in caso contrario, un numero negativo.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è minore di uno o più elementi presenti in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è maggiore di tutti gli elementi in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Se questo metodo viene chiamato con un oggetto <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è presente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> devono essere ordinati prima di chiamare questo metodo.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">È possibile applicare l'operatore di complemento bit per bit (~ in c#, <ph id="ph1">`Not`</ph> in Visual Basic) per il risultato per produrre un indice negativo.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Se l'indice è maggiore del limite superiore della matrice, non sono presenti elementi maggiori <ph id="ph1">`value`</ph> nella matrice.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">In caso contrario, è l'indice del primo elemento maggiore di <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">L'operatore di confronto consente di personalizzare la modalità di confronto di elementi.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Ad esempio, è possibile utilizzare un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> non <ph id="ph2">`null`</ph>, gli elementi di <ph id="ph3">`array`</ph> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementazione.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito da <ph id="ph2">`comparer`</ph>; in caso contrario, il risultato potrebbe non essere corretto.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, il confronto viene eseguito utilizzando il <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementazione fornita dall'elemento stesso o dal valore specificato.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementazione; in caso contrario, il risultato potrebbe essere errato.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph> e <ph id="ph3">`value`</ph> non implementa il <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interfaccia, gli elementi di <ph id="ph5">`array`</ph> non sono stati testati per <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> prima dell'inizio della ricerca.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Sono consentiti elementi duplicati.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> contiene più di un elemento uguale a <ph id="ph2">`value`</ph>, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph> può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con <ph id="ph2">`null`</ph> non genera un'eccezione quando si usano <ph id="ph3">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Per ogni elemento verificato, <ph id="ph1">`value`</ph> viene passato a appropriato <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementazione, anche se <ph id="ph3">`value`</ph> è <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Vale a dire il <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementazione determina il modo in cui un determinato elemento Confronta a <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (log <ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="value" /&gt;</ph> è di un tipo non compatibile con gli elementi di <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> non implementa l'interfaccia <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> e la ricerca rileva un elemento che non implementa l'interfaccia <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ordinato unidimensionale in base zero da cercare.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The object to search for.</source>
          <target state="translated">Oggetto da cercare.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and by the specified object.</source>
          <target state="translated">Effettua una ricerca in un'intera matrice unidimensionale ordinata per un elemento specifico, usando l'interfaccia generica <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementata da ogni elemento di <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> e dall'oggetto specificato.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Indice del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> specificato nel parametro <ph id="ph2">&lt;paramref name="array" /&gt;</ph> specificato, se viene trovato <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; in caso contrario, un numero negativo.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è minore di uno o più elementi presenti in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è maggiore di tutti gli elementi in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Se questo metodo viene chiamato con un oggetto <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è presente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> devono essere ordinati prima di chiamare questo metodo.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">`array`</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Se <ph id="ph1">`array`</ph> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">È possibile applicare l'operatore di complemento bit per bit (~ in c#, <ph id="ph1">`Not`</ph> in Visual Basic) per il risultato per produrre un indice negativo.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi maggiore <ph id="ph1">`value`</ph> nella matrice.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">In caso contrario, è l'indice del primo elemento maggiore di <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
          <target state="translated"><ph id="ph1">`T`</ph> deve implementare il <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfaccia generica, che viene utilizzato per i confronti.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementazione; in caso contrario, il risultato potrebbe essere errato.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Sono consentiti elementi duplicati.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> contiene più di un elemento uguale a <ph id="ph2">`value`</ph>, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con <ph id="ph2">`null`</ph> non generano un'eccezione.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Per ogni elemento verificato, <ph id="ph1">`value`</ph> viene passato a appropriato <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementazione, anche se <ph id="ph3">`value`</ph> è <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Vale a dire il <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementazione determina il modo in cui un determinato elemento Confronta a <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (log <ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> overload del metodo generico e <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> overload del metodo generico.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>An array of strings is created, in no particular order.</source>
          <target state="translated">Viene creata una matrice di stringhe, in nessun ordine particolare.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">La matrice è visualizzata, ordinata e visualizzata di nuovo.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Le matrici devono essere ordinate per utilizzare il <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Le chiamate al <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Se si utilizza il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> overload del metodo generico viene quindi utilizzato per eseguire la ricerca di due stringhe, uno che non si trova la matrice e uno che.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">La matrice e il valore restituito del <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metodo vengono passati al <ph id="ph2">`ShowWhere`</ph> metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario gli elementi della stringa di ricerca sarebbe compresa se fosse nella matrice.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The index is negative if the string is not in the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph>-1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">L'indice è negativo se la stringa non è incluso nella matrice, pertanto la <ph id="ph1">`ShowWhere`</ph> metodo accetta il complemento bit per bit (il ~ (operatore) in c# e Visual C++, <ph id="ph2">`Xor`</ph>-1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore della ricerca str sta eseguendo un'operazione.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="T" /&gt;</ph> non implementa l'interfaccia generica <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ordinato unidimensionale in base zero da cercare.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The object to search for.</source>
          <target state="translated">Oggetto da cercare.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementazione <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'implementazione <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Mediante l'interfaccia generica <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> specificata, esegue la ricerca di un valore all'interno di una matrice unidimensionale e ordinata.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Indice del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> specificato nel parametro <ph id="ph2">&lt;paramref name="array" /&gt;</ph> specificato, se viene trovato <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; in caso contrario, un numero negativo.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è minore di uno o più elementi presenti in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è maggiore di tutti gli elementi in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Se questo metodo viene chiamato con un oggetto <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è presente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> devono essere ordinati prima di chiamare questo metodo.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> non contiene il valore specificato, il metodo restituisce un numero intero negativo.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
          <target state="translated">È possibile applicare l'operatore di complemento bit per bit (~ in c#, <ph id="ph1">`Not`</ph> in Visual Basic) per il risultato per produrre un indice negativo.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi maggiore <ph id="ph1">`value`</ph> nella matrice.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">In caso contrario, è l'indice del primo elemento maggiore di <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">L'operatore di confronto consente di personalizzare la modalità di confronto di elementi.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Ad esempio, è possibile utilizzare un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> non <ph id="ph2">`null`</ph>, gli elementi di <ph id="ph3">`array`</ph> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementazione dell'interfaccia generica.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito da <ph id="ph2">`comparer`</ph>; in caso contrario, il risultato potrebbe non essere corretto.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided by <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, il confronto viene eseguito utilizzando il <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> fornito dall'implementazione dell'interfaccia generica <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementazione; in caso contrario, il risultato potrebbe essere errato.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable%601&gt;</ph> before the search begins.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph> e <ph id="ph3">`value`</ph> non implementa il <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> interfaccia generica, gli elementi di <ph id="ph5">`array`</ph> non sono stati testati per <ph id="ph6">&lt;xref:System.IComparable%601&gt;</ph> prima dell'inizio della ricerca.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph>.</source>
          <target state="translated">Viene generata un'eccezione se la ricerca rileva un elemento che non implementa <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Sono consentiti elementi duplicati.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> contiene più di un elemento uguale a <ph id="ph2">`value`</ph>, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con <ph id="ph2">`null`</ph> non generano un'eccezione.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Per ogni elemento verificato, <ph id="ph1">`value`</ph> viene passato a appropriato <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementazione, anche se <ph id="ph3">`value`</ph> è <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Vale a dire il <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementazione determina il modo in cui un determinato elemento Confronta a <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (log <ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload del metodo generico e <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload del metodo generico.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato <ph id="ph1">`ReverseCompare`</ph>, che implementa il <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) dell'interfaccia generica.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Operatore di confronto chiama il <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">La matrice è visualizzata, ordinata e visualizzata di nuovo.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Le matrici devono essere ordinate per utilizzare il <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Le chiamate al <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Se si utilizza il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload del metodo generico viene quindi utilizzato per eseguire la ricerca di due stringhe, uno che non si trova la matrice e uno che.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">La matrice e il valore restituito del <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metodo vengono passati al <ph id="ph2">`ShowWhere`</ph> metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario gli elementi della stringa di ricerca sarebbe compresa se fosse nella matrice.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">L'indice è negativo se la stringa non è inclusa nella matrice, pertanto la <ph id="ph1">`ShowWhere`</ph> metodo accetta il complemento bit per bit (il ~ operatore in c# e Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore di stri di ricerca NG.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="value" /&gt;</ph> è di un tipo non compatibile con gli elementi di <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="T" /&gt;</ph> non implementa l'interfaccia generica <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ordinato unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Indice iniziale dell'intervallo in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The length of the range to search.</source>
          <target state="translated">Lunghezza dell'intervallo in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The object to search for.</source>
          <target state="translated">Oggetto da cercare.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and by the specified value.</source>
          <target state="translated">Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata, usando l'interfaccia generica <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementata da ogni elemento dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> e dal valore specificato.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Indice del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> specificato nel parametro <ph id="ph2">&lt;paramref name="array" /&gt;</ph> specificato, se viene trovato <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; in caso contrario, un numero negativo.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è minore di uno o più elementi presenti in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è maggiore di tutti gli elementi in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Se questo metodo viene chiamato con un oggetto <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è presente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> devono essere ordinati prima di chiamare questo metodo.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Se la matrice non contiene il valore specificato, il metodo restituisce un numero intero negativo.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">È possibile applicare l'operatore di complemento bit per bit (~ in c#, <ph id="ph1">`Not`</ph> in Visual Basic) per il risultato per produrre un indice negativo.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi maggiore <ph id="ph1">`value`</ph> nella matrice.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">In caso contrario, è l'indice del primo elemento maggiore di <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
          <target state="translated"><ph id="ph1">`T`</ph> deve implementare il <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfaccia generica, che viene utilizzato per i confronti.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementazione; in caso contrario, il risultato potrebbe essere errato.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Sono consentiti elementi duplicati.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> contiene più di un elemento uguale a <ph id="ph2">`value`</ph>, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con <ph id="ph2">`null`</ph> non generano un'eccezione.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Per ogni elemento verificato, <ph id="ph1">`value`</ph> viene passato a appropriato <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementazione, anche se <ph id="ph3">`value`</ph> è <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Vale a dire il <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementazione determina il modo in cui un determinato elemento Confronta a <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (log <ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è di un tipo non compatibile con gli elementi di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="T" /&gt;</ph> non implementa l'interfaccia generica <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ordinato unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to search.</source>
          <target state="translated">Indice iniziale dell'intervallo in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The length of the range to search.</source>
          <target state="translated">Lunghezza dell'intervallo in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The object to search for.</source>
          <target state="translated">Oggetto da cercare.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementazione <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'implementazione <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Cerca un valore in un intervallo di elementi di una matrice unidimensionale ordinata mediante l'interfaccia generica <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Indice del parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> specificato nel parametro <ph id="ph2">&lt;paramref name="array" /&gt;</ph> specificato, se viene trovato <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; in caso contrario, un numero negativo.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è minore di uno o più elementi presenti in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice del primo elemento maggiore di <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="value" /&gt;</ph> non viene trovato e <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è maggiore di tutti gli elementi in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, il numero negativo restituito corrisponde al complemento bit per bit dell'indice dell'ultimo elemento più 1.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Se questo metodo viene chiamato con un oggetto <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non ordinato, il valore restituito potrebbe non essere corretto e potrebbe essere restituito un numero negativo, anche se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è presente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Questo metodo non supporta la ricerca di matrici che contengono indici negativi.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> devono essere ordinati prima di chiamare questo metodo.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Se la matrice non contiene il valore specificato, il metodo restituisce un numero intero negativo.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">È possibile applicare l'operatore di complemento bit per bit (~ in c#, <ph id="ph1">`Not`</ph> in Visual Basic) per il risultato per produrre un indice negativo.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Se l'indice è uguale alla dimensione della matrice, non sono presenti elementi maggiore <ph id="ph1">`value`</ph> nella matrice.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">In caso contrario, è l'indice del primo elemento maggiore di <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">L'operatore di confronto consente di personalizzare la modalità di confronto di elementi.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Ad esempio, è possibile utilizzare un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> come operatore di confronto per eseguire ricerche di stringhe tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> non <ph id="ph2">`null`</ph>, gli elementi di <ph id="ph3">`array`</ph> vengono confrontati con il valore specificato utilizzando l'oggetto specificato <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementazione dell'interfaccia generica.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito da <ph id="ph2">`comparer`</ph>; in caso contrario, il risultato potrebbe non essere corretto.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided for type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, il confronto viene eseguito utilizzando il <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> fornito per il tipo di implementazione dell'interfaccia generica <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> già devono essere ordinati in ordine crescente in base all'ordinamento definito per il <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementazione; in caso contrario, il risultato potrebbe essere errato.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Sono consentiti elementi duplicati.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> contiene più di un elemento uguale a <ph id="ph2">`value`</ph>, il metodo restituisce l'indice solo uno dei casi e non necessariamente il primo.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph> può sempre essere confrontato con altri tipi riferimento. di conseguenza, i confronti con <ph id="ph2">`null`</ph> non genera un'eccezione quando si usano <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Per ogni elemento verificato, <ph id="ph1">`value`</ph> viene passato a appropriato <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementazione, anche se <ph id="ph3">`value`</ph> è <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Vale a dire il <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementazione determina il modo in cui un determinato elemento Confronta a <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (log <ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="value" /&gt;</ph> è di un tipo non compatibile con gli elementi di <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="T" /&gt;</ph> non implementa l'interfaccia generica <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The array whose elements need to be cleared.</source>
          <target state="translated">Matrice i cui elementi devono essere cancellati.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range of elements to clear.</source>
          <target state="translated">Indice iniziale dell'intervallo di elementi da cancellare.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The number of elements to clear.</source>
          <target state="translated">Numero di elementi da cancellare.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Sets a range of elements in an array to the default value of each element type.</source>
          <target state="translated">Imposta un intervallo di elementi in una matrice sul valore predefinito di ogni tipo di elemento.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method resets each element in an array to the element type's default value.</source>
          <target state="translated">Questo metodo viene reimpostato ogni elemento in una matrice sul valore predefinito del tipo di elemento.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>It sets elements of reference types (including <ph id="ph1">&lt;xref:System.String&gt;</ph> elements) to <ph id="ph2">`null`</ph>, and sets elements of value types to the default values shown in the following table.</source>
          <target state="translated">Imposta gli elementi dei tipi di riferimento (inclusi <ph id="ph1">&lt;xref:System.String&gt;</ph> elementi) per <ph id="ph2">`null`</ph>e imposta gli elementi di tipi di valore per i valori predefiniti illustrati nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Type</source>
          <target state="translated">Tipo</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Value</source>
          <target state="translated">Valore</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>All integral and floating point numeric types</source>
          <target state="translated">Tutti i tipi numerici integrali e a virgola mobile</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>0 (zero)</source>
          <target state="translated">0 (zero)</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Other value types</source>
          <target state="translated">Altri tipi di valore</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Default value of the type's fields</source>
          <target state="translated">Valore predefinito di campi del tipo</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The range of cleared elements wrap from row to row in a multi-dimensional array.</source>
          <target state="translated">L'intervallo di elementi cancellati dalla riga per riga in una matrice multidimensionale.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method only clears the values of the elements; it does not delete the elements themselves.</source>
          <target state="translated">Questo metodo cancella solo i valori di elementi. non elimina gli elementi stessi.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>An array has a fixed size; therefore, elements cannot be added or removed.</source>
          <target state="translated">Una matrice ha dimensioni fisse. di conseguenza, non è possibile aggiungere o rimuovere elementi.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> method to reset integer values in a one-dimensional, two-dimensional, and three-dimensional array.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> per reimpostare i valori interi in una matrice unidimensionale, bidimensionale e tridimensionale.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The following example defines a <ph id="ph1">`TimeZoneTime`</ph> structure that includes a <ph id="ph2">&lt;xref:System.TimeZoneInfo&gt;</ph> field and a <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> field.</source>
          <target state="translated">L'esempio seguente definisce un <ph id="ph1">`TimeZoneTime`</ph> struttura che include un <ph id="ph2">&lt;xref:System.TimeZoneInfo&gt;</ph> campo e un <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> campo.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> method to clear one element in a two-element array of <ph id="ph2">`TimeZoneTime`</ph> values.</source>
          <target state="translated">Chiama quindi il <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> metodo per eliminare un elemento in una matrice di due elementi di <ph id="ph2">`TimeZoneTime`</ph> valori.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The method sets the value of the cleared element to the default value of a <ph id="ph1">&lt;xref:System.TimeZoneInfo&gt;</ph> object, which is <ph id="ph2">`null`</ph>, and the default value of a <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> object, which is <ph id="ph4">&lt;xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il metodo imposta il valore dell'elemento cancellata per il valore predefinito di un <ph id="ph1">&lt;xref:System.TimeZoneInfo&gt;</ph> oggetto, ovvero <ph id="ph2">`null`</ph>e il valore predefinito di un <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> oggetto, ovvero <ph id="ph4">&lt;xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the size of <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">La somma di <ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> è maggiore della dimensione di <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Array.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Crea una copia superficiale di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Array.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Copia superficiale di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies only the elements of the <ph id="ph2">&lt;xref:System.Array&gt;</ph>, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Una copia superficiale di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copia solo gli elementi del <ph id="ph2">&lt;xref:System.Array&gt;</ph>, indipendentemente che siano tipi riferimento o tipi di valore, ma non copia gli oggetti che fanno riferimento i riferimenti a.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The references in the new <ph id="ph1">&lt;xref:System.Array&gt;</ph> point to the same objects that the references in the original <ph id="ph2">&lt;xref:System.Array&gt;</ph> point to.</source>
          <target state="translated">I riferimenti nel nuovo <ph id="ph1">&lt;xref:System.Array&gt;</ph> puntano allo stesso gli oggetti che i riferimenti nell'originale <ph id="ph2">&lt;xref:System.Array&gt;</ph> scegliere.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Al contrario, una copia completa di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The clone is of the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> as the original <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Il clone è dello stesso <ph id="ph1">&lt;xref:System.Type&gt;</ph> dell'originale <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The following code example clones a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> array and demonstrates the behavior of a shallow copy.</source>
          <target state="translated">Nell'esempio di codice riportato di seguito viene cloni un <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> di matrice e viene illustrato il comportamento di una copia superficiale.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che contiene i dati da copiare.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Integer a 32 bit che rappresenta l'indice in <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> da cui viene avviata la copia.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che riceve i dati.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">Integer a 32 bit che rappresenta l'indice in <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> da cui viene avviata la copia.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Intero a 32 bit che rappresenta il numero degli elementi da copiare.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Copia un intervallo di elementi da un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> a partire dall'indice di origine specificato e lo incolla in un altro oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> a partire dall'indice di destinazione specificato.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Guarantees that all changes are undone if the copy does not succeed completely.</source>
          <target state="translated">Garantisce che tutte le modifiche vengano annullate se la copia non riesce completamente.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Il <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> i parametri devono contenere lo stesso numero di dimensioni.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> type must be the same as or derived from the <ph id="ph2">`destinationArray`</ph> type; otherwise, an <ph id="ph3">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown.</source>
          <target state="translated">Il <ph id="ph1">`sourceArray`</ph> tipo deve essere uguale o derivato dal <ph id="ph2">`destinationArray`</ph> tipo; in caso contrario, un <ph id="ph3">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Unlike <ph id="ph1">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> verifies the compatibility of the array types before performing any operation.</source>
          <target state="translated">A differenza di <ph id="ph1">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> verifica la compatibilità dei tipi di matrice prima di eseguire qualsiasi operazione.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Durante la copia tra le matrici multidimensionali, la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o le colonne) sono concettualmente disposte end-to-end.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Ad esempio, se una matrice dispone di tre righe (o le colonne) con quattro elementi, ogni copiando sei elementi dall'inizio della matrice copiava tutti e quattro gli elementi della prima riga (o della colonna) e i primi due elementi della seconda riga (o colonna).</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Per avviare la copia dal secondo elemento della terza riga (o colonna), <ph id="ph1">`sourceIndex`</ph> deve essere il limite superiore della prima riga (o colonna) più la lunghezza della seconda riga (o colonna) più due.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Se <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> si sovrappongono, questo metodo si comporta come se i valori originali di <ph id="ph3">`sourceArray`</ph> siano stati conservati in un percorso temporaneo prima <ph id="ph4">`destinationArray`</ph> viene sovrascritto.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Questo metodo è equivalente alla funzione standard C/C++ <ph id="ph1">`memmove`</ph>, non <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Le matrici possono essere matrici di tipo riferimento o matrici di tipi di valore.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Se <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <ph id="ph3">&lt;xref:System.Object&gt;</ph>, viene eseguita una copia superficiale.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Una copia superficiale di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> è una nuova <ph id="ph2">&lt;xref:System.Array&gt;</ph> contenenti riferimenti agli stessi elementi originale <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Gli elementi stessi o qualsiasi elemento a cui fa riferimento gli elementi non vengono copiati.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Al contrario, una copia completa di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If this method throws an exception while copying, the <ph id="ph1">`destinationArray`</ph> remains unchanged; therefore, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> can be used within a constrained execution region (<ph id="ph3">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>).</source>
          <target state="translated">Se questo metodo genera un'eccezione durante la copia, il <ph id="ph1">`destinationArray`</ph> rimane invariata; pertanto, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> può essere utilizzato all'interno di un'area a esecuzione vincolata (<ph id="ph3">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> e <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> hanno classificazioni diverse.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> type is neither the same as nor derived from the <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> type.</source>
          <target state="translated">Il tipo <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> non è né lo stesso né derivato dal tipo <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast di almeno un elemento in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> al tipo di <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> è minore del limite inferiore della prima dimensione di <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> è minore del limite inferiore della prima dimensione di <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è maggiore del numero di elementi compresi tra <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> e la fine di <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è maggiore del numero di elementi compresi tra <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> e la fine di <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The type of the elements of the source array.</source>
          <target state="translated">Tipo degli elementi della matrice di origine.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The type of the elements of the target array.</source>
          <target state="translated">Tipo degli elementi della matrice di destinazione.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to convert to a target type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero da convertire in un tipo di destinazione.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>A <ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph> that converts each element from one type to another type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph> che converte ogni elemento da un tipo a un altro.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>Converts an array of one type to an array of another type.</source>
          <target state="translated">Converte una matrice di un tipo in una matrice di un altro tipo.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>An array of the target type containing the converted elements from the source array.</source>
          <target state="translated">Matrice del tipo di destinazione contenente gli elementi convertiti dalla matrice di origine.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> is a delegate to a method that converts an object to the target type.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> è un delegato a un metodo che converte un oggetto per il tipo di destinazione.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph>, and the converted elements are saved in the new array.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph>, e gli elementi convertiti vengono salvati nella nuova matrice.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The source <ph id="ph1">`array`</ph> remains unchanged.</source>
          <target state="translated">L'origine <ph id="ph1">`array`</ph> rimane invariato.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The following code example defines a method named <ph id="ph1">`PointFToPoint`</ph> that converts a <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> structure to a <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structure.</source>
          <target state="translated">Esempio di codice seguente definisce un metodo denominato <ph id="ph1">`PointFToPoint`</ph> che converte un <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> struttura in un <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> struttura.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The example then creates an array of <ph id="ph1">&lt;xref:System.Drawing.PointF&gt;</ph> structures, creates a <ph id="ph2">`Converter&lt;PointF, Point&gt;`</ph> delegate (<ph id="ph3">`Converter(Of PointF, Point)`</ph> in Visual Basic) to represent the <ph id="ph4">`PointFToPoint`</ph> method, and passes the delegate to the <ph id="ph5">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> method.</source>
          <target state="translated">Viene quindi creata una matrice di <ph id="ph1">&lt;xref:System.Drawing.PointF&gt;</ph> strutture, crea un <ph id="ph2">`Converter&lt;PointF, Point&gt;`</ph> delegato (<ph id="ph3">`Converter(Of PointF, Point)`</ph> in Visual Basic) per rappresentare il <ph id="ph4">`PointFToPoint`</ph> metodo e passa il delegato per il <ph id="ph5">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The <ph id="ph1">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> method passes each element of the input list to the <ph id="ph2">`PointFToPoint`</ph> method and puts the converted elements into a new list of <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> metodo passa ogni elemento dell'elenco di input per il <ph id="ph2">`PointFToPoint`</ph> (metodo) e inserisce gli elementi convertiti in un nuovo elenco di <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> strutture.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>Both lists are displayed.</source>
          <target state="translated">Entrambi gli elenchi vengono visualizzati.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source><ph id="ph1">&lt;paramref name="converter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="converter" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Copies a range of elements in one <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and performs type casting and boxing as required.</source>
          <target state="translated">Copia un intervallo di elementi di un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> in un altro oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ed esegue il cast e il boxing del tipo secondo le necessità.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che contiene i dati da copiare.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che riceve i dati.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Intero a 32 bit che rappresenta il numero degli elementi da copiare.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element.</source>
          <target state="translated">Copia un intervallo di elementi da un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> a partire dal primo elemento e lo incolla in un altro oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> a partire dal primo elemento.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The length is specified as a 32-bit integer.</source>
          <target state="translated">La lunghezza viene specificata come intero a 32 bit.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Il <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> i parametri devono contenere lo stesso numero di dimensioni.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
          <target state="translated">Inoltre, <ph id="ph1">`destinationArray`</ph> deve già dimensionata e deve avere un numero sufficiente di elementi da includere tutti i dati copiati.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
          <target state="translated">Durante la copia tra le matrici multidimensionali, la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o le colonne) sono concettualmente disposte end-to-end.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Ad esempio, se una matrice dispone di tre righe (o le colonne) con quattro elementi, ogni copiando sei elementi dall'inizio della matrice copiava tutti e quattro gli elementi della prima riga (o della colonna) e i primi due elementi della seconda riga (o colonna).</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Se <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> si sovrappongono, questo metodo si comporta come se i valori originali di <ph id="ph3">`sourceArray`</ph> siano stati conservati in un percorso temporaneo prima <ph id="ph4">`destinationArray`</ph> viene sovrascritto.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Questo metodo è equivalente alla funzione standard C/C++ <ph id="ph1">`memmove`</ph>, non <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Le matrici possono essere matrici di tipo riferimento o matrici di tipi di valore.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Viene eseguito il downcast del tipo, come richiesto.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Durante la copia da una matrice di tipo riferimento a una matrice di tipo di valore, ogni elemento è unboxed e quindi copiata.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Quando si copia da una matrice di tipo riferimento o tipo di valore a un <ph id="ph1">&lt;xref:System.Object&gt;</ph> matrice, un <ph id="ph2">&lt;xref:System.Object&gt;</ph> viene creata per contenere ogni valore o riferimento e quindi copiata.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Durante la copia da un <ph id="ph1">&lt;xref:System.Object&gt;</ph> matrice a una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Se <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <ph id="ph3">&lt;xref:System.Object&gt;</ph>, viene eseguita una copia superficiale.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Una copia superficiale di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> è una nuova <ph id="ph2">&lt;xref:System.Array&gt;</ph> contenenti riferimenti agli stessi elementi originale <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Gli elementi stessi o qualsiasi elemento a cui fa riferimento gli elementi non vengono copiati.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Al contrario, una copia completa di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generato se le matrici di tipi incompatibili.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Compatibilità del tipo viene definita come segue:</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Un tipo è compatibile con se stesso.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">È compatibile con un tipo di valore <ph id="ph1">&lt;xref:System.Object&gt;</ph> e con un'interfaccia implementata dal tipo di valore.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa l'interfaccia direttamente.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">I tipi disconnessi non sono compatibili.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine al tipo di destinazione è una conversione di ampliamento.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Una conversione widening mai perdite di informazioni, mentre una conversione di narrowing può provocare la perdita di informazioni.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e la conversione di un intero con segno a 64 bit in un intero con segno a 32 bit è una conversione di narrowing.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Un tipo di valore (definita dall'utente) non intrinseco è compatibile solo con se stesso.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Le enumerazioni dispongono di una conversione implicita a <ph id="ph1">&lt;xref:System.Enum&gt;</ph> e al tipo sottostante.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Se ogni elemento in <ph id="ph1">`sourceArray`</ph> richiede un downcast (ad esempio, da una classe base per una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in <ph id="ph2">`destinationArray`</ph>, un <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Se questo metodo genera un'eccezione durante la copia, lo stato di <ph id="ph1">`destinationArray`</ph> non è definito.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> e <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> hanno classificazioni diverse.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated">I tipi di <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> e <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sono incompatibili.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast di almeno un elemento in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> al tipo di <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è maggiore del numero di elementi in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è maggiore del numero di elementi in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che contiene i dati da copiare.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che riceve i dati.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Intero a 64 bit che rappresenta il numero di elementi da copiare.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The integer must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">L'intero deve essere compreso tra zero e <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusi.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element.</source>
          <target state="translated">Copia un intervallo di elementi da un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> a partire dal primo elemento e lo incolla in un altro oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> a partire dal primo elemento.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The length is specified as a 64-bit integer.</source>
          <target state="translated">La lunghezza viene specificata come intero a 64 bit.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Il <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> i parametri devono contenere lo stesso numero di dimensioni.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
          <target state="translated">Inoltre, <ph id="ph1">`destinationArray`</ph> deve già dimensionata e deve avere un numero sufficiente di elementi da includere tutti i dati copiati.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
          <target state="translated">Durante la copia tra le matrici multidimensionali, la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o le colonne) sono concettualmente disposte end-to-end.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Ad esempio, se una matrice dispone di tre righe (o le colonne) con quattro elementi, ogni copiando sei elementi dall'inizio della matrice copiava tutti e quattro gli elementi della prima riga (o della colonna) e i primi due elementi della seconda riga (o colonna).</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Se <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> si sovrappongono, questo metodo si comporta come se i valori originali di <ph id="ph3">`sourceArray`</ph> siano stati conservati in un percorso temporaneo prima <ph id="ph4">`destinationArray`</ph> viene sovrascritto.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Questo metodo è equivalente alla funzione standard C/C++ <ph id="ph1">`memmove`</ph>, non <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Le matrici possono essere matrici di tipo riferimento o matrici di tipi di valore.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Viene eseguito il downcast del tipo, come richiesto.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Durante la copia da una matrice di tipo riferimento a una matrice di tipo di valore, ogni elemento è unboxed e quindi copiata.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Quando si copia da una matrice di tipo riferimento o tipo di valore a un <ph id="ph1">&lt;xref:System.Object&gt;</ph> matrice, un <ph id="ph2">&lt;xref:System.Object&gt;</ph> viene creata per contenere ogni valore o riferimento e quindi copiata.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Durante la copia da un <ph id="ph1">&lt;xref:System.Object&gt;</ph> matrice a una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Se <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <ph id="ph3">&lt;xref:System.Object&gt;</ph>, viene eseguita una copia superficiale.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Una copia superficiale di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> è una nuova <ph id="ph2">&lt;xref:System.Array&gt;</ph> contenenti riferimenti agli stessi elementi originale <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Gli elementi stessi o qualsiasi elemento a cui fa riferimento gli elementi non vengono copiati.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Al contrario, una copia completa di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generato se le matrici di tipi incompatibili.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Compatibilità del tipo viene definita come segue:</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Un tipo è compatibile con se stesso.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">È compatibile con un tipo di valore <ph id="ph1">&lt;xref:System.Object&gt;</ph> e con un'interfaccia implementata dal tipo di valore.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa l'interfaccia direttamente.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">I tipi disconnessi non sono compatibili.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine al tipo di destinazione è una conversione di ampliamento.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Una conversione widening mai perdite di informazioni, mentre una conversione di narrowing può provocare la perdita di informazioni.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e la conversione di un intero con segno a 64 bit in un intero con segno a 32 bit è una conversione di narrowing.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Un tipo di valore (definita dall'utente) non intrinseco è compatibile solo con se stesso.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Le enumerazioni dispongono di una conversione implicita a <ph id="ph1">&lt;xref:System.Enum&gt;</ph> e al tipo sottostante.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Se ogni elemento in <ph id="ph1">`sourceArray`</ph> richiede un downcast (ad esempio, da una classe base per una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in <ph id="ph2">`destinationArray`</ph>, un <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Se questo metodo genera un'eccezione durante la copia, lo stato di <ph id="ph1">`destinationArray`</ph> non è definito.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> e <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> hanno classificazioni diverse.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated">I tipi di <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> e <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sono incompatibili.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast di almeno un elemento in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> al tipo di <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di 0 o maggiore di <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è maggiore del numero di elementi in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è maggiore del numero di elementi in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che contiene i dati da copiare.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Integer a 32 bit che rappresenta l'indice in <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> da cui viene avviata la copia.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che riceve i dati.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">Integer a 32 bit che rappresenta l'indice in <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> da cui viene avviata la copia.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Intero a 32 bit che rappresenta il numero degli elementi da copiare.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Copia un intervallo di elementi da un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> a partire dall'indice di origine specificato e lo incolla in un altro oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> a partire dall'indice di destinazione specificato.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The length and the indexes are specified as 32-bit integers.</source>
          <target state="translated">La lunghezza e gli indici vengono specificati come interi a 32 bit.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Il <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> i parametri devono contenere lo stesso numero di dimensioni.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
          <target state="translated">Inoltre, <ph id="ph1">`destinationArray`</ph> deve già dimensionata e deve avere un numero sufficiente di elementi a partire dal <ph id="ph2">`destinationIndex`</ph> posizione per contenere i dati copiati.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Durante la copia tra le matrici multidimensionali, la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o le colonne) sono concettualmente disposte end-to-end.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Ad esempio, se una matrice dispone di tre righe (o le colonne) con quattro elementi, ogni copiando sei elementi dall'inizio della matrice copiava tutti e quattro gli elementi della prima riga (o della colonna) e i primi due elementi della seconda riga (o colonna).</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Per avviare la copia dal secondo elemento della terza riga (o colonna), <ph id="ph1">`sourceIndex`</ph> deve essere il limite superiore della prima riga (o colonna) più la lunghezza della seconda riga (o colonna) più due.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Se <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> si sovrappongono, questo metodo si comporta come se i valori originali di <ph id="ph3">`sourceArray`</ph> siano stati conservati in un percorso temporaneo prima <ph id="ph4">`destinationArray`</ph> viene sovrascritto.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Questo metodo è equivalente alla funzione standard C/C++ <ph id="ph1">`memmove`</ph>, non <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Le matrici possono essere matrici di tipo riferimento o matrici di tipi di valore.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Viene eseguito il downcast del tipo, come richiesto.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Durante la copia da una matrice di tipo riferimento a una matrice di tipo di valore, ogni elemento è unboxed e quindi copiata.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Quando si copia da una matrice di tipo riferimento o tipo di valore a un <ph id="ph1">&lt;xref:System.Object&gt;</ph> matrice, un <ph id="ph2">&lt;xref:System.Object&gt;</ph> viene creata per contenere ogni valore o riferimento e quindi copiata.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Durante la copia da un <ph id="ph1">&lt;xref:System.Object&gt;</ph> matrice a una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Se <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <ph id="ph3">&lt;xref:System.Object&gt;</ph>, viene eseguita una copia superficiale.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Una copia superficiale di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> è una nuova <ph id="ph2">&lt;xref:System.Array&gt;</ph> contenenti riferimenti agli stessi elementi originale <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Gli elementi stessi o qualsiasi elemento a cui fa riferimento gli elementi non vengono copiati.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Al contrario, una copia completa di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generato se le matrici di tipi incompatibili.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Compatibilità del tipo viene definita come segue:</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Un tipo è compatibile con se stesso.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">È compatibile con un tipo di valore <ph id="ph1">&lt;xref:System.Object&gt;</ph> e con un'interfaccia implementata dal tipo di valore.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa l'interfaccia direttamente.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">I tipi disconnessi non sono compatibili.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine al tipo di destinazione è una conversione di ampliamento.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Una conversione widening mai perdite di informazioni, mentre una conversione di narrowing può provocare la perdita di informazioni.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e la conversione di un intero con segno a 64 bit in un intero con segno a 32 bit è una conversione di narrowing.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Un tipo di valore (definita dall'utente) non intrinseco è compatibile solo con se stesso.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Le enumerazioni dispongono di una conversione implicita a <ph id="ph1">&lt;xref:System.Enum&gt;</ph> e al tipo sottostante.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Se ogni elemento in <ph id="ph1">`sourceArray`</ph> richiede un downcast (ad esempio, da una classe base per una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in <ph id="ph2">`destinationArray`</ph>, un <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Se questo metodo genera un'eccezione durante la copia, lo stato di <ph id="ph1">`destinationArray`</ph> non è definito.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to copy from one <ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Object&gt;</ph> to another <ph id="ph3">&lt;xref:System.Array&gt;</ph> of type integer.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come copiare da una <ph id="ph1">&lt;xref:System.Array&gt;</ph> di tipo <ph id="ph2">&lt;xref:System.Object&gt;</ph> a un altro <ph id="ph3">&lt;xref:System.Array&gt;</ph> di tipo integer.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> e <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> hanno classificazioni diverse.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated">I tipi di <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> e <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sono incompatibili.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast di almeno un elemento in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> al tipo di <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> è minore del limite inferiore della prima dimensione di <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> è minore del limite inferiore della prima dimensione di <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è maggiore del numero di elementi compresi tra <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> e la fine di <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è maggiore del numero di elementi compresi tra <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> e la fine di <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che contiene i dati da copiare.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice in <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> da cui viene avviata la copia.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che riceve i dati.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice in <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> da cui viene avviata la copia.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Intero a 64 bit che rappresenta il numero di elementi da copiare.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The integer must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">L'intero deve essere compreso tra zero e <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusi.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Copia un intervallo di elementi da un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> a partire dall'indice di origine specificato e lo incolla in un altro oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> a partire dall'indice di destinazione specificato.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The length and the indexes are specified as 64-bit integers.</source>
          <target state="translated">La lunghezza e gli indici vengono specificati come interi a 64 bit.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Il <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> i parametri devono contenere lo stesso numero di dimensioni.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
          <target state="translated">Inoltre, <ph id="ph1">`destinationArray`</ph> deve già dimensionata e deve avere un numero sufficiente di elementi a partire dal <ph id="ph2">`destinationIndex`</ph> posizione per contenere i dati copiati.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Durante la copia tra le matrici multidimensionali, la matrice si comporta come una matrice unidimensionale di tempo, in cui le righe (o le colonne) sono concettualmente disposte end-to-end.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Ad esempio, se una matrice dispone di tre righe (o le colonne) con quattro elementi, ogni copiando sei elementi dall'inizio della matrice copiava tutti e quattro gli elementi della prima riga (o della colonna) e i primi due elementi della seconda riga (o colonna).</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Per avviare la copia dal secondo elemento della terza riga (o colonna), <ph id="ph1">`sourceIndex`</ph> deve essere il limite superiore della prima riga (o colonna) più la lunghezza della seconda riga (o colonna) più due.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Se <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> si sovrappongono, questo metodo si comporta come se i valori originali di <ph id="ph3">`sourceArray`</ph> siano stati conservati in un percorso temporaneo prima <ph id="ph4">`destinationArray`</ph> viene sovrascritto.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Questo metodo è equivalente alla funzione standard C/C++ <ph id="ph1">`memmove`</ph>, non <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Le matrici possono essere matrici di tipo riferimento o matrici di tipi di valore.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Viene eseguito il downcast del tipo, come richiesto.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Durante la copia da una matrice di tipo riferimento a una matrice di tipo di valore, ogni elemento è unboxed e quindi copiata.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Quando si copia da una matrice di tipo di valore in una matrice di tipo riferimento, ogni elemento viene sottoposto a boxing e quindi copiato.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Quando si copia da una matrice di tipo riferimento o tipo di valore a un <ph id="ph1">&lt;xref:System.Object&gt;</ph> matrice, un <ph id="ph2">&lt;xref:System.Object&gt;</ph> viene creata per contenere ogni valore o riferimento e quindi copiata.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Durante la copia da un <ph id="ph1">&lt;xref:System.Object&gt;</ph> matrice a una matrice di tipo riferimento o tipo di valore e l'assegnazione non è possibile, un <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Se <ph id="ph1">`sourceArray`</ph> e <ph id="ph2">`destinationArray`</ph> sono entrambe le matrici di tipo riferimento o entrambe le matrici di tipo <ph id="ph3">&lt;xref:System.Object&gt;</ph>, viene eseguita una copia superficiale.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Una copia superficiale di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> è una nuova <ph id="ph2">&lt;xref:System.Array&gt;</ph> contenenti riferimenti agli stessi elementi originale <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Gli elementi stessi o qualsiasi elemento a cui fa riferimento gli elementi non vengono copiati.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Al contrario, una copia completa di un <ph id="ph1">&lt;xref:System.Array&gt;</ph> copia gli elementi e tutti gli elementi direttamente o indirettamente a cui fa riferimento gli elementi.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> viene generato se le matrici di tipi incompatibili.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Compatibilità del tipo viene definita come segue:</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Un tipo è compatibile con se stesso.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">È compatibile con un tipo di valore <ph id="ph1">&lt;xref:System.Object&gt;</ph> e con un'interfaccia implementata dal tipo di valore.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Un tipo di valore viene considerato connesso a un'interfaccia solo se implementa l'interfaccia direttamente.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">I tipi disconnessi non sono compatibili.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Due tipi di valore intrinseco (predefinito) sono compatibili se la copia dal tipo di origine al tipo di destinazione è una conversione di ampliamento.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Una conversione widening mai perdite di informazioni, mentre una conversione di narrowing può provocare la perdita di informazioni.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Ad esempio, la conversione di un intero con segno a 32 bit in un intero con segno a 64 bit è una conversione verso e la conversione di un intero con segno a 64 bit in un intero con segno a 32 bit è una conversione di narrowing.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Un tipo di valore (definita dall'utente) non intrinseco è compatibile solo con se stesso.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Le enumerazioni dispongono di una conversione implicita a <ph id="ph1">&lt;xref:System.Enum&gt;</ph> e al tipo sottostante.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Se ogni elemento in <ph id="ph1">`sourceArray`</ph> richiede un downcast (ad esempio, da una classe base per una classe derivata o da un'interfaccia a un oggetto) e uno o più elementi non è possibile eseguire il cast al tipo corrispondente in <ph id="ph2">`destinationArray`</ph>, un <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Se questo metodo genera un'eccezione durante la copia, lo stato di <ph id="ph1">`destinationArray`</ph> non è definito.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The following code example shows how to copy from one <ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Object&gt;</ph> to another <ph id="ph3">&lt;xref:System.Array&gt;</ph> of type integer.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come copiare da una <ph id="ph1">&lt;xref:System.Array&gt;</ph> di tipo <ph id="ph2">&lt;xref:System.Object&gt;</ph> a un altro <ph id="ph3">&lt;xref:System.Array&gt;</ph> di tipo integer.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> e <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> hanno classificazioni diverse.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated">I tipi di <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> e <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sono incompatibili.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast di almeno un elemento in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> al tipo di <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di 0 o maggiore di <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è maggiore del numero di elementi compresi tra <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> e la fine di <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è maggiore del numero di elementi compresi tra <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> e la fine di <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array.</source>
          <target state="translated">Copia tutti gli elementi dell'attuale matrice unidimensionale nella matrice unidimensionale specificata.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
          <target state="translated">Matrice unidimensionale che costituisce la destinazione degli elementi copiati dalla matrice corrente.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>A 32-bit integer that represents the index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Integer a 32 bit che rappresenta l'indice in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> da cui viene avviata la copia.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
          <target state="translated">Copia tutti gli elementi dell'attuale matrice unidimensionale nella matrice unidimensionale specificata a partire dall'indice della matrice di destinazione indicato.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">L'indice viene specificato come intero a 32 bit.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
          <target state="translated">Questo metodo copia tutti gli elementi dell'istanza corrente di matrice per la <ph id="ph1">`array`</ph> matrice di destinazione, a partire dall'indice <ph id="ph2">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
          <target state="translated">Il <ph id="ph1">`array`</ph> matrice di destinazione deve già dimensionata e deve avere un numero sufficiente di elementi per contenere gli elementi copiati.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Otherwise, the method throws an exception.</source>
          <target state="translated">In caso contrario, il metodo genererà un'eccezione.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Questo metodo supporta il <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
          <target state="translated">Se l'implementazione <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> è necessario non in modo esplicito, utilizzare <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> per evitare un riferimento indiretto aggiuntivo.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
          <target state="translated">Se questo metodo genera un'eccezione durante la copia, lo stato di <ph id="ph1">`array`</ph> non è definito.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>. Consente di eseguire solo una copia superficiale.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come copiare un <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un altro <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph> with a nonzero lower bound.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come copiare un <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un altro <ph id="ph2">&lt;xref:System.Array&gt;</ph> con limite inferiore diverso da zero.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Note that the entire source <ph id="ph1">&lt;xref:System.Array&gt;</ph> is copied, including empty elements that overwrite existing elements in the target <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Si noti che l'intera origine <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene copiato, inclusi gli elementi vuoti che sovrascrivono gli elementi esistenti nella destinazione <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source array is greater than the available number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Il numero di elementi nella matrice di origine è maggiore del numero disponibile di elementi da <ph id="ph1">&lt;paramref name="index" /&gt;</ph> alla fine dell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> di destinazione.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast automatico del tipo dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> di origine al tipo dell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> di destinazione.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The source array is multidimensional.</source>
          <target state="translated">La matrice di origine è multidimensionale.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>At least one element in the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast to the type of destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast di almeno un elemento nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> di origine al tipo dell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> di destinazione.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
          <target state="translated">Matrice unidimensionale che costituisce la destinazione degli elementi copiati dalla matrice corrente.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>A 64-bit integer that represents the index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> da cui viene avviata la copia.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
          <target state="translated">Copia tutti gli elementi dell'attuale matrice unidimensionale nella matrice unidimensionale specificata a partire dall'indice della matrice di destinazione indicato.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">L'indice viene specificato come intero a 64 bit.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
          <target state="translated">Questo metodo copia tutti gli elementi dell'istanza corrente di matrice per la <ph id="ph1">`array`</ph> matrice di destinazione, a partire dall'indice <ph id="ph2">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
          <target state="translated">Il <ph id="ph1">`array`</ph> matrice di destinazione deve già dimensionata e deve avere un numero sufficiente di elementi per contenere gli elementi copiati.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Otherwise, the method throws an exception.</source>
          <target state="translated">In caso contrario, il metodo genererà un'eccezione.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Questo metodo supporta il <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
          <target state="translated">Se l'implementazione <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> è necessario non in modo esplicito, utilizzare <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> per evitare un riferimento indiretto aggiuntivo.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
          <target state="translated">Se questo metodo genera un'eccezione durante la copia, lo stato di <ph id="ph1">`array`</ph> non è definito.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>. Consente di eseguire solo una copia superficiale.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come copiare un <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un altro <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph> with a nonzero lower bound.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come copiare un <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un altro <ph id="ph2">&lt;xref:System.Array&gt;</ph> con limite inferiore diverso da zero.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Note that the entire source <ph id="ph1">&lt;xref:System.Array&gt;</ph> is copied, including empty elements that overwrite existing elements in the target <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Si noti che l'intera origine <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene copiato, inclusi gli elementi vuoti che sovrascrivono gli elementi esistenti nella destinazione <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The number of elements in the source array is greater than the available number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Il numero di elementi nella matrice di origine è maggiore del numero disponibile di elementi da <ph id="ph1">&lt;paramref name="index" /&gt;</ph> alla fine dell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> di destinazione.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast automatico del tipo dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> di origine al tipo dell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> di destinazione.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">L'origine <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>At least one element in the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast to the type of destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Non è possibile eseguire il cast di almeno un elemento nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> di origine al tipo dell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> di destinazione.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The size of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Dimensione dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Creates a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and length, with zero-based indexing.</source>
          <target state="translated">Crea un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale dell'oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> specificato e della lunghezza, con indice in base zero.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>A new one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length, using zero-based indexing.</source>
          <target state="translated">Nuovo oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale dell'oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> specificato con la lunghezza indicata e con indice in base zero.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">A differenza della maggior parte delle classi, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fornisce il <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Gli elementi di tipo di riferimento vengono inizializzati <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Gli elementi di tipo di valore vengono inizializzati a zero.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The following code example shows how to create and initialize a one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto unidimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è un oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valido.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è un tipo generico aperto.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>An array of 32-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Matrice di interi a 32 bit che rappresentano le grandezze di ciascuna dimensione dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Crea un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale dell'oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> specificato e delle lunghezze della dimensione, con indicizzazione in base zero.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The dimension lengths are specified in an array of 32-bit integers.</source>
          <target state="translated">Le lunghezze vengono specificate in una matrice di interi a 32 bit.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nuovo oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale dell'oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> specificato, con la lunghezza specificata per ogni dimensione, usando l'indicizzazione in base zero.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">A differenza della maggior parte delle classi, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fornisce il <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Il numero di elementi di <ph id="ph1">`lengths`</ph> matrice deve essere uguale al numero di dimensioni nel nuovo <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni elemento del <ph id="ph1">`lengths`</ph> matrice debba specificare la lunghezza della dimensione corrispondente nel nuovo <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Gli elementi di tipo di riferimento vengono inizializzati <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Gli elementi di tipo di valore vengono inizializzati a zero.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il prodotto di tutti i valori <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto multidimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è un oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valido.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated">La matrice di <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> contiene meno di un elemento.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è un tipo generico aperto.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero.</source>
          <target state="translated">Qualsiasi valore in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>An array of 64-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Matrice di interi a 64 bit che rappresentano le grandezze di ciascuna dimensione dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Each integer in the array must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">Ogni intero nella matrice deve essere compreso tra zero e <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusi.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Crea un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale dell'oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> specificato e delle lunghezze della dimensione, con indicizzazione in base zero.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The dimension lengths are specified in an array of 64-bit integers.</source>
          <target state="translated">Le lunghezze delle dimensioni vengono specificate in una matrice di interi a 64 bit.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nuovo oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale dell'oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> specificato, con la lunghezza specificata per ogni dimensione, usando l'indicizzazione in base zero.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">A differenza della maggior parte delle classi, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fornisce il <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Il numero di elementi di <ph id="ph1">`lengths`</ph> matrice deve essere uguale al numero di dimensioni nel nuovo <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni elemento del <ph id="ph1">`lengths`</ph> matrice debba specificare la lunghezza della dimensione corrispondente nel nuovo <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Gli elementi di tipo di riferimento vengono inizializzati <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Gli elementi di tipo di valore vengono inizializzati a zero.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il prodotto di tutti i valori <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto multidimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è un oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valido.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated">La matrice di <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> contiene meno di un elemento.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è un tipo generico aperto.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Qualsiasi valore in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> è minore di zero o maggiore di <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The size of the first dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Dimensioni della prima dimensione di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The size of the second dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Dimensioni della seconda dimensione dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Creates a two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Crea un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> bidimensionale dell'oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> specificato e delle lunghezze delle dimensioni specificate, con indice in base zero.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>A new two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nuovo oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> bidimensionale dell'oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> specificato con la lunghezza specificata per ciascuna dimensione, con indice in base zero.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">A differenza della maggior parte delle classi, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fornisce il <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Gli elementi di tipo di riferimento vengono inizializzati <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Gli elementi di tipo di valore vengono inizializzati a zero.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph> and <ph id="ph4">`length2`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il prodotto di <ph id="ph3">`length1`</ph> e <ph id="ph4">`length2`</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The following code example shows how to create and initialize a two-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto bidimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è un oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valido.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è un tipo generico aperto.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A one-dimensional array that contains the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Matrice unidimensionale che contiene la grandezza di ciascuna dimensione dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A one-dimensional array that contains the lower bound (starting index) of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Matrice unidimensionale che contiene il limite inferiore (indice iniziale) di ciascuna dimensione dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with the specified lower bounds.</source>
          <target state="translated">Crea una matrice <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale con il valore <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> e lunghezze della dimensione specificati, con i limiti inferiori specificati.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length and lower bound for each dimension.</source>
          <target state="translated">Nuovo oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale con il valore <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> specificato, con la lunghezza e il limite inferiore specificati per ogni dimensione.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">A differenza della maggior parte delle classi, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fornisce il <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">`lengths`</ph> and <ph id="ph2">`lowerBounds`</ph> arrays must have the same number of elements.</source>
          <target state="translated">Il <ph id="ph1">`lengths`</ph> e <ph id="ph2">`lowerBounds`</ph> matrici devono avere lo stesso numero di elementi.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Il numero di elementi di <ph id="ph1">`lengths`</ph> matrice deve essere uguale al numero di dimensioni nel nuovo <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni elemento del <ph id="ph1">`lengths`</ph> matrice debba specificare la lunghezza della dimensione corrispondente nel nuovo <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Each element of the <ph id="ph1">`lowerBounds`</ph> array must specify the lower bound of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni elemento del <ph id="ph1">`lowerBounds`</ph> matrice è necessario specificare il limite inferiore della dimensione corrispondente nel nuovo <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</source>
          <target state="translated">In genere, la libreria di classi .NET Framework e molti linguaggi di programmazione non gestiscono i limiti inferiori diversi da zero.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Gli elementi di tipo di riferimento vengono inizializzati <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Gli elementi di tipo di valore vengono inizializzati a zero.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il prodotto di tutti i valori <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> with specified lower bounds.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto multidimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph> con limiti inferiori specificati.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è un oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valido.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated">La matrice di <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> contiene meno di un elemento.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> and <ph id="ph2">&lt;paramref name="lowerBounds" /&gt;</ph> arrays do not contain the same number of elements.</source>
          <target state="translated">Le matrici <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> e <ph id="ph2">&lt;paramref name="lowerBounds" /&gt;</ph> non contengono lo stesso numero di elementi.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è un tipo generico aperto.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero.</source>
          <target state="translated">Qualsiasi valore in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> is very large, such that the sum of a dimension's lower bound and length is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Qualsiasi valore in <ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> è tanto grande che la somma del limite inferiore e della lunghezza di una dimensione risulta essere maggiore di <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the first dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Dimensioni della prima dimensione di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the second dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Dimensioni della seconda dimensione dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the third dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Dimensioni della terza dimensione dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da creare.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Creates a three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Crea un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> tridimensionale dell'oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> specificato e le lunghezze della dimensione, con indice in base zero.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>A new three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nuovo oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> tridimensionale dell'oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> specificato con la lunghezza specificata per ciascuna dimensione, con indice in base zero.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">A differenza della maggior parte delle classi, <ph id="ph1">&lt;xref:System.Array&gt;</ph> fornisce il <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> (metodo), anziché i costruttori pubblici, per consentire l'accesso ad associazione tardiva.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Gli elementi di tipo di riferimento vengono inizializzati <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Gli elementi di tipo di valore vengono inizializzati a zero.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph>, <ph id="ph4">`length2`</ph>, and <ph id="ph5">`length3`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il prodotto di <ph id="ph3">`length1`</ph>, <ph id="ph4">`length2`</ph>, e <ph id="ph5">`length3`</ph>.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The following code example shows how to create and initialize a three-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare e inizializzare un oggetto tridimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è un oggetto <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> valido.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> non è supportato.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> è un tipo generico aperto.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length3" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length3" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Empty``1">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Array.Empty``1">
          <source>Returns an empty array.</source>
          <target state="translated">Restituisce una matrice vuota.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Array.Empty``1">
          <source>Returns an empty <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vuoto.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the elements to search for.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> che definisce le condizioni degli elementi da cercare.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">Determina se la matrice indicata contiene elementi che soddisfano le condizioni definite nel predicato specificato.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="array" /&gt;</ph> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="array" /&gt;</ph> contiene uno o più elementi che soddisfano le condizioni definite dal predicato specificato; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> è un delegato a un metodo che restituisce <ph id="ph2">`true`</ph> se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when a match is found.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, e l'elaborazione viene arrestata quando viene trovata una corrispondenza.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate explicitly.</source>
          <target state="translated">In c# e Visual Basic, non è necessario creare il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegare in modo esplicito.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example specifies the match conditions for the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method usinglambda expressions to check whether a planet starts with a given letter or whether the planet is found on the given array.</source>
          <target state="translated">Nell'esempio seguente specifica le condizioni di corrispondenza per il <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> espressioni usinglambda metodo per verificare se un pianeta inizia con una lettera specificata o meno il pianeta individuato nella matrice specificata.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method to indicate whether any names in a string array begin with a specified character.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> metodo per indicare se i nomi in una matrice di stringhe iniziano con un carattere specificato.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The example instantiates a <ph id="ph1">`StringSearcher`</ph> object by passing the string to search for to its class constructor.</source>
          <target state="translated">Nell'esempio viene creata un'istanza di un <ph id="ph1">`StringSearcher`</ph> oggetto passando la stringa di ricerca al costruttore della classe.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">`StringSearcher.StartsWith`</ph> method has same signature as the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Il <ph id="ph1">`StringSearcher.StartsWith`</ph> metodo ha stessa firma di <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegato.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>When the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method is called, each member of the array is passed to the delegate until it returns <ph id="ph2">`true`</ph> or iterates all the elements in the array.</source>
          <target state="translated">Quando il <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> metodo viene chiamato, ogni membro della matrice viene passato al delegato fino a quando non viene restituito <ph id="ph2">`true`</ph> o esegue l'iterazione di tutti gli elementi nella matrice.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>You can also use a lambda expression rather than explicitly define a method whose signature corresponds to that of the delegate.</source>
          <target state="translated">È possibile inoltre utilizzare un'espressione lambda anziché definire in modo esplicito un metodo la cui firma corrisponde a quella del delegato.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example replaces the <ph id="ph1">`StringSearcher`</ph> class and its <ph id="ph2">`StartsWith`</ph> method with a lambda expression.</source>
          <target state="translated">Nell'esempio seguente sostituisce il <ph id="ph1">`StringSearcher`</ph> classe e il relativo <ph id="ph2">`StartsWith`</ph> (metodo) con un'espressione lambda.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Matrice unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The predicate that defines the conditions of the element to search for.</source>
          <target state="translated">Predicato che definisce le condizioni dell'elemento da cercare.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Cerca un elemento che soddisfi le condizioni definite nel predicato specificato e restituisce la prima occorrenza all'interno dell'intero oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Primo elemento che soddisfa le condizioni definite dal predicato specificato, se trovato; in caso contrario, viene restituito il valore predefinito del tipo <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method or a lambda expression that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate or lambda expression.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> è un delegato di un metodo o un'espressione lambda che restituisce <ph id="ph2">`true`</ph> se l'oggetto passato a corrisponda alle condizioni definite nel delegato o un'espressione lambda.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, starting with the first element and ending with the last element.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, a partire dal primo elemento e terminando con l'ultimo elemento.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">L'elaborazione viene arrestata quando viene trovata una corrispondenza.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The following example uses a <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate with the <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> generic method to search an array of <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</source>
          <target state="translated">Nell'esempio seguente viene utilizzato un <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegato con il <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> un metodo generico per cercare una matrice di <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> strutture.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The method the delegate represents, <ph id="ph1">`ProductGT10`</ph>, returns <ph id="ph2">`true`</ph> if the product of the X and Y fields is greater than 100,000.</source>
          <target state="translated">Il metodo rappresentato dal delegato, <ph id="ph1">`ProductGT10`</ph>, restituisce <ph id="ph2">`true`</ph> se il prodotto dei campi X e Y è maggiore di 100.000.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> method calls the delegate for each element of the array, returning the first point that meets the test condition.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> metodo chiama il delegato per ogni elemento della matrice, restituendo il primo punto che soddisfa la condizione di test.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Visual Basic and C# users do not have to create the delegate explicitly or specify the type argument of the generic method.</source>
          <target state="translated">Gli utenti di c# e Visual Basic non dispone di creare il delegato in modo esplicito o specificare l'argomento di tipo del metodo generico.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The compilers determine the necessary types from the method arguments you supply.</source>
          <target state="translated">I compilatori determinano i tipi necessari dagli argomenti del metodo che è fornito.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Rather than explicitly defining a method with the necessary signature, instantiating a <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate, and passing the delegate to the <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> method, it is customary to use a lambda expression.</source>
          <target state="translated">Anziché definire in modo esplicito un metodo con la firma necessaria, creare un'istanza di un <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegare e passa il delegato per il <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> (metodo), è solitamente si utilizza un'espressione lambda.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The following example is identical to the previous one, except that it uses a lambda expression as the <ph id="ph1">`match`</ph> argument.</source>
          <target state="translated">L'esempio seguente è identico a quello precedente, ad eccezione del fatto che viene utilizzata un'espressione lambda come il <ph id="ph1">`match`</ph> argomento.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the elements to search for.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> che definisce le condizioni degli elementi da cercare.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Retrieves all the elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">Recupera tutti gli elementi che soddisfano le condizioni definite nel predicato specificato.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>An <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> contenente tutti gli elementi che soddisfano le condizioni definite nel predicato specificato, se trovati; in caso contrario, verrà restituito un oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> vuoto.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> è un delegato a un metodo che restituisce <ph id="ph2">`true`</ph> se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and the elements that match the conditions are saved in the returned array.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, e gli elementi che soddisfano le condizioni vengono salvati nella matrice restituita.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The following example creates an array of 50 random numbers with values that can range from 0 to 1,000.</source>
          <target state="translated">Nell'esempio seguente crea una matrice di numeri casuali 50 con i valori sono compresi tra 0 e 1000.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> method with a lambda expression that returns the values that range from 300 to 600.</source>
          <target state="translated">Chiama quindi il <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> (metodo) con un'espressione lambda che restituisce i valori di intervallo compreso tra 300 su 600.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Note that the lambda expression is passed a parameter named <ph id="ph1">`x`</ph>;  this represents the individual array member that is passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Si noti che l'espressione lambda viene passata un parametro denominato <ph id="ph1">`x`</ph>;  rappresenta il membro di matrice singoli che viene passato per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Also note that the local <ph id="ph1">`lBound`</ph> and <ph id="ph2">`uBound`</ph> variables are accessible within the lambda expression.</source>
          <target state="translated">Si noti inoltre che locale <ph id="ph1">`lBound`</ph> e <ph id="ph2">`uBound`</ph> le variabili sono accessibili all'interno dell'espressione lambda.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> metodi generici.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato <ph id="ph1">`EndsWithSaurus`</ph>, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generic method traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> metodo generico consente di scorrere la matrice dall'inizio, passando a sua volta a ogni elemento di <ph id="ph2">`EndsWithSaurus`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element "Amargasaurus".</source>
          <target state="translated">La ricerca si interrompe quando il <ph id="ph1">`EndsWithSaurus`</ph> restituisce <ph id="ph2">`true`</ph> per l'elemento "Amargasaurus".</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# e Visual Basic, non è necessario creare il <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegato (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) in modo esplicito.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generic method is used to search the array backward from the end.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> metodo generico utilizzato per la ricerca della matrice con le versioni precedenti dalla fine.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>It finds the element "Dilophosaurus" at position 5.</source>
          <target state="translated">Trova l'elemento "Dilophosaurus" nella posizione 5.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic method is used to return an array containing all the elements that end in "saurus".</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> metodo generico viene utilizzato per restituire una matrice contenente tutti gli elementi che terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The elements are displayed.</source>
          <target state="translated">Gli elementi vengono visualizzati.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">L'esempio di codice viene inoltre illustrato il <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> metodi generici.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Cerca un elemento che soddisfi le condizioni definite in un predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno di un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> o in parte di esso.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> che definisce le condizioni dell'elemento da cercare.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Cerca un elemento che corrisponda alle condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, se presente; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> avanti al primo elemento fino all'ultimo elemento, viene eseguita la ricerca.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> è un delegato a un metodo che restituisce <ph id="ph2">`true`</ph> se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Esempio di codice seguente illustra i tre overload del <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> metodo generico.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato <ph id="ph1">`EndsWithSaurus`</ph>, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo consente di scorrere la matrice dall'inizio, passando a sua volta a ogni elemento di <ph id="ph2">`EndsWithSaurus`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">La ricerca si interrompe quando il <ph id="ph1">`EndsWithSaurus`</ph> restituisce <ph id="ph2">`true`</ph> per l'elemento nella posizione 1.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# e Visual Basic, non è necessario creare il <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegato (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) in modo esplicito.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 2 e continuando fino alla fine della matrice.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Trova l'elemento in corrispondenza della posizione 5.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 2.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> che definisce le condizioni dell'elemento da cercare.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the specified index to the last element.</source>
          <target state="translated">Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> compreso tra l'indice specificato e l'ultimo elemento.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, se presente; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at the last element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene eseguita la ricerca in avanti a partire da <ph id="ph2">`startIndex`</ph> e termina con l'ultimo elemento.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> è un delegato a un metodo che restituisce <ph id="ph2">`true`</ph> se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il numero di elementi da <ph id="ph3">`startIndex`</ph> alla fine di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Esempio di codice seguente illustra i tre overload del <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> metodo generico.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato <ph id="ph1">`EndsWithSaurus`</ph>, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo consente di scorrere la matrice dall'inizio, passando a sua volta a ogni elemento di <ph id="ph2">`EndsWithSaurus`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">La ricerca si interrompe quando il <ph id="ph1">`EndsWithSaurus`</ph> restituisce <ph id="ph2">`true`</ph> per l'elemento nella posizione 1.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# e Visual Basic, non è necessario creare il <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegato (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) in modo esplicito.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 2 e continuando fino alla fine della matrice.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Trova l'elemento in corrispondenza della posizione 5.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 2.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Numero di elementi nella sezione in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> che definisce le condizioni dell'elemento da cercare.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
          <target state="translated">Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero della prima occorrenza all'interno dell'intervallo di elementi nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che inizia dall'indice specificato e contiene il numero indicato di elementi.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Indice in base zero della prima occorrenza di un elemento che corrisponde alle condizioni definite da <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, se presente; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene eseguita la ricerca in avanti a partire da <ph id="ph2">`startIndex`</ph> e fine <ph id="ph3">`startIndex`</ph> più <ph id="ph4">`count`</ph> -1, se <ph id="ph5">`count`</ph> è maggiore di 0.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> è un delegato a un metodo che restituisce <ph id="ph2">`true`</ph> se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Esempio di codice seguente illustra i tre overload del <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> metodo generico.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato <ph id="ph1">`EndsWithSaurus`</ph>, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo consente di scorrere la matrice dall'inizio, passando a sua volta a ogni elemento di <ph id="ph2">`EndsWithSaurus`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">La ricerca si interrompe quando il <ph id="ph1">`EndsWithSaurus`</ph> restituisce <ph id="ph2">`true`</ph> per l'elemento nella posizione 1.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# e Visual Basic, non è necessario creare il <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegato (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) in modo esplicito.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 2 e continuando fino alla fine della matrice.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Trova l'elemento in corrispondenza della posizione 5.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 2.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non specificano una sezione valida in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> che definisce le condizioni dell'elemento da cercare.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Cerca un elemento che soddisfi le condizioni definite nel predicato specificato e restituisce l'ultima occorrenza all'interno dell'intero oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Ultimo elemento che soddisfa le condizioni definite dal predicato specificato, se trovato; in caso contrario, viene restituito il valore predefinito del tipo <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> è un delegato a un metodo che restituisce <ph id="ph2">`true`</ph> se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, moving backward in the <ph id="ph3">&lt;xref:System.Array&gt;</ph>, starting with the last element and ending with the first element.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, lo spostamento indietro nel <ph id="ph3">&lt;xref:System.Array&gt;</ph>, a partire dall'ultimo elemento e terminando con il primo elemento.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">L'elaborazione viene arrestata quando viene trovata una corrispondenza.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> metodi generici.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato <ph id="ph1">`EndsWithSaurus`</ph>, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generic method traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> metodo generico consente di scorrere la matrice dall'inizio, passando a sua volta a ogni elemento di <ph id="ph2">`EndsWithSaurus`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element "Amargasaurus".</source>
          <target state="translated">La ricerca si interrompe quando il <ph id="ph1">`EndsWithSaurus`</ph> restituisce <ph id="ph2">`true`</ph> per l'elemento "Amargasaurus".</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the<ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# e Visual Basic, non è necessario creare il<ph id="ph1">`Predicate&lt;string&gt;`</ph> delegato (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) in modo esplicito.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generic method is used to search the array backward from the end.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> metodo generico utilizzato per la ricerca della matrice con le versioni precedenti dalla fine.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>It finds the element "Dilophosaurus" at position 5.</source>
          <target state="translated">Trova l'elemento "Dilophosaurus" nella posizione 5.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic method is used to return an array containing all the elements that end in "saurus".</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> metodo generico viene utilizzato per restituire una matrice contenente tutti gli elementi che terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The elements are displayed.</source>
          <target state="translated">Gli elementi vengono visualizzati.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">L'esempio di codice viene inoltre illustrato il <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> metodi generici.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Cerca un elemento che soddisfi le condizioni definite in un predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno di un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> o in parte di esso.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> che definisce le condizioni dell'elemento da cercare.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intero oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, se presente; in caso contrario, –1.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> è un delegato a un metodo che restituisce <ph id="ph2">`true`</ph> se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Esempio di codice seguente illustra i tre overload del <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> metodo generico.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato <ph id="ph1">`EndsWithSaurus`</ph>, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo consente di scorrere la matrice con le versioni precedenti alla fine, passando a sua volta a ogni elemento di <ph id="ph2">`EndsWithSaurus`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">La ricerca si interrompe quando il <ph id="ph1">`EndsWithSaurus`</ph> restituisce <ph id="ph2">`true`</ph> per l'elemento in corrispondenza della posizione 5.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# e Visual Basic, non è necessario creare il <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegato (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) in modo esplicito.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 4, continuando all'indietro fino all'inizio della matrice.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Trova l'elemento nella posizione 1.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 4 e procedendo a ritroso (vale a dire, 2, 3 e 4).</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca all'indietro.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> che definisce le condizioni dell'elemento da cercare.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi in <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> compreso tra il primo elemento e l'indice specificato.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, se presente; in caso contrario, –1.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene eseguita con le versioni precedenti a partire dall'indice <ph id="ph2">`startIndex`</ph> e termina in corrispondenza del primo elemento.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> è un delegato a un metodo che restituisce <ph id="ph2">`true`</ph> se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il numero di elementi dall'inizio del <ph id="ph3">`array`</ph> a <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Esempio di codice seguente illustra i tre overload del <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> metodo generico.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato <ph id="ph1">`EndsWithSaurus`</ph>, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo consente di scorrere la matrice con le versioni precedenti alla fine, passando a sua volta a ogni elemento di <ph id="ph2">`EndsWithSaurus`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">La ricerca si interrompe quando il <ph id="ph1">`EndsWithSaurus`</ph> restituisce <ph id="ph2">`true`</ph> per l'elemento in corrispondenza della posizione 5.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# e Visual Basic, non è necessario creare il <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegato (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) in modo esplicito.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 4, continuando all'indietro fino all'inizio della matrice.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Trova l'elemento nella posizione 1.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 4 e procedendo a ritroso (vale a dire, 2, 3 e 4).</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca all'indietro.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Numero di elementi nella sezione in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> che definisce le condizioni dell'elemento da cercare.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Cerca un elemento che soddisfi le condizioni definite dal predicato specificato e restituisce l'indice in base zero dell'ultima occorrenza all'interno dell'intervallo di elementi in <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che contiene il numero indicato di elementi e termina in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Indice in base zero dell'ultima occorrenza di un elemento che corrisponde alle condizioni definite in <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, se presente; in caso contrario, –1.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene eseguita con le versioni precedenti a partire dall'indice <ph id="ph2">`startIndex`</ph> e fine <ph id="ph3">`startIndex`</ph> meno <ph id="ph4">`count`</ph> + 1, se <ph id="ph5">`count`</ph> è maggiore di 0.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> è un delegato a un metodo che restituisce <ph id="ph2">`true`</ph> se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Esempio di codice seguente illustra i tre overload del <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> metodo generico.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Viene creata una matrice di stringhe contenente 8 dinosauro, due dei quali (in corrispondenza delle posizioni 1 e 5) terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">L'esempio di codice definisce anche un metodo di predicato di ricerca denominato <ph id="ph1">`EndsWithSaurus`</ph>, che accetta un parametro di stringa e restituisce un valore booleano che indica se la stringa di input termina con "saurus".</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo consente di scorrere la matrice con le versioni precedenti alla fine, passando a sua volta a ogni elemento di <ph id="ph2">`EndsWithSaurus`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">La ricerca si interrompe quando il <ph id="ph1">`EndsWithSaurus`</ph> restituisce <ph id="ph2">`true`</ph> per l'elemento in corrispondenza della posizione 5.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# e Visual Basic, non è necessario creare il <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegato (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) in modo esplicito.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca di matrice a partire dalla posizione 4, continuando all'indietro fino all'inizio della matrice.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Trova l'elemento nella posizione 1.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> overload del metodo utilizzato per la ricerca dell'intervallo di tre elementi a partire dalla posizione 4 e procedendo a ritroso (vale a dire, 2, 3 e 4).</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Restituisce -1 poiché non sono presenti nomi di dinosauro compreso nell'intervallo che terminano con "saurus".</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non specificano una sezione valida in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> on whose elements the action is to be performed.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale e in base zero sui cui elementi si desidera eseguire l'azione.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph> to perform on each element of <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph> da eseguire su ogni elemento di <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>Performs the specified action on each element of the specified array.</source>
          <target state="translated">Esegue l'azione specificata su ciascun elemento della matrice indicata.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> is a delegate to a method that performs an action on the object passed to it.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> un delegato a un metodo che esegue un'azione per l'oggetto passato.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Action%601&gt;</ph>.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Action%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The following example shows how to use <ph id="ph1">&lt;xref:System.Array.ForEach%2A&gt;</ph> to display the squares of each element in an integer array.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare <ph id="ph1">&lt;xref:System.Array.ForEach%2A&gt;</ph> per visualizzare i quadrati di ogni elemento in una matrice di interi.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source><ph id="ph1">&lt;paramref name="action" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Array.GetEnumerator">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Restituisce <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> per <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Array.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> per l'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, c#]</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">Il <ph id="ph1">`foreach`</ph> istruzione del linguaggio c# (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) nasconde la complessità degli enumeratori.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Pertanto, si consiglia l'utilizzo di <ph id="ph1">`foreach`</ph>, anziché la modifica diretta dell'enumeratore.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">È possibile utilizzare enumeratori per leggere i dati nella raccolta, ma non per modificare la raccolta sottostante.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inizialmente l'enumeratore è posizionato davanti al primo elemento della raccolta.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated">Anche il metodo <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> riporta l'enumeratore in questa posizione.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">In questa posizione, la proprietà <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> è indefinita.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Pertanto, è necessario chiamare il metodo <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> per spostare in avanti l'enumeratore, in corrispondenza del primo elemento della raccolta, prima di leggere il valore di <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> restituisce lo stesso oggetto finché non viene chiamato il metodo <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> imposta <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> sull'elemento successivo.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> raggiunge la fine della raccolta, l'enumeratore è posizionato dopo l'ultimo elemento nella raccolta e <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> restituisce <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Quando l'enumeratore si trova in questa posizione, le chiamate successive a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> restituire anche <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Se l'ultima chiamata a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> restituito <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> è definito.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Per impostare nuovamente la proprietà <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> sul primo elemento della raccolta, è possibile chiamare il metodo <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> seguito da <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Un enumeratore rimane valido fino a quando la raccolta non subisce modifiche.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">In caso di modifiche alla raccolta, ad esempio aggiunta, modifica o eliminazione di elementi, l'enumeratore sarà reso non valido in modo irreversibile e il comportamento corrispondente non sarà definito.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">L'enumeratore non dispone di accesso esclusivo alla raccolta, pertanto il processo di enumerazione di una raccolta non è di per sé thread-safe.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Per assicurare la protezione del thread durante l'enumerazione, è possibile bloccare la raccolta durante l'intera enumerazione.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Per consentire l'accesso alla raccolta in lettura e scrittura da parte di più thread, è necessario implementare la propria sincronizzazione.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Array.GetEnumerator%2A&gt;</ph> to list the elements of an array.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come utilizzare <ph id="ph1">&lt;xref:System.Array.GetEnumerator%2A&gt;</ph> per elencare gli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>A zero-based dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> whose length needs to be determined.</source>
          <target state="translated">Dimensione con inizio zero di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> di cui è necessario determinare la lunghezza.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>Gets a 32-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene un valore intero a 32 bit che rappresenta il numero di elementi nella dimensione specificata di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>A 32-bit integer that represents the number of elements in the specified dimension.</source>
          <target state="translated">Intero a 32 bit che rappresenta il numero di elementi nella dimensione specificata.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> is <ph id="ph2">`GetLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Un esempio di <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> è <ph id="ph2">`GetLength(0)`</ph>, che restituisce il numero di elementi nella prima dimensione del <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>The following example shows how to use <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> to display the dimensions of two arrays with different ranks.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> per visualizzare le dimensioni di due matrici con intervalli diversi.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> è uguale a o maggiore di <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>A zero-based dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> whose length needs to be determined.</source>
          <target state="translated">Dimensione con inizio zero di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> di cui è necessario determinare la lunghezza.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>Gets a 64-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene un integer a 64 bit che rappresenta il numero di elementi nella dimensione specificata di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>A 64-bit integer that represents the number of elements in the specified dimension.</source>
          <target state="translated">Intero a 64 bit che rappresenta il numero di elementi nella dimensione specificata.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> is <ph id="ph2">`GetLongLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Un esempio di <ph id="ph1">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> è <ph id="ph2">`GetLongLength(0)`</ph>, che restituisce il numero di elementi nella prima dimensione del <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> è uguale a o maggiore di <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>A zero-based dimension of the array whose starting index needs to be determined.</source>
          <target state="translated">Dimensione in base zero della matrice di cui è necessario determinare l'indice iniziale.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Gets the index of the first element of the specified dimension in the array.</source>
          <target state="translated">Ottiene l'indice del primo elemento della dimensione specificata nella matrice.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The index of the first element of the specified dimension in the array.</source>
          <target state="translated">Indice del primo elemento della dimensione specificata nella matrice.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">`GetLowerBound(0)`</ph> returns the starting index of the first dimension of the array, and <ph id="ph2">`GetLowerBound(Rank - 1)`</ph> returns the starting index of the last dimension of the array.</source>
          <target state="translated"><ph id="ph1">`GetLowerBound(0)`</ph> Restituisce l'indice inizia della prima dimensione della matrice e <ph id="ph2">`GetLowerBound(Rank - 1)`</ph> restituisce l'indice inizia dell'ultima dimensione della matrice.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> metodo restituisce sempre un valore che indica l'indice del limite inferiore della finestra della matrice, anche se la matrice è vuota.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Note that, although most arrays in the .NET Framework are zero-based (that is, the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based.</source>
          <target state="translated">Si noti che, sebbene la maggior parte delle matrici in .NET Framework sono in base zero (ovvero, il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> metodo restituisce zero per ciascuna dimensione della matrice), .NET Framework supporta le matrici che non sono in base zero.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Such arrays can be created with the <ph id="ph1">&lt;xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29&gt;</ph> method, and can also be returned from unmanaged code.</source>
          <target state="translated">Tali matrici possono essere creati con il <ph id="ph1">&lt;xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29&gt;</ph> (metodo) e possono essere restituiti dal codice non gestito.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi per visualizzare i limiti di una matrice unidimensionale e bidimensionale e visualizzare i valori dei relativi elementi di matrice.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> è uguale a o maggiore di <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>A zero-based dimension of the array whose upper bound needs to be determined.</source>
          <target state="translated">Dimensione in base zero della matrice di cui è necessario determinare il limite superiore.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>Gets the index of the last element of the specified dimension in the array.</source>
          <target state="translated">Ottiene l'indice dell'ultimo elemento della dimensione specificata nella matrice.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty.</source>
          <target state="translated">Indice dell'ultimo elemento della dimensione specificata nella matrice oppure -1 se la dimensione specificata è vuota.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">`GetUpperBound(0)`</ph> returns the last index in the first dimension of the array, and <ph id="ph2">`GetUpperBound(Rank - 1)`</ph> returns the last index of the last dimension of the array.</source>
          <target state="translated"><ph id="ph1">`GetUpperBound(0)`</ph> Restituisce l'ultimo indice della prima dimensione della matrice e <ph id="ph2">`GetUpperBound(Rank - 1)`</ph> restituisce l'ultimo indice dell'ultima dimensione della matrice.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi per visualizzare i limiti di una matrice unidimensionale e bidimensionale e visualizzare i valori dei relativi elementi di matrice.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> è uguale a o maggiore di <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Gets the value of the specified element in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il valore dell'elemento specificato nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta la posizione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">L'indice viene specificato come intero a 32 bit.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> i metodi possono determinare se il valore di <ph id="ph3">`index`</ph> è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente una dimensione.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> non è compreso nell'intervallo di indici validi per l'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Matrice unidimensionale di valori interi a 32 bit che rappresentano gli indici che specificano la posizione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The indexes are specified as an array of 32-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come una matrice di interi a 32 bit.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Il numero di elementi in <ph id="ph1">`indices`</ph> sia uguale al numero di dimensioni di <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Tutti gli elementi di <ph id="ph1">`indices`</ph> matrice deve specificare collettivamente la posizione dell'elemento desiderato nell'oggetto multidimensionale <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Il numero di dimensioni nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non è uguale al numero di elementi in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ogni elemento in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Integer a 64 bit che rappresenta la posizione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">L'indice viene specificato come intero a 64 bit.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> i metodi possono determinare se il valore di <ph id="ph3">`index`</ph> è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente una dimensione.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> non è compreso nell'intervallo di indici validi per l'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Matrice unidimensionale di integer a 64 bit che rappresentano gli indici che specificano la posizione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The indexes are specified as an array of 64-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come una matrice di interi a 64 bit.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Il numero di elementi in <ph id="ph1">`indices`</ph> sia uguale al numero di dimensioni di <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Tutti gli elementi di <ph id="ph1">`indices`</ph> matrice deve specificare collettivamente la posizione dell'elemento desiderato nell'oggetto multidimensionale <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Il numero di dimensioni nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non è uguale al numero di elementi in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ogni elemento in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> bidimensionale.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come interi a 32 bit.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> bidimensionale.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente due dimensioni.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> bidimensionale.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come interi a 64 bit.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> bidimensionale.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente due dimensioni.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta l'indice della terza dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> tridimensionale.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come interi a 32 bit.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> tridimensionale.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente tre dimensioni.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> o <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice della terza dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da ottenere.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> tridimensionale.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come interi a 64 bit.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> tridimensionale.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente tre dimensioni.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> o <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array or in a range of elements in the array.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in una matrice unidimensionale o in un intervallo di elementi nella matrice.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Matrice unidimensionale da cercare.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice della prima ricorrenza all'interno di una matrice unidimensionale.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indice della prima occorrenza di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, se presente; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This method searches all the elements of a one-dimensional arrayfor <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Questo metodo cerca tutti gli elementi di un oggetto unidimensionale arrayfor <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling each element's <ph id="ph3">`Equals`</ph> method until it finds a match.</source>
          <target state="translated">Per determinare se <ph id="ph1">`value`</ph> esiste <ph id="ph2">`array`</ph>, il metodo esegue un confronto di uguaglianza chiamando ogni elemento <ph id="ph3">`Equals`</ph> metodo fino a quando non viene trovata una corrispondenza.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Ciò significa che se l'elemento esegue l'override di <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> , tale sostituzione viene chiamato.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if<ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Poiché la maggior parte delle matrici hanno un limite inferiore pari a zero, questo metodo in genere restituisce – 1 se<ph id="ph1">`value`</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">Nel raro caso in cui il limite inferiore della matrice è uguale a <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) e <ph id="ph2">`value`</ph> non viene trovato, questo metodo restituisce <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">Nell'esempio viene chiamato tre overload del seguenti il <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metodo per trovare l'indice di una stringa in una matrice di stringhe:</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, per determinare la prima occorrenza della stringa "the" in una matrice di stringhe.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, per determinare la prima occorrenza della stringa "the" per la quarta agli ultimi elementi di una matrice di stringhe.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, per determinare la prima occorrenza della stringa "the" in una stringa di matrice dall'elemento che segue l'ultima corrispondenza corretta alla fine della matrice.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Matrice unidimensionale da cercare.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The starting index of the search.</source>
          <target state="translated">Indice iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zero) è valido in una matrice vuota.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The range extends from a specified index to the end of the array.</source>
          <target state="translated">L'intervallo si estende da un indice specificato fino alla fine della matrice.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if it’s found, within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indice della prima occorrenza di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, se trovato, all'interno degli elementi nell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> che si estende da <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> fino all'ultimo elemento; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This method searches a one-dimensional array from the element at index <ph id="ph1">`startIndex`</ph> to the last element.</source>
          <target state="translated">Questo metodo cerca in una matrice unidimensionale dall'elemento in corrispondenza dell'indice <ph id="ph1">`startIndex`</ph> all'ultimo elemento.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
          <target state="translated">Per determinare se <ph id="ph1">`value`</ph> esiste <ph id="ph2">`array`</ph>, il metodo esegue un confronto di uguaglianza chiamando il <ph id="ph3">`Equals`</ph> metodo di ogni elemento fino a quando non viene trovata una corrispondenza.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Ciò significa che se l'elemento esegue l'override di <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> , tale sostituzione viene chiamato.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if <ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Poiché la maggior parte delle matrici hanno un limite inferiore pari a zero, questo metodo in genere restituisce – 1 se <ph id="ph1">`value`</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">Nel raro caso in cui il limite inferiore della matrice è uguale a <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) e <ph id="ph2">`value`</ph> non viene trovato, questo metodo restituisce <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>,the method returns -1.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è uguale a <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, il metodo restituisce -1.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è maggiore di <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, il metodo genera un <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il numero di elementi da <ph id="ph3">`startIndex`</ph> alla fine di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">Nell'esempio viene chiamato tre overload del seguenti il <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metodo per trovare l'indice di una stringa in una matrice di stringhe:</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, per determinare la prima occorrenza della stringa "the" in una matrice di stringhe.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, per determinare la prima occorrenza della stringa "the" per la quarta agli ultimi elementi di una matrice di stringhe.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, per determinare la prima occorrenza della stringa "the" in una stringa di matrice dall'elemento che segue l'ultima corrispondenza corretta alla fine della matrice.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Matrice unidimensionale da cercare.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The starting index of the search.</source>
          <target state="translated">Indice iniziale della ricerca.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zero) è valido in una matrice vuota.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The number of elements to search.</source>
          <target state="translated">Numero di elementi in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The range extends from a specified index for a specified number of elements.</source>
          <target state="translated">L'intervallo si estende da un indice specificato per un numero specificato di elementi.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if it’s found in the <ph id="ph2">&lt;paramref name="array" /&gt;</ph> from index <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph5"> + </ph><ph id="ph6">&lt;paramref name="count" /&gt;</ph> - 1; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indice della prima occorrenza di <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, se trovato, nell'oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph> dall'indice <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> a <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph5"> + </ph><ph id="ph6">&lt;paramref name="count" /&gt;</ph> - 1; in caso contrario verrà restituito il limite inferiore della matrice meno 1.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method searches the elements of a one-dimensional arrayfrom <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
          <target state="translated">Questo metodo cerca gli elementi di un oggetto unidimensionale arrayfrom <ph id="ph1">`startIndex`</ph> a <ph id="ph2">`startIndex`</ph> più <ph id="ph3">`count`</ph> -1, se <ph id="ph4">`count`</ph> è maggiore di 0.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
          <target state="translated">Per determinare se <ph id="ph1">`value`</ph> esiste <ph id="ph2">`array`</ph>, il metodo esegue un confronto di uguaglianza chiamando il <ph id="ph3">`Equals`</ph> metodo di ogni elemento fino a quando non viene trovata una corrispondenza.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Ciò significa che se l'elemento esegue l'override di <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> , tale sostituzione viene chiamato.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Becausemost arrays have a lower bound of zero, this method generally returns –1 when <ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Le matrici Becausemost hanno un limite inferiore pari a zero, in genere, questo metodo restituisce-1 se <ph id="ph1">`value`</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> (0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">Nel raro caso in cui il limite inferiore della matrice è uguale a <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> (0x80000000) e <ph id="ph2">`value`</ph> non viene trovato, questo metodo restituisce <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startindex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method returns -1.</source>
          <target state="translated">Se <ph id="ph1">`startindex`</ph> è uguale a <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, il metodo restituisce -1.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è maggiore di <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, il metodo genera un <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">Nell'esempio viene chiamato tre overload del seguenti il <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metodo per trovare l'indice di una stringa in una matrice di stringhe:</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, per determinare la prima occorrenza della stringa "the" in una matrice di stringhe.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, per determinare la prima occorrenza della stringa "the" per la quarta agli ultimi elementi di una matrice di stringhe.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, per determinare la prima occorrenza della stringa "the" in una stringa di matrice dall'elemento che segue l'ultima corrispondenza corretta alla fine della matrice.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>To determine the value of the <ph id="ph1">`count`</ph> argument, it subtracts the upper bound of the array from the starting index and adds one.</source>
          <target state="translated">Per determinare il valore del <ph id="ph1">`count`</ph> argomento, sottrae il limite superiore della matrice dall'indice inizia e viene aggiunto uno.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non specificano una sezione valida in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Matrice unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice della prima ricorrenza all'interno di una matrice unidimensionale.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Indice in base zero della prima occorrenza di <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intero oggetto <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, se presente; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This method searches all the elements of a one-dimensional array for <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Questo metodo cerca tutti gli elementi di una matrice unidimensionale di <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Per determinare se <ph id="ph1">`value`</ph> esiste <ph id="ph2">`array`</ph>, il metodo esegue un confronto di uguaglianza chiamando il <ph id="ph3">`T.Equals`</ph> metodo su ogni elemento.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Questo significa che se <ph id="ph1">`T`</ph> esegue l'override di <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> , tale sostituzione viene chiamato.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">L'esempio seguente illustra i tre overload generico del <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> overload del metodo cerca nella matrice dall'inizio e trova la prima occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca nella matrice a partire dalla posizione dell'indice 3 e continuando fino alla fine della matrice e trova la seconda occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 poiché non siano presenti istanze della stringa di ricerca in tale intervallo.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Matrice unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zero) è valido in una matrice vuota.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The range extends from a specified index to the end of the array.</source>
          <target state="translated">L'intervallo si estende da un indice specificato fino alla fine della matrice.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element, if found; otherwise, –1.</source>
          <target state="translated">Indice in base zero della prima occorrenza del valore indicato nel parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intervallo di elementi della matrice <ph id="ph2">&lt;paramref name="array" /&gt;</ph> compreso tra l'indice <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> e l'ultimo elemento, se trovato; in caso contrario, –1.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This method searches a one-dimensional array from the element at <ph id="ph1">`startIndex`</ph> to the end of the array.</source>
          <target state="translated">Questo metodo cerca in una matrice unidimensionale rispetto all'elemento <ph id="ph1">`startIndex`</ph> alla fine della matrice.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Per determinare se <ph id="ph1">`value`</ph> esiste <ph id="ph2">`array`</ph>, il metodo esegue un confronto di uguaglianza chiamando il <ph id="ph3">`T.Equals`</ph> metodo su ogni elemento.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Questo significa che se <ph id="ph1">`T`</ph> esegue l'override di <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> , tale sostituzione viene chiamato.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph>,the method returns -1.If <ph id="ph3">`startIndex`</ph> is greater than <ph id="ph4">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph5">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è uguale a <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph>, il metodo restituisce - 1.If <ph id="ph3">`startIndex`</ph> è maggiore di <ph id="ph4">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, il metodo genera un <ph id="ph5">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il numero di elementi da <ph id="ph3">`startIndex`</ph> alla fine di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">L'esempio seguente illustra i tre overload generico del <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> overload del metodo cerca nella matrice dall'inizio e trova la prima occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca nella matrice a partire dalla posizione dell'indice 3 e continuando fino alla fine della matrice e trova la seconda occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 poiché non siano presenti istanze della stringa di ricerca in tale intervallo.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Matrice unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zero) è valido in una matrice vuota.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Numero di elementi nella sezione in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice della prima occorrenza in un intervallo di elementi di una matrice unidimensionale.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The range extends from a specified index for a specified number of elements.</source>
          <target state="translated">L'intervallo si estende da un indice specificato per un numero specificato di elementi.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that starts at <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and contains the number of elements specified in <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Indice in base zero della prima occorrenza del valore indicato nel parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intervallo di elementi della matrice <ph id="ph2">&lt;paramref name="array" /&gt;</ph> che inizia dall'indice <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> e contiene il numero di elementi specificato nel parametro <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, se trovato; in caso contrario, –1.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method searchesthe elements of a one-dimensional array from <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
          <target state="translated">Questo metodo ricercheI elementi di una matrice unidimensionale da <ph id="ph1">`startIndex`</ph> a <ph id="ph2">`startIndex`</ph> più <ph id="ph3">`count`</ph> -1, se <ph id="ph4">`count`</ph> è maggiore di 0.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Per determinare se <ph id="ph1">`value`</ph> esiste <ph id="ph2">`array`</ph>, il metodo esegue un confronto di uguaglianza chiamando il <ph id="ph3">`T.Equals`</ph> metodo su ogni elemento.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Questo significa che se <ph id="ph1">`T`</ph> esegue l'override di <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> , tale sostituzione viene chiamato.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method returns -1.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è uguale a <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, il metodo restituisce -1.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`startIndex`</ph> è maggiore di <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, il metodo genera un <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">L'esempio seguente illustra i tre overload generico del <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> overload del metodo cerca nella matrice dall'inizio e trova la prima occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca nella matrice a partire dalla posizione dell'indice 3 e continuando fino alla fine della matrice e trova la seconda occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca di un intervallo di due voci, a partire dalla posizione di indice due; restituisce -1 poiché non siano presenti istanze della stringa di ricerca in tale intervallo.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non specificano una sezione valida in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Array.Initialize">
          <source>Initializes every element of the value-type <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> by calling the default constructor of the value type.</source>
          <target state="translated">Inizializza ogni elemento del tipo valore <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> tramite chiamate al costruttore predefinito del tipo valore.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>This method is designed to help compilers support value-type arrays; most users do not need this method.</source>
          <target state="translated">Questo metodo è progettato per supportare le matrici di tipi di valore, compilatori Questo metodo non è necessario maggior parte degli utenti.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>It must not be used on reference-type arrays.</source>
          <target state="translated">Non deve essere utilizzato su matrici di tipi di riferimento.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not a value-type <ph id="ph2">&lt;xref:System.Array&gt;</ph> or if the value type does not have a default constructor, the <ph id="ph3">&lt;xref:System.Array&gt;</ph> is not modified.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Array&gt;</ph> non è un tipo di valore <ph id="ph2">&lt;xref:System.Array&gt;</ph> o se il tipo di valore non ha un costruttore predefinito, il <ph id="ph3">&lt;xref:System.Array&gt;</ph> non viene modificato.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>The value-type <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound and any number of dimensions.</source>
          <target state="translated">Il tipo di valore <ph id="ph1">&lt;xref:System.Array&gt;</ph> può avere un limite inferiore e qualsiasi numero di dimensioni.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</source>
          <target state="translated">È possibile utilizzare questo metodo solo su tipi di valore hanno costruttori; Tuttavia, i tipi di valore native in c# non dispone di costruttori.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="P:System.Array.IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Ottiene un valore che indica se <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ha dimensioni fisse.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>This property is always <ph id="ph1">&lt;see langword="true" /&gt;</ph> for all arrays.</source>
          <target state="translated">Questa proprietà è sempre <ph id="ph1">&lt;see langword="true" /&gt;</ph> per tutte le matrici.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implementa il <ph id="ph2">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> proprietà perché è necessaria per il <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>An array with a fixed size does not allow the addition or removal of elements after the array is created, but it allows the modification of existing elements.</source>
          <target state="translated">Una matrice con dimensioni fisse non consente l'aggiunta o la rimozione di elementi dopo la creazione della matrice, ma consente la modifica degli elementi esistenti.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="P:System.Array.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is read-only.</source>
          <target state="translated">Ottiene un valore che indica se <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph> for all arrays.</source>
          <target state="translated">Questa proprietà è sempre <ph id="ph1">&lt;see langword="false" /&gt;</ph> per tutte le matrici.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsReadOnly%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implementa il <ph id="ph2">&lt;xref:System.Array.IsReadOnly%2A&gt;</ph> proprietà perché è necessaria per il <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</source>
          <target state="translated">Matrice che è di sola lettura non consente l'aggiunta, rimozione o modifica di elementi dopo la creazione della matrice.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>If you require a read-only collection, use a <ph id="ph1">&lt;xref:System.Collections&gt;</ph> class that implements the <ph id="ph2">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Se è necessaria una raccolta di sola lettura, utilizzare un <ph id="ph1">&lt;xref:System.Collections&gt;</ph> classe che implementa il <ph id="ph2">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>If you cast or convert an array to an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface object, the <ph id="ph2">&lt;xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType&gt;</ph> property returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Se si esegue il cast dell'o convertire una matrice a un <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> oggetto dell'interfaccia, il <ph id="ph2">&lt;xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType&gt;</ph> restituisce proprietà <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>However, if you cast or convert an array to a <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> interface, the <ph id="ph2">`IsReadOnly`</ph> property returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Tuttavia, se si esegue il cast dell'o convertire una matrice a un <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> interfaccia, il <ph id="ph2">`IsReadOnly`</ph> restituisce proprietà <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="P:System.Array.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Ottiene un valore che indica se l'accesso a <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> è sincronizzato (thread-safe).</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph> for all arrays.</source>
          <target state="translated">Questa proprietà è sempre <ph id="ph1">&lt;see langword="false" /&gt;</ph> per tutte le matrici.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsSynchronized%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implementa il <ph id="ph2">&lt;xref:System.Array.IsSynchronized%2A&gt;</ph> proprietà perché è necessaria per il <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Classi di .NET framework basate su <ph id="ph1">&lt;xref:System.Array&gt;</ph> fornire una propria versione sincronizzata della raccolta mediante la <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Le classi che utilizzano matrici anche possono implementare la propria sincronizzazione utilizzando il <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
          <target state="translated">Il codice di sincronizzazione è necessario eseguire operazioni sul <ph id="ph1">`SyncRoot`</ph> della raccolta, non direttamente sulla raccolta.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
          <target state="translated">In particolare, mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente l'insieme.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
          <target state="translated">Si noti che alcune implementazioni di <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> potrebbe restituire il <ph id="ph2">&lt;xref:System.Array&gt;</ph> stesso.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">L'enumerazione di una raccolta non è quindi una procedura thread-safe.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>The following code example shows how to lock an array during the entire enumeration by using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come bloccare la matrice durante l'intera enumerazione tramite il <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Returns the index of the last occurrence of a value in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or in a portion of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Restituisce l'indice della prima ricorrenza di un valore in un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale o in una parte di <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale di cui effettuare la ricerca.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice dell'ultima ricorrenza all'interno dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale intero.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indice dell'ultima occorrenza del valore indicato nel parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intera matrice <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, se trovato; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">Oggetto unidimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli elementi vengono confrontati con il valore specificato utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il <ph id="ph1">`Equals`</ph> viene utilizzata l'implementazione di tale tipo.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Poiché la maggior parte delle matrici dispone di un limite inferiore pari a zero, questo metodo in genere restituirà-1 se <ph id="ph1">`value`</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">Nel raro caso in cui il limite inferiore della matrice è uguale a <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">`value`</ph> non viene trovato, questo metodo restituisce <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, ovvero <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">In .NET Framework versione 2.0, questo metodo Usa il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi del <ph id="ph3">&lt;xref:System.Array&gt;</ph> per determinare se il <ph id="ph4">&lt;xref:System.Object&gt;</ph> specificato da di <ph id="ph5">`value`</ph> esiste un parametro.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi il <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> stesso.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph2">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi di <ph id="ph2">`item`</ph> parametro per gli oggetti nella raccolta.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato in una matrice.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale di cui effettuare la ricerca.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The starting index of the backward search.</source>
          <target state="translated">Indice iniziale della ricerca all'indietro.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale compreso tra il primo elemento e l'indice specificato.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indice della prima occorrenza del valore indicato nel parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intervallo di elementi della matrice <ph id="ph2">&lt;paramref name="array" /&gt;</ph> compreso tra il primo elemento e l'indice <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, se trovato; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">Oggetto unidimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene eseguita con le versioni precedenti a partire dall'indice <ph id="ph2">`startIndex`</ph> e termina in corrispondenza del primo elemento.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli elementi vengono confrontati con il valore specificato utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il <ph id="ph1">`Equals`</ph> viene utilizzata l'implementazione di tale tipo.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Poiché la maggior parte delle matrici dispone di un limite inferiore pari a zero, questo metodo in genere restituirà-1 se <ph id="ph1">`value`</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">Nel raro caso in cui il limite inferiore della matrice è uguale a <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">`value`</ph> non viene trovato, questo metodo restituisce <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, ovvero <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il numero di elementi dall'inizio del <ph id="ph3">`array`</ph> a <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">In .NET Framework versione 2.0, questo metodo Usa il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi del <ph id="ph3">&lt;xref:System.Array&gt;</ph> per determinare se il <ph id="ph4">&lt;xref:System.Object&gt;</ph> specificato da di <ph id="ph5">`value`</ph> esiste un parametro.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi il <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> stesso.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato in una matrice.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale di cui effettuare la ricerca.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The starting index of the backward search.</source>
          <target state="translated">Indice iniziale della ricerca all'indietro.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Numero di elementi nella sezione in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che contiene il numero specificato di elementi e termina in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that contains the number of elements specified in <ph id="ph3">&lt;paramref name="count" /&gt;</ph> and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indice dell'ultima occorrenza del valore indicato nel parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intervallo di elementi della matrice <ph id="ph2">&lt;paramref name="array" /&gt;</ph> che contiene il numero di elementi specificato nel parametro <ph id="ph3">&lt;paramref name="count" /&gt;</ph> e termina in corrispondenza dell'indice <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, se trovato; in caso contrario, verrà restituito il limite inferiore della matrice meno 1.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Oggetto unidimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene eseguita con le versioni precedenti a partire dall'indice <ph id="ph2">`startIndex`</ph> e fine <ph id="ph3">`startIndex`</ph> meno <ph id="ph4">`count`</ph> + 1, se <ph id="ph5">`count`</ph> è maggiore di 0.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli elementi vengono confrontati con il valore specificato utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the<ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il<ph id="ph1">`Equals`</ph> viene utilizzata l'implementazione di tale tipo.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Poiché la maggior parte delle matrici dispone di un limite inferiore pari a zero, questo metodo in genere restituirà-1 se <ph id="ph1">`value`</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">Nel raro caso in cui il limite inferiore della matrice è uguale a <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">`value`</ph> non viene trovato, questo metodo restituisce <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, ovvero <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">In .NET Framework versione 2.0, questo metodo Usa il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi del <ph id="ph3">&lt;xref:System.Array&gt;</ph> per determinare se il <ph id="ph4">&lt;xref:System.Object&gt;</ph> specificato da di <ph id="ph5">`value`</ph> esiste un parametro.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">Nelle versioni precedenti di .NET Framework, questa operazione è stata effettuata utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metodi il <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> stesso.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come determinare l'indice dell'ultima occorrenza di un elemento specificato in una matrice.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method is a backward search; therefore, <ph id="ph2">`count`</ph> must be less than or equal to (<ph id="ph3">`startIndex`</ph> minus the lower bound of the array plus 1).</source>
          <target state="translated">Si noti che il <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> metodo è una ricerca con le versioni precedenti, pertanto, <ph id="ph2">`count`</ph> deve essere minore o uguale a (<ph id="ph3">`startIndex`</ph> meno il limite inferiore della matrice + 1).</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non specificano una sezione valida in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intera matrice <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Indice in base zero dell'ultima occorrenza del valore indicato nel parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intera matrice <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, se trovato; in caso contrario, –1.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene eseguita la ricerca all'indietro a partire dall'ultimo elemento e termina in corrispondenza del primo elemento.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli elementi vengono confrontati con il valore specificato utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il <ph id="ph1">`Equals`</ph> viene utilizzata l'implementazione di tale tipo.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Esempio di codice seguente illustra i tre overload generico del <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> overload del metodo cerca l'intera matrice dalla fine e trova la seconda occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca nella matrice con le versioni precedenti a partire dalla posizione dell'indice 3 e continuando fino all'inizio della matrice e trova la prima occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, viene eseguita la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1 perché non siano presenti istanze della ricerca stringa in tale intervallo.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca all'indietro.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> compreso tra il primo elemento e l'indice specificato.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Indice in base zero dell'ultima occorrenza del valore indicato nel parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intervallo di elementi della matrice <ph id="ph2">&lt;paramref name="array" /&gt;</ph> compreso tra il primo elemento e l'indice <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, se trovato; in caso contrario, –1.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene eseguita con le versioni precedenti a partire dall'indice <ph id="ph2">`startIndex`</ph> e termina in corrispondenza del primo elemento.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli elementi vengono confrontati con il valore specificato utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il <ph id="ph1">`Equals`</ph> viene utilizzata l'implementazione di tale tipo.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il numero di elementi dall'inizio del <ph id="ph3">`array`</ph> a <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Esempio di codice seguente illustra i tre overload generico del <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> overload del metodo cerca l'intera matrice dalla fine e trova la seconda occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca nella matrice con le versioni precedenti a partire dalla posizione dell'indice 3 e continuando fino all'inizio della matrice e trova la prima occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, viene eseguita la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1 perché non siano presenti istanze della ricerca stringa in tale intervallo.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto da individuare in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Indice iniziale in base zero della ricerca all'indietro.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Numero di elementi nella sezione in cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Cerca l'oggetto specificato e restituisce l'indice dell'ultima occorrenza all'interno dell'intervallo di elementi dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che contiene il numero specificato di elementi e termina in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that contains the number of elements specified in <ph id="ph3">&lt;paramref name="count" /&gt;</ph> and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Indice in base zero dell'ultima occorrenza del valore indicato nel parametro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> all'interno dell'intervallo di elementi della matrice <ph id="ph2">&lt;paramref name="array" /&gt;</ph> che contiene il numero di elementi specificato nel parametro <ph id="ph3">&lt;paramref name="count" /&gt;</ph> e termina in corrispondenza dell'indice <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, se trovato; in caso contrario, –1.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> viene eseguita con le versioni precedenti a partire dall'indice <ph id="ph2">`startIndex`</ph> e fine <ph id="ph3">`startIndex`</ph> meno <ph id="ph4">`count`</ph> + 1, se <ph id="ph5">`count`</ph> è maggiore di 0.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Gli elementi vengono confrontati con il valore specificato utilizzando il <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Se il tipo di elemento è un tipo non intrinseco (definito dall'utente), il <ph id="ph1">`Equals`</ph> viene utilizzata l'implementazione di tale tipo.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Esempio di codice seguente illustra i tre overload generico del <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Viene creata una matrice di stringhe, con una voce visualizzata due volte, una posizione di indice 0 e la posizione di indice 5.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> overload del metodo cerca l'intera matrice dalla fine e trova la seconda occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca nella matrice con le versioni precedenti a partire dalla posizione dell'indice 3 e continuando fino all'inizio della matrice e trova la prima occorrenza della stringa.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Infine, il <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload del metodo utilizzato per la ricerca di un intervallo di quattro voci, a partire dalla posizione di indice 4 e l'estensione all'indietro (vale a dire, viene eseguita la ricerca di elementi in posizioni 4, 3, 2 e 1); questa ricerca restituisce – 1 perché non siano presenti istanze della ricerca stringa in tale intervallo.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> non è compreso nell'intervallo di indici validi per <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> non specificano una sezione valida in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="P:System.Array.Length">
          <source>Gets the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il numero totale di elementi in tutte le dimensioni di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>The total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; zero if there are no elements in the array.</source>
          <target state="translated">Il numero totale di elementi in tutte le dimensioni del <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; zero se non sono presenti elementi nella matrice.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>The following example uses the                                 <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property to get the total number of elements in an array.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> proprietà per ottenere il numero totale di elementi in una matrice.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>It also uses the                                 <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> method to determine the number of elements in each dimension of a multidimensional array.</source>
          <target state="translated">Utilizza inoltre il <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodo per determinare il numero di elementi in ogni dimensione di una matrice multidimensionale.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="P:System.Array.Length">
          <source>The array is multidimensional and contains more than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> elements.</source>
          <target state="translated">La matrice è multidimensionale e contiene più di <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> elementi.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="P:System.Array.LongLength">
          <source>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene un integer a 64 bit che rappresenta il numero totale di elementi in tutte le dimensioni di <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.LongLength">
          <source>A 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Valore intero a 64 bit che rappresenta il numero totale di elementi in tutte le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.LongLength">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="P:System.Array.Rank">
          <source>Gets the rank (number of dimensions) of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il rango (numero di dimensioni) dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="P:System.Array.Rank">
          <source>For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on.</source>
          <target state="translated">Ad esempio, una matrice unidimensionale restituisce 1, una matrice bidimensionale restituisce 2 e così via.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>The rank (number of dimensions) of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Rango (numero di dimensioni) dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>For example, the Visual Basic code</source>
          <target state="translated">Ad esempio, il codice di Visual Basic</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>and the C# code</source>
          <target state="translated">e il codice c#</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>create an array of three dimensions with a <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property whose value is 3.</source>
          <target state="translated">creare una matrice di tre dimensioni con un <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> proprietà il cui valore è 3.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>A jagged array (an array of arrays) is a one-dimensional array; the value of its <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property is 1.</source>
          <target state="translated">Una matrice di matrici (una matrice di matrici) è una matrice unidimensionale; il valore della relativa <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> proprietà è 1.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>The following example initializes a one-dimensional array, a two-dimensional array, and a jagged array, and retrieves the <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property of each.</source>
          <target state="translated">Nell'esempio seguente consente di inizializzare una matrice unidimensionale, una matrice bidimensionale e una matrice di matrici e recupera il <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> proprietà di ogni.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The one-dimensional, zero-based array to resize, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> to create a new array with the specified size.</source>
          <target state="translated">Matrice in base zero unidimensionale da ridimensionare oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> per creare una nuova matrice della dimensione specificata.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The size of the new array.</source>
          <target state="translated">Dimensione della nuova matrice.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>Changes the number of elements of a one-dimensional array to the specified new size.</source>
          <target state="translated">Modifica il numero di elementi di una matrice unidimensionale in una nuova dimensione specificata.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>This method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one.</source>
          <target state="translated">Questo metodo consente di allocare una nuova matrice con la dimensione specificata, copia gli elementi dalla matrice precedente a quello nuovo e quindi sostituisce quella precedente con quello nuovo.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source><ph id="ph1">`array`</ph> must be a one-dimensional array.</source>
          <target state="translated"><ph id="ph1">`array`</ph> deve essere una matrice unidimensionale.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`array`</ph> is <ph id="ph2">`null`</ph>, this method creates a new array with the specified size.</source>
          <target state="translated">Se <ph id="ph1">`array`</ph> è <ph id="ph2">`null`</ph>, questo metodo crea una nuova matrice con la dimensione specificata.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is greater than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and all the elements are copied from the old array to the new one.</source>
          <target state="translated">Se <ph id="ph1">`newSize`</ph> è maggiore di <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> della matrice precedente viene allocata una nuova matrice e tutti gli elementi vengono copiati dalla matrice di precedente a quello nuovo.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is less than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and elements are copied from the old array to the new one until the new one is filled; the rest of the elements in the old array are ignored.</source>
          <target state="translated">Se <ph id="ph1">`newSize`</ph> è inferiore a quello di <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> della matrice precedente viene allocata una nuova matrice e gli elementi vengono copiati dalla matrice precedente a quello nuovo fino a quando non viene compilata una nuova; il resto degli elementi nella matrice precedente viene ignorato.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is equal to the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, this method does nothing.</source>
          <target state="translated">Se <ph id="ph1">`newSize`</ph> è uguale al <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> della vecchia matrice, questo metodo non esegue alcuna operazione.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`newSize`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`newSize`</ph>.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Resize%2A&gt;</ph> method resizes a one-dimensional array only.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Resize%2A&gt;</ph> metodo ridimensiona solo una matrice unidimensionale.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class does not include a method for resizing multi-dimensional arrays.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array&gt;</ph> non include un metodo per ridimensionare le matrici multidimensionali.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>To do this, you must either provide your own code or call a special-purpose method in a third-party library.</source>
          <target state="translated">A tale scopo, è necessario fornire il proprio codice o chiamare un metodo speciale in una libreria di terze parti.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The following code illustrates one possible implementation for a method that resizes an array of <bpt id="p1">*</bpt>n<ept id="p1">*</ept> dimensions.</source>
          <target state="translated">Il codice seguente illustra una possibile implementazione per un metodo che effettui il ridimensionamento di una matrice di <bpt id="p1">*</bpt>n<ept id="p1">*</ept> dimensioni.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The following example shows how resizing affects the array.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come il ridimensionamento influisce sulla matrice.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="newSize" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newSize" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Reverses the order of the elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or in a portion of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Inverte l'ordine degli elementi in un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale o in una parte dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to reverse.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale da invertire.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source>Reverses the sequence of the elements in the entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Inverte la sequenza degli elementi nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> intero unidimensionale.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
          <target state="translated">Dopo una chiamata a questo metodo, l'elemento in corrispondenza <ph id="ph1">`myArray[i]`</ph>, dove <ph id="ph2">`i`</ph> è un indice nella matrice, viene spostato in <ph id="ph3">`myArray[j]`</ph>, dove <ph id="ph4">`j`</ph> è uguale a <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>As the following example shows, the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
          <target state="translated">Come illustrato nell'esempio seguente, il <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> metodo può essere utilizzato per invertire una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>It initializes a jagged array with one element for each month of the current year in the current culture's calendar.</source>
          <target state="translated">Inizializza una matrice di matrici con un elemento per ogni mese dell'anno nel calendario le impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>Each element contains an array with as many elements as that month has days.</source>
          <target state="translated">Ogni elemento contiene una matrice con numero di elementi di tale mese è giorni.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>The example displays the contents of the array, calls the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method, and then displays the contents of the reversed array.</source>
          <target state="translated">Nell'esempio viene visualizzato il contenuto della matrice, chiama il <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> (metodo), quindi viene visualizzato il contenuto della matrice invertita.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>The following code example shows how to reverse the sort of the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come invertire l'ordine dei valori in un <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to reverse.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale da invertire.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the section to reverse.</source>
          <target state="translated">Indice iniziale della sezione da invertire.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the section to reverse.</source>
          <target state="translated">Numero di elementi nella sezione da invertire.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>Reverses the sequence of the elements in a range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Inverte la sequenza degli elementi in un intervallo di elementi dell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
          <target state="translated">Dopo una chiamata a questo metodo, l'elemento in corrispondenza <ph id="ph1">`myArray[i]`</ph>, dove <ph id="ph2">`i`</ph> è un indice nella matrice, viene spostato in <ph id="ph3">`myArray[j]`</ph>, dove <ph id="ph4">`j`</ph> è uguale a <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> metodo può essere utilizzato per invertire una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to reverse the sort of the values in a range of elements in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come invertire l'ordine dei valori in un intervallo di elementi in un <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Sets the specified element in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to the specified value.</source>
          <target state="translated">Ottiene il valore dell'elemento specificato nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente al valore specificato.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nuovo valore per l'elemento specificato.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta la posizione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">L'indice viene specificato come intero a 32 bit.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> i metodi possono determinare se il valore di <ph id="ph3">`index`</ph> è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> viene utilizzata per assegnare <ph id="ph2">`null`</ph> a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente una dimensione.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non può essere impostato sul tipo di elemento della <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> non è compreso nell'intervallo di indici validi per l'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The new value for the specified element.</source>
          <target state="translated">Nuovo valore per l'elemento specificato.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</source>
          <target state="translated">Matrice unidimensionale di interi a 32 bit che rappresentano gli indici che specificano la posizione dell'elemento da impostare.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Imposta il valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The indexes are specified as an array of 32-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come una matrice di interi a 32 bit.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Il numero di elementi in <ph id="ph1">`indices`</ph> sia uguale al numero di dimensioni di <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Tutti gli elementi di <ph id="ph1">`indices`</ph> matrice deve specificare collettivamente la posizione dell'elemento desiderato nell'oggetto multidimensionale <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi possono determinare se uno dei valori di <ph id="ph3">`indices`</ph> matrice è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> viene utilizzata per assegnare <ph id="ph2">`null`</ph> a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Il numero di dimensioni nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non è uguale al numero di elementi in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non può essere impostato sul tipo di elemento della <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ogni elemento in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nuovo valore per l'elemento specificato.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Integer a 64 bit che rappresenta la posizione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il valore in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">L'indice viene specificato come intero a 64 bit.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> i metodi possono determinare se il valore di <ph id="ph3">`index`</ph> è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> viene utilizzata per assegnare <ph id="ph2">`null`</ph> a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente una dimensione.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non può essere impostato sul tipo di elemento della <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> non è compreso nell'intervallo di indici validi per l'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The new value for the specified element.</source>
          <target state="translated">Nuovo valore per l'elemento specificato.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</source>
          <target state="translated">Matrice unidimensionale di interi a 64 bit che rappresentano gli indici che specificano la posizione dell'elemento da impostare.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Imposta il valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> multidimensionale.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The indexes are specified as an array of 64-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come una matrice di interi a 64 bit.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Il numero di elementi in <ph id="ph1">`indices`</ph> sia uguale al numero di dimensioni di <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Tutti gli elementi di <ph id="ph1">`indices`</ph> matrice deve specificare collettivamente la posizione dell'elemento desiderato nell'oggetto multidimensionale <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi possono determinare se uno dei valori di <ph id="ph3">`indices`</ph> matrice è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> viene utilizzata per assegnare <ph id="ph2">`null`</ph> a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Il numero di dimensioni nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non è uguale al numero di elementi in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non può essere impostato sul tipo di elemento della <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ogni elemento in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nuovo valore per l'elemento specificato.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> bidimensionale.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come interi a 32 bit.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> viene utilizzata per assegnare <ph id="ph2">`null`</ph> a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente due dimensioni.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non può essere impostato sul tipo di elemento della <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nuovo valore per l'elemento specificato.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> bidimensionale.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come interi a 64 bit.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> viene utilizzata per assegnare <ph id="ph2">`null`</ph> a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente due dimensioni.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non può essere impostato sul tipo di elemento della <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nuovo valore per l'elemento specificato.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta l'indice della prima dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta l'indice della seconda dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Valore intero a 32 bit che rappresenta l'indice della terza dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> tridimensionale.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come interi a 32 bit.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> viene utilizzata per assegnare <ph id="ph2">`null`</ph> a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente tre dimensioni.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non può essere impostato sul tipo di elemento della <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> o <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nuovo valore per l'elemento specificato.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice della prima dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice della seconda dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Integer a 64 bit che rappresenta l'indice della terza dimensione dell'elemento <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> da impostare.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Imposta un valore sull'elemento in corrispondenza della posizione specificata nell'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> tridimensionale.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Gli indici vengono specificati come interi a 64 bit.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodi è possono determinare se uno degli indici è compreso nell'intervallo.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni sulle conversioni, vedere <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Questo metodo è un'operazione o (1).</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> viene utilizzata per assegnare <ph id="ph2">`null`</ph> a un elemento di una matrice di tipi di valore, tutti i campi dell'elemento vengono inizializzati su zero.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Il valore dell'elemento non è un riferimento null e non può essere trovato cercando per un riferimento null.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come impostare e ottenere un valore specifico in una matrice unidimensionale o multidimensionale.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente tre dimensioni.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> non può essere impostato sul tipo di elemento della <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> o <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> non è compreso nell'intervallo di indici validi per la dimensione corrispondente dell'oggetto <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Sorts the elements in a one-dimensional array.</source>
          <target state="translated">Ordina gli elementi in una matrice unidimensionale.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale da ordinare.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>Sorts the elements in an entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ordina gli elementi di un'intera matrice <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale utilizzando l'implementazione dell'interfaccia <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ciascun elemento dell'oggetto <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Ogni elemento di <ph id="ph1">`array`</ph> deve implementare il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the partition size is fewer than 16 elements, it uses an<bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un<bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è il <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come ordinare i valori in un <ph id="ph1">&lt;xref:System.Array&gt;</ph> utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Si noti che il risultato potrebbe variare a seconda di corrente <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Uno o più elementi in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non implementano l'interfaccia <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che contiene le chiavi da ordinare.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per ordinare solo <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated">Ordina una coppia di oggetti <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionali (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'implementazione dell'interfaccia <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> di ciascuna chiave.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni chiave di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> dispone di un elemento corrispondente <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene riposizionato in modo analogo.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Pertanto, il <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene ordinato in base a disposizione delle chiavi corrispondenti nel <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Ogni chiave di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> deve implementare il <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è il <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph5">`keys`</ph>.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Ordinamenti vengono eseguiti utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Si noti che il risultato potrebbe variare a seconda di corrente <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e la lunghezza di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> è maggiore della lunghezza di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Uno o più elementi nell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> di <ph id="ph1">&lt;paramref name="keys" /&gt;</ph> non implementano l'interfaccia <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The one-dimensional array to sort.</source>
          <target state="translated">Matrice unidimensionale da ordinare.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The implementation to use when comparing elements.</source>
          <target state="translated">Implementazione da usare quando si confrontano elementi.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'implementazione <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Sorts the elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Ordina gli elementi in un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale utilizzando l'interfaccia <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, ogni elemento di <ph id="ph3">`array`</ph> deve implementare il <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è il <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework include predefiniti <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementazioni elencati nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementazione</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Confronta due oggetti, ma esegue un confronto tra maiuscole e minuscole delle stringhe.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura invarianti.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Confronta due oggetti di tipo <ph id="ph1">`T`</ph> utilizzando l'ordinamento predefinito del tipo.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">È anche possibile supportare i confronti personalizzati, fornendo un'istanza personalizzata <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementazione per il <ph id="ph2">`comparer`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
          <target state="translated">Nell'esempio viene eseguita la definizione di un <ph id="ph1">`ReverseComparer`</ph> classe che consente di invertire l'ordinamento predefinito per le istanze di un tipo ed esegue il confronto tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The following example sorts the values in a string arrayby using the default comparer.</source>
          <target state="translated">Nell'esempio seguente Ordina i valori in una stringa di arrayby utilizzando l'operatore di confronto predefinito.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>It also defines a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation named <ph id="ph2">`ReverseComparer`</ph> that reverses an object's default sort order while performing a case-insensitive string comparison.</source>
          <target state="translated">Definisce inoltre un oggetto personalizzato <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementazione denominato <ph id="ph2">`ReverseComparer`</ph> che inverte l'ordine predefinito dell'oggetto durante l'esecuzione di un confronto tra stringhe tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Note that the output might vary depending on the current culture.</source>
          <target state="translated">Si noti che l'output potrebbe variare a seconda delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e uno o più elementi in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> non implementano l'interfaccia <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L'implementazione di <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ha causato un errore durante l'ordinamento.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> eccezione e genera un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eccezione al chiamante.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, è possibile che le operazioni di ordinamento che in precedenza ha generato <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che contiene le chiavi da ordinare.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per ordinare solo <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementazione <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'implementazione <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Ordina una coppia di oggetti <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionali (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'interfaccia <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni chiave di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> dispone di un elemento corrispondente <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene riposizionato in modo analogo.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Pertanto, il <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene ordinato in base a disposizione delle chiavi corrispondenti nel <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, ogni chiave nel <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> deve implementare il <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework include predefiniti <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementazioni elencati nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementazione</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Confronta due oggetti, ma esegue un confronto tra maiuscole e minuscole delle stringhe.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura invarianti.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Confronta due oggetti di tipo <ph id="ph1">`T`</ph> utilizzando l'ordinamento predefinito del tipo.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">È anche possibile supportare i confronti personalizzati, fornendo un'istanza personalizzata <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementazione per il <ph id="ph2">`comparer`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The example does this by defining an <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
          <target state="translated">Nell'esempio viene eseguita la definizione di un <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementazione che consente di invertire l'ordinamento predefinito ed esegue il confronto tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è il <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph5">`keys`</ph>.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Ordinamenti vengono eseguiti utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Si noti che il risultato potrebbe variare a seconda di corrente <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e la lunghezza di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> è maggiore della lunghezza di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L'implementazione di <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ha causato un errore durante l'ordinamento.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e uno o più elementi in <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> non implementano l'interfaccia <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> eccezione e genera un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eccezione al chiamante.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previouslythrew <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, becausethe insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, è possibile che le operazioni di ordinamento che previouslythrew <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale da ordinare.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indice iniziale dell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Numero di elementi nell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ordina un intervallo di elementi di un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale utilizzando l'implementazione dell'interfaccia <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ciascun elemento dell'oggetto <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Ogni elemento all'interno dell'intervallo specificato di elementi in <ph id="ph1">`array`</ph> deve implementare il <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come ordinare i valori in un <ph id="ph1">&lt;xref:System.Array&gt;</ph> utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Si noti che il risultato potrebbe variare a seconda di corrente <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Uno o più elementi in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non implementano l'interfaccia <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che contiene le chiavi da ordinare.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per ordinare solo <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indice iniziale dell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Numero di elementi nell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated">Ordina un intervallo di elementi in una coppia di oggetti <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionali (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'implementazione dell'interfaccia <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> di ciascuna chiave.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni chiave di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> dispone di un elemento corrispondente <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene riposizionato in modo analogo.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Pertanto, il <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene ordinato in base a disposizione delle chiavi corrispondenti nel <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Ogni chiave all'interno dell'intervallo specificato di elementi di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> deve implementare il <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Ordinamenti vengono eseguiti utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Si noti che il risultato potrebbe variare a seconda di corrente <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e la lunghezza di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> è maggiore della lunghezza di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="index" /&gt;</ph> e <ph id="ph4">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Uno o più elementi nell'oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> di <ph id="ph1">&lt;paramref name="keys" /&gt;</ph> non implementano l'interfaccia <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale da ordinare.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indice iniziale dell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Numero di elementi nell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementazione <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'implementazione <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Ordina un intervallo di elementi di un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale utilizzando l'interfaccia <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, ogni elemento all'interno dell'intervallo specificato di elementi in <ph id="ph3">`array`</ph> deve implementare il <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interfaccia devono essere in grado di eseguire confronti con ogni altro elemento <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework include predefiniti <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementazioni elencati nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementazione</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Confronta due oggetti, ma esegue un confronto tra maiuscole e minuscole delle stringhe.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura invarianti.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Confronta due oggetti di tipo <ph id="ph1">`T`</ph> utilizzando l'ordinamento predefinito del tipo.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">È anche possibile supportare i confronti personalizzati, fornendo un'istanza personalizzata <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementazione per il <ph id="ph2">`comparer`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
          <target state="translated">Nell'esempio viene eseguita la definizione di un <ph id="ph1">`ReverseComparer`</ph> classe che consente di invertire l'ordinamento predefinito per le istanze di un tipo ed esegue il confronto tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come ordinare i valori in un <ph id="ph1">&lt;xref:System.Array&gt;</ph> utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Si noti che il risultato potrebbe variare a seconda di corrente <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L'implementazione di <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ha causato un errore durante l'ordinamento.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e uno o più elementi in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> non implementano l'interfaccia <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> eccezione e genera un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eccezione al chiamante.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, è possibile che le operazioni di ordinamento che in precedenza ha generato <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che contiene le chiavi da ordinare.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale che contiene gli elementi che corrispondono a ogni chiave nell'oggetto <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per ordinare solo <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indice iniziale dell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Numero di elementi nell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementazione <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'implementazione <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Ordina un intervallo di elementi in una coppia di oggetti <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionali (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'interfaccia <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni chiave di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> dispone di un elemento corrispondente <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene riposizionato in modo analogo.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Pertanto, il <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene ordinato in base a disposizione delle chiavi corrispondenti nel <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, ogni chiave all'interno dell'intervallo specificato di elementi nel <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> deve implementare il <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interfaccia devono essere in grado di eseguire confronti con ogni altra chiave.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework include predefiniti <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementazioni elencati nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementazione</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Confronta due oggetti, ma esegue un confronto tra maiuscole e minuscole delle stringhe.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura correnti.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Confronta due oggetti utilizzando le convenzioni di ordinamento delle impostazioni cultura invarianti.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Confronta due oggetti di tipo <ph id="ph1">`T`</ph> utilizzando l'ordinamento predefinito del tipo.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">È anche possibile supportare i confronti personalizzati, fornendo un'istanza personalizzata <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementazione per il <ph id="ph2">`comparer`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The example does this by defining a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
          <target state="translated">Nell'esempio viene eseguita la definizione di un oggetto personalizzato <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementazione che consente di invertire l'ordinamento predefinito ed esegue il confronto tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come ordinare due matrici associate, in cui la prima matrice contenente le chiavi e la seconda matrice contiene i valori.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Ordinamenti vengono eseguiti utilizzando l'operatore di confronto predefinito e un operatore di confronto personalizzato che consente di invertire l'ordinamento.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Si noti che il risultato potrebbe variare a seconda di corrente <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> è multidimensionale.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e il limite inferiore di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> non corrisponde al limite inferiore di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e la lunghezza di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> è maggiore della lunghezza di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="index" /&gt;</ph> e <ph id="ph4">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L'implementazione di <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ha causato un errore durante l'ordinamento.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e uno o più elementi in <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> non implementano l'interfaccia <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> eccezione e genera un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eccezione al chiamante.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, è possibile che le operazioni di ordinamento che in precedenza ha generato <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale e in base zero da ordinare.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>Sorts the elements in an entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ordina gli elementi di un'intera matrice <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'implementazione dell'interfaccia generica <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> di ciascun elemento della matrice <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Ogni elemento di <ph id="ph1">`array`</ph> deve implementare il <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfaccia generica per essere in grado di eseguire confronti con ogni altro elemento <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è il <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> overload del metodo generico e <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> overload del metodo generico.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>An array of strings is created, in no particular order.</source>
          <target state="translated">Viene creata una matrice di stringhe, in nessun ordine particolare.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">La matrice è visualizzata, ordinata e visualizzata di nuovo.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Le chiamate al <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Se si utilizza il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> overload del metodo generico viene quindi utilizzato per eseguire la ricerca di due stringhe, uno che non si trova la matrice e uno che.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">La matrice e il valore restituito del <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metodo vengono passati al <ph id="ph2">`ShowWhere`</ph> metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario gli elementi della stringa di ricerca sarebbe compresa se fosse nella matrice.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">L'indice è negativo se la stringa non è inclusa nella matrice, pertanto la <ph id="ph1">`ShowWhere`</ph> metodo accetta il complemento bit per bit (il ~ operatore in c# e Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore di stri di ricerca NG.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Uno o più elementi della matrice <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non implementano l'interfaccia generica <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-base <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale e in base zero da ordinare.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Implementazione dell'interfaccia generica <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> da utilizzare per il confronto fra gli elementi; oppure, impostare <ph id="ph2">&lt;see langword="null" /&gt;</ph> per utilizzare l'implementazione dell'interfaccia generica <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Sorts the elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Ordina gli elementi di un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'interfaccia generica <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, ogni elemento di <ph id="ph3">`array`</ph> deve implementare il <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> interfaccia generica per essere in grado di eseguire confronti con ogni altro elemento <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è il <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload del metodo generico e <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload del metodo generico.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato <ph id="ph1">`ReverseCompare`</ph>, che implementa il <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) dell'interfaccia generica.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Operatore di confronto chiama il <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">La matrice è visualizzata, ordinata e visualizzata di nuovo.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Le matrici devono essere ordinate per utilizzare il <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Le chiamate al <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Se si utilizza il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload del metodo generico viene quindi utilizzato per eseguire la ricerca di due stringhe, uno che non si trova la matrice e uno che.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">La matrice e il valore restituito del <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metodo vengono passati al <ph id="ph2">`ShowWhere`</ph> metodo generico, che viene visualizzato il valore di indice se la stringa viene trovata, e in caso contrario gli elementi della stringa di ricerca sarebbe compresa se fosse nella matrice.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">L'indice è negativo se la stringa non è inclusa nella matrice, pertanto la <ph id="ph1">`ShowWhere`</ph> metodo accetta il complemento bit per bit (il ~ operatore in c# e Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) per ottenere l'indice del primo elemento nell'elenco che è maggiore di stri di ricerca NG.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e uno o più elementi nella matrice <ph id="ph3">&lt;paramref name="array" /&gt;</ph> non implementano l'interfaccia generica <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L'implementazione di <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ha causato un errore durante l'ordinamento.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> eccezione e genera un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eccezione al chiamante.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, è possibile che le operazioni di ordinamento che in precedenza ha generato <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale e in base zero da ordinare.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph> to use when comparing elements.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph> da usare quando si confrontano gli elementi.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Sorts the elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph>.</source>
          <target state="translated">Ordina gli elementi di un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'interfaccia <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This method uses introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come indicato di seguito:</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è il <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> method overload.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The code example defines an alternative comparison method for strings, named <ph id="ph1">`CompareDinosByLength`</ph>.</source>
          <target state="translated">L'esempio di codice definisce un metodo di confronto alternativo per le stringhe, denominato <ph id="ph1">`CompareDinosByLength`</ph>.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This method works as follows: First, the comparandsare tested for<ph id="ph1">`null`</ph>, and a null reference is treated as less than a non-null.</source>
          <target state="translated">Questo metodo funziona nel modo seguente: prima di tutto, il comparandsare testato per<ph id="ph1">`null`</ph>, e un riferimento null viene considerato minore rispetto a un valore non null.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Second, the string lengths are compared, and the longer string is deemed to be greater.</source>
          <target state="translated">In secondo luogo, vengono confrontate le lunghezze di stringa e la stringa più lunga è considerata maggiore.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Third, if the lengths are equal, ordinary string comparison is used.</source>
          <target state="translated">In terzo luogo, se le lunghezze sono uguali, viene utilizzato il confronto di stringa normali.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>A array of strings is created and populated with four strings, in no particular order.</source>
          <target state="translated">Una matrice di stringhe viene creata e popolata con quattro stringhe, in nessun ordine particolare.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The list also includes an empty string and a null reference.</source>
          <target state="translated">L'elenco include anche una stringa vuota e un riferimento null.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The list is displayed, sorted using a <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> generic delegate representing the <ph id="ph2">`CompareDinosByLength`</ph> method, and displayed again.</source>
          <target state="translated">Viene visualizzato l'elenco e ordinato utilizzando un <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> delegato generico che rappresenta il <ph id="ph2">`CompareDinosByLength`</ph> (metodo), quindi viene nuovamente visualizzato.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L'implementazione di <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> ha causato un errore durante l'ordinamento.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> eccezione e genera un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eccezione al chiamante.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, è possibile che le operazioni di ordinamento che in precedenza ha generato <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale e in base zero da ordinare.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indice iniziale dell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Numero di elementi nell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ordina un intervallo di elementi di un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'implementazione dell'interfaccia generica <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> di ciascun elemento dell'oggetto <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Ogni elemento all'interno dell'intervallo specificato di elementi in <ph id="ph1">`array`</ph> deve implementare il <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfaccia generica per essere in grado di eseguire confronti con ogni altro elemento <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload for sorting a range in an array.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload del metodo generico e <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload del metodo generico per l'ordinamento di un intervallo in una matrice.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato <ph id="ph1">`ReverseCompare`</ph>, che implementa il <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) dell'interfaccia generica.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Operatore di confronto chiama il <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</source>
          <target state="translated">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro, costituito da tre erbivori seguiti da tre carnivori (precisa tyrannosaurids).</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload is used to sort the last three elements of the array, which is then displayed.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload del metodo generico viene utilizzato per ordinare gli ultimi tre elementi della matrice, che viene quindi visualizzato.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is used with <ph id="ph2">`ReverseCompare`</ph> to sort the last three elements in reverse order.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload di metodo generico viene utilizzato con <ph id="ph2">`ReverseCompare`</ph> per ordinare gli ultimi tre elementi in ordine inverso.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The thoroughly confused dinosaurs are displayed again.</source>
          <target state="translated">I dinosauri non vengono visualizzati nuovamente.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Le chiamate al <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Se si utilizza il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Uno o più elementi della matrice <ph id="ph1">&lt;paramref name="array" /&gt;</ph> non implementano l'interfaccia generica <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale e in base zero da ordinare.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indice iniziale dell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Numero di elementi nell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Implementazione dell'interfaccia generica <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> da utilizzare per il confronto fra gli elementi; oppure, impostare <ph id="ph2">&lt;see langword="null" /&gt;</ph> per utilizzare l'implementazione dell'interfaccia generica <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Ordina un intervallo di elementi di un oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'interfaccia generica <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, ogni elemento all'interno dell'intervallo specificato di elementi in <ph id="ph3">`array`</ph> deve implementare il <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> interfaccia generica per essere in grado di eseguire confronti con ogni altro elemento <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload for sorting a range in an array.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload del metodo generico e <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload del metodo generico per l'ordinamento di un intervallo in una matrice.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato <ph id="ph1">`ReverseCompare`</ph>, che implementa il <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) dell'interfaccia generica.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Operatore di confronto chiama il <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</source>
          <target state="translated">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro, costituito da tre erbivori seguiti da tre carnivori (precisa tyrannosaurids).</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload is used to sort the last three elements of the array, which is then displayed.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload del metodo generico viene utilizzato per ordinare gli ultimi tre elementi della matrice, che viene quindi visualizzato.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is used with <ph id="ph2">`ReverseCompare`</ph> to sort the last three elements in reverse order.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload di metodo generico viene utilizzato con <ph id="ph2">`ReverseCompare`</ph> per ordinare gli ultimi tre elementi in ordine inverso.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The thoroughly confused dinosaurs are displayed again.</source>
          <target state="translated">I dinosauri non vengono visualizzati nuovamente.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Le chiamate al <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> e <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo del primo argomento.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Se si utilizza il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L'implementazione di <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ha causato un errore durante l'ordinamento.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e uno o più elementi nella matrice <ph id="ph3">&lt;paramref name="array" /&gt;</ph> non implementano l'interfaccia generica <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> eccezione e genera un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eccezione al chiamante.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, è possibile che le operazioni di ordinamento che in precedenza ha generato <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Tipo degli elementi della matrice delle chiavi.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Tipo degli elementi della matrice degli elementi.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero che contiene le chiavi da ordinare.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto unidimensionale in base zero <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che contiene gli elementi che corrispondono alle chiavi in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept> oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> per ordinare solo <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Sorts a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each key.</source>
          <target state="translated">Ordina una coppia di oggetti <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi del primo oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'implementazione dell'interfaccia generica <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> di ciascuna chiave.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni chiave di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> dispone di un elemento corrispondente <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene riposizionato in modo analogo.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Pertanto, il <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene ordinato in base a disposizione delle chiavi corrispondenti nel <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Ogni chiave di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> deve implementare il <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> interfaccia generica per essere in grado di eseguire confronti con ogni altra chiave.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è il <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, e <ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload di metodo generico, per l'ordinamento di coppie di matrici che rappresentano le chiavi e valori.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato <ph id="ph1">`ReverseCompare`</ph>, che implementa il <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) dell'interfaccia generica.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Operatore di confronto chiama il <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ciascun dinosauro espressa in metri (valori).</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Le matrici vengono ordinate e visualizzate più volte:</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload viene utilizzato per ordinare entrambe le matrici in base ai nomi di dinosauro della prima matrice.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload e un'istanza di <ph id="ph2">`ReverseCompare`</ph> vengono utilizzati per invertire l'ordinamento della coppia di matrici.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici in ordine inverso.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Se si utilizza il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e il limite inferiore di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> non corrisponde al limite inferiore di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e la lunghezza di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> è maggiore della lunghezza di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Uno o più elementi in <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> non implementano l'interfaccia generica <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Tipo degli elementi della matrice delle chiavi.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Tipo degli elementi della matrice degli elementi.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero che contiene le chiavi da ordinare.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto unidimensionale in base zero <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che contiene gli elementi che corrispondono alle chiavi in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept> oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> per ordinare solo <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Implementazione dell'interfaccia generica <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> da utilizzare per il confronto fra gli elementi; oppure, impostare <ph id="ph2">&lt;see langword="null" /&gt;</ph> per utilizzare l'implementazione dell'interfaccia generica <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Sorts a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Ordina una coppia di oggetti <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> (uno contiene le chiavi e l'altro contiene gli elementi corrispondenti) in base alle chiavi nel primo oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'interfaccia generica <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni chiave di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> dispone di un elemento corrispondente <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene riposizionato in modo analogo.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Pertanto, il <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene ordinato in base a disposizione delle chiavi corrispondenti nel <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, ogni chiave nel <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> deve implementare il <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> interfaccia generica per essere in grado di eseguire confronti con ogni altra chiave.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è il <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, [<ph id="ph2">\]</ph>, TValue<ph id="ph3">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;,<ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, [<ph id="ph2">\]</ph>, TValue<ph id="ph3">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt;,<ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, e <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload di metodo generico, per l'ordinamento di coppie di matrici che rappresentano le chiavi e valori.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato <ph id="ph1">`ReverseCompare`</ph>, che implementa il <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) dell'interfaccia generica.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Operatore di confronto chiama il <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ciascun dinosauro espressa in metri (valori).</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Le matrici vengono ordinate e visualizzate più volte:</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload viene utilizzato per ordinare entrambe le matrici in base ai nomi di dinosauro della prima matrice.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; overload and an instance of <ph id="ph3">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Il [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; overload e un'istanza di <ph id="ph3">`ReverseCompare`</ph> vengono utilizzati per invertire l'ordinamento della coppia di matrici.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici in ordine inverso.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Se si utilizza il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e il limite inferiore di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> non corrisponde al limite inferiore di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e la lunghezza di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> è maggiore della lunghezza di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L'implementazione di <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ha causato un errore durante l'ordinamento.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e uno o più elementi in <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> non implementano l'interfaccia generica <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> eccezione e genera un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eccezione al chiamante.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, è possibile che le operazioni di ordinamento che in precedenza ha generato <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Tipo degli elementi della matrice delle chiavi.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Tipo degli elementi della matrice degli elementi.</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero che contiene le chiavi da ordinare.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto unidimensionale in base zero <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che contiene gli elementi che corrispondono alle chiavi in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept> oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> per ordinare solo <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indice iniziale dell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Numero di elementi nell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each key.</source>
          <target state="translated">Ordina un intervallo di elementi in una coppia di oggetti <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'implementazione dell'interfaccia generica <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> di ciascuna chiave.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni chiave di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> dispone di un elemento corrispondente <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene riposizionato in modo analogo.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Pertanto, il <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene ordinato in base a disposizione delle chiavi corrispondenti nel <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Ogni chiave all'interno dell'intervallo specificato di elementi di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> deve implementare il <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> interfaccia generica per essere in grado di eseguire confronti con ogni altra chiave.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, [<ph id="ph3">\]</ph>, TValue<ph id="ph4">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;, and <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, [<ph id="ph3">\]</ph>, TValue<ph id="ph4">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 &gt;, e <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload di metodo generico, per l'ordinamento di coppie di matrici che rappresentano le chiavi e valori.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato <ph id="ph1">`ReverseCompare`</ph>, che implementa il <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) dell'interfaccia generica.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Operatore di confronto chiama il <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ciascun dinosauro espressa in metri (valori).</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Le matrici vengono ordinate e visualizzate più volte:</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload viene utilizzato per ordinare entrambe le matrici in base ai nomi di dinosauro della prima matrice.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload e un'istanza di <ph id="ph2">`ReverseCompare`</ph> vengono utilizzati per invertire l'ordinamento della coppia di matrici.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt; overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Il [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 &gt; overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici in ordine inverso.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Se si utilizza il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e il limite inferiore di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> non corrisponde al limite inferiore di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e la lunghezza di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> è maggiore della lunghezza di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="index" /&gt;</ph> e <ph id="ph4">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Uno o più elementi in <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> non implementano l'interfaccia generica <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Tipo degli elementi della matrice delle chiavi.</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Tipo degli elementi della matrice degli elementi.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale in base zero che contiene le chiavi da ordinare.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto unidimensionale in base zero <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> che contiene gli elementi che corrispondono alle chiavi in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept> oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> per ordinare solo <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indice iniziale dell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Numero di elementi nell'intervallo da ordinare.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Implementazione dell'interfaccia generica <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> da utilizzare per il confronto fra gli elementi; oppure, impostare <ph id="ph2">&lt;see langword="null" /&gt;</ph> per utilizzare l'implementazione dell'interfaccia generica <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> di ciascun elemento.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Ordina un intervallo di elementi in una coppia di oggetti <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> (uno contenente le chiavi e l'altro contenente gli elementi corrispondenti) in base alle chiavi nel primo oggetto <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> utilizzando l'interfaccia generica <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> specificata.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ogni chiave di <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> dispone di un elemento corrispondente <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Quando una chiave viene riposizionata durante l'ordinamento, l'elemento corrispondente nella <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene riposizionato in modo analogo.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Pertanto, il <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> viene ordinato in base a disposizione delle chiavi corrispondenti nel <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Se <ph id="ph1">`comparer`</ph> è <ph id="ph2">`null`</ph>, ogni chiave all'interno dell'intervallo specificato di elementi di <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> deve implementare il <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> interfaccia generica per essere in grado di eseguire confronti con ogni altra chiave.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">È possibile ordinare se sono presenti più elementi di chiavi, ma non saranno ordinati gli elementi che non dispongono di alcuna chiave corrispondente.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Se sono presenti più chiavi di elementi; non è possibile ordinare in caso contrario viene generata una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Se l'ordinamento non è stato completato correttamente, i risultati sono indefiniti.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Questo metodo utilizza l'algoritmo di ordinamento interiorizzata (introsort) come segue:</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Se la dimensione della partizione è inferiore a 16 elementi, viene utilizzato un <bpt id="p1">[</bpt>ordinamento inserimento<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Se il numero di partizioni superiore a 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, dove <bpt id="p2">*</bpt>N<ept id="p2">*</ept> è l'intervallo della matrice di input, viene utilizzato un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">In caso contrario, viene utilizzato un <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Questa implementazione esegue un ordinamento instabile; ovvero, se due elementi sono uguali, l'ordine potrebbe non essere mantenuta.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Al contrario, un ordinamento stabile mantiene l'ordine degli elementi che sono uguali.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Per le matrici vengono ordinate utilizzando gli algoritmi Heapsort e Quicksort, nel peggiore dei casi, questo metodo è un'operazione O (<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operazione, in cui <ph id="ph3">`n`</ph> è <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and [<ph id="ph4">\]</ph>, TValue<ph id="ph5">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">L'esempio di codice seguente illustra il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, e [<ph id="ph4">\]</ph>, TValue<ph id="ph5">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; overload di metodo generico, per l'ordinamento di coppie di matrici che rappresentano le chiavi e valori.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph>(<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">L'esempio di codice definisce un operatore di confronto alternativo per le stringhe, denominato <ph id="ph1">`ReverseCompare`</ph>, che implementa il <ph id="ph2">`IComparer&lt;string&gt;`</ph>(<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) dell'interfaccia generica.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Operatore di confronto chiama il <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metodo, invertendo l'ordine dei termini del confronto in modo che l'ordinamento delle stringhe alto verso il basso, anziché basso verso l'alto.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">L'esempio di codice crea e visualizza una matrice di nomi di dinosauro (chiavi) e una matrice di interi che rappresenta la lunghezza massima di ciascun dinosauro espressa in metri (valori).</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Le matrici vengono ordinate e visualizzate più volte:</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload viene utilizzato per ordinare entrambe le matrici in base ai nomi di dinosauro della prima matrice.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload e un'istanza di <ph id="ph2">`ReverseCompare`</ph> vengono utilizzati per invertire l'ordinamento della coppia di matrici.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload viene utilizzato per ordinare gli ultimi tre elementi di entrambe le matrici.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Il [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; overload viene utilizzato per ordinare gli ultimi tre gli elementi di entrambe le matrici in ordine inverso.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Le chiamate ai metodi generici non presenta alcuna differenza dalle chiamate alle controparti non generiche, perché Visual Basic, c# e C++ dedurre il tipo di parametro di tipo generico dal tipo dei primi due argomenti.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Se si utilizza il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il Microsoft intermediate language (MSIL), si noterà che vengono chiamati i metodi generici.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore del limite inferiore di <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e il limite inferiore di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> non corrisponde al limite inferiore di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e la lunghezza di <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> è maggiore della lunghezza di <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> e <ph id="ph2">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="index" /&gt;</ph> e <ph id="ph4">&lt;paramref name="length" /&gt;</ph> non specificano un intervallo valido in <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">L'implementazione di <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ha causato un errore durante l'ordinamento.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Ad esempio, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> potrebbe non restituire 0 quando si confronta un elemento con se stesso.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>, e uno o più elementi in <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> non implementano l'interfaccia generica <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Il .NET Framework 4 e versioni precedenti utilizzato solo l'algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifica gli operatori di confronto non validi in alcune situazioni in cui l'operazione di ordinamento genera una <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> eccezione e genera un <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eccezione al chiamante.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, è possibile che le operazioni di ordinamento che in precedenza ha generato <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> non genererà un'eccezione, poiché gli algoritmi di ordinamento e heapsort di inserimento non viene rilevano un operatore di confronto non valido.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">La maggior parte, si applica alle matrici con un massimo di 16 elementi.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" uid="P:System.Array.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene un oggetto che può essere usato per sincronizzare l'accesso a <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Oggetto che può essere usato per sincronizzare l'accesso a <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>This property implements the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Questa proprietà implementa il <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Classi di .NET framework basate su <ph id="ph1">&lt;xref:System.Array&gt;</ph> fornire una propria versione sincronizzata della raccolta mediante la <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Le classi che utilizzano matrici anche possono implementare la propria sincronizzazione utilizzando il <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
          <target state="translated">Il codice di sincronizzazione è necessario eseguire operazioni sul <ph id="ph1">`SyncRoot`</ph> della raccolta, non direttamente sulla raccolta.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">In questo modo si garantisce il corretto funzionamento delle raccolte derivate da altri oggetti.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
          <target state="translated">In particolare, mantenuta la sincronizzazione con altri thread che potrebbero modificare contemporaneamente l'insieme.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
          <target state="translated">Si noti che alcune implementazioni di <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> potrebbe restituire il <ph id="ph2">&lt;xref:System.Array&gt;</ph> stesso.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">L'enumerazione di una raccolta non è quindi una procedura thread-safe.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Anche se una raccolta è sincronizzata, è possibile che venga modificata da altri thread, con conseguente generazione di un'eccezione da parte dell'enumeratore.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Per garantire la protezione dei thread durante l'enumerazione, è possibile bloccare la raccolta per l'intera enumerazione oppure intercettare le eccezioni determinate dalle modifiche apportate da altri thread.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Il recupero del valore di questa proprietà è un'operazione O(1).</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>The following code example shows how to lock an array during the entire enumeration by using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come bloccare la matrice durante l'intera enumerazione tramite il <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>Gets the number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ottiene il numero di elementi contenuti in <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>The number of elements contained in the collection.</source>
          <target state="translated">Numero di elementi contenuti nella raccolta.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>The object to be added to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Oggetto da aggiungere all'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Calling this method always throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> exception.</source>
          <target state="translated">La chiamata di questo metodo genera sempre un'eccezione <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Adding a value to an array is not supported.</source>
          <target state="translated">L'aggiunta di valori alla matrice non è supportata.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>No value is returned.</source>
          <target state="translated">Non vengono restituiti valori.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Ordinarily, an <ph id="ph1">&lt;xref:System.Collections.IList.Add%2A?displayProperty=nameWithType&gt;</ph> implementation adds a member to a collection.</source>
          <target state="translated">In genere, un <ph id="ph1">&lt;xref:System.Collections.IList.Add%2A?displayProperty=nameWithType&gt;</ph> implementazione aggiunge un membro a una raccolta.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>However, because arrays have a fixed size (the <ph id="ph1">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property always returns <ph id="ph2">`true`</ph>), this method always throws a <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
          <target state="translated">Tuttavia, poiché le matrici hanno una dimensione fissa (il <ph id="ph1">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> proprietà restituisce sempre <ph id="ph2">`true`</ph>), questo metodo genera sempre un <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph> eccezione.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Clear">
          <source>Removes all items from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Rimuove tutti gli elementi da <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Clear">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Clear">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>The object to locate in the current list.</source>
          <target state="translated">Oggetto da individuare nell'elenco corrente.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>The element to locate can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">L'elemento da individuare può essere <ph id="ph1">&lt;see langword="null" /&gt;</ph> per i tipi di riferimento.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>Determines whether an element is in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Determina se un elemento è incluso in <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è presente in <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph>; in caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>The object to locate in the current list.</source>
          <target state="translated">Oggetto da individuare nell'elenco corrente.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>Determines the index of a specific item in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Determina l'indice di un elemento specifico in <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>The index of value if found in the list; otherwise, -1.</source>
          <target state="translated">Indice di value, se presente nell'elenco; in caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The index at which <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be inserted.</source>
          <target state="translated">Indice in corrispondenza del quale inserire <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The object to insert.</source>
          <target state="translated">Oggetto da inserire.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>Inserts an item to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> at the specified index.</source>
          <target state="translated">Inserisce un elemento in <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is not a valid index in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> non è un indice valido nell'interfaccia <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is null reference in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> è un riferimento null nell'interfaccia <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The index of the element to get or set.</source>
          <target state="translated">Indice dell'elemento da ottenere o impostare.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>Gets or sets the element at the specified index.</source>
          <target state="translated">Ottiene o imposta l'elemento in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The element at the specified index.</source>
          <target state="translated">Elemento in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è minore di zero.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.ICollection.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> è uguale a o maggiore di <ph id="ph2">&lt;see cref="P:System.Collections.ICollection.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> corrente non ha esattamente una dimensione.</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The object to remove from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Oggetto da rimuovere da <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Rimuove la prima occorrenza di un oggetto specifico da <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The index of the element to remove.</source>
          <target state="translated">Indice dell'elemento da rimuovere.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>Removes the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> item at the specified index.</source>
          <target state="translated">Rimuove l'elemento <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> in corrispondenza dell'indice specificato.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>index is not a valid index in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">non è un indice valido in <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated">La classe <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> è di sola lettura.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Le dimensioni dell'oggetto <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> sono fisse.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">Oggetto da confrontare con l'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>An object that compares the current object and <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto che confronta l'oggetto corrente e <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</source>
          <target state="translated">Determina se l'oggetto raccolta corrente precede, è nella stessa posizione o segue un altro oggetto nell'ordinamento.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>An integer that indicates the relationship of the current collection object to other, as shown in the following table.</source>
          <target state="translated">Intero che indica la relazione tra l'oggetto raccolta corrente e other, come illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valore restituito</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Descrizione</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance precedes <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> L'istanza corrente precede <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance and <ph id="ph3">&lt;paramref name="other" /&gt;</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> L'istanza corrente è uguale a <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance follows <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> L'istanza corrente segue <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralComparable&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IStructuralComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">Oggetto da confrontare con l'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>An object that determines whether the current instance and <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept> are equal.</source>
          <target state="translated">Oggetto che determina se l'istanza corrente e <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept> sono uguali.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>Determines whether an object is equal to the current instance.</source>
          <target state="translated">Determina se un oggetto è uguale all'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the two objects are equal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se i due oggetti sono uguali; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>An object that computes the hash code of the current object.</source>
          <target state="translated">Oggetto che calcola il codice hash dell'oggetto corrente.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>Returns a hash code for the current instance.</source>
          <target state="translated">Restituisce un codice hash per l'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>The hash code for the current instance.</source>
          <target state="translated">Codice hash per l'istanza corrente.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Questo membro è un’implementazione esplicita di un membro di interfaccia.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interface.</source>
          <target state="translated">Può essere utilizzato solo quando si esegue il cast dell'istanza <ph id="ph1">&lt;xref:System.Array&gt;</ph> a un'interfaccia <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Tipo degli elementi della matrice.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to check against the conditions.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionale e in base zero per cui verificare se le condizioni sono soddisfatte.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The predicate that defines the conditions to check against the elements.</source>
          <target state="translated">Predicato che definisce le condizioni da verificare negli elementi.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>Determines whether every element in the array matches the conditions defined by the specified predicate.</source>
          <target state="translated">Determina se ogni elemento della matrice soddisfa le condizioni definite dal predicato specificato.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if every element in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> matches the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se ogni elemento della matrice <ph id="ph2">&lt;paramref name="array" /&gt;</ph> soddisfa le condizioni definite dal predicato specificato; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>If there are no elements in the array, the return value is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Se la matrice non contiene elementi, il valore restituito è <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns<ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> è un delegato a un metodo che restituisce<ph id="ph2">`true`</ph> se l'oggetto passato a corrisponda alle condizioni definite nel delegato.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when the delegate returns <ph id="ph3">`false`</ph> for any element.</source>
          <target state="translated">Gli elementi di <ph id="ph1">`array`</ph> vengono passati singolarmente per il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, e l'elaborazione viene arrestata quando il delegato restituisce <ph id="ph3">`false`</ph> per qualsiasi elemento.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Questo metodo è un'operazione O (<ph id="ph1">`n`</ph>) operazione, in cui <ph id="ph2">`n`</ph> è il <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> di <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The following example determines whether the last character of each element in a string array is a number.</source>
          <target state="translated">Nell'esempio seguente determina se l'ultimo carattere di ogni elemento nella matrice di stringhe è un numero.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>It creates two string arrays.</source>
          <target state="translated">Crea due matrici di stringhe.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The first arrayincludes both strings that end with alphabetic characters and strings that end with numeric characters.The second array consists only of strings that end with numeric characters.</source>
          <target state="translated">Il primo arrayincludes entrambe le stringhe che terminano con caratteri alfabetici e le stringhe che terminano con caratteri numerici. Seconda matrice è costituito solo da stringhe che terminano con caratteri numerici.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The example also defines an <ph id="ph1">`EndWithANumber`</ph> method whose signature matches the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Viene inoltre definito un <ph id="ph1">`EndWithANumber`</ph> metodo la cui firma corrisponde il <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegato.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The example passes each array to the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method along with a delegate that represents the <ph id="ph2">`EndsWithANumber`</ph> method.</source>
          <target state="translated">Nell'esempio vengono passate ogni matrice di <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> metodo insieme a un delegato che rappresenta il <ph id="ph2">`EndsWithANumber`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The following example is similar to the first, except that it passes the string array to the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method along with  a lambda expression that determines whether a particular array element ends with the string representation of a number.</source>
          <target state="translated">Nell'esempio seguente è simile al primo, ad eccezione del fatto che passa una matrice di stringhe per il <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> metodo insieme a un'espressione lambda che determina se un elemento specifico della matrice termina con la rappresentazione di stringa di un numero.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>In both cases, the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method returns <ph id="ph2">`false`</ph> as soon as it encounters the first array element that does not end in a number.</source>
          <target state="translated">In entrambi i casi, il <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> restituisce <ph id="ph2">`false`</ph> non appena viene rilevato il primo elemento della matrice che non terminano con un numero.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>Otherwise, it returns <ph id="ph1">`true`</ph> after iterating all the elements in the array.</source>
          <target state="translated">In caso contrario, restituisce <ph id="ph1">`true`</ph> dopo l'iterazione di tutti gli elementi nella matrice.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>As both examples show, in C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">Come mostrano in entrambi gli esempi, in c# e Visual Basic, non è necessario creare il <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegato (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) in modo esplicito.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Questi linguaggi deducono il delegato corretto dal contesto e creano automaticamente.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>