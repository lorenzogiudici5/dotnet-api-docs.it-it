<Type Name="Char" FullName="System.Char">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="40488152e512beff0c2ef2fb4e14f841dcd11dd7" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33684397" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;char&gt;, class System.IConvertible, class System.IEquatable`1&lt;char&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Char" />
  <TypeSignature Language="VB.NET" Value="Public Structure Char&#xA;Implements IComparable, IComparable(Of Char), IConvertible, IEquatable(Of Char)" />
  <TypeSignature Language="C++ CLI" Value="public value class Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Char&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un carattere come unità di codice UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] utilizza il <xref:System.Char> struttura per rappresentare un carattere Unicode. Lo Unicode Standard identifica ogni carattere Unicode con un numero scalare univoco a 21 bit chiamato un punto di codice e definisce il formato di codifica UTF-16 che specifica le modalità di codifica di un punto di codice in una sequenza di uno o più valori a 16 bit. Ogni valore a 16 bit compreso tra esadecimali 0x0000 e 0xFFFF, viene archiviato in un <xref:System.Char> struttura.  Il valore di un <xref:System.Char> oggetto è un valore numerico a 16 bit (ordinale).  
  
 Nelle sezioni seguenti di esaminare la relazione tra un <xref:System.Char> oggetto e un carattere e illustrano alcune attività comuni con <xref:System.Char> istanze.  
  
 [Oggetti char, caratteri Unicode e stringhe](#Relationship)   
 [Caratteri e le categorie di caratteri](#Categories)   
 [Caratteri e gli elementi di testo](#Elements)   
 [Operazioni comuni](#Operations)   
 [Interoperabilità e valori Char](#Interop)  
  
<a name="Relationship"></a>   
## <a name="char-objects-unicode-characters-and-strings"></a>Oggetti char, caratteri Unicode e stringhe  
 Oggetto <xref:System.String> oggetto è una raccolta sequenziale di <xref:System.Char> strutture che rappresenta una stringa di testo. La maggior parte dei caratteri Unicode possono essere rappresentati da un singolo <xref:System.Char> dell'oggetto, ma un carattere che viene codificato come un carattere di base, coppia di surrogati e/o la combinazione di sequenza di caratteri viene rappresentato da più <xref:System.Char> oggetti. Per questo motivo, un <xref:System.Char> struttura un <xref:System.String> oggetto non è necessariamente equivalente a un singolo carattere Unicode.  
  
 Più unità di codice a 16 bit vengono utilizzate per rappresentare caratteri Unicode solo nei casi seguenti:  
  
-   Icone, possono essere costituita da un singolo carattere o un carattere di base seguiti da uno o più caratteri di combinazione. Ad esempio, il carattere ä è rappresentato da un <xref:System.Char> il cui codice unità è U + 0061 seguito da un oggetto <xref:System.Char> oggetto la cui unità di codice è U + 0308. (Il carattere ä può essere definito anche da un unico <xref:System.Char> oggetto che dispone di un'unità di codice di U + 00E4.) Nell'esempio seguente viene illustrato che il carattere ä costituita da due <xref:System.Char> oggetti.  
  
     [!code-csharp[System.Char.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/grapheme1.cs#1)]
     [!code-vb[System.Char.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/grapheme1.vb#1)]  
  
-   Caratteri di fuori di Unicode Basic Multilingual Plane (BMP). Unicode supporta sedici piani oltre a BMP che rappresenta il piano 0. Un punto di codice Unicode è rappresentato in UTF-32 da un valore a 21 bit che include il piano. Ad esempio U + 1D160 rappresenta il carattere di simbolo MUSICALE. Perché la codifica UTF-16 è solo a 16 bit, i caratteri di fuori di BMP sono rappresentati da coppie di surrogati UTF-16. Nell'esempio seguente viene illustrato che l'equivalente di UTF-32 di U + 1D160, il carattere di simbolo MUSICALE, è U + D834 U + DD60. U + D834 è il surrogato alto; surrogati alti vanno da U + D800 e U + DBFF. U + DD60 è il surrogato basso; surrogati bassi vanno da U + DC00 e U + DFFF.  
  
     [!code-csharp[System.Char.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/surrogate1.cs#2)]
     [!code-vb[System.Char.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/surrogate1.vb#2)]  
  
<a name="Categories"></a>   
## <a name="characters-and-character-categories"></a>Caratteri e le categorie di caratteri  
 Ogni coppia di surrogati valida o un carattere Unicode appartiene a una categoria Unicode. In .NET Framework, alle categorie Unicode sono rappresentate dai membri del <xref:System.Globalization.UnicodeCategory> enumerazione e includere i valori, ad esempio <xref:System.Globalization.UnicodeCategory.CurrencySymbol?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType>, e <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType>, ad esempio.  
  
 Per determinare la categoria Unicode di un carattere, chiamare il <xref:System.Char.GetUnicodeCategory%2A> metodo. Ad esempio, nell'esempio seguente chiama il <xref:System.Char.GetUnicodeCategory%2A> per visualizzare la categoria Unicode di ogni carattere in una stringa.  
  
 [!code-csharp[System.Char.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/GetUnicodeCategory3.cs#6)]
 [!code-vb[System.Char.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/GetUnicodeCategory3.vb#6)]  
  
 Internamente, i caratteri di fuori dell'intervallo ASCII (U + 0000 a U + 00FF), il <xref:System.Char.GetUnicodeCategory%2A> metodo dipende dalle categorie Unicode segnalate dalla <xref:System.Globalization.CharUnicodeInfo> classe. A partire dal [!INCLUDE[net_v462](~/includes/net-v462-md.md)], caratteri Unicode vengono classificati in base alle [lo Unicode Standard, versione 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). Nelle versioni di .NET Framework dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] per il [!INCLUDE[net_v461](~/includes/net-v461-md.md)], sono classificati in base a [lo Unicode Standard, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
<a name="Elements"></a>   
## <a name="characters-and-text-elements"></a>Caratteri e gli elementi di testo  
 Poiché un singolo carattere può essere rappresentato da più <xref:System.Char> oggetti, non è sempre significativo per lavorare con singole <xref:System.Char> oggetti. Ad esempio, nell'esempio seguente converte i punti di codice Unicode che rappresentano i numeri Egeo zero a 9 per unità di codice codificata UTF-16. Poiché erroneamente equivale <xref:System.Char> gli oggetti con caratteri, in modo non corretto segnala che la stringa risultante è di 20 caratteri.  
  
 [!code-csharp[System.Char.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/textelements2.cs#3)]
 [!code-vb[System.Char.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/textelements2.vb#3)]  
  
 È possibile eseguire il comando seguente per evitare il presupposto che un <xref:System.Char> oggetto rappresenta un singolo carattere.  
  
-   È possibile utilizzare un <xref:System.String> oggetto nella sua interezza invece di lavorare con dei singoli caratteri per rappresentare e analizzare contenuto linguistico.  
  
-   È possibile utilizzare il <xref:System.Globalization.StringInfo> classe per funzionare con gli elementi di testo anziché singoli <xref:System.Char> oggetti. L'esempio seguente usa il <xref:System.Globalization.StringInfo> oggetto per contare il numero di elementi di testo in una stringa che include l'Egee numeri pari a zero e nove. Perché considera una coppia di surrogati un singolo carattere, correttamente segnala che la stringa contiene dieci caratteri.  
  
     [!code-csharp[System.Char.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/textelements2a.cs#4)]
     [!code-vb[System.Char.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/textelements2a.vb#4)]  
  
-   Se una stringa contiene un carattere di base che contiene uno o più caratteri di combinazione, è possibile chiamare il <xref:System.String.Normalize%2A?displayProperty=nameWithType> metodo per convertire la sottostringa in una singola unità di codice con codifica UTF-16. Nell'esempio seguente viene chiamato il <xref:System.String.Normalize%2A?displayProperty=nameWithType> per convertire il carattere di base U + 0061 (LATIN SMALL LETTER A) e combinazione carattere U + 0308 (combinazione di LATINO) a U + 00E4 (LATIN SMALL lettera A con LATINO).  
  
     [!code-csharp[System.Char.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/normalized.cs#5)]
     [!code-vb[System.Char.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/normalized.vb#5)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Operazioni comuni  
 Il <xref:System.Char> struttura fornisce metodi per confrontare <xref:System.Char> oggetti, convertire il valore dell'oggetto corrente <xref:System.Char> dell'oggetto a un oggetto di un altro tipo e determinare la categoria Unicode di un <xref:System.Char> oggetto:  
  
|Operazione da eseguire|Usare questi `System.Char` metodi|  
|----------------|-------------------------------------|  
|Confrontare <xref:System.Char> oggetti|<xref:System.Char.CompareTo%2A> e <xref:System.Char.Equals%2A>|  
|Convertire una stringa di un punto di codice|<xref:System.Char.ConvertFromUtf32%2A>|  
|Convertire un <xref:System.Char> oggetto o una coppia di surrogati <xref:System.Char> oggetti da un punto di codice|Per un singolo carattere: <xref:System.Convert.ToInt32%28System.Char%29?displayProperty=nameWithType><br /><br /> Per una coppia di surrogati o un carattere in una stringa: <xref:System.Char.ConvertToUtf32%2A?displayProperty=nameWithType>|  
|Ottenere la categoria Unicode di un carattere|<xref:System.Char.GetUnicodeCategory%2A>|  
|Determinare se un carattere in una particolare categoria Unicode, ad esempio cifra, lettera, punteggiatura, carattere di controllo e così via|<xref:System.Char.IsControl%2A>, <xref:System.Char.IsDigit%2A>, <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLetter%2A>, <xref:System.Char.IsLetterOrDigit%2A>, <xref:System.Char.IsLower%2A>, <xref:System.Char.IsLowSurrogate%2A>, <xref:System.Char.IsNumber%2A>, <xref:System.Char.IsPunctuation%2A>, <xref:System.Char.IsSeparator%2A>, <xref:System.Char.IsSurrogate%2A>, <xref:System.Char.IsSurrogatePair%2A>, <xref:System.Char.IsSymbol%2A>, <xref:System.Char.IsUpper%2A>, e <xref:System.Char.IsWhiteSpace%2A>|  
|Convertire un <xref:System.Char> oggetto che rappresenta un numero in un tipo di valore numerico|<xref:System.Char.GetNumericValue%2A>|  
|Converte un carattere in una stringa in un <xref:System.Char> oggetto|<xref:System.Char.Parse%2A> e <xref:System.Char.TryParse%2A>|  
|Convertire un <xref:System.Char> l'oggetto in un <xref:System.String> oggetto|<xref:System.Char.ToString%2A>|  
|Nel caso di modifica un <xref:System.Char> oggetto|<xref:System.Char.ToLower%2A>, <xref:System.Char.ToLowerInvariant%2A>, <xref:System.Char.ToUpper%2A> e <xref:System.Char.ToUpperInvariant%2A>|  
  
<a name="Interop"></a>   
## <a name="char-values-and-interop"></a>Interoperabilità e valori Char  
Quando un oggetto gestito <xref:System.Char> tipo, che è rappresentata come un'unità di codice con codifica Unicode UTF-16, viene passato a codice non gestito, il marshalling di interoperabilità converte il set di caratteri da ANSI per impostazione predefinita. È possibile applicare il <xref:System.Runtime.InteropServices.DllImportAttribute> dichiarazioni di attributo in platform invoke e <xref:System.Runtime.InteropServices.StructLayoutAttribute> dell'attributo a una dichiarazione di interoperabilità COM per controllare quale set di caratteri un sottoposto a marshalling <xref:System.Char> tipo utilizzato.  
  
   
  
## Examples  
 Esempio di codice seguente vengono illustrati alcuni dei metodi in <xref:System.Char>.  
  
 [!code-cpp[System.Char &#91;Type Level&#93;#23](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char [Type Level]/CPP/charstructure.cpp#23)]
 [!code-csharp[System.Char &#91;Type Level&#93;#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char [Type Level]/CS/charstructure.cs#23)]
 [!code-vb[System.Char &#91;Type Level&#93;#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char [Type Level]/VB/charstructure.vb#23)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tutti i membri di questo tipo sono thread-safe. I membri che apparentemente modificano lo stato dell'istanza è in realtà restituiscono una nuova istanza inizializzata con il nuovo valore. Come con qualsiasi altro tipo, lettura e scrittura in una variabile condivisa che contiene un'istanza di questo tipo deve essere protetto da un blocco per garantire la thread safety.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta questa istanza con un oggetto o un tipo valore specificato e indica se l'istanza precede, segue o viene visualizzata nella stessa posizione dell'oggetto o tipo valore specificato all'interno dell'ordinamento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(char value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto <see cref="T:System.Char" /> da confrontare.</param>
        <summary>Confronta questa istanza con un oggetto <see cref="T:System.Char" /> specificato e indica se l'istanza precede, segue o viene visualizzata nella stessa posizione dell'oggetto <see cref="T:System.Char" /> specificato all'interno dell'ordinamento.</summary>
        <returns>Numero con segno che indica la posizione dell'istanza nell'ordinamento in relazione al parametro <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valore restituito  
  
 </term><description> Descrizione  
  
 </description></listheader><item><term> Minore di zero  
  
 </term><description> Questa istanza precede <paramref name="value" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> Questa istanza si trova nella stessa posizione di <paramref name="value" /> nell'ordinamento.  
  
 </description></item><item><term> Maggiore di zero  
  
 </term><description> L'istanza segue <paramref name="value" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia ed esegue leggermente migliori rispetto di <xref:System.Char.CompareTo%2A?displayProperty=nameWithType> metodo perché non è necessario convertire il `value` parametro a un oggetto.  
  
 Il confronto eseguito da questo metodo si basa sui valori codificati di questa istanza e `value`, non le loro caratteristiche lessicografiche.  
  
 Se il <xref:System.Char.CompareTo%2A> il tipo di parametro di metodo presenta meno bit (è più ristretto) rispetto al tipo di istanza, alcuni linguaggi di programmazione eseguono conversioni implicite che trasforma il valore del parametro in un valore con più bit.  
  
 Ad esempio, si supponga che sia il tipo di istanza <xref:System.Int32> e il tipo di parametro è <xref:System.Byte>. Il compilatore Microsoft c# genera istruzioni per rappresentare il valore del parametro come un <xref:System.Int32> , quindi genera un <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> metodo che confronta i valori del <xref:System.Int32> istanza e <xref:System.Int32> parametro rappresentazione.  
  
 In genere, le conversioni di ampliamento implicite vengono eseguite su tipi numerici. Consultare la documentazione del linguaggio di programmazione per determinare se il compilatore esegue conversioni di ampliamento. Se la mancata corrispondenza tipi di istanza e di parametro e una conversione appropriata non è disponibile, il compilatore genera le istruzioni per convertire il parametro e richiamare il <xref:System.Char.CompareTo%2A> overload che accetta un <xref:System.Object> parametro.  
  
   
  
## Examples  
 Esempio di codice seguente vengono illustrate le versioni non generiche e del `CompareTo` metodo per diversi tipi di riferimento e valore.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto da confrontare con questa istanza o <see langword="null" />.</param>
        <summary>Confronta questa istanza con un oggetto specificato e indica se l'istanza precede, segue o viene visualizzata nella stessa posizione dell'oggetto <see cref="T:System.Object" /> specificato all'interno dell'ordinamento.</summary>
        <returns>Numero con segno che indica la posizione dell'istanza nell'ordinamento in relazione al parametro <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valore restituito  
  
 </term><description> Descrizione  
  
 </description></listheader><item><term> Minore di zero  
  
 </term><description> Questa istanza precede <paramref name="value" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> Questa istanza si trova nella stessa posizione di <paramref name="value" /> nell'ordinamento.  
  
 </description></item><item><term> Maggiore di zero  
  
 </term><description> L'istanza segue <paramref name="value" />.  
  
 oppure  
  
 <paramref name="value" /> è <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Char.CompareTo%2A> metodo implementa il <xref:System.IComparable> interfaccia.  
  
 Il `value` parametro deve essere `null` o un'istanza di <xref:System.Char>; in caso contrario, viene generata un'eccezione.  
  
 Il confronto eseguito da questo metodo si basa sui valori codificati di questa istanza e `value`, non necessariamente le loro caratteristiche lessicografiche. Qualsiasi istanza di <xref:System.Char>, indipendentemente dal valore, viene considerato maggiore `null`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.CompareTo%2A>.  
  
 [!code-cpp[System.Char.CompareTo#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.CompareTo/CPP/compareto.cpp#19)]
 [!code-csharp[System.Char.CompareTo#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.CompareTo/CS/compareto.cs#19)]
 [!code-vb[System.Char.CompareTo#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.CompareTo/VB/compareto.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> non è un oggetto <see cref="T:System.Char" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertFromUtf32">
      <MemberSignature Language="C#" Value="public static string ConvertFromUtf32 (int utf32);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ConvertFromUtf32(int32 utf32) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertFromUtf32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertFromUtf32 (utf32 As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ConvertFromUtf32(int utf32);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf32" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="utf32">Punto di codice Unicode a 21 bit.</param>
        <summary>Converte il punto di codice Unicode specificato in una stringa codificata UTF-16.</summary>
        <returns>Stringa costituita da un unico oggetto <see cref="T:System.Char" /> o da una coppia di surrogati di oggetti <see cref="T:System.Char" /> equivalente al punto di codice specificato dal parametro <paramref name="utf32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per convertire un punto di codice Unicode a 21 bit in una stringa codificata UTF-16 prima di testare la stringa con metodi come <xref:System.Char.IsLowSurrogate%28System.Char%29> e <xref:System.Char.IsHighSurrogate%28System.Char%29>.  
  
 Un punto di codice valido all'esterno di BMP Basic Multilingual Plane () restituisce sempre una coppia di surrogati valide. Tuttavia, un punto di codice valido all'interno di BMP potrebbe non produrre un risultato valido in base allo standard Unicode perché non viene utilizzata alcuna elaborazione linguistica durante la conversione. Per questo motivo, usare la <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> classe convertire bulk dei dati UTF-32 in dati UTF-16.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Char.ConvertToUtf32%2A> e <xref:System.Char.ConvertFromUtf32%2A> metodi.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="utf32" /> non è un punto di codice Unicode a 21 bit valido compreso tra U + 0 e U + 10FFFF, escluso l'intervallo della coppia di surrogati da U + D800 a U + DFFF.</exception>
        <altmember cref="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertToUtf32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore di una coppia di surrogati codificata UTF-16 in un punto di codice Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (highSurrogate As Char, lowSurrogate As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(char highSurrogate, char lowSurrogate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Unità di codice surrogato alto, ovvero un'unità di codice compreso tra U+D800 e U+DBFF.</param>
        <param name="lowSurrogate">Unità di codice surrogato basso, ovvero un'unità di codice compreso tra U+DC00 e U+DFFF.</param>
        <summary>Converte il valore di una coppia di surrogati codificata UTF-16 in un punto di codice Unicode.</summary>
        <returns>Punto di codice Unicode a 21 bit rappresentato dai parametri <paramref name="highSurrogate" /> e <paramref name="lowSurrogate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per convertire una coppia di surrogati in un punto di codice Unicode a 21 bit. Per convertire i dati UTF-16 in dati UTF-32, utilizzare la <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> classe.  
  
 In genere, la codifica UTF-16 rappresenta un singolo carattere Unicode come un'unità di codice a 16 bit. Tuttavia, supporta inoltre le coppie di surrogati, che consentono un singolo carattere astratto essere rappresentato come due unità di codice a 16 bit. I due <xref:System.Char> degli oggetti devono essere unità di codice intervallo tra U + D800 e U + DBFF per il primo surrogato (alto) e tra U + DC00 e U + DFFF per il secondo surrogato (basso). Le coppie di surrogati sono supportate solo da UTF-16 codifica. Questo metodo consente a un carattere rappresentato da una coppia di surrogati UTF-16 da convertire in un carattere utilizzando la codifica UTF-32.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Char.ConvertToUtf32%2A> e <xref:System.Char.ConvertFromUtf32%2A> metodi.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="highSurrogate" /> non è compreso nell'intervallo tra U+D800 e U+DBFF o <paramref name="lowSurrogate" /> non è compreso nell'intervallo tra U+DC00 e U+DFFF.</exception>
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (s As String, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Stringa che contiene un carattere o una coppia di surrogati.</param>
        <param name="index">Posizione di indice del carattere o della coppia di surrogati all'interno di <c>s</c>.</param>
        <summary>In corrispondenza della posizione specificata all'interno di una stringa, converte il valore di un carattere o di una coppia di surrogati con codifica UTF-16 in un punto di codice Unicode.</summary>
        <returns>Punto di codice Unicode a 21 bit rappresentato dal carattere o dalla coppia di surrogati in corrispondenza della posizione indicata dal parametro <paramref name="s" /> specificato nel parametro <paramref name="index" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per convertire una coppia di surrogati o carattere in un punto di codice Unicode a 21 bit. Per convertire i dati UTF-16 in dati UTF-32, utilizzare la <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> classe.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Char.ConvertToUtf32%2A> e <xref:System.Char.ConvertFromUtf32%2A> metodi.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è una posizione all'interno di <paramref name="s" />.</exception>
        <exception cref="T:System.ArgumentException">La posizione di indice specificata contiene una coppia di surrogati in cui il primo carattere non è un surrogato alto valido oppure il secondo carattere non è un surrogato basso valido.</exception>
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un valore che indica se questa istanza è uguale a un oggetto o a un valore <see cref="T:System.Char" /> specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (char obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(char obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(char obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con questa istanza.</param>
        <summary>Restituisce un valore che indica se questa istanza è uguale all'oggetto <see cref="T:System.Char" /> specificato.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="obj" /> è uguale al valore di questa istanza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il <xref:System.IEquatable%601?displayProperty=nameWithType> interfaccia ed esegue leggermente migliori rispetto <xref:System.Char.Equals%28System.Object%29?displayProperty=nameWithType> perché non è necessario eseguire la conversione unboxing di `obj` parametro.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con questa istanza o <see langword="null" />.</param>
        <summary>Restituisce un valore che indica se questa istanza è uguale a un oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> è un'istanza di <see cref="T:System.Char" /> ed è uguale al valore dell'istanza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il confronto eseguito da questo metodo si basa sui valori codificati di questa istanza e `obj`, non necessariamente le loro caratteristiche lessicografiche.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.Equals%2A>.  
  
 [!code-cpp[System.Char.Equals#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.Equals/CPP/equals.cpp#20)]
 [!code-csharp[System.Char.Equals#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.Equals/CS/equals.cs#20)]
 [!code-vb[System.Char.Equals#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Equals/VB/equals.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNumericValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte un carattere numerico Unicode specificato in un numero a virgola mobile a precisione doppia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (c As Char) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da convertire.</param>
        <summary>Converte il carattere numerico Unicode specificato in un numero a virgola mobile a precisione doppia.</summary>
        <returns>Il valore numerico di <paramref name="c" /> se tale carattere rappresenta un numero; in caso contrario, -1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `c` parametro deve essere il <xref:System.Char> rappresentazione di un valore numerico. Ad esempio, se `c` è "5", il valore restituito è 5. Tuttavia, se `c` è "z", il valore restituito è -1,0.  
  
 Un carattere dispone di un valore numerico associato se e solo se è un membro di uno dei seguenti <xref:System.Globalization.UnicodeCategory> categorie: `DecimalDigitNumber`, `LetterNumber`, o `OtherNumber`.  
  
 Il <xref:System.Char.GetNumericValue%2A> metodo presuppone che `c` corrisponde a un solo carattere linguistico e verificare se tale carattere può essere convertito in una cifra decimale. Tuttavia, alcuni numeri nello standard Unicode vengono rappresentati da due <xref:System.Char> gli oggetti che formano una coppia di surrogati. Ad esempio, il sistema di numerazione Egeo è costituito da punti di codice U + 10107 e U + 10133. L'esempio seguente usa il <xref:System.Char.ConvertFromUtf32%2A> metodo per creare un'istanza di una stringa che rappresenta numero uno EGEO. Come illustrato nell'esempio, l'output di <xref:System.Char.GetNumericValue%28System.Char%29> metodo restituisce -1 se viene passato un surrogato alto o un surrogato basso di questo carattere.  
  
 [!code-csharp[System.Char.GetNumericValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue1.cs#2)]
 [!code-vb[System.Char.GetNumericValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb#2)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato <xref:System.Char.GetNumericValue%2A>.  
  
 [!code-cpp[System.Char.GetNumericValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp#1)]
 [!code-csharp[System.Char.GetNumericValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue.cs#1)]
 [!code-vb[System.Char.GetNumericValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (s As String, index As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Oggetto <see cref="T:System.String" />.</param>
        <param name="index">Posizione del carattere in <c>s</c>.</param>
        <summary>Converte il carattere numerico Unicode nella posizione specificata di una determinata stringa in un numero a virgola mobile a precisione doppia.</summary>
        <returns>Valore numerico del carattere alla posizione <paramref name="index" /> in <paramref name="s" /> se tale carattere rappresenta un numero; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `s` parametro deve essere la rappresentazione di stringa di un valore numerico. Ad esempio, se il carattere alla posizione `index` in `s` è "5", il valore restituito è 5. Tuttavia, se il carattere alla posizione `index` in `s` è "z", il valore restituito è -1.  
  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Un carattere dispone di un valore numerico associato se e solo se è un membro di uno dei seguenti <xref:System.Globalization.UnicodeCategory> categorie: `DecimalDigitNumber`, `LetterNumber`, o `OtherNumber`.  
  
 Se il <xref:System.Char> oggetto posizione `index` è il primo carattere di una coppia di surrogati valide, la <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> metodo determina se la coppia di surrogati forma una cifra numerica. Ad esempio, il sistema di numerazione Egeo è costituito da punti di codice U + 10107 e U + 10133. L'esempio seguente usa il <xref:System.Char.ConvertFromUtf32%2A> metodo per creare un'istanza di una stringa che rappresenta ogni numero Egeo. Come illustrato nell'esempio, l'output di <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> metodo restituisce il valore numerico corretto se viene passato il surrogato alto di un numero Egeo. Tuttavia, se viene passato il surrogato basso, considera solo il surrogato basso in isolamento e restituisce -1.  
  
 [!code-csharp[System.Char.GetNumericValue#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue1.cs#3)]
 [!code-vb[System.Char.GetNumericValue#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb#3)]  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.GetNumericValue%2A>.  
  
 [!code-cpp[System.Char.GetNumericValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp#1)]
 [!code-csharp[System.Char.GetNumericValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue.cs#1)]
 [!code-vb[System.Char.GetNumericValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.TypeCode" /> del tipo di valore <see cref="T:System.Char" />.</summary>
        <returns>Costante enumerata <see cref="F:System.TypeCode.Char" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetUnicodeCategory">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Categorizza un carattere Unicode in un gruppo identificato da uno dei valori <see cref="T:System.Globalization.UnicodeCategory" />.</summary>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (c As Char) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da suddividere in categorie.</param>
        <summary>Categorizza un carattere Unicode specificato in un gruppo identificato da uno dei valori <see cref="T:System.Globalization.UnicodeCategory" />.</summary>
        <returns>Valore <see cref="T:System.Globalization.UnicodeCategory" /> che identifica il gruppo che contiene <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> metodo non restituisce sempre lo stesso <xref:System.Globalization.UnicodeCategory> valore come il <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> metodo quando viene passato come parametro un carattere specifico. Il <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> metodo è progettato in modo da riflettere la versione corrente dello standard Unicode. Al contrario, sebbene il <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> metodo in genere riflette la versione corrente dello standard Unicode, può restituire una la categoria di carattere in base a una versione precedente dello standard o può restituire una categoria che è diverso dallo standard corrente in ordine Per mantenere la compatibilità con le versioni precedenti. Di conseguenza, è consigliabile utilizzare il <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> anziché <xref:System.Char.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType>.  
  
 A partire dal [!INCLUDE[net_v462](~/includes/net-v462-md.md)], caratteri Unicode vengono classificati in base alle [lo Unix Standard, versione 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). Nelle versioni di .NET Framework dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] per il [!INCLUDE[net_v461](~/includes/net-v461-md.md)], sono classificati in base a [lo Unix Standard, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.GetUnicodeCategory%2A>.  
  
 [!code-cpp[System.Char.GetUnicodeCategory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CPP/getunicodecategory.cpp#1)]
 [!code-csharp[System.Char.GetUnicodeCategory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CS/getunicodecategory.cs#1)]
 [!code-vb[System.Char.GetUnicodeCategory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/VB/getunicodecategory.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (s As String, index As Integer) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Oggetto <see cref="T:System.String" />.</param>
        <param name="index">Posizione del carattere in <c>s</c>.</param>
        <summary>Categorizza il carattere in corrispondenza della posizione specificata in una determinata stringa in un gruppo identificato da uno dei valori <see cref="T:System.Globalization.UnicodeCategory" />.</summary>
        <returns>Costante enumerata <see cref="T:System.Globalization.UnicodeCategory" /> che identifica il gruppo contenente il carattere alla posizione <paramref name="index" /> in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Il <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> metodo non restituisce sempre lo stesso <xref:System.Globalization.UnicodeCategory> valore come il <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metodo quando viene passato come parametro un carattere specifico. Il <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metodo è progettato in modo da riflettere la versione corrente dello standard Unicode. Al contrario, sebbene il <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> metodo in genere riflette la versione corrente dello standard Unicode, può restituire una la categoria di carattere in base a una versione precedente dello standard o può restituire una categoria che è diverso dallo standard corrente in ordine Per mantenere la compatibilità con le versioni precedenti. Di conseguenza, è consigliabile utilizzare il <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> anziché <xref:System.Char.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>.  
  
 A partire dal [!INCLUDE[net_v462](~/includes/net-v462-md.md)], caratteri Unicode vengono classificati in base alle [lo Unix Standard, versione 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). Nelle versioni di .NET Framework dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] per il [!INCLUDE[net_v461](~/includes/net-v461-md.md)], sono classificati in base a [lo Unix Standard, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato <xref:System.Char.GetUnicodeCategory%2A>.  
  
 [!code-cpp[System.Char.GetUnicodeCategory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CPP/getunicodecategory.cpp#1)]
 [!code-csharp[System.Char.GetUnicodeCategory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CS/getunicodecategory.cs#1)]
 [!code-vb[System.Char.GetUnicodeCategory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/VB/getunicodecategory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsControl">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se uno specifico carattere Unicode è stato categorizzato come carattere di controllo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formattano i caratteri di controllo e altri caratteri non stampabili, ad esempio ACK, BEL, CR, FF, LF e VT. Lo standard Unicode assegna i punti di codice compresi tra \U0000 a \U001F, \U007F e da \U0080 a \U009F. per i caratteri di controllo. In base allo standard Unicode, questi valori devono essere interpretati come caratteri di controllo, a meno che l'utilizzo in caso contrario è definito da un'applicazione. Caratteri di controllo validi sono membri del <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoria.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere Unicode specificato è stato categorizzato come carattere di controllo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è un carattere di controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Formattano i caratteri di controllo e altri caratteri non stampabili, ad esempio ACK, BEL, CR, FF, LF e VT. T lo standard Unicode assegna i punti di codice compresi tra \U0000 a \U001F, \U007F e da \U0080 a \U009F. per i caratteri di controllo. In base allo standard Unicode, questi valori devono essere interpretati come caratteri di controllo, a meno che l'utilizzo in caso contrario è definito da un'applicazione. Caratteri di controllo validi sono membri del <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoria.  
  
   
  
## Examples  
 Nell'esempio seguente viene elencato il punto di codice Unicode di ogni carattere di controllo.  
  
 [!code-cpp[System.Char.IsControl#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol1.cpp#1)]
 [!code-csharp[System.Char.IsControl#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsControl/CS/IsControl1.cs#1)]
 [!code-vb[System.Char.IsControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa è stato categorizzato come carattere di controllo.</summary>
        <returns>
          <see langword="true" /> se il carattere alla posizione <paramref name="index" /> in <paramref name="s" /> è un carattere di controllo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Formattano i caratteri di controllo e altri caratteri non stampabili, ad esempio ACK, BEL, CR, FF, LF e VT. Lo standard Unicode assegna i punti di codice compresi tra \U0000 a \U001F, \U007F e da \U0080 a \U009F. per i caratteri di controllo. In base allo standard Unicode, questi valori devono essere interpretati come caratteri di controllo, a meno che l'utilizzo in caso contrario è definito da un'applicazione. Caratteri di controllo validi sono membri del <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoria.  
  
   
  
## Examples  
 Nell'esempio seguente enumera i caratteri in una stringa e determina se qualsiasi sono caratteri di controllo.  
  
 [!code-cpp[System.Char.IsControl#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol2.cpp#2)]
 [!code-csharp[System.Char.IsControl#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsControl/CS/IsControl2.cs#2)]
 [!code-vb[System.Char.IsControl#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se un carattere Unicode è stato categorizzato come cifra decimale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le cifre valide sono membri del <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> categoria.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere Unicode specificato è stato categorizzato come cifra decimale.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è una cifra decimale; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina se un <xref:System.Char> è una radice di 10. Questo contrasta con <xref:System.Char.IsNumber%2A>, che determina se un `Char` è di qualsiasi categoria Unicode numerica. Numeri includono caratteri come frazioni, indici, gli apici, i numeri romani, numeratori di valuta, numeri cerchiati e cifre specifiche dello script.  
  
 Le cifre valide sono membri del <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> categoria.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsDigit%2A>.  
  
 [!code-cpp[System.Char.IsDigit#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsDigit/CPP/isdigit.cpp#4)]
 [!code-csharp[System.Char.IsDigit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsDigit/CS/isdigit.cs#4)]
 [!code-vb[System.Char.IsDigit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsDigit/VB/isdigit.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa è stato categorizzato come cifra decimale.</summary>
        <returns>
          <see langword="true" /> se il carattere alla posizione <paramref name="index" /> in <paramref name="s" /> è una cifra decimale; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina se un <xref:System.Char> è una radice di 10. Questo contrasta con <xref:System.Char.IsNumber%2A>, che determina se un <xref:System.Char> è di qualsiasi categoria Unicode numerica. Numeri includono caratteri come frazioni, indici, gli apici, i numeri romani, numeratori di valuta, numeri cerchiati e cifre specifiche dello script.  
  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Le cifre valide sono membri del <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> categoria.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsDigit%2A>.  
  
 [!code-cpp[System.Char.IsDigit#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsDigit/CPP/isdigit.cpp#4)]
 [!code-csharp[System.Char.IsDigit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsDigit/CS/isdigit.cs#4)]
 [!code-vb[System.Char.IsDigit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsDigit/VB/isdigit.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsHighSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se l'oggetto <see cref="T:System.Char" /> specificato è un surrogato alto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se l'oggetto <see cref="T:System.Char" /> specificato è un surrogato alto.</summary>
        <returns>
          <see langword="true" /> se il valore numerico del parametro <paramref name="c" /> è compreso tra U+D800 e U+DBFF; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oltre a rappresentare singoli caratteri utilizzando un punto di codice a 16 bit, la codifica UTF-16 consente caratteri astratte essere rappresentato con due punti di codice a 16 bit, noto come una coppia di surrogati. Il primo elemento in questa coppia è il surrogato alto. Il punto di codice può variare da U + D800 e U + DBFF. Un singolo surrogato dispone di alcuna interpretazione propria; è significativo solo se utilizzato come parte di una coppia di surrogati.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, e <xref:System.Char.IsSurrogatePair%2A> metodi.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se l'oggetto <see cref="T:System.Char" /> in corrispondenza della posizione specificata all'interno di una stringa è un surrogato alto.</summary>
        <returns>
          <see langword="true" /> se il valore numerico del carattere specificato contenuto nel parametro <paramref name="s" /> è compreso tra U+D800 e U+DBFF; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `index` in base zero.  
  
 Oltre a rappresentare singoli caratteri utilizzando un punto di codice a 16 bit, la codifica UTF-16 consente caratteri astratte essere rappresentato con due punti di codice a 16 bit, noto come una coppia di surrogati. Il primo elemento in questa coppia è il surrogato alto. Il punto di codice può variare da U + D800 e U + DBFF. Un singolo surrogato dispone di alcuna interpretazione propria; è significativo solo se utilizzato come parte di una coppia di surrogati.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, e <xref:System.Char.IsSurrogatePair%2A> metodi.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è una posizione all'interno di <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetter">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se un carattere Unicode è categorizzato come lettera Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina se un <xref:System.Char> è un membro di una categoria della lettera Unicode. Le lettere Unicode includono quanto segue:  
  
-   Lettere maiuscole, ad esempio U + 0041 (lettera latina a maiuscola) e U + 005A (LATIN CAPITAL LETTER Z), U + 0400 (CIRILLICO lettera maiuscola IE con accento GRAVE) a U + 042F (CIRILLICO capitale ALFABETO) o. Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> categoria.  
  
-   Lettere minuscole, ad esempio U + 0061 (LATIN SMALL LETTER A) a U + 007A (lettera latina Z), U + 03AC o (greco SMALL lettera alfa con TONOS) a U + 03CE (greco SMALL lettera OMEGA con TONOS). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> categoria.  
  
-   Titolo di lettere maiuscole, ad esempio U + 01 C 5 (LATIN CAPITAL LETTER D con piccole lettera Z con PIPA) o U + 1FFC (greco lettera maiuscola OMEGA con PROSGEGRAMMENI). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> categoria.  
  
-   Modificatori, U + 02B0 (carattere) e U + 02C 1 (modificatore lettera REVERSED GLOTTAL STOP), U + 1D2C o (modificatore lettera maiuscola A) a U + 1D 61 (modificatore chi minuscolo). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> categoria.  
  
-   Altre lettere, ad esempio U + 05 D 0 (EBRAICO LETTER ALEF) a U + 05EA (EBRAICO ALFABETO EBRAICO), U + 0621 (lettera araba HAMZA) a U + 063A (ARABO ALFABETO ARABO) o U + 4E00 (\<degli ideogrammi CJK, prima >) a U + 9 FC 3 (\<degli ideogrammi CJK, ultimo >). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> categoria.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere Unicode specificato è stato categorizzato come lettera Unicode.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è una lettera; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina se un <xref:System.Char> è un membro di una categoria della lettera Unicode. Le lettere Unicode includono quanto segue:  
  
-   Lettere maiuscole, ad esempio U + 0041 (lettera latina a maiuscola) e U + 005A (LATIN CAPITAL LETTER Z), U + 0400 (CIRILLICO lettera maiuscola IE con accento GRAVE) a U + 042F (CIRILLICO capitale ALFABETO) o. Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> categoria.  
  
-   Lettere minuscole, ad esempio U + 0061 (LATIN SMALL LETTER A) a U + 007A (lettera latina Z), U + 03AC o (greco SMALL lettera alfa con TONOS) a U + 03CE (greco SMALL lettera OMEGA con TONOS). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> categoria.  
  
-   Titolo di lettere maiuscole, ad esempio U + 01 C 5 (LATIN CAPITAL LETTER D con piccole lettera Z con PIPA) o U + 1FFC (greco lettera maiuscola OMEGA con PROSGEGRAMMENI). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> categoria.  
  
-   Modificatori, U + 02B0 (carattere) e U + 02C 1 (modificatore lettera REVERSED GLOTTAL STOP), U + 1D2C o (modificatore lettera maiuscola A) a U + 1D 61 (modificatore chi minuscolo). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> categoria.  
  
-   Altre lettere, ad esempio U + 05 D 0 (EBRAICO LETTER ALEF) a U + 05EA (EBRAICO ALFABETO EBRAICO), U + 0621 (lettera araba HAMZA) a U + 063A (ARABO ALFABETO ARABO) o U + 4E00 (\<degli ideogrammi CJK, prima >) a U + 9 FC 3 (\<degli ideogrammi CJK, ultimo >). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> categoria.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsLetter%2A>.  
  
 [!code-cpp[System.Char.IsLetter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetter/CPP/isletter.cpp#5)]
 [!code-csharp[System.Char.IsLetter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetter/CS/isletter.cs#5)]
 [!code-vb[System.Char.IsLetter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetter/VB/isletter.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa è stato categorizzato come lettera Unicode.</summary>
        <returns>
          <see langword="true" /> se il carattere alla posizione <paramref name="index" /> in <paramref name="s" /> è una lettera; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Questo metodo determina se il carattere alla posizione di indice specificata in una stringa è un membro di una categoria della lettera Unicode. Le lettere Unicode includono quanto segue:  
  
-   Lettere maiuscole, ad esempio U + 0041 (lettera latina a maiuscola) e U + 005A (LATIN CAPITAL LETTER Z), U + 0400 (CIRILLICO lettera maiuscola IE con accento GRAVE) a U + 042F (CIRILLICO capitale ALFABETO) o. Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> categoria.  
  
-   Lettere minuscole, ad esempio U + 0061 (LATIN SMALL LETTER A) a U + 007A (lettera latina Z), U + 03AC o (greco SMALL lettera alfa con TONOS) a U + 03CE (greco SMALL lettera OMEGA con TONOS). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> categoria.  
  
-   Titolo di lettere maiuscole, ad esempio U + 01 C 5 (LATIN CAPITAL LETTER D con piccole lettera Z con PIPA) o U + 1FFC (greco lettera maiuscola OMEGA con PROSGEGRAMMENI). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> categoria.  
  
-   Modificatori, U + 02B0 (carattere) e U + 02C 1 (modificatore lettera REVERSED GLOTTAL STOP), U + 1D2C o (modificatore lettera maiuscola A) a U + 1D 61 (modificatore chi minuscolo). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> categoria.  
  
-   Altre lettere, ad esempio U + 05 D 0 (EBRAICO LETTER ALEF) a U + 05EA (EBRAICO ALFABETO EBRAICO), U + 0621 (lettera araba HAMZA) a U + 063A (ARABO ALFABETO ARABO) o U + 4E00 (\<degli ideogrammi CJK, prima >) a U + 9 FC 3 (\<degli ideogrammi CJK, ultimo >). Questi caratteri sono membri del <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> categoria.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsLetter%2A>.  
  
 [!code-cpp[System.Char.IsLetter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetter/CPP/isletter.cpp#5)]
 [!code-csharp[System.Char.IsLetter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetter/CS/isletter.cs#5)]
 [!code-vb[System.Char.IsLetter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetter/VB/isletter.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetterOrDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se un carattere Unicode è stato categorizzato come lettera o cifra decimale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le lettere valide e cifre decimali sono membri delle categorie seguenti in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, o `DecimalDigitNumber`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere Unicode specificato è stato categorizzato come lettera o cifra decimale.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è una lettera o una cifra decimale; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le lettere valide e cifre decimali sono membri delle categorie seguenti in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, o `DecimalDigitNumber`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsLetterOrDigit%2A>.  
  
 [!code-cpp[System.Char.IsLetterOrDigit#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CPP/isletterordigit.cpp#6)]
 [!code-csharp[System.Char.IsLetterOrDigit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CS/isletterordigit.cs#6)]
 [!code-vb[System.Char.IsLetterOrDigit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/VB/isletterordigit.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa è stato categorizzato come lettera o cifra decimale.</summary>
        <returns>
          <see langword="true" /> se il carattere alla posizione <paramref name="index" /> in <paramref name="s" /> è una lettera o una cifra decimale; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Le lettere valide e cifre decimali sono membri delle categorie seguenti in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, o `DecimalDigitNumber`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsLetterOrDigit%2A>.  
  
 [!code-cpp[System.Char.IsLetterOrDigit#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CPP/isletterordigit.cpp#6)]
 [!code-csharp[System.Char.IsLetterOrDigit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CS/isletterordigit.cs#6)]
 [!code-vb[System.Char.IsLetterOrDigit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/VB/isletterordigit.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se un carattere Unicode è stato categorizzato come lettera minuscola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere Unicode specificato è stato categorizzato come lettera minuscola.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è una lettera minuscola; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le lettere minuscole valide sono membri della categoria di seguito in <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsLower%2A>.  
  
 [!code-cpp[System.Char.IsLower#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLower/CPP/islower.cpp#7)]
 [!code-csharp[System.Char.IsLower#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLower/CS/islower.cs#7)]
 [!code-vb[System.Char.IsLower#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLower/VB/islower.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa è stato categorizzato come lettera minuscola.</summary>
        <returns>
          <see langword="true" /> se il carattere alla posizione <paramref name="index" /> in <paramref name="s" /> è una lettera minuscola; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Le lettere minuscole valide sono membri della categoria di seguito in <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsLower%2A>.  
  
 [!code-cpp[System.Char.IsLower#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLower/CPP/islower.cpp#7)]
 [!code-csharp[System.Char.IsLower#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLower/CS/islower.cs#7)]
 [!code-vb[System.Char.IsLower#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLower/VB/islower.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLowSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se l'oggetto <see cref="T:System.Char" /> specificato è un surrogato basso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere da valutare.</param>
        <summary>Indica se l'oggetto <see cref="T:System.Char" /> specificato è un surrogato basso.</summary>
        <returns>
          <see langword="true" /> se il valore numerico del parametro <paramref name="c" /> è compreso tra U+DC00 e U+DFFF; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oltre a rappresentare singoli caratteri utilizzando un punto di codice a 16 bit, la codifica UTF-16 consente caratteri astratte essere rappresentato con due punti di codice a 16 bit, noto come una coppia di surrogati. Il secondo elemento in questa coppia è il surrogato basso. Il punto di codice può variare da U + DC00 e U + DFFF. Un singolo surrogato dispone di alcuna interpretazione propria; è significativo solo se utilizzato come parte di una coppia di surrogati.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, e <xref:System.Char.IsSurrogatePair%2A> metodi.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se l'oggetto <see cref="T:System.Char" /> in corrispondenza della posizione specificata all'interno di una stringa è un surrogato basso.</summary>
        <returns>
          <see langword="true" /> se il valore numerico del carattere specificato contenuto nel parametro <paramref name="s" /> è compreso tra U+DC00 e U+DFFF; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `index` in base zero.  
  
 Oltre a rappresentare singoli caratteri utilizzando un punto di codice a 16 bit, la codifica UTF-16 consente caratteri astratte essere rappresentato con due punti di codice a 16 bit, noto come una coppia di surrogati. Il secondo elemento in questa coppia è il surrogato basso. Il punto di codice può variare da U + DC00 e U + DFFF. Un singolo surrogato dispone di alcuna interpretazione propria; è significativo solo se utilizzato come parte di una coppia di surrogati.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, e <xref:System.Char.IsSurrogatePair%2A> metodi.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è una posizione all'interno di <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNumber">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se un carattere Unicode è stato categorizzato come numero.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere Unicode specificato è stato categorizzato come numero.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è un numero; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina se un <xref:System.Char> è di qualsiasi categoria Unicode numerica. Oltre a includere cifre, numeri includono caratteri, frazioni, indici, gli apici, i numeri romani, numeratori di valuta e numeri cerchiati. Questo metodo è in contrasto con la <xref:System.Char.IsDigit%2A> metodo, che determina se un <xref:System.Char> è una radice di 10.  
  
> [!IMPORTANT]
>  Il <xref:System.Char.IsNumber%28System.Char%29> metodo non è progettato per determinare se una stringa costituita da caratteri numerici (ad esempio, chiamando il metodo per ogni carattere in una stringa). Per determinare se una stringa costituita da caratteri numerici, chiamare uno degli overload di `TryParse` metodo (ad esempio <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> o <xref:System.Double.TryParse%2A?displayProperty=nameWithType> di un tipo integrale o a virgola mobile.  
  
 I numeri validi sono membri del <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, o <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> categoria.  
  
 Il <xref:System.Char.IsNumber%28System.Char%29> metodo presuppone che `c` corrisponde a un solo carattere linguistico e controlla se tale carattere rappresenta un numero. Tuttavia, alcuni numeri nello standard Unicode vengono rappresentati da due <xref:System.Char> gli oggetti che formano una coppia di surrogati. Ad esempio, il sistema di numerazione Egeo è costituito da punti di codice U + 10107 e U + 10133. L'esempio seguente usa il <xref:System.Char.ConvertFromUtf32%2A> metodo per creare un'istanza di una stringa che rappresenta numero uno EGEO. Come illustrato nell'esempio, l'output di <xref:System.Char.IsNumber%28System.Char%29> restituisce `false` se viene passato un surrogato alto o un surrogato basso di questo carattere.  
  
 [!code-csharp[System.Char.IsNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber1.cs#1)]
 [!code-vb[System.Char.IsNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb#1)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato <xref:System.Char.IsNumber%2A>.  
  
 [!code-cpp[System.Char.IsNumber#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp#8)]
 [!code-csharp[System.Char.IsNumber#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber.cs#8)]
 [!code-vb[System.Char.IsNumber#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa è stato categorizzato come numero.</summary>
        <returns>
          <see langword="true" /> se il carattere alla posizione <paramref name="index" /> in <paramref name="s" /> è un numero; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo determina se un <xref:System.Char> è di qualsiasi categoria Unicode numerica. Oltre a includere cifre, numeri includono caratteri, frazioni, indici, gli apici, i numeri romani, numeratori di valuta e numeri cerchiati. Questo metodo è in contrasto con la <xref:System.Char.IsDigit%2A> metodo, che determina se un <xref:System.Char> è una radice di 10.  
  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
> [!IMPORTANT]
>  Il <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> metodo non è progettato per determinare se una stringa costituita da caratteri numerici (ad esempio, chiamando il metodo per ogni carattere in una stringa). Per determinare se una stringa costituita da caratteri numerici, chiamare uno degli overload di `TryParse` metodo (ad esempio <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> o <xref:System.Double.TryParse%2A?displayProperty=nameWithType> di un tipo integrale o a virgola mobile.  
  
 I numeri validi sono membri del <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, o <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> categoria.  
  
 Se il <xref:System.Char> oggetto posizione `index` è il primo carattere di una coppia di surrogati valide, la <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> metodo determina se la coppia di surrogati forma una cifra numerica. Ad esempio, il sistema di numerazione Egeo è costituito da punti di codice U + 10107 e U + 10133. L'esempio seguente usa il <xref:System.Char.ConvertFromUtf32%2A> metodo per creare un'istanza di una stringa che rappresenta numero uno EGEO. Come illustrato nell'esempio, l'output di <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> restituisce `true` se viene passato il surrogato alto del numero uno EGEO. Tuttavia, se viene passato il surrogato basso, prende in considerazione solo la categoria di surrogato basso e restituisce `false`.  
  
 [!code-csharp[System.Char.IsNumber#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber1.cs#2)]
 [!code-vb[System.Char.IsNumber#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb#2)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato <xref:System.Char.IsNumber%2A>.  
  
 [!code-cpp[System.Char.IsNumber#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp#8)]
 [!code-csharp[System.Char.IsNumber#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber.cs#8)]
 [!code-vb[System.Char.IsNumber#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPunctuation">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se un carattere Unicode è stato categorizzato come segno di punteggiatura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Segni di punteggiatura validi sono membri delle categorie seguenti in <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, o `OtherPunctuation`. Includono caratteri con punti di codice Unicode elencati nella tabella seguente.  
  
|||||  
|-|-|-|-|  
|U + 0021 a U + 0023|U + 060C e U + 060D|U + 1800 a U + 180A|U + 3014 a U + 301F|  
|U + 0025 a U + 002A|U+061B|U + 1944 e U + 1945|U+3030|  
|U + 002C a U + 002F|U + 061E e U + 061F|U + 19DE e U + 19DF|U + 303D|  
|U + 003A e U + 003B|U + 066A a U + 066D|U + 1A1E e U + 1A1F|U + 30A0|  
|U + 003F e U + 0040|U + 06D 4|U + 1B5A a U + 1B60|U + 30FB|  
|U + 005B a U + D 005|U + 0700 a U + D 070|U + 2010 a U + 2027|U + A874 a U + A877|  
|U+005F|U + 07F7 a U + 07F9|U + 2030 a U + 2043|U + FD3E e U + FD3F|  
|U+007B|U + 0964 e U + 0965|U + 2045 a U + 2051|U + FE10 a U + FE19|  
|U+007D|U+0970|U + 2053 a U + 205E|U + FE30 a U + FE52|  
|U+00A1|U+0DF4|U + D 207 e U + 207E|U + FE54 a U + FE61|  
|U + 00AB|U + 0E4F a U + 0E5B|U + 208D e U + 208E|U + FE63|  
|U + 00AD|U + 0F04 a U + 0F12|U + 2329 e U + 232A|U + FE68|  
|U + 00B7|U + 0F3A a U + 0F3D|U + 2768 a U + 2775|U + FE6A e U + FE6B|  
|U + 00BB|U+0F85|U + 5 27C a U + 27C 6|U + FF01 a U + FF03|  
|U + 00BF|U + 0FD0 e U + 0FD1|U + 27E6 a U + 27EB|U + FF05 a U + FF0A|  
|U + 037E|U + 104 a U + 104F|U + 2983 a U + 2998|U + FF0C a U + FF0F|  
|U+0387|U + 10FB|U + 8 29D a U + 29 DB|U + FF1A e U + FF1B|  
|U + 055A a U + 055F|U + 1361 a U + 1368|U + 29FC e U + 29FD|U + FF1F e U + FF20|  
|U + 0589 e U + 058A|U + D 166 e U + 166E|U + 2CF9 a U + 2CFC|U + FF3B a U + FF3D|  
|U + 05BE|U + 169B e U + 169C|U + 2CFE e U + 2CFF|U+FF3F|  
|U+05C0|U + 16EB a U + 16ED|U + 2E00 a U + 2E17|U+FF5B|  
|U+05C3|U + 1735 e U + 1736|U + 2E1C e U + 2E1D|U + FF5D|  
|U+05C6|U + 4 17D a U + 17D 6|U + 3001 a U + 3003|U + FF5F a U + FF65|  
|U + 05F3 e U + 05F4|U + 8 17D a U + 17DA|U + 3008 a U + 3011||  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere Unicode specificato è stato categorizzato come segno di punteggiatura.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è un segno di punteggiatura; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Segni di punteggiatura validi sono membri delle categorie seguenti in <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, o `OtherPunctuation`. Includono caratteri con punti di codice Unicode elencati nella tabella seguente.  
  
|||||  
|-|-|-|-|  
|U + 0021 a U + 0023|U + 060C e U + 060D|U + 1800 a U + 180A|U + 3014 a U + 301F|  
|U + 0025 a U + 002A|U+061B|U + 1944 e U + 1945|U+3030|  
|U + 002C a U + 002F|U + 061E e U + 061F|U + 19DE e U + 19DF|U + 303D|  
|U + 003A e U + 003B|U + 066A a U + 066D|U + 1A1E e U + 1A1F|U + 30A0|  
|U + 003F e U + 0040|U + 06D 4|U + 1B5A a U + 1B60|U + 30FB|  
|U + 005B a U + D 005|U + 0700 a U + D 070|U + 2010 a U + 2027|U + A874 a U + A877|  
|U+005F|U + 07F7 a U + 07F9|U + 2030 a U + 2043|U + FD3E e U + FD3F|  
|U+007B|U + 0964 e U + 0965|U + 2045 a U + 2051|U + FE10 a U + FE19|  
|U+007D|U+0970|U + 2053 a U + 205E|U + FE30 a U + FE52|  
|U+00A1|U+0DF4|U + D 207 e U + 207E|U + FE54 a U + FE61|  
|U + 00AB|U + 0E4F a U + 0E5B|U + 208D e U + 208E|U + FE63|  
|U + 00AD|U + 0F04 a U + 0F12|U + 2329 e U + 232A|U + FE68|  
|U + 00B7|U + 0F3A a U + 0F3D|U + 2768 a U + 2775|U + FE6A e U + FE6B|  
|U + 00BB|U+0F85|U + 5 27C a U + 27C 6|U + FF01 a U + FF03|  
|U + 00BF|U + 0FD0 e U + 0FD1|U + 27E6 a U + 27EB|U + FF05 a U + FF0A|  
|U + 037E|U + 104 a U + 104F|U + 2983 a U + 2998|U + FF0C a U + FF0F|  
|U+0387|U + 10FB|U + 8 29D a U + 29 DB|U + FF1A e U + FF1B|  
|U + 055A a U + 055F|U + 1361 a U + 1368|U + 29FC e U + 29FD|U + FF1F e U + FF20|  
|U + 0589 e U + 058A|U + D 166 e U + 166E|U + 2CF9 a U + 2CFC|U + FF3B a U + FF3D|  
|U + 05BE|U + 169B e U + 169C|U + 2CFE e U + 2CFF|U+FF3F|  
|U+05C0|U + 16EB a U + 16ED|U + 2E00 a U + 2E17|U+FF5B|  
|U+05C3|U + 1735 e U + 1736|U + 2E1C e U + 2E1D|U + FF5D|  
|U+05C6|U + 4 17D a U + 17D 6|U + 3001 a U + 3003|U + FF5F a U + FF65|  
|U + 05F3 e U + 05F4|U + 8 17D a U + 17DA|U + 3008 a U + 3011||  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsPunctuation%2A>.  
  
 [!code-cpp[System.Char.IsPunctuation#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CPP/ispunctuation.cpp#9)]
 [!code-csharp[System.Char.IsPunctuation#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CS/ispunctuation.cs#9)]
 [!code-vb[System.Char.IsPunctuation#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsPunctuation/VB/ispunctuation.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa è stato categorizzato come segno di punteggiatura.</summary>
        <returns>
          <see langword="true" /> se il carattere alla posizione <paramref name="index" /> in <paramref name="s" /> è un segno di punteggiatura; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Segni di punteggiatura validi sono membri delle categorie seguenti in <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, o `OtherPunctuation`. Includono caratteri con punti di codice Unicode elencati nella tabella seguente.  
  
|||||  
|-|-|-|-|  
|U + 0021 a U + 0023|U + 060C e U + 060D|U + 1800 a U + 180A|U + 3014 a U + 301F|  
|U + 0025 a U + 002A|U+061B|U + 1944 e U + 1945|U+3030|  
|U + 002C a U + 002F|U + 061E e U + 061F|U + 19DE e U + 19DF|U + 303D|  
|U + 003A e U + 003B|U + 066A a U + 066D|U + 1A1E e U + 1A1F|U + 30A0|  
|U + 003F e U + 0040|U + 06D 4|U + 1B5A a U + 1B60|U + 30FB|  
|U + 005B a U + D 005|U + 0700 a U + D 070|U + 2010 a U + 2027|U + A874 a U + A877|  
|U+005F|U + 07F7 a U + 07F9|U + 2030 a U + 2043|U + FD3E e U + FD3F|  
|U+007B|U + 0964 e U + 0965|U + 2045 a U + 2051|U + FE10 a U + FE19|  
|U+007D|U+0970|U + 2053 a U + 205E|U + FE30 a U + FE52|  
|U+00A1|U+0DF4|U + D 207 e U + 207E|U + FE54 a U + FE61|  
|U + 00AB|U + 0E4F a U + 0E5B|U + 208D e U + 208E|U + FE63|  
|U + 00AD|U + 0F04 a U + 0F12|U + 2329 e U + 232A|U + FE68|  
|U + 00B7|U + 0F3A a U + 0F3D|U + 2768 a U + 2775|U + FE6A e U + FE6B|  
|U + 00BB|U+0F85|U + 5 27C a U + 27C 6|U + FF01 a U + FF03|  
|U + 00BF|U + 0FD0 e U + 0FD1|U + 27E6 a U + 27EB|U + FF05 a U + FF0A|  
|U + 037E|U + 104 a U + 104F|U + 2983 a U + 2998|U + FF0C a U + FF0F|  
|U+0387|U + 10FB|U + 8 29D a U + 29 DB|U + FF1A e U + FF1B|  
|U + 055A a U + 055F|U + 1361 a U + 1368|U + 29FC e U + 29FD|U + FF1F e U + FF20|  
|U + 0589 e U + 058A|U + D 166 e U + 166E|U + 2CF9 a U + 2CFC|U + FF3B a U + FF3D|  
|U + 05BE|U + 169B e U + 169C|U + 2CFE e U + 2CFF|U+FF3F|  
|U+05C0|U + 16EB a U + 16ED|U + 2E00 a U + 2E17|U+FF5B|  
|U+05C3|U + 1735 e U + 1736|U + 2E1C e U + 2E1D|U + FF5D|  
|U+05C6|U + 4 17D a U + 17D 6|U + 3001 a U + 3003|U + FF5F a U + FF65|  
|U + 05F3 e U + 05F4|U + 8 17D a U + 17DA|U + 3008 a U + 3011||  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsPunctuation%2A>.  
  
 [!code-cpp[System.Char.IsPunctuation#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CPP/ispunctuation.cpp#9)]
 [!code-csharp[System.Char.IsPunctuation#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CS/ispunctuation.cs#9)]
 [!code-vb[System.Char.IsPunctuation#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsPunctuation/VB/ispunctuation.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSeparator">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se un carattere Unicode è stato categorizzato come carattere separatore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo standard Unicode riconosce tre sottocategorie di separatori:  
  
-   Spazio separatore (il <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> categoria), che include caratteri, ad esempio \u0020.  
  
-   Separatori di riga (il <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> categoria), che include \u2028.  
  
-   Separatori di paragrafo (la <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> categoria), che include \u2029.  
  
> [!NOTE]
>  Lo standard Unicode classifica i caratteri \u000A (LF), \u000C. (FF) e \u000D (CR) come caratteri di controllo (membri del <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoria), non come caratteri separatori.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere Unicode specificato è stato categorizzato come carattere separatore.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è un carattere separatore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo standard Unicode riconosce tre sottocategorie di separatori:  
  
-   Spazio separatore (il <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> categoria), che include caratteri, ad esempio \u0020.  
  
-   Separatori di riga (il <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> categoria), che include \u2028.  
  
-   Separatori di paragrafo (la <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> categoria), che include \u2029.  
  
> [!NOTE]
>  Lo standard Unicode classifica i caratteri \u000A (LF), \u000C. (FF) e \u000D (CR) come caratteri di controllo (membri del <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoria), non come caratteri separatori.  
  
   
  
## Examples  
 L'esempio seguente il <xref:System.Char> gli oggetti che sono classificati come caratteri separatori.  
  
 [!code-cpp[System.Char.IsSeparator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator1.cpp#1)]
 [!code-csharp[System.Char.IsSeparator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSeparator/CS/isseparator1.cs#1)]
 [!code-vb[System.Char.IsSeparator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa è stato categorizzato come carattere separatore.</summary>
        <returns>
          <see langword="true" /> se il carattere alla posizione <paramref name="index" /> in <paramref name="s" /> è un carattere separatore; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Lo standard Unicode riconosce tre sottocategorie di separatori:  
  
-   Spazio separatore (il <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> categoria), che include caratteri, ad esempio \u0020.  
  
-   Separatori di riga (il <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> categoria), che include \u2028.  
  
-   Separatori di paragrafo (la <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> categoria), che include \u2029.  
  
> [!NOTE]
>  Lo standard Unicode classifica i caratteri \u000A (LF), \u000C. (FF) e \u000D (CR) come caratteri di controllo (membri del <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoria), non come caratteri separatori.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato <xref:System.Char.IsSeparator%2A>.  
  
 [!code-cpp[System.Char.IsSeparator#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator.cpp#10)]
 [!code-csharp[System.Char.IsSeparator#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSeparator/CS/isseparator.cs#10)]
 [!code-vb[System.Char.IsSeparator#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se un carattere dispone di un'unità di codice surrogato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere specificato dispone di un'unità di codice surrogato.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è un surrogato alto o un surrogato basso; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È un surrogato un <xref:System.Char> oggetto con un'unità di codice UTF-16 nell'intervallo tra U + D800 e U + DFFF. Ogni carattere con un'unità di codice in questo intervallo appartiene il <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> categoria. L'unità di codice surrogato singoli dispone di un proprio alcuna interpretazione, ma ha significato solo se utilizzato come parte di una coppia di surrogati. Per ulteriori informazioni sulle coppie di surrogati, vedere lo Unicode Standard al [home page di Unicode](http://go.microsoft.com/fwlink/?linkid=37123).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Char.IsSurrogate%2A> metodo.  
  
 [!code-cpp[System.Char.IsSurrogate#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CPP/issurrogate.cpp#11)]
 [!code-csharp[System.Char.IsSurrogate#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CS/issurrogate.cs#11)]
 [!code-vb[System.Char.IsSurrogate#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSurrogate/VB/issurrogate.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa dispone di un'unità di codice surrogato.</summary>
        <returns>
          <see langword="true" /> se il carattere in corrispondenza della posizione <paramref name="index" /> in <paramref name="s" /> è un surrogato alto o un surrogato basso; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 È un surrogato un <xref:System.Char> oggetto con un'unità di codice UTF-16 nell'intervallo tra U + D800 e U + DFFF. Ogni carattere con un'unità di codice in questo intervallo appartiene il <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> categoria. L'unità di codice surrogato singoli dispone di un proprio alcuna interpretazione, ma ha significato solo se utilizzato come parte di una coppia di surrogati. Per ulteriori informazioni sulle coppie di surrogati, vedere lo Unicode Standard al [home page di Unicode](http://go.microsoft.com/fwlink/?linkid=37123).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsSurrogate%2A>.  
  
 [!code-cpp[System.Char.IsSurrogate#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CPP/issurrogate.cpp#11)]
 [!code-csharp[System.Char.IsSurrogate#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CS/issurrogate.cs#11)]
 [!code-vb[System.Char.IsSurrogate#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSurrogate/VB/issurrogate.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogatePair">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se due oggetti <see cref="T:System.Char" /> specificati formano una coppia di surrogati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (highSurrogate As Char, lowSurrogate As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Carattere da valutare come surrogato alto di una coppia di surrogati.</param>
        <param name="lowSurrogate">Carattere da valutare come surrogato basso di una coppia di surrogati.</param>
        <summary>Indica se i due oggetti <see cref="T:System.Char" /> specificati formano una coppia di surrogati.</summary>
        <returns>
          <see langword="true" /> se il valore numerico del parametro <paramref name="highSurrogate" /> è compreso tra U+D800 e U+DBFF e il valore numerico del parametro <paramref name="lowSurrogate" /> è compreso tra U+DC00 e U+DFFF; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, un singolo carattere è rappresentato da una singola unità di codice Unicode a 16 bit. La codifica UTF-16 supporta anche le coppie di surrogati, che consentono un singolo carattere astratto essere rappresentato da due unità di codice a 16 bit. La prima unità di codice, il cui valore può essere compreso tra U + D800 e U + DBFF, è il surrogato alto. La seconda unità di codice, il cui valore può essere compreso tra U + DC00 e U + DFFF, è il surrogato basso. Punti di codice surrogati singoli dispongono di propri alcuna interpretazione. Per ulteriori informazioni sui surrogati e lo Unicode Standard, vedere il [home page di Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, e <xref:System.Char.IsSurrogatePair%2A> metodi.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione iniziale della coppia di caratteri da valutare all'interno di <c>s</c>.</param>
        <summary>Indica se due oggetti <see cref="T:System.Char" /> adiacenti in corrispondenza di una posizione specificata all'interno di una stringa formano una coppia di surrogati.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="s" /> contiene caratteri adiacenti nelle posizioni <paramref name="index" /> e <paramref name="index" /> + 1, il valore numerico del carattere nella posizione <paramref name="index" /> è compreso tra U+D800 e U+DBFF e il valore numerico del carattere nella posizione <paramref name="index" />+1 è compreso tra U+DC00 e U+DFFF; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, un singolo carattere è rappresentato da una singola unità di codice Unicode a 16 bit. La codifica UTF-16 supporta anche le coppie di surrogati, che consentono un singolo carattere astratto essere rappresentato da due unità di codice a 16 bit. La prima unità di codice, il cui valore può essere compreso tra U + D800 e U + DBFF, è il surrogato alto. La seconda unità di codice, il cui valore può essere compreso tra U + DC00 e U + DFFF, è il surrogato basso. Punti di codice surrogati singoli dispongono di propri alcuna interpretazione. Per ulteriori informazioni sui surrogati e lo Unicode Standard, vedere il [home page di Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, e <xref:System.Char.IsSurrogatePair%2A> metodi.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> non è una posizione all'interno di <paramref name="s" />.</exception>
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSymbol">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se un carattere Unicode è stato categorizzato come carattere simbolo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Simboli validi sono membri delle categorie seguenti in <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, e `OtherSymbol`.  
  
 Simboli nello standard Unicode sono un regime di controllo libero definito set di caratteri che includono quanto segue:  
  
-   Simboli di valuta.  
  
-   Simboli alfabetici, che includono un set di simboli alfanumerici matematici, nonché i simboli, ad esempio ℅, № e™.  
  
-   Numero di moduli, come ad esempio apici e pedici.  
  
-   Operatori matematici e frecce.  
  
-   Simboli geometrici.  
  
-   Simboli tecnici.  
  
-   Modelli Braille.  
  
-   Dingbats.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere Unicode specificato è stato categorizzato come carattere simbolo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è un carattere simbolo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Simboli validi sono membri delle categorie seguenti in <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, e `OtherSymbol`.  
  
 Simboli nello standard Unicode sono un regime di controllo libero definito set di caratteri che includono quanto segue:  
  
-   Simboli di valuta.  
  
-   Simboli alfabetici, che includono un set di simboli alfanumerici matematici, nonché i simboli, ad esempio ℅, № e™.  
  
-   Numero di moduli, come ad esempio apici e pedici.  
  
-   Operatori matematici e frecce.  
  
-   Simboli geometrici.  
  
-   Simboli tecnici.  
  
-   Modelli Braille.  
  
-   Dingbats.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsSymbol%2A>.  
  
 [!code-cpp[System.Char.IsSymbol#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSymbol/CPP/issymbol.cpp#12)]
 [!code-csharp[System.Char.IsSymbol#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSymbol/CS/issymbol.cs#12)]
 [!code-vb[System.Char.IsSymbol#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSymbol/VB/issymbol.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa è stato categorizzato come carattere simbolo.</summary>
        <returns>
          <see langword="true" /> se il carattere alla posizione <paramref name="index" /> in <paramref name="s" /> è un carattere simbolo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Simboli validi sono membri delle categorie seguenti in <xref:System.Globalization.UnicodeCategory?displayProperty=nameWithType>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, e `OtherSymbol`.  
  
 Simboli nello standard Unicode sono un regime di controllo libero definito set di caratteri che includono quanto segue:  
  
-   Simboli di valuta.  
  
-   Simboli alfabetici, che includono un set di simboli alfanumerici matematici, nonché i simboli, ad esempio ℅, № e™.  
  
-   Numero di moduli, come ad esempio apici e pedici.  
  
-   Operatori matematici e frecce.  
  
-   Simboli geometrici.  
  
-   Simboli tecnici.  
  
-   Modelli Braille.  
  
-   Dingbats.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsSymbol%2A>.  
  
 [!code-cpp[System.Char.IsSymbol#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSymbol/CPP/issymbol.cpp#12)]
 [!code-csharp[System.Char.IsSymbol#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSymbol/CS/issymbol.cs#12)]
 [!code-vb[System.Char.IsSymbol#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSymbol/VB/issymbol.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se un carattere Unicode è stato categorizzato come lettera maiuscola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere Unicode specificato è stato categorizzato come lettera maiuscola.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è una lettera maiuscola; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le lettere maiuscole valide sono membri della categoria di seguito in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsLower(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa è stato categorizzato come lettera maiuscola.</summary>
        <returns>
          <see langword="true" /> se il carattere alla posizione <paramref name="index" /> in <paramref name="s" /> è una lettera maiuscola; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Le lettere maiuscole valide sono membri della categoria di seguito in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsWhiteSpace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se un carattere Unicode è stato categorizzato come spazio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spazi vuoti sono i seguenti caratteri Unicode:  
  
-   I membri del <xref:System.Globalization.UnicodeCategory.SpaceSeparator> categoria, che include i caratteri spazio (U + 0020), spazio OGHAM CONTRASSEGNARE (U + 1680), QUAD EN (U + 2000), EM QUAD (U + 2001), EN spazio (U + 2002), EM spazio (U + 2003), PER tre-EM spazio (U + 2004), PER quattro-EM spazio (U + 2005), PER sei-EM Lo spazio (U + 2006), nella figura spazio (U + 2007), segni di punteggiatura spazio (U + 2008), THIN spazio (U + 2009), selettore di precisione spazio (U + 200A), "narrow" senza interruzione spazio (U + 202F), MEDIUM MATHEMATICAL SPACE (U + 205F) e spazi IDEOGRAFICI (U + 3000).  
  
-   I membri del <xref:System.Globalization.UnicodeCategory.LineSeparator> categoria, costituita esclusivamente il carattere separatore di riga (U + 2028).  
  
-   I membri del <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> categoria, costituita esclusivamente il carattere separatore di paragrafo (U + 2029).  
  
-   I caratteri carattere di tabulazione (U + 0009), avanzamento riga (U + 000A), riga tabulazione (U + 000B), avanzamento modulo (U + 000C), ritorno a capo (U + 000D), quindi riga (U + 0085) e spazio unificatore (U + 00A0).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da valutare.</param>
        <summary>Indica se il carattere Unicode specificato è stato categorizzato come spazio.</summary>
        <returns>
          <see langword="true" /> se <paramref name="c" /> è uno spazio; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spazi vuoti sono i seguenti caratteri Unicode:  
  
-   I membri del <xref:System.Globalization.UnicodeCategory.SpaceSeparator> categoria, che include i caratteri spazio (U + 0020), spazio unificatore (U + 00A0), CONTRASSEGNARE spazio OGHAM (U + 1680), QUAD EN (U + 2000), EM QUAD (U + 2001), EN spazio (U + 2002), EM spazio (U + 2003), per ogni tre-EM spazio (U + 2004), spazio PER quattro-EM ( U+ 2005), per ogni sei-EM spazio (U + 2006), figura spazio (U + 2007), segni di punteggiatura spazio (U + 2008), THIN spazio (U + 2009), selettore di precisione spazio (U + 200A), "narrow" senza interruzione spazio (U + 202F), MEDIUM MATHEMATICAL SPACE (U + 205F) e spazi IDEOGRAFICI (U + 3000).  
  
-   I membri del <xref:System.Globalization.UnicodeCategory.LineSeparator> categoria, costituita esclusivamente il carattere separatore di riga (U + 2028).  
  
-   I membri del <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> categoria, costituita esclusivamente il carattere separatore di paragrafo (U + 2029).  
  
-   I caratteri carattere di tabulazione (U + 0009), riga FEED (U + 000A), riga tabulazione (U + 000B), avanzamento modulo (U + 000C), ritorno a capo (U + 000D) e quindi di riga (U + 0085).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Char.IsWhiteSpace%28System.Char%29> metodo.  
  
 [!code-cpp[System.Char.IsWhiteSpace#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CPP/iswhitespace.cpp#14)]
 [!code-csharp[System.Char.IsWhiteSpace#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CS/iswhitespace.cs#14)]
 [!code-vb[System.Char.IsWhiteSpace#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/VB/iswhitespace.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(System::String ^ s, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una stringa.</param>
        <param name="index">Posizione del carattere da valutare in <c>s</c>.</param>
        <summary>Indica se il carattere in corrispondenza della posizione specificata in una determinata stringa è stato categorizzato come spazio.</summary>
        <returns>
          <see langword="true" /> se il carattere alla posizione <paramref name="index" /> in <paramref name="s" /> è uno spazio; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posizioni dei caratteri in una stringa vengono indicizzate a partire da zero.  
  
 Spazi vuoti sono i seguenti caratteri Unicode:  
  
-   I membri del <xref:System.Globalization.UnicodeCategory.SpaceSeparator> categoria, che include i caratteri spazio (U + 0020), spazio unificatore (U + 00A0), CONTRASSEGNARE spazio OGHAM (U + 1680), QUAD EN (U + 2000), EM QUAD (U + 2001), EN spazio (U + 2002), EM spazio (U + 2003), per ogni tre-EM spazio (U + 2004), spazio PER quattro-EM ( U+ 2005), per ogni sei-EM spazio (U + 2006), figura spazio (U + 2007), segni di punteggiatura spazio (U + 2008), THIN spazio (U + 2009), selettore di precisione spazio (U + 200A), "narrow" senza interruzione spazio (U + 202F), MEDIUM MATHEMATICAL SPACE (U + 205F) e spazi IDEOGRAFICI (U + 3000).  
  
-   I membri del <xref:System.Globalization.UnicodeCategory.LineSeparator> categoria, costituita esclusivamente il carattere separatore di riga (U + 2028).  
  
-   I membri del <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> categoria, costituita esclusivamente il carattere separatore di paragrafo (U + 2029).  
  
-   I caratteri carattere di tabulazione (U + 0009), riga FEED (U + 000A), riga tabulazione (U + 000B), avanzamento modulo (U + 000C), ritorno a capo (U + 000D) e quindi di riga (U + 0085).  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.IsWhiteSpace%2A>.  
  
 [!code-cpp[System.Char.IsWhiteSpace#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CPP/iswhitespace.cpp#14)]
 [!code-csharp[System.Char.IsWhiteSpace#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CS/iswhitespace.cs#14)]
 [!code-vb[System.Char.IsWhiteSpace#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/VB/iswhitespace.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di zero o maggiore dell'ultima posizione in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const char MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Char " />
      <MemberSignature Language="C++ CLI" Value="public: char MaxValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il valore massimo possibile di <see cref="T:System.Char" />. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è 0xFFFF esadecimale.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const char MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MinValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Char " />
      <MemberSignature Language="C++ CLI" Value="public: char MinValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il valore minimo possibile di un oggetto <see cref="T:System.Char" />. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa costante è 0x00 esadecimale.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static char Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Stringa contenente un solo carattere oppure <see langword="null" />.</param>
        <summary>Converte il valore della stringa specificata nell'equivalente carattere Unicode.</summary>
        <returns>Carattere Unicode equivalente all'unico carattere in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.Parse%2A>.  
  
 [!code-cpp[System.Char.Parse#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.Parse/CPP/parse.cpp#15)]
 [!code-csharp[System.Char.Parse#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.Parse/CS/parse.cs#15)]
 [!code-vb[System.Char.Parse#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Parse/VB/parse.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La lunghezza di <paramref name="s" /> non è 1.</exception>
        <altmember cref="M:System.Char.ToString" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>**Nota** Questa conversione non è supportata. Qualsiasi tentativo di eseguire tale operazione genera un'eccezione <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Questa conversione non è supportata. Non vengono restituiti valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Questa conversione non è supportata.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.Char" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Char> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToByte%28System.Char%29?displayProperty=nameWithType> metodo invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Valore dell'oggetto <see cref="T:System.Char" /> corrente invariato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Char> a un'interfaccia <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>**Nota** Questa conversione non è supportata. Qualsiasi tentativo di eseguire tale operazione genera un'eccezione <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Non vengono restituiti valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Questa conversione non è supportata.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>**Nota** Questa conversione non è supportata. Qualsiasi tentativo di eseguire tale operazione genera un'eccezione <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Non vengono restituiti valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Questa conversione non è supportata.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>**Nota** Questa conversione non è supportata. Qualsiasi tentativo di eseguire tale operazione genera un'eccezione <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Non vengono restituiti valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Questa conversione non è supportata.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.Char" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Char> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt16%28System.Char%29?displayProperty=nameWithType> metodo invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.Char" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Char> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt32%28System.Char%29?displayProperty=nameWithType> metodo invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.Char" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Char> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt64%28System.Char%29?displayProperty=nameWithType> metodo invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.Char" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Char> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToSByte%28System.Char%29?displayProperty=nameWithType> metodo invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>**Nota** Questa conversione non è supportata. Qualsiasi tentativo di eseguire tale operazione genera un'eccezione <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Non vengono restituiti valori.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Questa conversione non è supportata.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Un oggetto <see cref="T:System.Type" />.</param>
        <param name="provider">Oggetto <see cref="T:System.IFormatProvider" />.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Oggetto del tipo specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Char> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29> metodo invece.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile convertire il valore dell'oggetto <see cref="T:System.Char" /> corrente nel tipo specificato dal parametro <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto <see cref="T:System.IFormatProvider" />. Specificare <see langword="null" />, in quanto il parametro <c>provider</c> viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.Char" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Char> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt16%28System.Char%29?displayProperty=nameWithType> metodo invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto <see cref="T:System.IFormatProvider" />. Specificare <see langword="null" />, in quanto il parametro <c>provider</c> viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.Char" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Char> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt32%28System.Char%29?displayProperty=nameWithType> metodo invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto <see cref="T:System.IFormatProvider" />. Specificare <see langword="null" />, in quanto il parametro <c>provider</c> viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.Char" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.Char> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt64%28System.Char%29?displayProperty=nameWithType> metodo invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore di un carattere Unicode nell'equivalente carattere minuscolo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da convertire.</param>
        <summary>Converte il valore di un carattere Unicode nell'equivalente carattere minuscolo.</summary>
        <returns>Equivalente minuscolo di <paramref name="c" /> o, se <paramref name="c" /> è già un carattere minuscolo o non alfabetico, valore non modificato di <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Regole di maiuscole e minuscole vengono ottenute dalle impostazioni cultura correnti.  
  
 Utilizzare <xref:System.String.ToLower%2A?displayProperty=nameWithType> per convertire una stringa in caratteri minuscoli.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato <xref:System.Char.ToLower%2A>.  
  
 [!code-cpp[System.Char.ToLower#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToLower/CPP/tolower.cpp#16)]
 [!code-csharp[System.Char.ToLower#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToLower/CS/tolower.cs#16)]
 [!code-vb[System.Char.ToLower#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToLower/VB/tolower.vb#16)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Come spiegato in [procedure consigliate per l'uso di stringhe](~/docs/standard/base-types/best-practices-strings.md), si consiglia di evitare di chiamare metodi-minuscole e maiuscole e minuscole di stringa che sostituiscono i valori predefiniti. In alternativa, è necessario chiamare metodi che richiedono parametri per specificare in modo esplicito. Per convertire un carattere in minuscolo utilizzando le convenzioni delle impostazioni cultura correnti, chiamare il <see cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" /> overload del metodo con un valore di <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> per relativo <paramref name="culture" /> parametro.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da convertire.</param>
        <param name="culture">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</param>
        <summary>Converte il valore di uno specifico carattere Unicode nell'equivalente carattere minuscolo mediante le informazioni di formattazione relative alle impostazioni cultura specificate.</summary>
        <returns>Equivalente minuscolo di <paramref name="c" />, modificato in base al parametro <paramref name="culture" />; oppure, se <paramref name="c" /> è già un carattere minuscolo o non alfabetico, valore non modificato di <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.String.ToLower%2A?displayProperty=nameWithType> per convertire una stringa in caratteri minuscoli.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.ToLower%2A>.  
  
 [!code-cpp[System.Char.ToLower#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToLower/CPP/tolower.cpp#16)]
 [!code-csharp[System.Char.ToLower#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToLower/CS/tolower.cs#16)]
 [!code-vb[System.Char.ToLower#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToLower/VB/tolower.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static char ToLowerInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLowerInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLowerInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLowerInvariant (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLowerInvariant(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da convertire.</param>
        <summary>Converte il valore di un carattere Unicode nell'equivalente carattere minuscolo mediante le regole relative all'utilizzo di maiuscole e minuscole delle impostazioni cultura invarianti.</summary>
        <returns>Equivalente minuscolo del parametro <paramref name="c" /> o, se <paramref name="c" /> è già un carattere minuscolo o non alfabetico, valore non modificato di <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'applicazione è interessata dalle impostazioni cultura correnti e dipende nel caso di un carattere che cambia in modo prevedibile, utilizzare il <xref:System.Char.ToLowerInvariant%2A> metodo. Il <xref:System.Char.ToLowerInvariant%2A> metodo è equivalente a `ToLower(Char, CultureInfo.InvariantCulture)`.  
  
 Utilizzare <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> per convertire una stringa in caratteri minuscoli.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore dell'istanza corrente nell'equivalente rappresentazione di stringa.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte il valore dell'istanza corrente nell'equivalente rappresentazione di stringa.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToString (c As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ToString(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da convertire.</param>
        <summary>Converte il carattere Unicode specificato nell'equivalente rappresentazione di stringa.</summary>
        <returns>Rappresentazione di stringa del valore di <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio di codice seguente illustra <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Riservato) Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Converte il valore dell'istanza corrente nella rappresentazione di stringa equivalente, usando le informazioni sul formato relative alle impostazioni cultura specificate.</summary>
        <returns>Rappresentazione di stringa del valore dell'istanza, in base a quanto specificato da <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `provider` parametro viene ignorato; non fa parte di questa operazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato un overload di <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore di un carattere Unicode nell'equivalente carattere maiuscolo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da convertire.</param>
        <summary>Converte il valore di un carattere Unicode nell'equivalente carattere maiuscolo.</summary>
        <returns>Equivalente maiuscolo del parametro <paramref name="c" /> o, se <paramref name="c" /> è già un carattere maiuscolo, non alfabetico o per cui non esiste equivalente maiuscolo, valore non modificato di <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Regole di maiuscole e minuscole vengono ottenute dalle impostazioni cultura correnti.  
  
 Utilizzare <xref:System.String.ToUpper%2A?displayProperty=nameWithType> per convertire una stringa in lettere maiuscole.  
  
   
  
## Examples  
 Nell'esempio seguente converte ogni carattere in una matrice nell'equivalente maiuscolo.  
  
 [!code-csharp[System.Char.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.toupper/cs/toupper1.cs#1)]
 [!code-vb[System.Char.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Come spiegato in [procedure consigliate per l'uso di stringhe](~/docs/standard/base-types/best-practices-strings.md), si consiglia di evitare di chiamare metodi-minuscole e maiuscole e minuscole di stringa che sostituiscono i valori predefiniti. In alternativa, è necessario chiamare metodi che richiedono parametri per specificare in modo esplicito. Per convertire un carattere maiuscolo mediante le convenzioni delle impostazioni cultura correnti, chiamare il <see cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" /> overload del metodo con un valore di <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> per relativo <paramref name="culture" /> parametro.</para>
        </block>
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da convertire.</param>
        <param name="culture">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</param>
        <summary>Converte il valore di uno specifico carattere Unicode nell'equivalente carattere maiuscolo mediante le informazioni di formattazione relative alle impostazioni cultura specificate.</summary>
        <returns>Equivalente maiuscolo di <paramref name="c" />, modificato in base al parametro <paramref name="culture" /> oppure valore non modificato di <paramref name="c" /> se <paramref name="c" /> è già un carattere maiuscolo, non ha un equivalente maiuscolo o non è alfabetico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.String.ToUpper%2A?displayProperty=nameWithType> per convertire una stringa in lettere maiuscole.  
  
   
  
## Examples  
 Nell'esempio seguente converte ogni carattere in una matrice nell'equivalente maiuscolo per le impostazioni cultura en-US, le impostazioni cultura invarianti e le impostazioni cultura tr-TR. In questo esempio è identico per tutte le impostazioni cultura, ad eccezione di un caso equivalente maiuscolo di ogni lettera minuscola. Il functoid minuscolo "i" caratteri (U + 0069) converte "I" (U + 0049) le impostazioni cultura invarianti e il en-US, ma a "İ" (U + 0130) nelle impostazioni cultura tr-TR.  
  
 [!code-csharp[System.Char.ToUpper#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.toupper/cs/toupper5.cs#2)]
 [!code-vb[System.Char.ToUpper#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static char ToUpperInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpperInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpperInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpperInvariant (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpperInvariant(char c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode da convertire.</param>
        <summary>Converte il valore di un carattere Unicode nell'equivalente carattere maiuscolo mediante le regole relative all'utilizzo di maiuscole e minuscole delle impostazioni cultura invarianti.</summary>
        <returns>Equivalente maiuscolo del parametro <paramref name="c" /> o, se <paramref name="c" /> è già un carattere maiuscolo o non alfabetico, valore non modificato di <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'applicazione è interessata dalle impostazioni cultura correnti e dipende nel caso di un carattere che cambia in modo prevedibile, utilizzare il <xref:System.Char.ToUpperInvariant%2A> metodo.  Il <xref:System.Char.ToUpperInvariant%2A> metodo è equivalente a `ToUpper(Char, CultureInfo.InvariantCulture)`.  
  
 Utilizzare <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> per convertire una stringa in lettere maiuscole.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out char result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.TryParse(System.String,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] char % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Char&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Stringa contenente un solo carattere oppure <see langword="null" />.</param>
        <param name="result">Quando termina, questo metodo contiene un carattere Unicode equivalente all'unico carattere contenuto in <c>s</c> se la conversione ha esito positivo; in caso contrario, il risultato contiene un valore non definito. La conversione non viene eseguita se il parametro <c>s</c> è <see langword="null" /> o se la lunghezza di <c>s</c> non è 1. Questo parametro viene passato non inizializzato.</param>
        <summary>Converte il valore della stringa specificata nell'equivalente carattere Unicode. Un codice restituito indica se la conversione ha avuto esito positivo o negativo.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="s" /> è stato convertito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Char.TryParse%2A> metodo è simile il <xref:System.Char.Parse%2A> metodo, ad eccezione di <xref:System.Char.TryParse%2A> metodo genera un'eccezione se la conversione non riesce.  
  
   
  
## Examples  
 L'esempio di codice seguente viene illustrato l'overload del <xref:System.Char.TryParse%2A> metodo per diversi tipi di base e <xref:System.DateTime.TryParseExact%2A> metodo per il <xref:System.DateTime> tipo di base.  
  
 [!code-cpp[T.TryParse#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.TryParse/CPP/tp.cpp#1)]
 [!code-csharp[T.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.TryParse/CS/tp.cs#1)]
 [!code-vb[T.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.TryParse/VB/tp.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="M:System.Char.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>