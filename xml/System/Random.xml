<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0173b6c93fb425317fee9f82a66537f25bb42b31" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37728433" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un generatore di numeri pseudo-casuali, ovvero un dispositivo che produce una sequenza di numeri che soddisfano determinati requisiti statistici di casualità.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numeri pseudo-casuali vengono scelti con uguale probabilità di un set di numeri. I numeri selezionati non sono completamente casuali perché viene usato un algoritmo matematico per selezionarli, ma sono sufficientemente casuale ai fini pratici. L'implementazione corrente del <xref:System.Random> classe si basa su una versione modificata del sottrattivo casuale di numeri generatore Knuth Donald E. Knuth. Per altre informazioni, vedere E. D. Knuth. *L'arte della programmazione Volume 2: algoritmi Seminumerical*. Edizione Addison-Wesley, lettura, MA, terza, 1997.  
  
 Per generare un numero casuale crittograficamente sicuro, ad esempio quella più adatta per la creazione di una password casuale, usare il <xref:System.Security.Cryptography.RNGCryptoServiceProvider> classe oppure derivare una classe da <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 In questo argomento  
  
 [Creazione di un'istanza del generatore di numeri casuali](#Instantiate)   
 [Come evitare più creazioni di istanza](#Multiple)   
 [La sicurezza di thread e classe Random](#ThreadSafety)   
 [Generazione di tipi diversi di numeri casuali](#Functionality)   
 [Sostituzione di un algoritmo personalizzato](#Overriding)   
 [Come si usa System. Random per...](#Operations)   
 [Recuperare la stessa sequenza di valori casuali](#Same)  
 [Recuperare le sequenze univoche di valori casuali](#Unique)  
 [Recuperare interi in un intervallo specificato](#Range)  
 [Recuperare interi con un numero di cifre specificato](#Digits)  
 [Recuperare i valori a virgola mobile in un intervallo specificato](#Floats)  
 [Generare i valori booleani casuale](#Boolean)  
 [Generare numeri interi a 64 bit casuali](#Long)  
 [Recuperare byte in un intervallo specificato](#Bytes)  
 [Recuperare un elemento da una matrice o raccolta in modo casuale](#Array)  
 [Recuperare un elemento univoco da una matrice o raccolta](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Creazione di un'istanza del generatore di numeri casuali  
 Si crea un'istanza del generatore di numeri casuali, fornendo un valore di inizializzazione (un valore iniziale per l'algoritmo di generazione di numeri pseudo-casuali) per un <xref:System.Random.%23ctor%2A> costruttore della classe.  È possibile fornire il valore di inizializzazione in modo implicito o esplicito:  
  
-   Il <xref:System.Random.%23ctor%28System.Int32%29> costruttore utilizza un valore di inizializzazione esplicita che viene fornito.  
  
-   Il <xref:System.Random.%23ctor> costruttore Usa l'orologio di sistema per fornire un valore di inizializzazione. Questo è il modo più comune di un'istanza del generatore di numeri casuali.  
  
 Se il valore di inizializzazione stessa viene utilizzato per separato <xref:System.Random> oggetti, i generatori produrranno la stessa serie di numeri casuali. Ciò può essere utile per la creazione di un gruppo di test che elabora i valori casuali o per la riproduzione dei giochi che derivano i propri dati da numeri casuali. Si noti tuttavia che <xref:System.Random> oggetti nei processi in esecuzione in versioni diverse di .NET Framework possono restituire diverse serie di numeri casuali, anche se ne è creata l'istanza con i valori di inizializzazione identici.  
  
 Per produrre un gruppo di sequenze di numeri casuali, è possibile apportare il valore di inizializzazione dipendente dal tempo, in tal modo producendo così una serie diversa con ogni nuova istanza di <xref:System.Random>. Con i parametri <xref:System.Random.%23ctor%28System.Int32%29> costruttore può accettare un' <xref:System.Int32> valore in base al numero di tick nell'ora corrente, mentre senza parametri <xref:System.Random.%23ctor> costruttore Usa l'orologio di sistema per generare il valore di inizializzazione. Tuttavia, poiché l'orologio ha una risoluzione finita, usando il costruttore senza parametri per creare diversi <xref:System.Random> gli oggetti in successione Chiudi crea generatori di numeri casuali che generano identiche sequenze di numeri casuali. Nell'esempio seguente viene illustrato come due <xref:System.Random> gli oggetti che vengono create istanze in successione Chiudi generano una serie di numeri casuali identica. Nella maggior parte dei sistemi Windows, <xref:System.Random> gli oggetti creati entro 15 millisecondi una da altra sono probabile che hanno valori di inizializzazione identici.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Per evitare questo problema, creare un singolo <xref:System.Random> oggetto anziché più oggetti.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Come evitare più creazioni di istanza  
 L'inizializzazione due i generatori di numeri casuali in un ciclo o in rapida successione crea due generatori di numeri casuali che possono produrre identiche sequenze di numeri casuali. Nella maggior parte dei casi, ciò non è intenzione dello sviluppatore e può causare problemi di prestazioni, perché un'istanza e inizializzazione di un generatore di numeri casuali è un processo relativamente costoso.  
  
 Per migliorare le prestazioni sia per evitare di creare inavvertitamente separati i generatori di numeri casuali che generano le sequenze numeriche identiche, è consigliabile creare un <xref:System.Random> oggetto per generare numeri casuali molti nel corso del tempo, invece di creare nuovo <xref:System.Random> oggetti per generare un numero casuale.  
  
 Tuttavia, il <xref:System.Random> classe non è thread-safe. Se si chiama <xref:System.Random> metodi da più thread, seguire le linee guida illustrate nella sezione successiva.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>La sicurezza di thread e classe Random  
 Anziché creare un'istanza di singoli <xref:System.Random> oggetti, si consiglia di creare un singolo <xref:System.Random> istanza da generare tutti i numeri casuali necessari all'applicazione. Tuttavia, <xref:System.Random> oggetti non sono thread-safe. Se l'app chiama <xref:System.Random> da più thread, è necessario usare un oggetto di sincronizzazione per garantire che solo un thread può accedere il generatore di numeri casuali in un momento. Se si non assicura che il <xref:System.Random> all'oggetto avviene in modo thread-safe, le chiamate ai metodi che restituiscono numeri casuali restituiscono 0.  
  
 L'esempio seguente usa il linguaggio c# [istruzione lock](~/docs/csharp/language-reference/keywords/lock-statement.md) e Visual Basic [istruzione SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) per garantire che un singolo generatore di numeri casuali è accessibile da 11 thread in modo thread-safe. Ogni thread genera numeri casuali di 2 milioni, Conta il numero di numeri casuali generati e viene calcolata la somma e quindi aggiorna i totali per tutti i thread quando termina l'esecuzione.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 L'esempio specifica la thread safety nei modi seguenti:  
  
-   Il <xref:System.ThreadStaticAttribute> attributo viene usato per definire le variabili locali del thread che tengono traccia il numero totale di numeri casuali generati e la somma per ogni thread.  
  
-   Un blocco (il `lock` istruzione in c# e il `SyncLock` istruzione in Visual Basic) consente di proteggere l'accesso alle variabili per il conteggio totale e la somma di tutti i numeri casuali generati su tutti i thread.  
  
-   Un semaforo (il <xref:System.Threading.CountdownEvent> oggetto) viene usato per garantire che il thread principale si blocca fino a tutti gli altri thread completamento dell'esecuzione.  
  
-   L'esempio controlla se il generatore di numeri casuali sia stato danneggiato, determinando se due chiamate consecutive per i metodi di generazione di numeri casuali restituiscono 0. Se vengono rilevati dati danneggiati, nell'esempio viene usato il <xref:System.Threading.CancellationTokenSource> oggetto per segnalare che tutti i thread devono essere annullati.  
  
-   Prima di generare ogni numero casuale, ogni thread controlla lo stato del <xref:System.Threading.CancellationToken> oggetto. Se viene richiesto l'annullamento, viene chiamato il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodo per annullare il thread.  
  
 L'esempio seguente è identico al primo, ad eccezione del fatto che usa un' <xref:System.Threading.Tasks.Task> oggetto e un'espressione lambda anziché <xref:System.Threading.Thread> oggetti.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 È diverso dal primo esempio nei modi seguenti:  
  
-   Le variabili di tenere traccia del numero di numeri casuali generati e somma in ogni attività sono locali per l'attività, pertanto non è necessario usare il <xref:System.ThreadStaticAttribute> attributo.  
  
-   Il metodo statico <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodo viene usato per assicurarsi che il thread principale non viene completata prima di aver completato tutte le attività. Non è necessario per il <xref:System.Threading.CountdownEvent> oggetto.  
  
-   L'eccezione che deriva dall'annullamento delle attività viene esposto nel <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> (metodo). Nell'esempio precedente, viene gestita da ogni thread.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Generazione di tipi diversi di numeri casuali  
 Generatore di numeri casuali fornisce metodi che consentono di generare i seguenti tipi di numeri casuali:  
  
-   Una serie di <xref:System.Byte> valori. Determinare il numero di valori di byte passando una matrice inizializzata sul numero di elementi si desidera che il metodo per tornare al <xref:System.Random.NextBytes%2A> (metodo). Nell'esempio seguente genera 20 byte.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Un numero intero. È possibile scegliere se si desidera che un numero intero compreso tra 0 a un valore massimo (<xref:System.Int32.MaxValue?displayProperty=nameWithType> -1) chiamando il <xref:System.Random.Next> metodo, un numero intero compreso tra 0 e un valore specifico chiamando il <xref:System.Random.Next%28System.Int32%29> metodo oppure un valore integer all'interno di un intervallo di valori chiamando il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>metodo. Negli overload con parametri, il valore massimo specificato è esclusivo; il numero massimo effettivo generato è uno minore del valore specificato.  
  
     L'esempio seguente chiama il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo per generare 10 numeri casuale compreso tra -10 e 10. Si noti che il secondo argomento al metodo specifica il limite superiore esclusivo dell'intervallo di valori casuali restituito dal metodo. In altre parole, l'intero più grande che il metodo può restituire uno è minore di questo valore.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Un singolo valore a virgola mobile compreso tra 0,0 e minore di 1,0 chiamando il <xref:System.Random.NextDouble%2A> (metodo). Limite superiore esclusivo del numero casuale restituito dal metodo è 1, pertanto il limite massimo effettivo è 0.99999999999999978. Nell'esempio seguente genera l'errore 10 numeri a virgola mobile casuale.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  Il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo consente di specificare l'intervallo del numero casuale restituito. Tuttavia, il `maxValue` parametro che specifica l'intervallo superiore restituiti numeri, è un'esclusiva e non un inclusivo, valore. Ciò significa che la chiamata al metodo `Next(0, 100)` restituisce un valore compreso tra 0 e 99 e non è compreso tra 0 e 100.  
  
 È anche possibile usare la <xref:System.Random> classe per attività quali la generazione [valori casuali T:System.Boolean](#Boolean), generazione [valori a virgola mobile casuale con un intervallo diverso da 0 a 1](#Floats), generazione [numeri interi a 64 bit casuali](#Long), e [richiamo in modo casuale di un elemento univoco da una matrice o raccolta](#UniqueArray). Per queste e altre attività comuni, vedere il [come si usa System. Random per...](#Operations) sezione.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Sostituzione di un algoritmo personalizzato  
 È possibile implementare il proprio generatore di numeri casuali ereditando dal <xref:System.Random> classe e specificando l'algoritmo di generazione di numeri casuali. Per fornire il proprio algoritmo, è necessario eseguire l'override di <xref:System.Random.Sample%2A> metodo, che implementa l'algoritmo di generazione di numeri casuali. È inoltre consigliabile eseguire l'override di <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, e <xref:System.Random.NextBytes%2A> metodi per garantire che chiamano sottoposto a override <xref:System.Random.Sample%2A> (metodo). Non è necessario eseguire l'override di <xref:System.Random.Next%28System.Int32%29> e <xref:System.Random.NextDouble%2A> metodi.  
  
 Per un esempio che deriva dal <xref:System.Random> classe e modifica, il generatore di numeri pseudo-casuali predefinito vedere il <xref:System.Random.Sample%2A> pagina di riferimento.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Come si usa System. Random per...  
 Le sezioni seguenti forniscono informazioni e codice di esempio per alcuni dei metodi che si potrebbe voler usare numeri casuali nell'app.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Recuperare la stessa sequenza di valori casuali  
 Talvolta si desidera generare la stessa sequenza di numeri casuali negli scenari di test di software e la riproduzione del gioco. Test con la stessa sequenza di numeri casuali consente di rilevare le regressioni e confermare le correzioni di bug. Utilizzando la stessa sequenza di numero casuale nei giochi è possibile riprodurre giochi precedente.  
  
 È possibile generare la stessa sequenza di numeri casuali, fornendo lo stesso valore di inizializzazione per il <xref:System.Random.%23ctor%28System.Int32%29> costruttore. Il valore di inizializzazione fornisce un valore iniziale per l'algoritmo di generazione di numeri pseudo-casuali. L'esempio seguente usa 100100 come un valore di inizializzazione arbitrario per creare un'istanza di <xref:System.Random> oggetto, vengono visualizzati 20 valori a virgola mobile casuali e mantiene il valore di inizializzazione. Quindi Ripristina il valore di inizializzazione, crea un'istanza di un nuovo generatore di numeri casuali e visualizza le stessi 20 casuale valori a virgola mobile.  Si noti che l'esempio può produrre un gruppo di sequenze di numeri casuali se eseguiti in versioni diverse di .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Recuperare le sequenze univoche di numeri casuali  
 Fornire i valori di inizializzazione diversi per le istanze del <xref:System.Random> classe fa in modo che ogni generatore di numeri casuali per produrre una sequenza di valori diversi. È possibile fornire un valore di inizializzazione in modo esplicito chiamando il <xref:System.Random.%23ctor%28System.Int32%29> costruttore, oppure in modo implicito chiamando la <xref:System.Random.%23ctor> costruttore. La maggior parte degli sviluppatori di chiamano il costruttore senza parametri, che usa il clock di sistema. L'esempio seguente usa questo approccio per creare un'istanza di due <xref:System.Random> istanze. Ogni istanza viene visualizzata una serie di 10 numeri interi casuali.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Tuttavia, a causa di risoluzione finita, l'orologio di sistema non rileva le differenze di orario di minore di circa 15 millisecondi. Pertanto, se il codice chiama il <xref:System.Random.%23ctor> per creare un'istanza di due overload <xref:System.Random> gli oggetti in successione, si potrebbero inavvertitamente fornire gli oggetti con valori di inizializzazione identici. Per verificarlo nell'esempio precedente, impostare come commento il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> chiamata al metodo e compilazione ed eseguire l'esempio di nuovo.  
  
 Per evitare che ciò accada, è consigliabile che si crea un'istanza di un singolo <xref:System.Random> oggetto anziché più sessioni. Tuttavia, poiché <xref:System.Random> non è thread-safe, è necessario usare un dispositivo di sincronizzazione se si accede a un <xref:System.Random> dell'istanza da più thread; per altre informazioni, vedere [casuale la sicurezza della classe e thread](#ThreadSafety) più indietro in questo argomento. In alternativa, è possibile usare un meccanismo di ritardo, ad esempio il <xref:System.Threading.Thread.Sleep%2A> metodo usato nell'esempio precedente, per garantire che le istanze create si distanti più di 15 millisecondi.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Recuperare interi in un intervallo specificato  
 È possibile recuperare valori interi in un intervallo specificato chiamando il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo, che consente di specificare sia il limite minimo e il limite superiore dei numeri di cui si vuole che il generatore di numeri casuali da restituire. Il limite superiore è un'esclusiva e non un inclusivo, valore. Vale a dire non è incluso nell'intervallo dei valori restituiti dal metodo. L'esempio seguente usa questo metodo per generare numeri casuali interi compresi tra -10 e 10. Si noti che specifichi 11, ovvero una maggiore del valore desiderato, come il valore della `maxValue` argomento nella chiamata al metodo.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Recuperare interi con un numero di cifre specificato  
 È possibile chiamare il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo per recuperare numeri con un numero di cifre specificato. Ad esempio, per recuperare numeri con quattro cifre (ovvero numeri compresi tra 1000 e 9999), si chiama il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo con un `minValue` pari a 1000 e un `maxValue` pari a 10000, come illustrato nell'esempio seguente.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Recuperare i valori a virgola mobile in un intervallo specificato  
 Il <xref:System.Random.NextDouble%2A> metodo restituisce valori a virgola mobile casuale quell'intervallo da 0 a meno di 1. Tuttavia, spesso è opportuno generare valori casuali in un altro intervallo.  
  
 Se l'intervallo tra i valori minimi e massimo desiderati è 1, è possibile aggiungere la differenza tra l'intervallo inizia desiderato e 0 per il numero restituito dal <xref:System.Random.NextDouble%2A> (metodo). Nell'esempio seguente esegue questa opzione per generare 10 numeri casuale compreso tra -1 e 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Per generare numeri a virgola mobile casuale con limite inferiore è 0 ma limite superiore è maggiore di 1 (o, nel caso i numeri negativi, il cui limite inferiore è minore di -1 e il limite superiore è 0), moltiplicare il numero casuale per il limite diverso da zero. Nell'esempio seguente esegue questa generazione di numeri a virgola mobile casuale 20 milioni di quell'intervallo compreso tra 0 e <xref:System.Int64.MaxValue?displayProperty=nameWithType>. In Visualizza anche la distribuzione dei valori casuali generati dal metodo.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Per generare numeri a virgola mobile casuale compreso tra due valori arbitrari, ad esempio il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo per i numeri interi, utilizzare la formula seguente:  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 Nell'esempio seguente genera numeri casuali di 1 milione che vanno da 10.0 a 11.0 e Visualizza la loro distribuzione.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Generare i valori booleani casuale  
 Il <xref:System.Random> classe non fornisce metodi che generano <xref:System.Boolean> valori. Tuttavia, è possibile definire il proprio classe o un metodo per eseguire questa operazione. L'esempio seguente definisce una classe `BooleanGenerator`, con un solo metodo, `NextBoolean`. Il `BooleanGenerator` classe archivia un <xref:System.Random> oggetto come una variabile privata. Il `NextBoolean` chiamate al metodo il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo e passa il risultato per il <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> (metodo). Si noti che 2 viene utilizzata come argomento per specificare il limite superiore del numero casuale. Poiché si tratta di un valore esclusivo, la chiamata al metodo restituisce 0 o 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Anziché creare una classe separata per generare casuale <xref:System.Boolean> valori, nell'esempio viene semplicemente potrebbe essere stata definita un singolo metodo. In tal caso, tuttavia, il <xref:System.Random> deve avere l'oggetto sia stato definito come una variabile a livello di classe per evitare un'istanza di un nuovo <xref:System.Random> istanza in ogni chiamata al metodo. In Visual Basic, l'istanza di Random può essere definita come una [statici](~/docs/visual-basic/language-reference/modifiers/static.md) di una variabile nel `NextBoolean` (metodo).  Nell'esempio seguente fornisce un'implementazione.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Generare numeri interi a 64 bit casuali  
 Gli overload del <xref:System.Random.Next%2A> metodo restituiscono valori integer a 32 bit. Tuttavia, in alcuni casi, potrebbe voler usare con numeri interi a 64 bit. Procedere come segue:  
  
1.  Chiamare il <xref:System.Random.NextDouble%2A> valore del punto per recuperare un mobile e precisione doppia.  
  
2.  Tale valore da moltiplicare <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 Nell'esempio seguente usa questa tecnica per generare valori long integer 20 milioni casuali e li classifica in 10 gruppi di uguali. Viene quindi valutato la distribuzione di numeri casuali contando il numero in ogni gruppo compreso tra 0 e <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Come illustrato nell'output dell'esempio, i numeri vengono distribuiti più o meno in modo uniforme tramite l'intervallo di un long integer.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Una tecnica alternativa che viene utilizzato bit manipolazione non genera numeri casuali realmente. Questa tecnica chiama <xref:System.Random.Next> per generare due numeri interi, sposta verso sinistra uno da 32 bit e sono uno a altro. Questa tecnica presenta due limitazioni:  
  
1.  Poiché il bit 31 bit di segno, il valore in bit 31 long integer risultante è sempre 0.  Questo problema può essere risolto tramite la generazione casuale 0 o 1, spostamento a sinistra 31 bit e ORing con long integer casuale originale.  
  
2.  Attenzione, perché la probabilità che il valore restituito da <xref:System.Random.Next> sarà pari a 0, vi saranno alcuni eventuali numeri casuali nell'intervallo 0x0 0x00000000FFFFFFFF.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Recuperare byte in un intervallo specificato  
 Gli overload del <xref:System.Random.Next%2A> metodo consentono di specificare l'intervallo di numeri casuali, ma il <xref:System.Random.NextBytes%2A> non dal metodo. L'esempio seguente implementa un `NextBytes` metodo che consente di specificare l'intervallo di byte restituiti. Definisce un `Random2` classe che deriva da <xref:System.Random> ed esegue l'overload relativi `NextBytes` (metodo).  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 Il `NextBytes(Byte[], Byte, Byte)` metodo esegue il wrapping di una chiamata al <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> (metodo) e specifica il valore minimo e una maggiore rispetto al valore massimo (in questo caso, 0 e 101) che si desidera vengano restituite nella matrice di byte. Poiché si è certi che i valori interi restituita dal <xref:System.Random.Next%2A> metodo siano compresi nell'intervallo del <xref:System.Byte> tipo di dati, è possibile in modo sicuro eseguirne il cast (in c#) o convertire (in Visual Basic) da numeri interi in byte.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Recuperare un elemento da una matrice o raccolta in modo casuale  
 Numeri casuali vengono spesso usati come gli indici per recuperare valori da matrici o raccolte. Per recuperare un valore di indice casuale, è possibile chiamare il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo e usare il limite inferiore della matrice come valore di relativi `minValue` argomento e una maggiore del limite superiore della matrice come valore del relativo `maxValue` argomento. Per una matrice in base zero, questo è equivalente al relativo <xref:System.Array.Length%2A> proprietà o una maggiore del valore restituito dal <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> (metodo). Nell'esempio seguente recupera in modo casuale il nome di una città negli Stati Uniti da una matrice di città.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Recuperare un elemento univoco da una matrice o raccolta  
 Un generatore di numeri casuali può restituire sempre valori duplicati. Quando l'intervallo di numeri diventa più piccolo o il numero di valori generati diventa più grande, aumenta la probabilità di duplicati. Se i valori casuali devono essere univoci, più numeri vengono generati per compensare la presenza di duplicati, causando sempre più spesso una riduzione delle prestazioni.  
  
 Esistono diverse tecniche per gestire questo scenario. Una soluzione comune consiste nel creare una matrice o raccolta che contiene i valori da recuperare e una matrice parallela che contiene numeri a virgola mobile casuale. Nella seconda matrice viene popolata con i numeri casuali al momento della creazione, la prima matrice e <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> metodo viene utilizzato per ordinare la prima matrice utilizzando i valori nella matrice parallela.  
  
 Ad esempio, se si sta sviluppando un gioco di Solitario, si desidera assicurarsi che ogni scheda venga utilizzata una sola volta. Invece di generare numeri casuali per recuperare una scheda e verificando se tale scheda ha già coinvolti, è possibile creare una matrice parallela di numeri casuali che possono essere usati per ordinare il mazzo di carte. Una volta il mazzo di carte è ordinato, l'app può mantenere un puntatore per indicare l'indice della scheda successiva di mettersi all'opera.  
  
 Questo approccio viene illustrato nell'esempio seguente: Definisce un `Card` classe che rappresenta una carta da gioco e un `Dealer` classe che gestisce un mazzo di carte riprodurre con sequenza casuale. Il `Dealer` costruttore di classe popola due matrici: una `deck` array con ambito di classe e che rappresenta tutte le schede in una variabile locale e il mazzo; `order` array con lo stesso numero di elementi come il `deck` matrice e come viene popolato con generato casualmente <xref:System.Double> valori.  Il <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> viene quindi chiamato il metodo per ordinare le `deck` matrice in base ai valori nel `order` matrice.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 L'esempio seguente crea un singolo generatore di numeri casuali e le chiamate relative <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, e <xref:System.Random.NextDouble%2A> metodi per generare le sequenze di numeri casuali all'interno degli intervalli diversi.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 Nell'esempio seguente genera un integer casuale che viene utilizzato come indice per recuperare un valore stringa da una matrice.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>In .NET Framework 1.0 e 1.1, un'implementazione minima di una classe derivata da <see cref="T:System.Random" /> richiedeva l'override di <see cref="M:System.Random.Sample" /> metodo per definire un algoritmo di nuovo o modificato per la generazione di numeri casuali. La classe derivata può quindi si basano sull'implementazione della classe di base del <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, e <see cref="M:System.Random.NextDouble" /> metodi per chiamare l'implementazione della classe derivata di <see cref="M:System.Random.Sample" /> (metodo).  In .NET Framework 2.0 e versioni successive, il comportamento dei <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, e <see cref="M:System.Random.NextBytes(System.Byte[])" /> metodi sono stati modificati in modo che questi metodi non necessariamente chiamano l'implementazione della classe derivata di <see cref="M:System.Random.Sample" /> (metodo). Di conseguenza, le classi derivate da <see cref="T:System.Random" /> che destinate a .NET Framework 2.0 e in un secondo momento eseguire l'override di questi tre metodi.</para>
    </block>
    <block subset="none" type="usage">
      <para>L'implementazione del generatore di numeri casuali nel <see cref="T:System.Random" /> classe non è garantito che deve rimanere uguale in tutte le versioni principali di .NET Framework. Di conseguenza, si dovrebbero evitare supposizioni che il valore di inizializzazione stessa avrà come risultato nella stessa sequenza pseudocasuale nelle diverse versioni di .NET Framework.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Random" /> utilizzando un valore di inizializzazione predefinito dipendente da un fattore temporale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di inizializzazione predefinito è derivato dal clock di sistema e ha una risoluzione limitata. Di conseguenza, diversa <xref:System.Random> gli oggetti creati da una chiamata al costruttore predefinito in successione Chiudi avranno valori di inizializzazione predefinito identici e, pertanto restituirà stessi set di numeri casuali. Questo problema può essere evitato usando un singolo <xref:System.Random> oggetto per generare tutti i numeri casuali. Possono anche aggirare il problema modificando il valore di inizializzazione restituito dal clock di sistema e quindi fornire in modo esplicito questo nuovo valore di inizializzazione per il <xref:System.Random.%23ctor%28System.Int32%29> costruttore. Per altre informazioni, vedere il <xref:System.Random.%23ctor%28System.Int32%29> costruttore.  
  
 Chiamare questo costruttore se si desidera che il generatore di numeri casuali per generare una sequenza di numeri casuali. Per generare una sequenza fissa di numeri casuali che saranno gli stessi per generatori di numeri casuali diversi, chiamare il <xref:System.Random.%23ctor%28System.Int32%29> costruttore con un valore di inizializzazione predefinito. Ciò <xref:System.Random> overload del costruttore viene spesso utilizzato durante il test di App che usano numeri casuali.  
  
 Dopo aver creato l'istanza del generatore di numeri casuali, è chiamare singole <xref:System.Random> metodi, ad esempio <xref:System.Random.Next> o <xref:System.Random.NextDouble>per generare numeri casuali.  
  
   
  
## Examples  
 L'esempio seguente usa il costruttore predefinito per creare un'istanza di tre <xref:System.Random> degli oggetti e consente di visualizzare una sequenza di cinque valori integer casuale per ognuno. Poiché le prime due <xref:System.Random> gli oggetti vengono creati in successione Chiudi, le relative istanze vengono create usando i valori di inizializzazione identici in base al clock di sistema e, pertanto producono una sequenza identica di numeri casuali. D'altra parte, il costruttore predefinito del terzo <xref:System.Random> oggetto viene chiamato dopo un ritardo di due secondi indotte chiamando il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> (metodo). Poiché questo genera un valore di inizializzazione diversi per la terza <xref:System.Random> dell'oggetto, produce una sequenza di numeri casuali diversi.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Numero usato per calcolare un valore iniziale per la sequenza di numeri pseudo-casuali. Se viene specificato un numero negativo, viene usato il valore assoluto del numero.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Random" /> usando il valore di inizializzazione specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fornendo un valore di inizializzazione identici a diversi <xref:System.Random> oggetti fa in modo che ogni istanza per produrre identiche sequenze di numeri casuali. Questa operazione viene spesso eseguita durante il test di App che si basano su generatori di numeri casuali.  
  
 Se l'applicazione richiede diverse sequenze di numeri casuali, richiamare il costruttore più volte con valori di inizializzazione diverso. Un modo per generare un valore di inizializzazione univoco è per renderla dipendenti dal tempo. Ad esempio, derivare il valore di inizializzazione dal clock di sistema, come il <xref:System.Random.%23ctor> viene overload. Tuttavia, l'orologio di sistema potrebbe non avere risoluzione sufficiente per fornire diverse chiamate di questo costruttore con un valore di inizializzazione diverso. Ciò comporta generatori di numeri casuali che generano identiche sequenze di numeri pseudo-casuali, come illustrato nei primi due <xref:System.Random> oggetti nell'esempio seguente. Per evitare questo problema, applicare un algoritmo per distinguere il valore di inizializzazione in ogni chiamata o chiamare il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per assicurarsi di aver previsto ogni costruttore con un valore di inizializzazione diverso.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Un'altra opzione consiste nel creare un'istanza di un singolo <xref:System.Random> che è utilizzato per generare tutti i numeri casuali nell'applicazione. Ciò produce prestazioni leggermente migliori, poiché è piuttosto costosa, creare un'istanza di un generatore di numeri casuali.  
  
   
  
## Examples  
 L'esempio seguente crea <xref:System.Random> oggetti con il costruttore della classe che accetta un parametro di inizializzazione e genera una sequenza di numeri interi casuali e Double. Nell'esempio viene illustrato che la stessa sequenza viene generata quando il <xref:System.Random> oggetto viene creato nuovamente con il parametro di costruttore e valore di inizializzazione.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un intero casuale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un intero casuale non negativo.</summary>
        <returns>Intero con segno a 32 bit maggiore o uguale a 0 e minore di <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> Genera un numero casuale, il cui valore è compreso tra 0 e minore di <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Per generare un numero casuale, il cui valore è compreso tra 0 e un altro numero positivo, utilizzare il <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> overload del metodo. Per generare un numero casuale all'interno di un intervallo diverso, usare il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito vengono effettuate chiamate ripetute al metodo <xref:System.Random.Next%2A> per generare un numero specifico di numeri casuali richiesti dall'utente. Il metodo <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> viene utilizzato per ricevere l'input del cliente.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 Nell'esempio seguente deriva una classe dalla classe <xref:System.Random> per generare una sequenza di numeri casuale la cui distribuzione è diversa dalla distribuzione uniforme generata dal <xref:System.Random.Sample%2A> metodo della classe di base. Viene eseguito l'override di <xref:System.Random.Sample%2A> metodo per fornire la distribuzione di numeri casuali ed esegue l'override di <xref:System.Random.Next%2A?displayProperty=nameWithType> metodo da usare una serie di numeri casuali.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Partire da .NET Framework versione 2.0, se si deriva una classe dalla classe <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione del <see cref="M:System.Random.Next" /> (metodo). Al contrario, la distribuzione uniforme restituito dalla base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento migliora le prestazioni complessive del <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare il <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è inoltre necessario sostituire il <see cref="M:System.Random.Next" /> (metodo).</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Limite superiore esclusivo del numero casuale da generare. <c>maxValue</c> deve essere maggiore o uguale a 0.</param>
        <summary>Restituisce un intero casuale non negativo inferiore al massimo specificato.</summary>
        <returns>Intero con segno a 32 bit maggiore o uguale a 0 e minore di <paramref name="maxValue" />; ovvero, l'intervallo dei valori restituiti in genere include 0 ma non <paramref name="maxValue" />. Se tuttavia <paramref name="maxValue" /> è uguale a 0 viene restituito <paramref name="maxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Random.Next%28System.Int32%29> overload restituisce numeri interi casuali quell'intervallo compreso tra 0 e `maxValue` – 1. Tuttavia, se `maxValue` è 0, il metodo restituisce 0.  
  
   
  
## Examples  
 L'esempio seguente genera integer casuale con diversi overload del <xref:System.Random.Next%2A> (metodo).  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 Nell'esempio seguente genera un integer casuale che viene utilizzato come indice per recuperare un valore stringa da una matrice. Poiché l'indice più alto della matrice è una minore la sua lunghezza, il valore della <xref:System.Array.Length%2A?displayProperty=nameWithType> proprietà deve essere fornita come un il `maxValue` parametro.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> è minore di 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Limite inferiore inclusivo del numero casuale restituito.</param>
        <param name="maxValue">Limite superiore esclusivo del numero casuale restituito. <c>maxValue</c> deve essere maggiore o uguale a <c>minValue</c>.</param>
        <summary>Restituisce un intero casuale all'interno di un intervallo specificato.</summary>
        <returns>Intero con segno a 32 bit maggiore o uguale a <paramref name="minValue" /> e minore di <paramref name="maxValue" />: l'intervallo dei valori restituiti includerà <paramref name="minValue" /> ma non <paramref name="maxValue" />. Se <paramref name="minValue" /> è uguale a <paramref name="maxValue" />, viene restituito <paramref name="minValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload restituisce numeri interi casuali compresi tra `minValue` a `maxValue` – 1. Tuttavia, se `maxValue` è uguale a `minValue`, il metodo restituisce `minValue`.  
  
 A differenza di altri overload del <xref:System.Random.Next%2A> (metodo), che restituiscono valori solo un valore non negativo, questo metodo può restituire un intero casuale negativo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo per generare numeri interi casuali con tre intervalli distinti. Si noti che l'output dell'esempio esatta dipende il valore di inizializzazione di sistema passato al <xref:System.Random> costruttore della classe.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 Nell'esempio seguente genera un integer casuale che viene utilizzato come indice per recuperare un valore stringa da una matrice. Poiché l'indice più alto della matrice è una minore la sua lunghezza, il valore della <xref:System.Array.Length%2A?displayProperty=nameWithType> proprietà deve essere fornita come un il `maxValue` parametro.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> è maggiore di <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides">
          <para>Partire da .NET Framework versione 2.0, se si deriva una classe dalla classe <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione del <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> overload del metodo se la differenza tra il <paramref name="minValue" /> e <paramref name="maxValue" /> parametri è maggiore di quella <see cref="F:System.Int32.MaxValue" />. Al contrario, la distribuzione uniforme restituito dalla base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento migliora le prestazioni complessive del <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare il <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è inoltre necessario sostituire il <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> overload del metodo.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di byte che deve contenere numeri casuali.</param>
        <summary>Inserisce numeri casuali negli elementi di una matrice di byte specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni elemento della matrice di byte è impostata su un numero casuale maggiore o uguale a 0 e minore o uguale a <xref:System.Byte.MaxValue>.  
  
 Ad esempio, per generare un numero casuale sicuro da adatto per la creazione di una password casuale, usare un metodo, ad esempio <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Random.NextBytes%2A> metodo da riempire una matrice di byte con valori di byte casuali.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Partire da .NET Framework versione 2.0, se si deriva una classe dalla classe <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione del <see cref="M:System.Random.NextBytes(System.Byte[])" /> (metodo). Al contrario, la distribuzione uniforme restituito dalla base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento migliora le prestazioni complessive del <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare il <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è inoltre necessario sostituire il <see cref="M:System.Random.NextBytes(System.Byte[])" /> (metodo).</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un numero casuale a virgola mobile e precisione doppia maggiore o uguale a 0,0 e minore di 1,0.</summary>
        <returns>Numero a virgola mobile e precisione doppia maggiore o uguale a 0,0 e minore di 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il limite superiore effettivo del numero casuale restituito da questo metodo è 0.99999999999999978.  
  
 Per recuperare i valori a virgola mobile casuale compreso in un intervallo diverso da 0.0 e 1.0, vedere la sezione "Valori a virgola mobile in un intervallo specificato di recuperare" le <xref:System.Random> argomento relativo alla classe.  
  
 Questo metodo è la versione pubblica del metodo protetto, <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Random.NextDouble%2A> metodo per generare le sequenze di valori double casuale.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 L'esempio seguente chiama il <xref:System.Random.NextDouble%2A> metodo per generare casuale 100 numeri e Visualizza la frequenza di distribuzione.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un numero a virgola mobile casuale compreso tra 0,0 e 1,0.</summary>
        <returns>Numero a virgola mobile e precisione doppia maggiore o uguale a 0,0 e minore di 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per produrre una distribuzione casuale diversa o un principio del generatore di numeri casuali diversi, derivare una classe dal <xref:System.Random> classe ed eseguire l'override di <xref:System.Random.Sample%2A> (metodo).  
  
> [!IMPORTANT]
>  Il <xref:System.Random.Sample%2A> metodo viene `protected`, che significa che è accessibile solo all'interno di <xref:System.Random> classe e le relative classi derivate. Per generare un numero casuale compreso tra 0 e 1 da un <xref:System.Random> dell'istanza, chiamare il <xref:System.Random.NextDouble%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente deriva una classe dalla classe <xref:System.Random> ed esegue l'override di <xref:System.Random.Sample%2A> metodo per generare una distribuzione di numeri casuali. Questa distribuzione è diversa dalla distribuzione uniforme generata dal <xref:System.Random.Sample%2A> metodo della classe di base.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Partire da .NET Framework versione 2.0, se si deriva una classe dalla classe <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione dei metodi seguenti: - il <see cref="M:System.Random.NextBytes(System.Byte[])" /> (metodo).  -La <see cref="M:System.Random.Next" /> (metodo).  -il <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> metodo, se (<paramref name="maxValue" /> - <paramref name="minValue" />) è maggiore di quella <see cref="F:System.Int32.MaxValue" />.  Al contrario, la distribuzione uniforme fornito da base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento migliora le prestazioni complessive del <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare l'implementazione del <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è anche necessario eseguire l'override del comportamento di questi tre membri. Nell'esempio viene illustrato.</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>