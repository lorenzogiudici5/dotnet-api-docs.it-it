<Type Name="Random" FullName="System.Random">
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un generatore di numeri pseudo-casuali, ovvero un dispositivo che produce una sequenza di numeri che soddisfano determinati requisiti statistici di casualità.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numeri pseudo-casuali vengono scelti con probabilità uguale da un set limitato di numeri. I numeri selezionati non sono completamente casuali perché viene utilizzato un algoritmo matematico per selezionarli, ma sono sufficientemente casuale ai fini pratici. L'implementazione corrente del <xref:System.Random> classe si basa su una versione modificata del sottrattivo generatore algoritmo di numeri casuali Donald E. Knuth. Per altre informazioni, vedere E. D. Knuth. *La locandina dei linguaggi di programmazione, il Volume 2: algoritmi Seminumerical*. Edizione Addison-Wesley, lettura, MA, terzo, 1997.  
  
 Per generare un numero casuale crittograficamente sicuro, ad esempio un oggetto che è adatto per la creazione di una password casuale, usare il <xref:System.Security.Cryptography.RNGCryptoServiceProvider> classe o una classe derivata da <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 In questo argomento  
  
 [Creazione di un'istanza del generatore di numeri caso](#Instantiate)   
 [Come evitare il più creazioni di istanza](#Multiple)   
 [La sicurezza di thread e classe Random](#ThreadSafety)   
 [Generazione di tipi diversi di numeri casuali](#Functionality)   
 [Sostituzione di un proprio algoritmo](#Overriding)   
 [Utilizzo di Random per...](#Operations)   
 [Recuperare la stessa sequenza di valori casuali](#Same)  
 [Recuperano le sequenza univoche di valori casuali](#Unique)  
 [Recuperare interi in un intervallo specificato](#Range)  
 [Recuperare interi con un numero di cifre specificato](#Digits)  
 [Recuperare i valori a virgola mobile in un intervallo specificato](#Floats)  
 [Generazione casuali Boolean (valori)](#Boolean)  
 [Generare numeri interi a 64 bit casuali](#Long)  
 [Recuperare byte in un intervallo specificato](#Bytes)  
 [Recupera un elemento da una matrice o raccolta in modo casuale](#Array)  
 [Recupera un elemento univoco da una matrice o raccolta](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Creazione di un'istanza del generatore di numeri caso  
 Si crea un'istanza del generatore di numeri caso, fornendo un valore di inizializzazione (un valore iniziale per l'algoritmo di generazione di numeri pseudo-casuali) per un <xref:System.Random.%23ctor%2A> costruttore della classe.  È possibile fornire il valore di inizializzazione in modo implicito o esplicito:  
  
-   Il <xref:System.Random.%23ctor%28System.Int32%29> costruttore Usa un valore di inizializzazione esplicita che viene fornito.  
  
-   Il <xref:System.Random.%23ctor> costruttore Usa l'orologio di sistema per fornire un valore di inizializzazione. Questo è il modo più comune di un'istanza del generatore di numeri caso.  
  
 Se il valore di inizializzazione stessa viene utilizzato per separato <xref:System.Random> oggetti, i generatori produrranno la stessa serie di numeri casuali. Ciò può essere utile per la creazione di un gruppo di test che elabora i valori casuali o per riprodurre i giochi che derivano i dati da numeri casuali. Si noti tuttavia che <xref:System.Random> oggetti nei processi in esecuzione in versioni diverse di .NET Framework potrebbero restituire diverse serie di numeri casuali, anche se si è creata un'istanza con valori di inizializzazione identici.  
  
 Per produrre un gruppo di sequenze di numeri casuali, è possibile apportare il valore di inizializzazione dipendenti dal tempo, in tal modo che produce una serie diversa con ogni nuova istanza della <xref:System.Random>. I parametri <xref:System.Random.%23ctor%28System.Int32%29> costruttore può accettare una <xref:System.Int32> valore in base al numero di tick nell'ora corrente, mentre senza parametri <xref:System.Random.%23ctor> costruttore Usa l'orologio di sistema per generare il valore di inizializzazione. Tuttavia, poiché l'orologio ha una risoluzione finita, utilizzando il costruttore senza parametri per creare diversi <xref:System.Random> oggetti in successione Chiudi crea generatori di numeri casuali che producono sequenze identiche di numeri casuali. Nell'esempio seguente viene illustrato come due <xref:System.Random> gli oggetti che vengono creata un'istanza in successione Chiudi generano una serie di numeri casuali identica. Nella maggior parte dei sistemi Windows, <xref:System.Random> gli oggetti creati entro 15 millisecondi una da altra sono probabilmente hanno valori di inizializzazione identici.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Per evitare questo problema, creare un singolo <xref:System.Random> oggetto anziché più oggetti.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Come evitare il più creazioni di istanza  
 L'inizializzazione due i generatori di numeri casuali in un ciclo rigido o in rapida successione crea due generatori di numeri casuali che possono produrre identiche sequenze di numeri casuali. Nella maggior parte dei casi, ciò non preventivo per gli sviluppatori e può causare problemi di prestazioni, poiché creandone un'istanza e l'inizializzazione di un generatore di numeri casuali è un processo relativamente costoso.  
  
 Per migliorare le prestazioni sia per evitare di creare inavvertitamente separati i generatori di numeri casuali che generano sequenze numeriche identiche, è consigliabile creare un <xref:System.Random> oggetto per generare numeri casuali molti nel corso del tempo, anziché creare nuovo <xref:System.Random> oggetti per generare un numero casuale.  
  
 Tuttavia, il <xref:System.Random> classe non è thread-safe. Se si chiama <xref:System.Random> i metodi da più thread, seguire le linee guida descritte nella sezione successiva.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>La sicurezza di thread e classe Random  
 Anziché creare un'istanza utente singolo <xref:System.Random> oggetti, si consiglia di creare un singolo <xref:System.Random> istanza per generare tutti i numeri casuali necessari all'applicazione. Tuttavia, <xref:System.Random> oggetti non sono thread-safe. Se l'app chiama <xref:System.Random> metodi da più thread, è necessario utilizzare un oggetto di sincronizzazione per garantire che solo un thread può accedere il generatore di numeri casuali alla volta. Se si non garantiscono che le <xref:System.Random> oggetto avviene in modo thread-safe, le chiamate ai metodi che restituiscono numeri casuali restituiscono 0.  
  
 L'esempio seguente usa il linguaggio c# [istruzione lock](~/docs/csharp/language-reference/keywords/lock-statement.md) e Visual Basic [istruzione SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) per garantire che un singolo generatore di numeri casuali accedono 11 thread in modo thread-safe. Ogni thread genera 2 milioni di numeri casuali, Conta il numero di numeri casuali generati e viene calcolata la somma e quindi aggiorna i totali per tutti i thread quando viene completata l'esecuzione.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 L'esempio specifica la thread safety nei modi seguenti:  
  
-   Il <xref:System.ThreadStaticAttribute> attributo viene utilizzato per definire le variabili locali del thread che rilevano il numero totale di numeri casuali generati e la somma per ogni thread.  
  
-   Un blocco (il `lock` istruzione nel linguaggio c# e `SyncLock` istruzione in Visual Basic) protegge l'accesso alle variabili per il numero totale e la somma di tutti i numeri casuali generati in tutti i thread.  
  
-   Un semaforo (il <xref:System.Threading.CountdownEvent> oggetto) viene usato per garantire che il thread principale si blocca finché tutti gli altri thread completamento dell'esecuzione.  
  
-   Nell'esempio viene controllato se il generatore di numeri casuali è danneggiato, determinando se due chiamate consecutive di metodi di generazione di numeri casuali restituiscono 0. Se l'errore viene individuato, nell'esempio viene utilizzato il <xref:System.Threading.CancellationTokenSource> oggetto per segnalare che tutti i thread devono essere annullati.  
  
-   Prima di generare ogni numero casuale, ogni thread controlla lo stato del <xref:System.Threading.CancellationToken> oggetto. Se viene richiesto l'annullamento, nell'esempio viene chiamato il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodo per annullare il thread.  
  
 Nell'esempio seguente è identico al primo, ad eccezione del fatto che usa un <xref:System.Threading.Tasks.Task> oggetto e un'espressione lambda anziché <xref:System.Threading.Thread> oggetti.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Differisce da nel primo esempio nei modi seguenti:  
  
-   Le variabili di tenere traccia del numero di numeri casuali generati e somma in ogni attività sono locali per l'attività, pertanto non è necessario utilizzare il <xref:System.ThreadStaticAttribute> attributo.  
  
-   Il metodo statico <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodo viene utilizzato per verificare che il thread principale non viene completato prima del completamento di tutte le attività. Non è necessario per il <xref:System.Threading.CountdownEvent> oggetto.  
  
-   L'eccezione risultante dall'annullamento delle attività viene esposto nel <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodo. Nell'esempio precedente, viene gestita da ogni thread.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Generazione di tipi diversi di numeri casuali  
 Generatore di numeri casuali fornisce metodi che consentono di generare i tipi di numeri casuali seguenti:  
  
-   Una serie di <xref:System.Byte> valori. Determinare il numero di valori byte passando una matrice inizializzata per il numero di elementi che si desidera che il metodo per restituire il <xref:System.Random.NextBytes%2A> metodo. Nell'esempio seguente genera l'errore pari a 20 byte.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Un numero intero. È possibile scegliere se si desidera che un numero intero compreso tra 0 a un valore massimo (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) chiamando il <xref:System.Random.Next> metodo, un numero intero compreso tra 0 e un valore specifico chiamando il <xref:System.Random.Next%28System.Int32%29> metodo oppure un valore integer all'interno di un intervallo di valori mediante la chiamata di <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>metodo. In overload con parametri, il valore massimo specificato è esclusivo; vale a dire, il numero massimo effettivo generato è uno minore del valore specificato.  
  
     L'esempio seguente chiama il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> per generare i 10 numeri casuali compreso tra -10 e 10. Si noti che il secondo argomento del metodo specifica il limite superiore esclusivo dell'intervallo di valori casuali restituito dal metodo. In altre parole, l'intero più grande che il metodo può restituire è inferiore a questo valore.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Un singolo valore a virgola mobile compreso tra 0,0 minore di 1,0 chiamando il <xref:System.Random.NextDouble%2A> metodo. Il limite superiore esclusivo del numero casuale restituito dal metodo è 1, pertanto il limite massimo effettivo è 0.99999999999999978. Nell'esempio seguente genera l'errore 10 numeri a virgola mobile casuali.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  Il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo consente di specificare l'intervallo del numero casuale restituito. Tuttavia, il `maxValue` parametro, che specifica l'intervallo superiore restituiti numeri, è esclusiva, non un inclusivo, valore. Ciò significa che la chiamata al metodo `Next(0, 100)` restituisce un valore compreso tra 0 e 99 e non è compreso tra 0 e 100.  
  
 È anche possibile usare il <xref:System.Random> classe per attività quali la generazione [valori casuali T:System.Boolean](#Boolean), la generazione [valori a virgola mobile casuale con un intervallo diverso da 0 a 1](#Floats), generazione [interi a 64 bit casuale](#Long), e [in modo casuale il recupero di un elemento univoco da una matrice o raccolta](#UniqueArray). Per queste e altre attività comuni, vedere il [come utilizzare Random per...](#Operations) sezione.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Sostituzione di un proprio algoritmo  
 È possibile implementare il propria generatore di numeri casuali tramite l'eredità dal <xref:System.Random> (classe) e fornendo l'algoritmo di generazione di numeri casuali. Per fornire un proprio algoritmo, è necessario eseguire l'override di <xref:System.Random.Sample%2A> metodo, che implementa l'algoritmo di generazione di numeri casuali. È inoltre necessario sostituire i <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, e <xref:System.Random.NextBytes%2A> metodi per garantire che chiamano sottoposto a override <xref:System.Random.Sample%2A> metodo. Non è necessario eseguire l'override di <xref:System.Random.Next%28System.Int32%29> e <xref:System.Random.NextDouble%2A> metodi.  
  
 Per un esempio da cui deriva il <xref:System.Random> classe e modifica, il generatore di numeri pseudo-casuali predefinito vedere il <xref:System.Random.Sample%2A> pagina di riferimento.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Utilizzo di Random per...  
 Nelle sezioni seguenti forniscono informazioni e codice di esempio per alcuni dei modi che si potrebbe voler usare numeri casuali nell'app.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Recuperare la stessa sequenza di valori casuali  
 Talvolta si desidera generare la stessa sequenza di numeri casuali negli scenari di test di software e giochi. Eseguire i test con la stessa sequenza di numeri casuali consente di rilevare le regressioni e confermare la correzione di bug. Utilizzando la stessa sequenza di numero casuale nei giochi consente di riprodurre giochi precedente.  
  
 È possibile generare la stessa sequenza di numeri casuali, fornendo lo stesso valore di inizializzazione per il <xref:System.Random.%23ctor%28System.Int32%29> costruttore. Il valore di inizializzazione fornisce un valore inizio per l'algoritmo di generazione di numeri pseudo-casuali. L'esempio seguente usa 100100 come un valore di inizializzazione arbitrario per creare un'istanza di <xref:System.Random> oggetto, vengono visualizzati i valori a virgola mobile casuali 20 e mantiene il valore di inizializzazione. Quindi Ripristina il valore di inizializzazione, viene creata un'istanza di un nuovo generatore di numeri casuali e consente di visualizzare lo stessi 20 casuali valori a virgola mobile.  Si noti che nell'esempio può produrre un gruppo di sequenze di numeri casuali se eseguiti in versioni diverse di .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Recuperano le sequenza univoche di numeri casuali  
 Fornire valori di inizializzazione diversi per le istanze del <xref:System.Random> classe fa sì che ogni generatore di numeri casuali generare una sequenza di valori diversi. È possibile fornire un valore di inizializzazione in modo esplicito chiamando il <xref:System.Random.%23ctor%28System.Int32%29> costruttore, o in modo implicito chiamando la <xref:System.Random.%23ctor> costruttore. La maggior parte degli sviluppatori di chiamano il costruttore senza parametri, che usa l'orologio di sistema. Nell'esempio seguente viene utilizzato questo approccio per creare un'istanza di due <xref:System.Random> istanze. Ogni istanza viene visualizzata una serie di 10 numeri interi casuali.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Tuttavia, a causa di risoluzione finita, l'orologio di sistema non rileva le differenze di ora che sono meno di circa 15 millisecondi. Pertanto, se il codice chiama il <xref:System.Random.%23ctor> per creare un'istanza di due overload <xref:System.Random> oggetti in successione, si potrebbero inavvertitamente rese gli oggetti con valori di inizializzazione identici. Per visualizzare il risultato nell'esempio precedente, impostare come commento il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> chiamata al metodo e compilazione ed eseguire nuovamente l'esempio.  
  
 Per evitare che ciò accada, è consigliabile che si crea un'istanza di un singolo <xref:System.Random> oggetto anziché più sessioni. Tuttavia, poiché <xref:System.Random> non è thread-safe, è necessario usare un dispositivo di sincronizzazione se si accede a un <xref:System.Random> dell'istanza da più thread; per ulteriori informazioni, vedere [casuale di indipendenza dai tipi di classe e thread](#ThreadSafety) più indietro in questo argomento. In alternativa, è possibile utilizzare un meccanismo di ritardo, ad esempio il <xref:System.Threading.Thread.Sleep%2A> metodo usato nell'esempio precedente, per garantire che le istanze create esecuzione distanti superiore a 15 millisecondi.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Recuperare interi in un intervallo specificato  
 È possibile recuperare valori integer in un intervallo specificato chiamando il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo, che consente di specificare sia il più basso e il limite superiore dei numeri desideri generatore di numeri casuali da restituire. Il limite superiore è esclusiva, non un inclusivo, valore. Vale a dire, e non è incluso nell'intervallo dei valori restituiti dal metodo. Definisce una  classe che deriva da  ed esegue l'overload relativi  metodo. Il `maxValue` metodo esegue il wrapping di una chiamata al  (metodo) e specifica il valore minimo e una maggiore rispetto al valore massimo (in questo caso, 0 e 101) che si desidera vengano restituite nella matrice di byte.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Recuperare interi con un numero di cifre specificato  
 Poiché si è certi che i valori interi restituito dal <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo siano compresi nell'intervallo del  tipo di dati, è possibile in modo sicuro eseguirne il cast (in c#) o convertire (in Visual Basic) da numeri interi in byte. Numeri casuali vengono spesso utilizzate come indici per recuperare valori da matrici o raccolte.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Recuperare i valori a virgola mobile in un intervallo specificato  
 Per recuperare un valore di indice casuale, è possibile chiamare il <xref:System.Random.NextDouble%2A> metodo e utilizzare il limite inferiore della matrice come valore della relativa  argomento e una maggiore del limite superiore della matrice come valore del relativo  argomento. Una matrice in base zero, questa opzione equivale a relativa  proprietà oppure una maggiore del valore restituito dal  metodo.  
  
 Nell'esempio seguente recupera in modo casuale il nome di una città negli Stati Uniti da una matrice di città. Un generatore di numeri casuali può restituire sempre valori duplicati.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Quando l'intervallo di numeri diventa più piccolo o il numero di valori generati diventa più grande, aumenta la probabilità di duplicati. Se i valori casuali devono essere univoci, altri numeri vengono generati per compensare la presenza di duplicati, risultante sempre più spesso una riduzione delle prestazioni. Esistono diverse tecniche per gestire questo scenario.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Una soluzione comune consiste nel creare una matrice o raccolta che contiene i valori da recuperare e una matrice parallela che contiene numeri a virgola mobile casuali.  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 La seconda matrice viene popolata con numeri casuali al momento della creazione, la prima matrice e il  metodo viene utilizzato per ordinare la prima matrice utilizzando i valori nella matrice parallela.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Generazione casuali Boolean (valori)  
 Ad esempio, se stai sviluppando un gioco di Spider, si desidera garantire che ogni scheda venga utilizzata una sola volta. Invece di generare numeri casuali per recuperare una scheda e verificare se tale scheda già coinvolti, è possibile creare una matrice parallela di numeri casuali che possono essere usati per ordinare il ponte. Una volta il ponte è ordinato, l'app consente di mantenere un puntatore per indicare l'indice della scheda successiva nel piano. Definisce una `BooleanGenerator` classe che rappresenta una carta da gioco e <xref:System.Random> classe che gestisce un ponte di schede di riprodurre con sequenza casuale. Il `NextBoolean` costruttore di classe popola due matrici: una <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> matrice con ambito di classe e che rappresenta tutte le schede in locale e il ponte; <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> matrice con lo stesso numero di elementi come il  matrice e come viene popolato con generato casualmente  valori. Il  viene quindi chiamato il metodo per ordinare il  matrice in base ai valori nel  matrice. L'esempio seguente crea un generatore di numeri casuali singolo e chiama il relativo , , e  i metodi per generare le sequenze di numeri casuali all'interno degli intervalli diversi.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Nell'esempio seguente genera l'errore di un intero casuale che viene utilizzato come indice per recuperare un valore stringa da una matrice. In .NET Framework 1.0 e 1.1, un'implementazione minima di una classe derivata da <xref:System.Random> richiedeva l'override di  metodo per definire un algoritmo nuovo o modificato per la generazione di numeri casuali. La classe derivata poteva quindi basarsi sull'implementazione della classe base il , , , , e  metodi per chiamare l'implementazione della classe derivata di  (metodo).  In .NET Framework 2.0 e versioni successive, il comportamento del , , e  metodi sono stati modificati in modo che questi metodi non necessariamente chiamare l'implementazione della classe derivata di  metodo.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Generare numeri interi a 64 bit casuali  
 Di conseguenza, le classi derivate da  che destinate a .NET Framework 2.0 e versioni successive deve anche eseguire l'override tre metodi seguenti. L'implementazione del generatore di numeri casuali nel  classe non è garantito che rimangono invariati dalle versioni principali di .NET Framework. Procedere come segue:  
  
1.  Di conseguenza, è consigliabile non presupporre che il valore di inizializzazione stessa comporterà la stessa sequenza pseudocasuale in versioni diverse di .NET Framework.  
  
2.  Inizializza una nuova istanza di <xref:System.Int64.MaxValue?displayProperty=nameWithType> classe, utilizzando un valore di inizializzazione predefinito dipendenti dal tempo.  
  
 Il valore di inizializzazione predefinito è derivato dal clock di sistema e ha una risoluzione limitata. Di conseguenza, diversi <xref:System.Int64.MaxValue?displayProperty=nameWithType> gli oggetti creati in stretta successione da una chiamata al costruttore predefinito avranno i valori di inizializzazione predefiniti identici e, pertanto, produrranno insiemi identici di numeri casuali. Questo problema può essere evitato utilizzando una singola  oggetto per generare tutti i numeri casuali.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Possono anche aggirare il problema modificando il valore di inizializzazione restituito dal clock di sistema e quindi specificare esplicitamente il nuovo valore di inizializzazione per il  costruttore. Per altre informazioni, vedere il <xref:System.Random.Next> costruttore. Chiamare questo costruttore se si desidera che il generatore di numeri casuali per generare una sequenza di numeri casuali.  
  
1.  Per generare una sequenza di numeri casuali che saranno uguali per differenti generatori di numeri casuali fissa, chiamare il  costruttore con un valore di inizializzazione predefinito.  Ciò  overload del costruttore è frequente durante il test di App che usano numeri casuali.  
  
2.  Dopo aver creato l'istanza del generatore di numeri caso, si chiama singole <xref:System.Random.Next> metodi, ad esempio  o , per generare numeri casuali.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Recuperare byte in un intervallo specificato  
 L'esempio seguente usa il costruttore predefinito per creare un'istanza di tre <xref:System.Random.Next%2A> oggetti e viene visualizzata una sequenza di numeri interi casuali cinque per ognuno. Poiché le prime due `NextBytes` gli oggetti vengono creati in successione Chiudi, creazione di istanze con valori di inizializzazione identici in base al clock di sistema e, pertanto producono una sequenza identica di numeri casuali. D'altra parte, il costruttore predefinito del terzo `Random2` oggetto viene chiamato dopo un ritardo di due secondi si verifichino chiamando il <xref:System.Random> metodo.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 Poiché questo genera un valore di inizializzazione diversi per la terza `NextBytes(Byte[], Byte, Byte)` dell'oggetto, viene prodotta una sequenza di numeri casuali diversi. Inizializza una nuova istanza di <xref:System.Random.Next%2A> classe, utilizzando il valore di inizializzazione specificato.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Recupera un elemento da una matrice o raccolta in modo casuale  
 Fornendo un valore di inizializzazione identico a diversi  oggetti fa sì che ogni istanza per produrre sequenze identiche di numeri casuali. Questo accade spesso quando il test di App che si basano su generatori di numeri casuali. Se l'applicazione richiede diverse sequenze di numeri casuali, richiamare il costruttore più volte con valori di inizializzazione diversi. Un modo per generare un valore di inizializzazione univoco è per renderlo dipendenti dal tempo.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Recupera un elemento univoco da una matrice o raccolta  
 Ad esempio, derivare il valore di inizializzazione dal clock di sistema, come il  overload. Tuttavia, l'orologio di sistema potrebbe non avere risoluzione sufficiente per fornire diverse chiamate di questo costruttore con un valore di inizializzazione diversi. Di conseguenza generatori di numeri casuali che generano sequenze identiche di numeri pseudo-casuali, come illustrato per le prime due  oggetti nell'esempio seguente.  
  
 Per evitare questo problema, applica un algoritmo per distinguere il valore di inizializzazione in ogni chiamata oppure chiamare il  metodo in modo che si fornisce ogni costruttore con un valore di inizializzazione diversi. È anche possibile creare un'istanza di un singolo  dell'oggetto che consente di generare tutti i numeri casuali nell'applicazione. Questo offre prestazioni leggermente migliori, poiché creazione di un generatore di numeri casuali è alquanto costosa.  
  
 L'esempio seguente crea  oggetti con il costruttore della classe che accetta un parametro di inizializzazione e genera una sequenza di numeri interi casuali e Double. Nell'esempio viene illustrato che la stessa sequenza viene generata quando il  oggetto viene creato nuovamente con il parametro di costruttore e valore di inizializzazione. Genera un numero casuale il cui valore è compreso tra 0 e minore .  
  
 Questo approccio viene illustrato nell'esempio seguente: Per generare un numero casuale il cui valore è compreso tra 0 e un altro numero positivo, utilizzare il `Card` overload del metodo. Per generare un numero casuale all'interno di un intervallo diverso, utilizzare il `Dealer` overload del metodo.  Nell'esempio seguente deriva una classe da <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> per generare una sequenza di numeri casuali la cui distribuzione differisce dalla distribuzione uniforme generata dal `deck` metodo della classe base.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 Per produrre una distribuzione casuale diversa o un principio generatore di numeri casuali diversi, derivare una classe dal <xref:System.Random.NextBytes%2A> classe ed eseguire l'override di <xref:System.Random.Next%2A> metodo.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 Il  metodo , il che significa che sia accessibile solo all'interno di  classe e le relative classi derivate.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Per generare un numero casuale compreso tra 0 e 1 da un <para> dell'istanza, chiamare il <see cref="T:System.Random" /> metodo. Nell'esempio seguente deriva una classe da  ed esegue l'override di  per generare una distribuzione di numeri casuali.  Questa distribuzione è diversa rispetto a distribuzione uniforme generata dal  metodo della classe base. Partire da .NET Framework versione 2.0, se si deriva una classe da  ed eseguire l'override di  metodo, la distribuzione fornita dall'implementazione della classe derivata del  metodo non viene utilizzato nelle chiamate alla classe di base implementazione dei metodi seguenti: - il  metodo.  -La  metodo.  -La  metodo, se () è maggiore di .</para></block>
    <block subset="none" type="usage"><para>Al contrario, la distribuzione uniforme fornita da base  classe viene utilizzata. Questo comportamento consente di migliorare le prestazioni complessive della  classe.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Random" /> utilizzando un valore di inizializzazione predefinito dipendente da un fattore temporale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di inizializzazione predefinito è derivato dal clock di sistema e ha una risoluzione limitata. Di conseguenza, diversi <xref:System.Random> gli oggetti creati in stretta successione da una chiamata al costruttore predefinito avranno i valori di inizializzazione predefiniti identici e, pertanto, produrranno insiemi identici di numeri casuali. Questo problema può essere evitato utilizzando una singola <xref:System.Random> oggetto per generare tutti i numeri casuali. Possono anche aggirare il problema modificando il valore di inizializzazione restituito dal clock di sistema e quindi specificare esplicitamente il nuovo valore di inizializzazione per il <xref:System.Random.%23ctor%28System.Int32%29> costruttore. Per altre informazioni, vedere il <xref:System.Random.%23ctor%28System.Int32%29> costruttore.  
  
 Chiamare questo costruttore se si desidera che il generatore di numeri casuali per generare una sequenza di numeri casuali. Per generare una sequenza di numeri casuali che saranno uguali per differenti generatori di numeri casuali fissa, chiamare il <xref:System.Random.%23ctor%28System.Int32%29> costruttore con un valore di inizializzazione predefinito. Ciò <xref:System.Random> overload del costruttore è frequente durante il test di App che usano numeri casuali.  
  
 Dopo aver creato l'istanza del generatore di numeri caso, si chiama singole <xref:System.Random> metodi, ad esempio <xref:System.Random.Next> o <xref:System.Random.NextDouble>, per generare numeri casuali.  
  
   
  
## Examples  
 L'esempio seguente usa il costruttore predefinito per creare un'istanza di tre <xref:System.Random> oggetti e viene visualizzata una sequenza di numeri interi casuali cinque per ognuno. Poiché le prime due <xref:System.Random> gli oggetti vengono creati in successione Chiudi, creazione di istanze con valori di inizializzazione identici in base al clock di sistema e, pertanto producono una sequenza identica di numeri casuali. D'altra parte, il costruttore predefinito del terzo <xref:System.Random> oggetto viene chiamato dopo un ritardo di due secondi si verifichino chiamando il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo. Poiché questo genera un valore di inizializzazione diversi per la terza <xref:System.Random> dell'oggetto, viene prodotta una sequenza di numeri casuali diversi.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Numero usato per calcolare un valore iniziale per la sequenza di numeri pseudo-casuali. Se viene specificato un numero negativo, viene usato il valore assoluto del numero.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Random" /> usando il valore di inizializzazione specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fornendo un valore di inizializzazione identico a diversi <xref:System.Random> oggetti fa sì che ogni istanza per produrre sequenze identiche di numeri casuali. Questo accade spesso quando il test di App che si basano su generatori di numeri casuali.  
  
 Se l'applicazione richiede diverse sequenze di numeri casuali, richiamare il costruttore più volte con valori di inizializzazione diversi. Un modo per generare un valore di inizializzazione univoco è per renderlo dipendenti dal tempo. Ad esempio, derivare il valore di inizializzazione dal clock di sistema, come il <xref:System.Random.%23ctor> overload. Tuttavia, l'orologio di sistema potrebbe non avere risoluzione sufficiente per fornire diverse chiamate di questo costruttore con un valore di inizializzazione diversi. Di conseguenza generatori di numeri casuali che generano sequenze identiche di numeri pseudo-casuali, come illustrato per le prime due <xref:System.Random> oggetti nell'esempio seguente. Per evitare questo problema, applica un algoritmo per distinguere il valore di inizializzazione in ogni chiamata oppure chiamare il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo in modo che si fornisce ogni costruttore con un valore di inizializzazione diversi.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 È anche possibile creare un'istanza di un singolo <xref:System.Random> dell'oggetto che consente di generare tutti i numeri casuali nell'applicazione. Questo offre prestazioni leggermente migliori, poiché creazione di un generatore di numeri casuali è alquanto costosa.  
  
   
  
## Examples  
 L'esempio seguente crea <xref:System.Random> oggetti con il costruttore della classe che accetta un parametro di inizializzazione e genera una sequenza di numeri interi casuali e Double. Nell'esempio viene illustrato che la stessa sequenza viene generata quando il <xref:System.Random> oggetto viene creato nuovamente con il parametro di costruttore e valore di inizializzazione.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un intero casuale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un intero casuale non negativo.</summary>
        <returns>Intero con segno a 32 bit maggiore o uguale a 0 e minore di <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> Genera un numero casuale il cui valore è compreso tra 0 e minore <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Per generare un numero casuale il cui valore è compreso tra 0 e un altro numero positivo, utilizzare il <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> overload del metodo. Per generare un numero casuale all'interno di un intervallo diverso, utilizzare il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito vengono effettuate chiamate ripetute al metodo <xref:System.Random.Next%2A> per generare un numero specifico di numeri casuali richiesti dall'utente. Il metodo <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> viene utilizzato per ricevere l'input del cliente.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 Nell'esempio seguente deriva una classe da <xref:System.Random> per generare una sequenza di numeri casuali la cui distribuzione differisce dalla distribuzione uniforme generata dal <xref:System.Random.Sample%2A> metodo della classe base. Viene eseguito l'override di <xref:System.Random.Sample%2A> metodo per fornire la distribuzione di numeri casuali ed esegue l'override di <xref:System.Random.Next%2A?displayProperty=nameWithType> metodo da utilizzare serie di numeri casuali.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Partire da .NET Framework versione 2.0, se si deriva una classe da <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione del <see cref="M:System.Random.Next" /> metodo. Al contrario, la distribuzione uniforme restituito da base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento consente di migliorare le prestazioni complessive della <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare il <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è necessario inoltre l'override di <see cref="M:System.Random.Next" /> metodo.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Limite superiore esclusivo del numero casuale da generare. <c>maxValue</c> deve essere maggiore o uguale a 0.</param>
        <summary>Restituisce un intero casuale non negativo inferiore al massimo specificato.</summary>
        <returns>Intero con segno a 32 bit maggiore o uguale a 0 e minore di <paramref name="maxValue" />; ovvero, l'intervallo dei valori restituiti in genere include 0 ma non <paramref name="maxValue" />. Se tuttavia <paramref name="maxValue" /> è uguale a 0 viene restituito <paramref name="maxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Random.Next%28System.Int32%29> overload restituisce integer casuali quell'intervallo da 0 a `maxValue` – 1. Tuttavia, se `maxValue` è 0, il metodo restituisce 0.  
  
   
  
## Examples  
 Nell'esempio seguente genera l'errore integer casuali con diversi overload del <xref:System.Random.Next%2A> metodo.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 Il  metodo , il che significa che sia accessibile solo all'interno di  classe e le relative classi derivate. Poiché l'indice più alto della matrice è una minore relativa lunghezza, il valore della <xref:System.Array.Length%2A?displayProperty=nameWithType> proprietà deve essere fornita come un il `maxValue` parametro.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue" /> è minore di 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Limite inferiore inclusivo del numero casuale restituito.</param>
        <param name="maxValue">Limite superiore esclusivo del numero casuale restituito. <c>maxValue</c> deve essere maggiore o uguale a <c>minValue</c>.</param>
        <summary>Restituisce un intero casuale all'interno di un intervallo specificato.</summary>
        <returns>Intero con segno a 32 bit maggiore o uguale a <paramref name="minValue" /> e minore di <paramref name="maxValue" />: l'intervallo dei valori restituiti includerà <paramref name="minValue" /> ma non <paramref name="maxValue" />. Se <paramref name="minValue" /> è uguale a <paramref name="maxValue" />, viene restituito <paramref name="minValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload restituisce integer casuali che vanno da `minValue` a `maxValue` – 1. Tuttavia, se `maxValue` è uguale a `minValue`, il metodo restituisce `minValue`.  
  
 A differenza di altri overload del <xref:System.Random.Next%2A> (metodo), che restituiscono valori solo negativo, questo metodo può restituire un intero casuale negativo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> per generare numeri interi casuali con tre intervalli distinti. Si noti che l'output dell'esempio esatto dipende dal valore inizializzazione fornito dal sistema passato al <xref:System.Random> costruttore della classe.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 Il  metodo , il che significa che sia accessibile solo all'interno di  classe e le relative classi derivate. Poiché l'indice più alto della matrice è una minore relativa lunghezza, il valore della <xref:System.Array.Length%2A?displayProperty=nameWithType> proprietà deve essere fornita come un il `maxValue` parametro.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minValue" /> è maggiore di <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides"><para>Partire da .NET Framework versione 2.0, se si deriva una classe da <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione del <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> overload del metodo se la differenza tra il <paramref name="minValue" /> e <paramref name="maxValue" /> parametri è maggiore di <see cref="F:System.Int32.MaxValue" />. Al contrario, la distribuzione uniforme restituito da base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento consente di migliorare le prestazioni complessive della <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare il <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è necessario inoltre l'override di <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> overload del metodo.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di byte che deve contenere numeri casuali.</param>
        <summary>Inserisce numeri casuali negli elementi di una matrice di byte specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni elemento della matrice di byte è impostata su un numero casuale maggiore o uguale a 0 e minore o uguale a <xref:System.Byte.MaxValue>.  
  
 Ad esempio, per generare un numero casuale crittograficamente sicuro adatto per la creazione di una password casuale, utilizzare un metodo, ad esempio <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Random.NextBytes%2A> (metodo) con valori a byte casuali a una matrice di byte.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> è <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Partire da .NET Framework versione 2.0, se si deriva una classe da <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione del <see cref="M:System.Random.NextBytes(System.Byte[])" /> metodo. Al contrario, la distribuzione uniforme restituito da base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento consente di migliorare le prestazioni complessive della <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare il <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è necessario inoltre l'override di <see cref="M:System.Random.NextBytes(System.Byte[])" /> metodo.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un numero casuale a virgola mobile e precisione doppia maggiore o uguale a 0,0 e minore di 1,0.</summary>
        <returns>Numero a virgola mobile e precisione doppia maggiore o uguale a 0,0 e minore di 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il limite superiore effettivo del numero casuale restituito da questo metodo è 0.99999999999999978.  
  
 Per recuperare i valori a virgola mobile casuali compreso in un intervallo diverso da 0,0 e 1,0, vedere la sezione "Recuperare valori a virgola mobile in un intervallo specificato" il <xref:System.Random> argomento relativo alla classe.  
  
 Questo metodo è la versione pubblica del metodo protetto, <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Random.NextDouble%2A> per generare le sequenze di valori double casuali.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 L'esempio seguente chiama il <xref:System.Random.NextDouble%2A> per generare 100 casuale numeri e Visualizza la distribuzione della frequenza.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un numero a virgola mobile casuale compreso tra 0,0 e 1,0.</summary>
        <returns>Numero a virgola mobile e precisione doppia maggiore o uguale a 0,0 e minore di 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per produrre una distribuzione casuale diversa o un principio generatore di numeri casuali diversi, derivare una classe dal <xref:System.Random> classe ed eseguire l'override di <xref:System.Random.Sample%2A> metodo.  
  
> [!IMPORTANT]
>  Il <xref:System.Random.Sample%2A> metodo `protected`, il che significa che sia accessibile solo all'interno di <xref:System.Random> classe e le relative classi derivate. Per generare un numero casuale compreso tra 0 e 1 da un <xref:System.Random> dell'istanza, chiamare il <xref:System.Random.NextDouble%2A> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente deriva una classe da <xref:System.Random> ed esegue l'override di <xref:System.Random.Sample%2A> per generare una distribuzione di numeri casuali. Questa distribuzione è diversa rispetto a distribuzione uniforme generata dal <xref:System.Random.Sample%2A> metodo della classe base.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Partire da .NET Framework versione 2.0, se si deriva una classe da <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione dei metodi seguenti: - il <see cref="M:System.Random.NextBytes(System.Byte[])" /> metodo.  -La <see cref="M:System.Random.Next" /> metodo.  -La <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> metodo, se (<paramref name="maxValue" /> - <paramref name="minValue" />) è maggiore di <see cref="F:System.Int32.MaxValue" />.  Al contrario, la distribuzione uniforme fornita da base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento consente di migliorare le prestazioni complessive della <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare l'implementazione del <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è inoltre necessario eseguire l'override del comportamento di questi tre membri. Nell'esempio viene illustrato questo concetto.</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>