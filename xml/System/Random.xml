<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4ad7a7caff000dc43adcd1a90679ce6c6f419bc0" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174126" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un generatore di numeri pseudo-casuali, ovvero un dispositivo che produce una sequenza di numeri che soddisfano determinati requisiti statistici di casualità.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numeri pseudo-casuali vengono scelti con probabilità uguale da un set limitato di numeri. I numeri selezionati non sono completamente casuali perché viene utilizzato un algoritmo matematico per selezionarli, ma sono sufficientemente casuale ai fini pratici. L'implementazione corrente della <xref:System.Random> classe si basa su una versione modificata del algoritmo numeri casuali sottrattivo generatore Donald E. Knuth. Per ulteriori informazioni, vedere E. D. Knuth. *La grafica dei linguaggi di programmazione, il Volume 2: algoritmi Seminumerical*. Edizione Addison-Wesley, lettura, MA, terzo, 1997.  
  
 Per generare un numero casuale crittograficamente sicuro, ad esempio un oggetto che è adatto per la creazione di una password casuale, utilizzare il <xref:System.Security.Cryptography.RNGCryptoServiceProvider> di classe o una classe derivata da <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 In questo argomento  
  
 [Creazione di un'istanza del generatore di numeri caso](#Instantiate)   
 [Evitare più creazioni di istanza](#Multiple)   
 [La sicurezza di thread e classe Random](#ThreadSafety)   
 [Generazione di tipi diversi di numeri casuali](#Functionality)   
 [Sostituzione di un algoritmo personalizzato](#Overriding)   
 [Utilizzo di Random per...](#Operations)   
 [Recuperare la stessa sequenza di valori casuali](#Same)  
 [Recuperare sequenze univoche di valori casuali](#Unique)  
 [Recuperare interi in un intervallo specificato](#Range)  
 [Recuperare interi con un numero di cifre specificato](#Digits)  
 [Recuperare i valori a virgola mobile in un intervallo specificato](#Floats)  
 [Generare i valori booleani casuale](#Boolean)  
 [Generare numeri interi casuali a 64 bit](#Long)  
 [Recuperare byte in un intervallo specificato](#Bytes)  
 [Recuperare un elemento da una matrice o raccolta in modo casuale](#Array)  
 [Recuperare un elemento univoco da una matrice o raccolta](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Creazione di un'istanza del generatore di numeri caso  
 Si crea un'istanza del generatore di numeri caso, fornendo un valore di inizializzazione (vale a dire un valore iniziale per l'algoritmo di generazione di numeri pseudo-casuali) per un <xref:System.Random.%23ctor%2A> costruttore della classe.  È possibile fornire il valore di inizializzazione in modo esplicito o implicito:  
  
-   Il <xref:System.Random.%23ctor%28System.Int32%29> costruttore utilizza un valore di inizializzazione esplicita che viene fornito.  
  
-   Il <xref:System.Random.%23ctor> costruttore utilizza l'orologio di sistema per fornire un valore di inizializzazione. Questo è il modo più comune di un'istanza del generatore di numeri caso.  
  
 Se il valore di inizializzazione stessa viene utilizzato per separato <xref:System.Random> oggetti, che genera le stesse serie di numeri casuali. Questo può essere utile per la creazione di un gruppo di test che elabora i valori casuali, o per riprodurre i giochi che derivano i dati da numeri casuali. Si noti tuttavia che <xref:System.Random> oggetti nei processi in esecuzione in versioni diverse di .NET Framework potrebbero restituire diverse serie di numeri casuali, anche se si è creata un'istanza con valori di inizializzazione identici.  
  
 Per produrre un gruppo di sequenze di numeri casuali, è possibile apportare il valore di inizializzazione dipendenti dal tempo, in tal modo che produce una diversa serie a ogni nuova istanza della <xref:System.Random>. I parametri <xref:System.Random.%23ctor%28System.Int32%29> costruttore può accettare un <xref:System.Int32> valore in base al numero di tick nell'ora corrente, mentre senza parametri <xref:System.Random.%23ctor> costruttore utilizza l'orologio di sistema per generare il valore di inizializzazione. Tuttavia, poiché l'orologio ha una risoluzione limitata, utilizzando il costruttore senza parametri per creare diversi <xref:System.Random> oggetti in successione Chiudi crea generatori di numeri casuali che producono sequenze identiche di numeri casuali. Nell'esempio seguente viene illustrato come due <xref:System.Random> oggetti che vengono creata un'istanza in stretta successione generano una serie di numeri casuali identica. Nella maggior parte dei sistemi Windows, <xref:System.Random> gli oggetti creati entro 15 millisecondi una da altra sono possono avere valori di inizializzazione identici.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Per evitare questo problema, creare un singolo <xref:System.Random> oggetto anziché più oggetti.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Evitare più creazioni di istanza  
 L'inizializzazione due i generatori di numeri casuali in un loop o in rapida successione crea due generatori di numeri casuali in grado di produrre sequenze identiche di numeri casuali. Nella maggior parte dei casi, ciò non finalità dello sviluppatore e può causare problemi di prestazioni, poiché creazione e inizializzazione di un generatore di numeri casuali è un processo relativamente costoso.  
  
 Per migliorare le prestazioni sia per evitare di creare inavvertitamente separati i generatori di numeri casuali che generano sequenze numeriche identiche, è consigliabile creare uno <xref:System.Random> oggetto per generare numeri casuali molti nel tempo, anziché creare nuovo <xref:System.Random> oggetti per generare un numero casuale.  
  
 Tuttavia, la <xref:System.Random> classe non è thread-safe. Se si chiama <xref:System.Random> i metodi da più thread, seguire le linee guida descritte nella sezione successiva.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>La sicurezza di thread e classe Random  
 Anziché creare un'istanza di singoli <xref:System.Random> oggetti, è consigliabile creare un singolo <xref:System.Random> istanza per generare tutti i numeri casuali necessari all'applicazione. Tuttavia, <xref:System.Random> oggetti non sono thread-safe. Se l'app chiama <xref:System.Random> metodi da più thread, è necessario utilizzare un oggetto di sincronizzazione per garantire che solo un thread può accedere il generatore di numeri casuali alla volta. Se si non garantiscono che il <xref:System.Random> oggetto avviene in modo thread-safe, le chiamate ai metodi che restituiscono numeri casuali restituiscono 0.  
  
 L'esempio seguente usa c# [istruzione lock](~/docs/csharp/language-reference/keywords/lock-statement.md) e Visual Basic [istruzione SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) per garantire che un singolo generatore di numeri casuali accedono 11 thread in modo thread-safe. Ogni thread che genera l'errore 2 milioni di numeri casuali, Conta il numero di numeri casuali generati e viene calcolata la somma e quindi aggiorna i totali per tutti i thread quando termina l'esecuzione.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 L'esempio specifica la thread safety nei modi seguenti:  
  
-   Il <xref:System.ThreadStaticAttribute> attributo viene utilizzato per definire le variabili locali del thread che registra il numero totale di numeri casuali generati e la somma per ogni thread.  
  
-   Un blocco (il `lock` istruzione in c# e `SyncLock` istruzione in Visual Basic) protegge l'accesso alle variabili per il conteggio totale e la somma di tutti i numeri casuali generati in tutti i thread.  
  
-   Un semaforo (il <xref:System.Threading.CountdownEvent> oggetto) viene utilizzato per garantire che il thread principale si blocca fino a quando tutti gli altri thread completamento dell'esecuzione.  
  
-   Nell'esempio viene controllato se il generatore di numeri casuali è danneggiato, determinando se due chiamate consecutive di metodi di generazione di numeri casuali restituiscono 0. Se l'errore viene individuato, nell'esempio viene utilizzato il <xref:System.Threading.CancellationTokenSource> oggetto per segnalare che tutti i thread devono essere annullati.  
  
-   Prima di generare ogni numero casuale, ogni thread controlla lo stato del <xref:System.Threading.CancellationToken> oggetto. Se la richiesta di annullamento, viene chiamato il <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metodo per annullare il thread.  
  
 L'esempio seguente è identico al primo, ad eccezione del fatto che usa un <xref:System.Threading.Tasks.Task> oggetto e un'espressione lambda anziché <xref:System.Threading.Thread> oggetti.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Differisce da nel primo esempio nei modi seguenti:  
  
-   Le variabili di tenere traccia del numero di numeri casuali generati e la somma di ogni attività sono locali per l'attività, pertanto non è necessario utilizzare il <xref:System.ThreadStaticAttribute> attributo.  
  
-   Il metodo statico <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodo viene utilizzato per verificare che il thread principale non viene completato prima del completamento di tutte le attività. Non è necessario per il <xref:System.Threading.CountdownEvent> oggetto.  
  
-   L'eccezione risultante dall'annullamento delle attività viene esposto nel <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodo. Nell'esempio precedente, viene gestita da ogni thread.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Generazione di tipi diversi di numeri casuali  
 Generatore di numeri casuali fornisce metodi che consentono di generare i tipi di numeri casuali seguenti:  
  
-   Una serie di <xref:System.Byte> valori. Determinare il numero di valori byte passando una matrice di inizializzazione per il numero di elementi che si desidera che il metodo per tornare al <xref:System.Random.NextBytes%2A> metodo. Nell'esempio seguente genera l'errore 20 byte.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Un numero intero. È possibile scegliere se si desidera che un numero intero compreso tra 0 a un valore massimo (<xref:System.Int32.MaxValue?displayProperty=nameWithType> -1) chiamando il <xref:System.Random.Next> (metodo), un numero intero compreso tra 0 e un valore specifico chiamando il <xref:System.Random.Next%28System.Int32%29> metodo oppure un valore integer all'interno di un intervallo di valori mediante la chiamata di <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>metodo. In overload con parametri, il valore massimo specificato è esclusivo; il numero massimo effettivo generato è uno minore del valore specificato.  
  
     L'esempio seguente chiama il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo per generare numeri casuali 10 compreso tra -10 e 10. Si noti che il secondo argomento al metodo specifica il limite superiore esclusivo dell'intervallo di valori casuali restituito dal metodo. In altre parole, l'intero più grande che il metodo può restituire uno è minore di questo valore.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Un singolo valore a virgola mobile compreso tra 0,0 e minore di 1,0 chiamando il <xref:System.Random.NextDouble%2A> metodo. Il limite superiore esclusivo del numero casuale restituito dal metodo è 1, pertanto il limite massimo effettivo è 0.99999999999999978. Nell'esempio seguente genera l'errore 10 numeri a virgola mobile casuale.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  Il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo consente di specificare l'intervallo del numero casuale restituito. Tuttavia, il `maxValue` parametro, che specifica l'intervallo superiore restituito numero, è esclusiva, non un inclusivo, valore. Ciò significa che la chiamata al metodo `Next(0, 100)` restituisce un valore compreso tra 0 e 99 e non è compreso tra 0 e 100.  
  
 È inoltre possibile utilizzare il <xref:System.Random> classe per attività quali la generazione di [valori T:System.Boolean casuali](#Boolean), generazione [valori a virgola mobile casuale con un intervallo diverso da 0 a 1](#Floats), generazione [casuale interi a 64 bit](#Long), e [in modo casuale il recupero di un elemento univoco da una matrice o raccolta](#UniqueArray). Per queste e altre attività comuni, vedere il [come utilizzare Random per...](#Operations) sezione.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Sostituzione di un algoritmo personalizzato  
 È possibile implementare il propria generatore di numeri casuali tramite l'eredità dalla <xref:System.Random> classe e fornisce l'algoritmo di generazione di numeri casuali. Per fornire un proprio algoritmo, è necessario eseguire l'override di <xref:System.Random.Sample%2A> metodo, che implementa l'algoritmo di generazione di numeri casuali. È inoltre necessario eseguire l'override di <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, e <xref:System.Random.NextBytes%2A> metodi per garantire che chiamano sottoposto a override <xref:System.Random.Sample%2A> metodo. Non è necessario eseguire l'override di <xref:System.Random.Next%28System.Int32%29> e <xref:System.Random.NextDouble%2A> metodi.  
  
 Per un esempio da cui deriva il <xref:System.Random> classe e modifica, il generatore di numeri pseudo-casuali predefinito vedere il <xref:System.Random.Sample%2A> pagina di riferimento.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Utilizzo di Random per...  
 Nelle sezioni seguenti discutere e forniscono codice di esempio per alcuni dei metodi che è possibile utilizzare numeri casuali in app.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Recuperare la stessa sequenza di valori casuali  
 Talvolta si desidera generare la stessa sequenza di numeri casuali negli scenari di test di software e giochi. Test con la stessa sequenza di numeri casuali consente di rilevare le regressioni e confermare la correzione di bug. Utilizzando la stessa sequenza di numero casuale nei giochi consente di riprodurre giochi precedente.  
  
 È possibile generare la stessa sequenza di numeri casuali, fornendo lo stesso valore di inizializzazione per il <xref:System.Random.%23ctor%28System.Int32%29> costruttore. Il valore di inizializzazione fornisce un valore iniziale per l'algoritmo di generazione di numeri pseudo-casuali. L'esempio seguente usa 100100 come un valore di inizializzazione non autorizzato di creare un'istanza di <xref:System.Random> oggetto, vengono visualizzate 20 valori a virgola mobile casuale e mantiene il valore di inizializzazione. Quindi Ripristina il valore di inizializzazione, viene creata un'istanza di un nuovo generatore di numeri casuali e consente di visualizzare lo stessi 20 casuale valori a virgola mobile.  Si noti che l'esempio può produrre un gruppo di sequenze di numeri casuali se eseguiti in versioni diverse di .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Recuperare univoche sequenze di numeri casuali  
 Fornire i valori di inizializzazione diversi per le istanze del <xref:System.Random> classe causa ogni generatore di numeri casuali generare una sequenza di valori diversi. È possibile fornire un valore di inizializzazione in modo esplicito chiamando il <xref:System.Random.%23ctor%28System.Int32%29> costruttore o in modo implicito mediante la chiamata di <xref:System.Random.%23ctor> costruttore. La maggior parte degli sviluppatori di chiamano il costruttore senza parametri, che usa l'orologio di sistema. Nell'esempio seguente viene utilizzato questo approccio per creare un'istanza di due <xref:System.Random> istanze. Ogni istanza viene visualizzata una serie di 10 numeri interi casuali.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Tuttavia, a causa di risoluzione finita, l'orologio di sistema non rilevate differenze che sono meno di circa 15 millisecondi. Pertanto, se il codice chiama il <xref:System.Random.%23ctor> overload per creare un'istanza di due <xref:System.Random> oggetti in successione, si potrebbero inavvertitamente essere fornendo gli oggetti con valori di inizializzazione identici. Per vedere questo aspetto nell'esempio precedente, impostare come commento il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> chiamata al metodo e di compilazione e di eseguire nuovamente l'esempio.  
  
 Per evitare questa situazione, è consigliabile che si crea un'istanza di un singolo <xref:System.Random> anziché quelli più dell'oggetto. Tuttavia, poiché <xref:System.Random> non è thread-safe, è necessario utilizzare un dispositivo di sincronizzazione, se si accede a un <xref:System.Random> dell'istanza da più thread; per ulteriori informazioni, vedere [casuale di sicurezza di classe e thread](#ThreadSafety) più indietro in questo argomento. In alternativa, è possibile utilizzare un meccanismo di ritardo, ad esempio il <xref:System.Threading.Thread.Sleep%2A> metodo usato nell'esempio precedente, per garantire che le istanze create si verificano più di 15 millisecondi distanti.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Recuperare interi in un intervallo specificato  
 È possibile recuperare i numeri interi nell'intervallo specificato chiamando il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo, che consente di specificare sia il più basso e il limite superiore dei numeri di cui si desidera che il generatore di numeri casuali da restituire. Il limite superiore è esclusiva, non un inclusivo, valore. Vale a dire non è incluso nell'intervallo dei valori restituiti dal metodo. Nell'esempio seguente viene utilizzato questo metodo per generare valori integer casuale compreso tra -10 e 10. Si noti che specifica 11, che è maggiore del valore desiderato, come il valore del `maxValue` argomento nella chiamata al metodo.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Recuperare interi con un numero di cifre specificato  
 È possibile chiamare il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo per recuperare i numeri con un numero di cifre specificato. Ad esempio, per recuperare i numeri con quattro cifre (ovvero, i numeri compresi tra 1000 e 9999), chiamare il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo con un `minValue` valore pari a 1000 e un `maxValue` valore di 10000, come illustrato nell'esempio seguente.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Recuperare i valori a virgola mobile in un intervallo specificato  
 Il <xref:System.Random.NextDouble%2A> metodo restituisce valori a virgola mobile casuale che vanno da 0 minore di 1. Tuttavia, spesso è opportuno generare valori casuali in un altro intervallo.  
  
 Se l'intervallo tra i valori minimi e massimo desiderati è 1, è possibile aggiungere la differenza tra l'intervallo inizia desiderato e 0 per il numero restituito dal <xref:System.Random.NextDouble%2A> metodo. Nell'esempio seguente esegue questa opzione per generare numeri casuali 10 tra -1 e 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Per generare numeri a virgola mobile casuale il cui limite inferiore è 0 ma limite superiore è maggiore di 1 (o, nel caso di numeri negativi, il cui limite inferiore è minore di -1 e il limite superiore è 0), moltiplicare il numero casuale per il limite di diverso da zero. Nell'esempio seguente viene eseguita l'operazione per generare numeri a virgola mobile casuale di 20 milioni di tale intervallo da 0 a <xref:System.Int64.MaxValue?displayProperty=nameWithType>. In Visualizza anche la distribuzione dei valori casuali generati dal metodo.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Per generare numeri a virgola mobile casuale compreso tra due valori arbitrari, ad esempio il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo avviene per i numeri interi, utilizzare la formula seguente:  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 Nell'esempio seguente genera numeri casuali di 1 milione che vanno da 10.0 a 11.0 e Visualizza la loro distribuzione.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Generare i valori booleani casuale  
 Il <xref:System.Random> classe non fornisce metodi che generano <xref:System.Boolean> valori. Tuttavia, è possibile definire la propria classe o un metodo per eseguire questa operazione. L'esempio seguente definisce una classe, `BooleanGenerator`, con un singolo metodo `NextBoolean`. Il `BooleanGenerator` classe archivia un <xref:System.Random> oggetto come una variabile privata. Il `NextBoolean` chiamate al metodo di <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo e passa il risultato per il <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> (metodo). Nota 2 viene utilizzato come argomento per specificare il limite superiore del numero casuale. Poiché si tratta di un valore esclusivo, la chiamata al metodo restituisce 0 o 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Anziché creare una classe separata per generare casuale <xref:System.Boolean> valori, l'esempio può semplicemente hanno definito in un singolo metodo. In questo caso, tuttavia, il <xref:System.Random> oggetto deve definito come una variabile a livello di classe per evitare la creazione di un nuovo <xref:System.Random> istanza in ogni chiamata al metodo. In Visual Basic, l'istanza casuale può essere definito come un [statico](~/docs/visual-basic/language-reference/modifiers/static.md) variabile il `NextBoolean` metodo.  Nell'esempio seguente fornisce un'implementazione.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Generare numeri interi casuali a 64 bit  
 Gli overload di <xref:System.Random.Next%2A> metodo restituiscono valori integer a 32 bit. Tuttavia, in alcuni casi, è consigliabile l'utilizzo di interi a 64 bit. Procedere come segue:  
  
1.  Chiamare il <xref:System.Random.NextDouble%2A> valore punto metodo per recuperare un mobile e precisione doppia.  
  
2.  Moltiplicare il valore <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 Nell'esempio seguente usa questa tecnica per generare valori long integer di 20 milioni di casuale e li classifica in 10 gruppi di uguali. Quindi, valuta la distribuzione di numeri casuali contando il numero in ciascun gruppo da 0 a <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Come illustrato nell'output dell'esempio, i numeri vengono distribuiti più o meno in modo uniforme nell'intervallo di un valore long integer.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Una tecnica alternativa che utilizza bit manipolazione non genera numeri casuali. Questa tecnica chiama <xref:System.Random.Next> per generare due numeri interi, sposta verso sinistra uno da 32 bit e OR insieme. Questa tecnica presenta due limiti:  
  
1.  Poiché il bit 31 bit di segno, il valore in bit 31 long integer risultante è sempre 0.  Questo problema può essere risolto tramite la generazione casuale 0 o 1, spostamento a sinistra 31 bit e OR con long integer casuali originale.  
  
2.  Più gravi, poiché la probabilità che il valore restituito da <xref:System.Random.Next> sarà pari a 0, non si verificherà alcuni eventuali numeri casuali 0x0 0x00000000FFFFFFFF dell'intervallo.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Recuperare byte in un intervallo specificato  
 Gli overload di <xref:System.Random.Next%2A> metodo consente di specificare l'intervallo di numeri casuali, ma la <xref:System.Random.NextBytes%2A> non dal metodo. Nell'esempio seguente viene implementato un `NextBytes` metodo che consente di specificare l'intervallo di byte restituiti. Definisce un `Random2` classe che deriva da <xref:System.Random> ed esegue l'overload relativo `NextBytes` metodo.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 Il `NextBytes(Byte[], Byte, Byte)` metodo esegue il wrapping di una chiamata al <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> (metodo) e specifica il valore minimo e una maggiore del valore massimo (in questo caso, 0 e 101) che si desidera vengano restituite nella matrice di byte. Perché si è certi che i valori integer restituito dal <xref:System.Random.Next%2A> metodo siano compresi nell'intervallo del <xref:System.Byte> tipo di dati, è possibile in modo sicuro eseguirne il cast (in c#) o convertire (in Visual Basic) da numeri interi in byte.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Recuperare un elemento da una matrice o raccolta in modo casuale  
 Numeri casuali vengono spesso utilizzate come indici per recuperare valori da matrici o raccolte. Per recuperare un valore di indice, è possibile chiamare il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> metodo e utilizzare il limite inferiore della matrice come valore del relativo `minValue` argomento e una maggiore del limite superiore della matrice come valore del relativo `maxValue` argomento. Una matrice in base zero, questa opzione equivale a relativo <xref:System.Array.Length%2A> proprietà o maggiore del valore restituito da una di <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> metodo. Nell'esempio seguente recupera in modo casuale il nome di una città negli Stati Uniti da una matrice di città.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Recuperare un elemento univoco da una matrice o raccolta  
 Un generatore di numeri casuali può restituire sempre valori duplicati. Quando l'intervallo di numeri diventa più piccolo o il numero di valori generati diventa più complesso, aumenta la probabilità di duplicati. Se i valori casuali devono essere univoci, altri numeri vengono generati per compensare la presenza di duplicati, risultante sempre più spesso una riduzione delle prestazioni.  
  
 Esistono diverse tecniche per gestire questo scenario. Una soluzione comune consiste nel creare una matrice o raccolta che contiene i valori devono essere recuperate e una matrice parallela che contiene numeri a virgola mobile casuale. Seconda matrice viene popolata con i numeri casuali al momento della creazione, la prima matrice e <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> metodo viene utilizzato per ordinare la prima matrice utilizzando i valori nella matrice parallela.  
  
 Ad esempio, se si sta sviluppando un gioco di Spider, si desidera garantire che ogni scheda venga utilizzata una sola volta. Invece di generare numeri casuali per recuperare una scheda e verificare se tale scheda ha già coinvolti, è possibile creare una matrice parallela di numeri casuali che possono essere utilizzati per ordinare il ponte. Una volta la presentazione è ordinata, l'app consente di mantenere un puntatore per indicare l'indice della scheda successiva nel piano.  
  
 Questo approccio viene illustrato nell'esempio seguente: Definisce un `Card` classe che rappresenta una carta da gioco e `Dealer` classe che gestisce un ponte di schede riprodurre con sequenza casuale. Il `Dealer` costruttore della classe popola due matrici: un `deck` matrice con ambito di classe e che rappresenta tutte le schede in locale e di ponte; `order` matrice con lo stesso numero di elementi come il `deck` della matrice e viene popolato con generato casualmente <xref:System.Double> valori.  Il <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> viene quindi chiamato il metodo per ordinare il `deck` matrice in base ai valori nel `order` matrice.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 L'esempio seguente crea un generatore di numeri casuali singolo e chiama il relativo <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, e <xref:System.Random.NextDouble%2A> metodi per generare le sequenze di numeri casuali all'interno di intervalli diversi.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 Nell'esempio seguente genera l'errore di un intero casuale che viene utilizzato come indice per recuperare un valore stringa da una matrice.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>In .NET Framework 1.0 e 1.1, un'implementazione minima di una classe derivata da <see cref="T:System.Random" /> richiedeva l'override di <see cref="M:System.Random.Sample" /> metodo per definire un algoritmo nuovo o modificato per la generazione di numeri casuali. La classe derivata poteva quindi basarsi sull'implementazione della classe base il <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, e <see cref="M:System.Random.NextDouble" /> metodi per chiamare l'implementazione della classe derivata di <see cref="M:System.Random.Sample" /> (metodo).  In .NET Framework 2.0 e versioni successive, il comportamento del <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, e <see cref="M:System.Random.NextBytes(System.Byte[])" /> metodi sono stati modificati in modo che questi metodi non necessariamente chiamare l'implementazione della classe derivata di <see cref="M:System.Random.Sample" /> metodo. Di conseguenza, le classi derivate da <see cref="T:System.Random" /> che destinate a .NET Framework 2.0 e versioni successive deve anche eseguire l'override tre metodi seguenti.</para>
    </block>
    <block subset="none" type="usage">
      <para>L'implementazione del generatore di numeri casuali nel <see cref="T:System.Random" /> classe non è garantito che rimangono invariati dalle versioni principali di .NET Framework. È di conseguenza, non deve presupporre che il valore di inizializzazione stessa avrà come risultato nella stessa sequenza pseudocasuale in versioni diverse di .NET Framework.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Random" /> utilizzando un valore di inizializzazione predefinito dipendente da un fattore temporale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di inizializzazione predefinito è derivato dal clock di sistema e ha una risoluzione limitata. Di conseguenza, diversi <xref:System.Random> gli oggetti creati in stretta successione da una chiamata al costruttore predefinito avranno valori di inizializzazione predefiniti identici e, pertanto, produrranno insiemi identici di numeri casuali. Questo problema può essere evitato utilizzando una singola <xref:System.Random> oggetto per generare tutti i numeri casuali. Possono anche aggirare il problema modificando il valore di inizializzazione restituito dal clock di sistema e quindi specificare esplicitamente il nuovo valore di inizializzazione per il <xref:System.Random.%23ctor%28System.Int32%29> costruttore. Per ulteriori informazioni, vedere il <xref:System.Random.%23ctor%28System.Int32%29> costruttore.  
  
 Chiamare questo costruttore se si desidera che il generatore di numeri casuali per generare una sequenza di numeri casuali. Per generare una sequenza di numeri casuali che saranno gli stessi per generatori di numeri casuali diversi fissa, chiamare il <xref:System.Random.%23ctor%28System.Int32%29> costruttore con un valore di inizializzazione predefinito. Questo <xref:System.Random> overload del costruttore viene spesso utilizzato durante il test di App che usano numeri casuali.  
  
 Dopo aver creato l'istanza del generatore di numeri caso, si chiama singoli <xref:System.Random> metodi, ad esempio <xref:System.Random.Next> o <xref:System.Random.NextDouble>, per generare numeri casuali.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzato il costruttore predefinito per creare un'istanza di tre <xref:System.Random> degli oggetti e per ognuno viene visualizzata una sequenza di numeri interi casuali cinque. Poiché le prime due <xref:System.Random> gli oggetti vengono creati in stretta successione, le relative istanze vengono create utilizzando i valori di inizializzazione identici in base al clock di sistema e, pertanto producono una sequenza identica di numeri casuali. D'altra parte, il costruttore predefinito del terzo <xref:System.Random> oggetto viene chiamato dopo un ritardo di due secondi causato chiamando il <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo. Poiché questo genera un valore di inizializzazione diversi per la terza <xref:System.Random> dell'oggetto, viene prodotta una sequenza di numeri casuali diversi.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Numero usato per calcolare un valore iniziale per la sequenza di numeri pseudo-casuali. Se viene specificato un numero negativo, viene usato il valore assoluto del numero.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Random" /> usando il valore di inizializzazione specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fornendo un valore di inizializzazione identico a diversi <xref:System.Random> oggetti, ogni istanza produrrà sequenze identiche di numeri casuali. Questo accade spesso quando il test di App che si basano su generatori di numeri casuali.  
  
 Se l'applicazione richiede diverse sequenze di numeri casuali, richiamare il costruttore più volte con valori di inizializzazione diversi. Un modo per produrre un valore di inizializzazione univoco è consentire di apportare dipendenti dal tempo. Ad esempio, derivare il valore di inizializzazione dal clock di sistema, come il <xref:System.Random.%23ctor> overload. Tuttavia, l'orologio di sistema potrebbe non avere risoluzione sufficiente per fornire diverse chiamate di questo costruttore con un valore di inizializzazione diversi. Di conseguenza generatori di numeri casuali che generano sequenze identiche di numeri pseudo-casuali, come illustrato per le prime due <xref:System.Random> oggetti nell'esempio seguente. Per evitare questo problema, applicare un algoritmo per distinguere il valore di inizializzazione in ogni chiamata o chiamata di <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per assicurarsi di fornire ogni costruttore con un valore di inizializzazione diversi.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Un'altra opzione consiste nel creare un'istanza di un singolo <xref:System.Random> dell'oggetto che consente di generare tutti i numeri casuali all'interno dell'applicazione. Si ottengono prestazioni leggermente migliori, poiché la creazione di un generatore di numeri casuali è alquanto costosa.  
  
   
  
## Examples  
 L'esempio seguente crea <xref:System.Random> oggetti con il costruttore della classe che accetta un parametro di inizializzazione e genera una sequenza di valori casuali integer e Double. Nell'esempio viene illustrato che la stessa sequenza viene generata quando il <xref:System.Random> oggetto viene creato nuovamente con il parametro di costruttore e valore di inizializzazione.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un intero casuale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un intero casuale non negativo.</summary>
        <returns>Intero con segno a 32 bit maggiore o uguale a 0 e minore di <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> Genera un numero casuale il cui valore è compreso tra 0 e minore di <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Per generare un numero casuale il cui valore è compreso tra 0 e un altro numero positivo, utilizzare il <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> overload del metodo. Per generare un numero casuale all'interno di un intervallo diverso, utilizzare il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio riportato di seguito vengono effettuate chiamate ripetute al metodo <xref:System.Random.Next%2A> per generare un numero specifico di numeri casuali richiesti dall'utente. Il metodo <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> viene utilizzato per ricevere l'input del cliente.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 Nell'esempio seguente deriva una classe da <xref:System.Random> per generare una sequenza di numeri casuali la cui distribuzione differisce dalla distribuzione uniforme generata dal <xref:System.Random.Sample%2A> metodo della classe di base. Esegue l'override di <xref:System.Random.Sample%2A> metodo per fornire la distribuzione di numeri casuali ed esegue l'override di <xref:System.Random.Next%2A?displayProperty=nameWithType> metodo da utilizzare una serie di numeri casuali.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Partire da .NET Framework versione 2.0, se si deriva una classe da <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione del <see cref="M:System.Random.Next" /> metodo. Al contrario, la distribuzione uniforme restituito da base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento consente di migliorare le prestazioni complessive della <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare il <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è necessario inoltre l'override di <see cref="M:System.Random.Next" /> metodo.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Limite superiore esclusivo del numero casuale da generare. <c>maxValue</c> deve essere maggiore o uguale a 0.</param>
        <summary>Restituisce un intero casuale non negativo inferiore al massimo specificato.</summary>
        <returns>Intero con segno a 32 bit maggiore o uguale a 0 e minore di <paramref name="maxValue" />; ovvero, l'intervallo dei valori restituiti in genere include 0 ma non <paramref name="maxValue" />. Se tuttavia <paramref name="maxValue" /> è uguale a 0 viene restituito <paramref name="maxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Random.Next%28System.Int32%29> overload restituisce numeri interi casuali che vanno da 0 a `maxValue` – 1. Tuttavia, se `maxValue` è 0, il metodo restituisce 0.  
  
   
  
## Examples  
 Nell'esempio seguente genera l'errore numeri interi casuali con diversi overload di <xref:System.Random.Next%2A> metodo.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 Nell'esempio seguente genera l'errore di un intero casuale che viene utilizzato come indice per recuperare un valore stringa da una matrice. Poiché l'indice più alto della matrice è una minore la sua lunghezza, il valore della <xref:System.Array.Length%2A?displayProperty=nameWithType> proprietà deve essere fornita come un il `maxValue` parametro.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> è minore di 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Limite inferiore inclusivo del numero casuale restituito.</param>
        <param name="maxValue">Limite superiore esclusivo del numero casuale restituito. <c>maxValue</c> deve essere maggiore o uguale a <c>minValue</c>.</param>
        <summary>Restituisce un intero casuale all'interno di un intervallo specificato.</summary>
        <returns>Intero con segno a 32 bit maggiore o uguale a <paramref name="minValue" /> e minore di <paramref name="maxValue" />: l'intervallo dei valori restituiti includerà <paramref name="minValue" /> ma non <paramref name="maxValue" />. Se <paramref name="minValue" /> è uguale a <paramref name="maxValue" />, viene restituito <paramref name="minValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload restituisce numeri interi casuali che vanno da `minValue` a `maxValue` – 1. Tuttavia, se `maxValue` è uguale a `minValue`, il metodo restituisce `minValue`.  
  
 A differenza di altri overload di <xref:System.Random.Next%2A> (metodo), che restituiscono valori solo un valore non negativo, questo metodo può restituire un intero casuale negativo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo per generare numeri interi casuali con tre intervalli distinti. Si noti che l'output dell'esempio esatto dipende dal valore di inizializzazione fornito dal sistema passato al <xref:System.Random> costruttore della classe.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 Nell'esempio seguente genera l'errore di un intero casuale che viene utilizzato come indice per recuperare un valore stringa da una matrice. Poiché l'indice più alto della matrice è una minore la sua lunghezza, il valore della <xref:System.Array.Length%2A?displayProperty=nameWithType> proprietà deve essere fornita come un il `maxValue` parametro.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> è maggiore di <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides">
          <para>Partire da .NET Framework versione 2.0, se si deriva una classe da <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione del <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> overload del metodo se la differenza tra il <paramref name="minValue" /> e <paramref name="maxValue" /> parametri è maggiore di <see cref="F:System.Int32.MaxValue" />. Al contrario, la distribuzione uniforme restituito da base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento consente di migliorare le prestazioni complessive della <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare il <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è necessario inoltre l'override di <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> overload del metodo.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Matrice di byte che deve contenere numeri casuali.</param>
        <summary>Inserisce numeri casuali negli elementi di una matrice di byte specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni elemento della matrice di byte è impostata su un numero casuale maggiore o uguale a 0 e minore o uguale a <xref:System.Byte.MaxValue>.  
  
 Ad esempio, per generare un numero casuale crittograficamente sicuro adatto per la creazione di una password casuale, utilizzare un metodo, ad esempio <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Random.NextBytes%2A> per inserire una matrice di byte con valori byte casuali.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> è <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Partire da .NET Framework versione 2.0, se si deriva una classe da <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione del <see cref="M:System.Random.NextBytes(System.Byte[])" /> metodo. Al contrario, la distribuzione uniforme restituito da base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento consente di migliorare le prestazioni complessive della <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare il <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è necessario inoltre l'override di <see cref="M:System.Random.NextBytes(System.Byte[])" /> metodo.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un numero casuale a virgola mobile e precisione doppia maggiore o uguale a 0,0 e minore di 1,0.</summary>
        <returns>Numero a virgola mobile e precisione doppia maggiore o uguale a 0,0 e minore di 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il limite superiore effettivo del numero casuale restituito da questo metodo è 0.99999999999999978.  
  
 Per recuperare i valori a virgola mobile casuale compreso in un intervallo diverso da 0,0 e 1,0, vedere la sezione "Valori a virgola mobile in un intervallo specificato di recuperare" il <xref:System.Random> argomento relativo alla classe.  
  
 Questo metodo è la versione del metodo protetto, pubblica <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Random.NextDouble%2A> metodo per generare le sequenze di valori double casuali.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 L'esempio seguente chiama il <xref:System.Random.NextDouble%2A> metodo per generare 100 casuale numeri e Visualizza la distribuzione della frequenza.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un numero a virgola mobile casuale compreso tra 0,0 e 1,0.</summary>
        <returns>Numero a virgola mobile e precisione doppia maggiore o uguale a 0,0 e minore di 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per generare una distribuzione casuale diversa o un principio generatore di numeri casuali diverso, derivare una classe dal <xref:System.Random> classe ed eseguire l'override di <xref:System.Random.Sample%2A> metodo.  
  
> [!IMPORTANT]
>  Il <xref:System.Random.Sample%2A> metodo `protected`, che significa che è accessibile solo all'interno di <xref:System.Random> classe e le relative classi derivate. Per generare un numero casuale compreso tra 0 e 1 da un <xref:System.Random> dell'istanza, chiamare il <xref:System.Random.NextDouble%2A> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente deriva una classe da <xref:System.Random> ed esegue l'override di <xref:System.Random.Sample%2A> metodo per generare una distribuzione di numeri casuali. Questa distribuzione è diversa da quello generata dalla distribuzione uniforme di <xref:System.Random.Sample%2A> metodo della classe di base.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Partire da .NET Framework versione 2.0, se si deriva una classe da <see cref="T:System.Random" /> ed eseguire l'override di <see cref="M:System.Random.Sample" /> metodo, la distribuzione fornita dall'implementazione della classe derivata del <see cref="M:System.Random.Sample" /> metodo non viene utilizzato nelle chiamate alla classe di base implementazione dei metodi seguenti: - il <see cref="M:System.Random.NextBytes(System.Byte[])" /> metodo.  -La <see cref="M:System.Random.Next" /> metodo.  -La <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> metodo, se (<paramref name="maxValue" /> - <paramref name="minValue" />) è maggiore di <see cref="F:System.Int32.MaxValue" />.  Al contrario, la distribuzione uniforme fornita da base <see cref="T:System.Random" /> classe viene utilizzata. Questo comportamento consente di migliorare le prestazioni complessive della <see cref="T:System.Random" /> classe. Per modificare questo comportamento per chiamare l'implementazione del <see cref="M:System.Random.Sample" /> metodo nella classe derivata, è inoltre necessario eseguire l'override del comportamento di questi tre membri. Nell'esempio viene illustrato questo concetto.</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>