<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="de1a8d1ecd07f9f8d0291eb6d18e2d042042a9b2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30730035" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta le informazioni di associazione dell'assembly che possono essere aggiunte a un'istanza di <see cref="T:System.AppDomain" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modifica delle proprietà di un <xref:System.AppDomainSetup> istanza non influisce sulla esistenti <xref:System.AppDomain>. Può interessare solo la creazione di un nuovo <xref:System.AppDomain>, quando il <xref:System.AppDomain.CreateDomain%2A> metodo viene chiamato con il <xref:System.AppDomainSetup> istanza come parametro.  
  
 Questa classe implementa l'interfaccia <xref:System.IAppDomainSetup>.  
  
> [!CAUTION]
>  Il valore predefinito per il <xref:System.AppDomainSetup.DisallowCodeDownload%2A> proprietà è false. Questa impostazione è sicura per i servizi. Per impedire ai servizi di scaricare codice parzialmente attendibile, impostare questa proprietà su true  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.AppDomainSetup" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.AppDomainSetup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Contesto di attivazione da usare per un dominio applicazione.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.AppDomainSetup" /> con il contesto di attivazione specificato da usare per l'attivazione basata su manifesto di un dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ActivationContext> oggetto specificato per `activationContext` viene utilizzato per generare un <xref:System.Runtime.Hosting.ActivationArguments> oggetto contenente le informazioni necessarie per attivare un nuovo dominio applicazione. Questo <xref:System.Runtime.Hosting.ActivationArguments> può accedere all'oggetto utilizzando il <xref:System.AppDomainSetup.ActivationArguments%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationContext" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">Oggetto che specifica le informazioni necessarie all'attivazione basata su manifesto di un nuovo dominio applicazione.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.AppDomainSetup" /> con gli argomenti di attivazione specificati necessari all'attivazione basata su manifesto di un dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'oggetto specificato per `activationArguments` è possibile accedere tramite il <xref:System.AppDomainSetup.ActivationArguments%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationArguments" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i dati sull'attivazione di un dominio applicazione.</summary>
        <value>Oggetto che contiene i dati relativi all'attivazione di un dominio applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene generata alcuna eccezione se questa proprietà è impostata su `null`.  
  
 Le informazioni fornite dal <xref:System.Runtime.Hosting.ActivationArguments> oggetto supporta l'attivazione basata su manifesto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà è impostata su un oggetto <see cref="T:System.Runtime.Hosting.ActivationArguments" /> la cui identità dell'applicazione non corrisponde a quella dell'oggetto <see cref="T:System.Security.Policy.ApplicationTrust" /> restituito dalla proprietà <see cref="P:System.AppDomainSetup.ApplicationTrust" />. Se la proprietà <see cref="P:System.AppDomainSetup.ApplicationTrust" /> è <see langword="null" />, non viene generata alcuna eccezione.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il delegato <see cref="T:System.AppDomainInitializer" />, che rappresenta un metodo di callback che viene richiamato quando il dominio applicazione viene inizializzato.</summary>
        <value>Delegato che rappresenta un metodo di callback che viene richiamato quando il dominio applicazione viene inizializzato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per passare informazioni al metodo di callback, assegnare una matrice di stringhe per il <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> proprietà. La matrice viene passata al metodo di callback ogni volta che un <xref:System.AppDomain> viene inizializzato.  
  
 Il metodo di callback viene eseguito nel contesto del dominio applicazione appena creato.  
  
   
  
## Examples  
 L'esempio seguente crea un dominio applicazione figlio denominato `ChildDomain`, usando un <xref:System.AppDomainSetup> oggetto e l'evidenza del dominio applicazione predefinito. Il <xref:System.AppDomainSetup.AppDomainInitializer%2A> proprietà è impostata per il metodo di callback `AppDomainInit`, che viene richiamato quando viene inizializzato il dominio figlio. Gli argomenti del metodo di callback sono inseriti in una matrice di stringhe, che viene assegnato al <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> proprietà. Quando viene creato il dominio figlio, il metodo di callback stampa semplicemente le stringhe.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta gli argomenti passati al metodo di callback rappresentato dal delegato <see cref="T:System.AppDomainInitializer" />. Il metodo di callback viene richiamato quando il dominio applicazione viene inizializzato.</summary>
        <value>Matrice di stringhe che viene passata al metodo di callback rappresentato dal delegato <see cref="T:System.AppDomainInitializer" /> quando il metodo di callback viene richiamato durante l'inizializzazione dell'oggetto <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.AppDomainSetup.AppDomainInitializer%2A> proprietà per specificare un metodo di callback che viene richiamato durante <xref:System.AppDomain> l'inizializzazione. Se il <xref:System.AppDomainSetup.AppDomainInitializer%2A> non è impostata, la matrice assegnata a questa proprietà non viene utilizzata.  
  
 Il metodo di callback viene eseguito nel contesto del dominio applicazione appena creato.  
  
   
  
## Examples  
 Esempio di codice seguente crea un dominio applicazione figlio denominato `ChildDomain`, usando un <xref:System.AppDomainSetup> oggetto e l'evidenza del dominio applicazione predefinito. Il <xref:System.AppDomainSetup.AppDomainInitializer%2A> proprietà è impostata per il metodo di callback `AppDomainInit`, che viene richiamato quando viene inizializzato il dominio figlio. Gli argomenti del metodo di callback sono inseriti in una matrice di stringhe, che viene assegnato al <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> proprietà. Quando viene creato il dominio figlio, il metodo di callback stampa semplicemente le stringhe.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome visualizzato dell'assembly che fornisce il tipo del gestore di dominio applicazione per i domini applicazione creati usando questo oggetto <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Nome visualizzato dell'assembly che fornisce l'oggetto <see cref="T:System.Type" /> del gestore di dominio applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per specificare il tipo del gestore di dominio di applicazione, impostare questa proprietà e <xref:System.AppDomainSetup.AppDomainManagerType%2A> proprietà. Se una di queste proprietà non è impostata, l'altra viene ignorata.  
  
 Se non viene specificato alcun tipo, il gestore di dominio applicazione viene creato dallo stesso tipo del dominio applicazione padre (ovvero, il dominio dell'applicazione da cui il <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> metodo viene chiamato).  
  
 Quando viene caricato il dominio dell'applicazione, <xref:System.TypeLoadException> viene generata se l'assembly non esiste o se l'assembly non contiene il tipo specificato dal <xref:System.AppDomainSetup.AppDomainManagerType%2A> proprietà. <xref:System.IO.FileLoadException> viene generata se l'assembly viene trovato, ma le informazioni sulla versione non corrisponde.  
  
 Per impostare il gestore di dominio di applicazione per il dominio applicazione predefinito, utilizzare il [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) e [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) gli elementi di [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sezione del file di configurazione dell'applicazione oppure utilizzare le variabili di ambiente descritte in <xref:System.AppDomainManager>.  
  
 Questa funzionalità richiede che l'applicazione disponga di attendibilità. (Ad esempio, un'applicazione in esecuzione sul desktop è l'attendibilità totale.) Se l'applicazione non ha l'attendibilità totale, un <xref:System.TypeLoadException> viene generata un'eccezione.  
  
 Il formato del nome visualizzato dell'assembly viene fornito per il <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome completo del tipo che fornisce il gestore di dominio applicazione per i domini applicazione creati usando questo oggetto <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Nome completo del tipo, incluso lo spazio dei nomi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per specificare il tipo del gestore di dominio di applicazione, impostare questa proprietà e <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> proprietà. Se una di queste proprietà non è impostata, l'altra viene ignorata.  
  
 Se non viene specificato alcun tipo, il gestore di dominio applicazione viene creato dallo stesso tipo del dominio applicazione padre (ovvero, il dominio dell'applicazione da cui il <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> metodo viene chiamato).  
  
 Quando viene caricato il dominio dell'applicazione, <xref:System.TypeLoadException> viene generata se l'assembly specificato per il <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> proprietà non contiene il tipo specificato da questa proprietà.  
  
 Per impostare il gestore di dominio di applicazione per il dominio applicazione predefinito, utilizzare il [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) e [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) gli elementi di [ \<runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sezione del file di configurazione dell'applicazione oppure utilizzare le variabili di ambiente descritte in <xref:System.AppDomainManager>.  
  
 Questa funzionalità richiede che l'applicazione disponga di attendibilità. (Ad esempio, un'applicazione in esecuzione sul desktop è l'attendibilità totale.) Se l'applicazione non ha l'attendibilità totale, un <xref:System.TypeLoadException> viene generata un'eccezione.  
  
 Il formato del nome completo di un tipo viene fornito per il <xref:System.Type.FullName%2A?displayProperty=nameWithType> proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome della directory contenente l'applicazione.</summary>
        <value>Nome della directory della base dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Directory base dell'applicazione è in cui il gestore dell'assembly inizia la ricerca degli assembly.  
  
 Il <xref:System.AppDomainSetup.ApplicationBase%2A> proprietà può influenzare le autorizzazioni concesse a un dominio applicazione. Ad esempio, un dominio dell'applicazione provenienti dal computer locale in genere considerato completamente attendibile in base alla relativa posizione di origine. Tuttavia, se il <xref:System.AppDomainSetup.ApplicationBase%2A> proprietà di tale <xref:System.AppDomain> è impostato sul nome completo di una directory di rete intranet, il <xref:System.AppDomainSetup.ApplicationBase%2A> impostazione limita le autorizzazioni concesse al dominio applicazione a un tipo LocalIntranet anche se il dominio dell'applicazione in realtà ha dal computer locale.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.AppDomainSetup.ApplicationBase%2A> proprietà per impostare il percorso in cui il caricatore di assembly inizia la ricerca degli assembly da caricare in un nuovo dominio applicazione.  
  
> [!NOTE]
>  È necessario verificare che la cartella specificata esista.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni sul percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome dell'applicazione.</summary>
        <value>Nome dell'applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come impostare il <xref:System.AppDomainSetup.ApplicationName%2A> proprietà quando si crea un nuovo dominio applicazione.  
  
 L'esempio crea un nuovo dominio applicazione e quindi chiama il <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> metodo per caricare l'assembly di esempio nel nuovo dominio applicazione e creare un'istanza di `Worker` classe. Il `Worker` classe eredita <xref:System.MarshalByRefObject>, quindi l'esempio è possibile usare il proxy restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> per chiamare il `TestLoad` metodo.  
  
 Il `TestLoad` metodo carica un assembly specificato. È necessario specificare un nome valido e completo di assembly o impostare come commento il <xref:System.Reflection.Assembly.Load%28System.String%29> metodo. Il `TestLoad` metodo sono elencati gli assembly caricati nel nuovo dominio applicazione, indicando che l'assembly specificato e l'assembly di esempio vengono caricati.  
  
 Nell'esempio viene utilizzato il <xref:System.LoaderOptimizationAttribute> attributo per indicare il caricatore di assembly, come l'applicazione condividerà il codice tra domini dell'applicazione.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un oggetto che contiene le informazioni sulla sicurezza e sull'attendibilità.</summary>
        <value>Oggetto contenente le informazioni sulla sicurezza e sull'attendibilità.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è `null` quando il <xref:System.AppDomainSetup> viene creato. Una volta modificata, non è possibile ripristinare un riferimento null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà è impostata su un oggetto <see cref="T:System.Security.Policy.ApplicationTrust" /> la cui identità dell'applicazione non corrisponde a quella dell'oggetto <see cref="T:System.Runtime.Hosting.ActivationArguments" /> restituito dalla proprietà <see cref="P:System.AppDomainSetup.ActivationArguments" />. Se la proprietà <see cref="P:System.AppDomainSetup.ActivationArguments" /> è <see langword="null" />, non viene generata alcuna eccezione.</exception>
        <exception cref="T:System.ArgumentNullException">La proprietà è impostata su <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome di un'area specifica per l'applicazione, dove verrà creata una replica dei file.</summary>
        <value>Nome completo del percorso della directory e nome del file in cui viene creata la copia shadow dei file.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Affinché questa proprietà ha un effetto, la <xref:System.AppDomainSetup.ApplicationName%2A> deve anche essere impostata. Se il <xref:System.AppDomainSetup.ApplicationName%2A> non è impostata, il <xref:System.AppDomainSetup.CachePath%2A> proprietà viene ignorata e il percorso della cache di copia shadow per impostazione predefinita la download cache.  
  
 Per ulteriori informazioni sulla creazione di copie shadow, vedere [copie Shadow di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni sul percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del file di configurazione per un dominio applicazione.</summary>
        <value>Nome del file di configurazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il file di configurazione vengono descritte le regole di ricerca e i dati di configurazione per il dominio applicazione. L'host che crea il dominio applicazione è responsabile di fornire questi dati in quanto i valori significativi variano da caso a situazione.  
  
 Ad esempio, i dati di configurazione per le applicazioni ASP.NET vengono archiviati per ogni applicazione, sito e computer, mentre i dati di configurazione per un eseguibile vengono archiviati per ogni applicazione, utente e computer. Solo l'host sappia le specifiche dei dati di configurazione per una particolare circostanza.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni sul percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica se il percorso base dell'applicazione e il percorso binario privato vengono sondati durante la ricerca degli assembly da caricare.</summary>
        <value>
          <see langword="true" /> se il sondaggio non è consentito; in caso contrario, <see langword="false" />. Il valore predefinito è <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> proprietà `true`, il valore della <xref:System.AppDomainSetup.ApplicationBase%2A> proprietà viene ignorata. Ovvero nessun assembly subiscono nelle directory specificate per il <xref:System.AppDomainSetup.ApplicationBase%2A> proprietà. Inoltre, i valori del <xref:System.AppDomainSetup.PrivateBinPath%2A> proprietà e <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> proprietà vengono ignorate. Nessun assembly subiscono nella directory specificata dal <xref:System.AppDomainSetup.PrivateBinPath%2A> proprietà.  
  
 Il <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> proprietà fornisce un ulteriore livello di controllo sul processo di caricamento. Nella normale sequenza di caricamento degli assembly, la base dell'applicazione viene eseguita prima il <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> viene generato l'evento. Tuttavia, alcune applicazioni potrebbe essere necessario caricare gli assembly da un file composto OLE all'interno di un documento o da un percorso univoco noto che non è nella global assembly cache né nelle directory specificate per il <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> proprietà. Tali applicazioni possono utilizzare il <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> proprietà per evitare il ritardo causato dal sondaggio normale e per evitare il caricamento di copie dell'assembly necessari che possono trovarsi nei percorsi di sondaggio normale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se in un dominio applicazione è consentito il reindirizzamento dell'associazione degli assembly.</summary>
        <value>
          <see langword="true" /> se il reindirizzamento degli assembly non è consentito; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> proprietà è progettata per essere utilizzata da servizi e applicazioni server in cui il reindirizzamento dell'associazione di assembly non fa parte dello scenario di applicazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se per un dominio applicazione è consentito il download HTTP di assembly.</summary>
        <value>
          <see langword="true" /> se il download HTTP di assembly non è consentito; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomainSetup.DisallowCodeDownload%2A> proprietà è progettata per essere utilizzata da servizi e applicazioni server in cui il download di codice da una rete intranet o Internet non fa parte dello scenario di applicazione.  
  
> [!CAUTION]
>  Il valore predefinito per il <xref:System.AppDomainSetup.DisallowCodeDownload%2A> proprietà `false`. Questa impostazione è sicura per i servizi. Per impedire lo scaricamento di codice parzialmente attendibile da servizi, impostare questa proprietà su `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la sezione [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) del file di configurazione si applica a un dominio dell'applicazione.</summary>
        <value>
          <see langword="true" /> se la sezione <see langword="&lt;publisherPolicy&gt;" /> del file di configurazione per un dominio applicazione viene ignorata; in caso contrario, <see langword="false" /> indica che i criteri dell'editore dichiarati vengono applicati.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> proprietà si applica in particolare a un'applicazione Web che viene caricata in locale. Utilizzare questa proprietà per evitare che un tentativo non autorizzato per l'esecuzione di un'applicazione Web non sicura in modalità provvisoria.  
  
 Per ulteriori informazioni sull'esclusione dei criteri dell'editore, vedere il [reindirizzamento delle versioni degli Assembly](~/docs/framework/configure-apps/redirect-assembly-versions.md) argomento. Per ulteriori informazioni sulla modalità provvisoria, vedere la sezione "Analisi dei file di configurazione" del [come il Runtime individua gli assembly](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) argomento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la directory di base in cui si trova la directory dei file generati dinamicamente.</summary>
        <value>Directory contenente la proprietà <see cref="P:System.AppDomain.DynamicDirectory" />.  
 <block subset="none" type="note"><para>  
 Il valore restituito di questa proprietà è differente dal valore assegnato.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Utilizzare questa proprietà per impostare la directory di base in cui verranno collocate directory dinamica per il nuovo dominio applicazione. Quando codice nel nuovo dominio applicazione viene caricato un assembly, la risoluzione dell'assembly Cerca primo nei percorsi di sondaggio normale. Se non trova l'assembly, la ricerca nella directory dinamica, viene restituita dal <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> proprietà. È possibile posizionare gli assembly dinamici che saranno caricati ed eseguiti dal nuovo dominio applicazione.  
  
 Quando si assegna un percorso per il <xref:System.AppDomainSetup.DynamicBase%2A> proprietà, viene aggiunta una sottodirectory aggiuntiva; il nome della sottodirectory è il codice hash del valore assegnato per il <xref:System.AppDomainSetup.ApplicationName%2A> proprietà. Di conseguenza, la directory di base successivamente restituita da questa proprietà è sempre diversa dal valore assegnato.  
  
> [!IMPORTANT]
>  Assegnazione di un valore per questa proprietà non crea le directory. La directory deve essere creata o verificate dal codice in cui vengono utilizzati.  
  
 La directory dinamica è una sottodirectory di <xref:System.AppDomainSetup.DynamicBase%2A>. Il nome semplice è il valore restituito dal <xref:System.AppDomainSetup.ApplicationName%2A> proprietà, pertanto il formato è *percorso originale*\\*il codice hash*\\*nome applicazione*.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.AppDomainSetup.DynamicBase%2A> proprietà per impostare il percorso di un dominio applicazione viene eseguita la ricerca durante il caricamento di assembly dinamici.  
  
 Nell'esempio viene creato un <xref:System.AppDomainSetup> oggetto e imposta il relativo <xref:System.AppDomainSetup.ApplicationName%2A> proprietà su "Esempio" e il relativo <xref:System.AppDomainSetup.DynamicBase%2A> proprietà su "C:\DynamicAssemblyDir". Nell'esempio viene quindi visualizzato il <xref:System.AppDomainSetup.DynamicBase%2A> proprietà, per mostrare che il codice hash del nome dell'applicazione è stato aggiunto come una sottodirectory del percorso a cui è stato originariamente assegnato.  
  
> [!NOTE]
>  La directory di base in questo esempio deve essere utilizzata all'esterno del percorso di sondaggio per l'applicazione di esempio. Assicurarsi di compilare l'esempio in un percorso diverso. Eliminare la directory di base e tutte le relative sottodirectory ogni volta che si esegue l'esempio.  
  
 Nell'esempio viene creato un nuovo dominio applicazione utilizzando il <xref:System.AppDomainSetup> oggetto. L'esempio crea quindi la directory dinamica se non esiste già. Sebbene nell'esempio viene utilizzato il dominio di applicazione <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> proprietà per ottenere il nome della directory dinamica, è possibile creare facilmente la directory in anticipo concatenando il percorso originale, il codice hash del nome dell'applicazione e nome dell'applicazione.  
  
 L'esempio include una `GenerateDynamicAssembly` metodo che genera un assembly denominato `DynamicHelloWorld.dll` e lo archivia nella directory dinamica del nuovo dominio applicazione. L'assembly dinamico contiene un solo tipo, `HelloWorld`, che dispone di un metodo statico (`Shared` metodo in Visual Basic) denominata `HelloFromAD`. Chiamare questo metodo visualizza il nome del dominio dell'applicazione.  
  
 Il `Example` deriva dalla classe <xref:System.MarshalByRefObject>, pertanto l'esempio è possibile creare un'istanza della classe in cui il nuovo dominio applicazione e chiamare il relativo `Test` metodo. Il `Test` metodo carica l'assembly dinamico con il nome visualizzato e chiama il metodo statico `HelloFromAD` metodo.  
  
 È possibile mostrare che viene eseguita la ricerca di directory dinamica dopo i percorsi di sondaggio normale scrivendo il codice per un assembly denominato `DynamicHelloWorld.dll` e compilarlo nella stessa directory in questo esempio. L'assembly deve avere una classe denominata `HelloWorld` con un metodo statico denominato `HelloFromAD`. Questo metodo non è necessario avere la stessa funzionalità come quello nell'esempio; può visualizzare semplicemente una stringa sulla console. L'assembly deve avere anche un <xref:System.Reflection.AssemblyVersionAttribute> attributo che imposta la versione 1.0.0.0. Quando si esegue l'esempio, si trova l'assembly che è stato compilato nella directory corrente prima che la directory dinamica viene eseguita la ricerca.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Questa proprietà non può essere impostata perché il nome dell'applicazione nel dominio applicazione è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni sul percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce le informazioni di configurazione XML impostate dal metodo <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />. Tali informazioni sostituiscono quelle della configurazione XML dell'applicazione.</summary>
        <returns>Matrice contenente le informazioni di configurazione XML impostate dal metodo <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> oppure <see langword="null" /> se il metodo <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> non è stato chiamato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomainSetup.SetConfigurationBytes%2A> metodo fornisce un modo per ignorare le informazioni di configurazione di un'applicazione che crea un nuovo dominio applicazione. Le informazioni sul file di configurazione in `value` sostituisce le informazioni del file di configurazione per l'applicazione. Ad esempio, quando l'applicazione Example.exe crea un nuovo dominio applicazione, è possibile eseguire l'override originariamente ottenute dal file example.exe le informazioni di configurazione.  
  
> [!IMPORTANT]
>  Non utilizzano le informazioni archiviate da alcuni utenti di informazioni sui file di configurazione di <xref:System.AppDomainSetup.SetConfigurationBytes%2A> metodo. Il runtime non applicare questo comportamento. Per garantire che tutte le informazioni sui file di configurazione è sottoposto a override in un nuovo dominio applicazione, utilizzare il <xref:System.AppDomainSetup.ConfigurationFile%2A> proprietà per specificare un file di configurazione. Il <xref:System.AppDomainSetup.SetConfigurationBytes%2A> metodo influisce l'associazione di assembly.  
  
 Il codice XML nel `value` corrisponde a quello del file XML in un normale file di configurazione, ad eccezione del fatto che viene archiviato come un <xref:System.Byte> matrice.  
  
 Per accedere ai byte di configurazione per un dominio applicazione, utilizzare il <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> proprietà da ottenere il <xref:System.AppDomainSetup> dell'oggetto per il dominio applicazione, quindi utilizzare il <xref:System.AppDomainSetup.GetConfigurationBytes%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la posizione del file di licenza associato al dominio.</summary>
        <value>Nome e percorso del file di licenza.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni sul percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica i criteri di ottimizzazione usati per caricare un eseguibile.</summary>
        <value>Costante enumerata usata con <see cref="T:System.LoaderOptimizationAttribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un assembly dinamico e salvato su disco e quindi viene utilizzato il <xref:System.AppDomainSetup.LoaderOptimization%2A> proprietà per impostare i criteri di ottimizzazione usati per caricare l'assembly in un dominio applicazione.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un elenco di assembly contrassegnati con il flag <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> resi visibili a codice parzialmente attendibile in esecuzione in un dominio applicazione creato mediante sandbox.</summary>
        <value>Matrice di nomi di assembly parziali, dove ogni nome parziale è costituito dal nome dell'assembly semplice e dalla chiave pubblica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Security.AllowPartiallyTrustedCallersAttribute> attributo (APTCA) può essere reso condizionale impostando il relativo <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> proprietà <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>. Un assembly APTCA contrassegnato con <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> non può essere utilizzato da codice parzialmente attendibile a meno che non ne consente l'applicazione host.  
  
 L'host di un dominio applicazione creato mediante sandbox consente al codice nel dominio dell'applicazione per utilizzare gli assembly con attributi APTCA condizionali creando una matrice che contiene il nome semplice e la chiave pubblica di ogni assembly e l'assegnazione di matrice a questa proprietà. For example, an element of the array might look like the following: "MyAssembly, PublicKey=0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9".  
  
> [!IMPORTANT]
>  Se si utilizza una sottoclasse di <xref:System.AppDomainManager>e l'assembly che lo definisce dipende da assembly contrassegnati con l'attributo APTCA condizionale, è necessario includere tali assembly nell'elenco passato al <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> proprietà del <xref:System.AppDomainSetup>consente di creare i domini applicazione. In caso contrario, gli assembly contrassegnati con l'attributo APTCA condizionale verranno disabilitati.  
  
> [!NOTE]
>  Quando si esegue il debug di un'applicazione è in esecuzione in un dominio applicazione creato mediante sandbox, alcuni <xref:System.Security.SecurityException> messaggi possono essere fuorvianti. Ad esempio, un messaggio potrebbe indicare che uno degli assembly completamente attendibile dispone solo di autorizzazioni limitate, quando la causa effettiva del problema è che una richiesta di sicurezza che supera il set di concessioni del dominio applicazione creato mediante sandbox è stato propagato al limite del dominio applicazione creato mediante sandbox e non è riuscita.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'elenco delle directory nella directory base dell'applicazione in cui effettuare il sondaggio degli assembly privati.</summary>
        <value>Elenco di nomi di directory separati con punti e virgola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assembly privati vengono distribuiti nella stessa struttura di directory dell'applicazione. Se la directory specificata per <xref:System.AppDomainSetup.PrivateBinPath%2A> non sono in <xref:System.AppDomainSetup.ApplicationBase%2A>, vengono ignorati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore di stringa che include o esclude la directory <see cref="P:System.AppDomainSetup.ApplicationBase" /> dal percorso di ricerca dell'applicazione; inoltre, esegue la ricerca soltanto nel percorso indicato nella proprietà <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</summary>
        <value>Riferimento Null (<see langword="Nothing" /> in Visual Basic) per includere il percorso di base dell'applicazione quando si esegue la ricerca di assembly; qualsiasi valore stringa non Null per escludere il percorso. Il valore predefinito è <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare questa proprietà su un valore di stringa non null, inclusi <xref:System.String.Empty?displayProperty=nameWithType> (""), escludere il percorso di directory dell'applicazione, vale a dire <xref:System.AppDomainSetup.ApplicationBase%2A> : dal percorso di ricerca per l'applicazione e la ricerca di assembly solo in <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se la memorizzazione dell'interfaccia nella cache è disabilitata per le chiamate all'interoperabilità nel dominio dell'applicazione, pertanto viene eseguita una <c>QueryInterface</c> per ogni chiamata.</summary>
        <value>
          <see langword="true" /> se la memorizzazione dell'interfaccia nella cache è disabilitata per le chiamate all'interoperabilità nei domini dell'applicazione creati con l'oggetto <see cref="T:System.AppDomainSetup" /> corrente; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La disabilitazione del caching interfaccia ha un impatto significativo sulle prestazioni delle chiamate di interoperabilità.  
  
 Questo membro è stato introdotto nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">Set enumerabile di valori di stringa che specifica le opzioni di compatibilità oppure <see langword="null" /> per cancellare le opzioni di compatibilità esistenti.</param>
        <summary>Imposta le opzioni specificate, rendendo il dominio dell'applicazione compatibile con le versioni precedenti di .NET Framework per i problemi specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Versioni principali di .NET Framework talvolta introducono modifiche di rilievo introdotte dalla versione precedente. Ad esempio, il [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] introduce un numero esiguo di modifiche di rilievo rispetto di [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]. Utilizzare il <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> per specificare che uno o più di queste modifiche di rilievo deve eseguire il rollback per il dominio applicazione, per rendere il comportamento compatibile con la versione precedente di .NET Framework.  
  
 Ogni volta che si chiama questo metodo, sostituisce le impostazioni del commutatore esistenti. Per cancellare le impostazioni, specificare `null` per il `switches` parametro.  
  
 Il set di valori stringa forniti per `switches` può essere una matrice di stringa semplice, poiché le matrici implementano la <xref:System.Collections.IEnumerable> interfaccia.  
  
 Nella tabella seguente vengono forniti esempi di opzioni di compatibilità che è possibile impostare per ripristinare il comportamento delle versioni precedenti di .NET Framework.  
  
|Opzione|Significato|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Codice di accesso di sicurezza per il [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] è abilitato in questo dominio applicazione. Vedere [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Stringa di ordinamento dei valori predefiniti per il [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] sono abilitate nel dominio applicazione. Il ripristino corretto del comportamento dell'ordinamento legacy richiede anche la libreria a collegamento dinamico sort00001000.dll siano disponibili nel sistema locale. Vedere [ &lt;CompatSortNLSVersion&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Le impostazioni predefinite relative all'ordinamento delle stringhe per [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e per Unicode 5.0 sono abilitate in questo dominio applicazione. Per il ripristino corretto del comportamento dell'ordinamento legacy è necessaria inoltre la disponibilità della libreria a collegamento dinamico sort00060101.dll nel sistema locale.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> il comportamento di formattazione di [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] è abilitato in questo dominio applicazione. Vedere [ &lt;TimeSpan_LegacyFormatMode&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) e la sezione "Ripristino Legacy TimeSpan formattazione" del <xref:System.TimeSpan> argomento.|  
|"UseRandomizedStringHashAlgorithm"|Il runtime calcola i codici hash per le stringhe in una base di dominio dell'applicazione anziché un solo algoritmo hash che genera un codice hash coerente tra domini dell'applicazione. Vedere [ &lt;UseRandomizedStringHashAlgorithm&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Matrice contenente le informazioni di configurazione XML da usare per il dominio applicazione.</param>
        <summary>Fornisce le informazioni di configurazione XML del dominio applicazione e sostituisce tali informazioni alle informazioni di configurazione XML dell'applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo <xref:System.AppDomainSetup.SetConfigurationBytes%2A> fornisce un modo per sostituire le informazioni di configurazione di un'applicazione che crea un nuovo dominio applicazione. Le informazioni sul file di configurazione contenute in `value` sostituiscono le informazioni sul file di configurazione per l'applicazione. Ad esempio, quando l'applicazione Example.exe crea un nuovo dominio applicazione, può sostituire le informazioni di configurazione ottenute in origine dal file Example.exe.config.  
  
> [!IMPORTANT]
>  Non utilizzano le informazioni archiviate da alcuni utenti di informazioni sui file di configurazione di <xref:System.AppDomainSetup.SetConfigurationBytes%2A> metodo. Il runtime non applicare questo comportamento. Per assicurarsi che tutte le informazioni nel file di configurazione vengano sostituite in un nuovo dominio applicazione, utilizzare la proprietà <xref:System.AppDomainSetup.ConfigurationFile%2A> per specificare un file di configurazione. Il <xref:System.AppDomainSetup.SetConfigurationBytes%2A> metodo influisce l'associazione di assembly.  
  
 Il codice XML nel `value` corrisponde a quello del file XML in un normale file di configurazione, ad eccezione del fatto che viene archiviato come un <xref:System.Byte> matrice.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">Nome della funzione di confronto di stringhe di cui eseguire l'override.</param>
        <param name="functionVersion">Versione della funzione. Per [!INCLUDE[net_v45](~/includes/net-v45-md.md)] il valore deve essere maggiore o uguale a 1.</param>
        <param name="functionPointer">Puntatore alla funzione che esegue l'override di <c>functionName</c>.</param>
        <summary>Fornisce Common Language Runtime con un'implementazione alternativa di una funzione di confronto delle stringhe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile eseguire l'override dei seguenti metodi di confronto e ordinamento delle stringhe con il metodo <xref:System.AppDomainSetup.SetNativeFunction%2A>:  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Per informazioni su queste funzioni, vedere [le funzioni di supporto lingua nazionale](http://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionVersion" /> non è 1 o maggiore.  
  
 oppure  
  
 <paramref name="functionPointer" /> è <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta i nomi delle directory contenenti assembly delle quali creare una copia di replica.</summary>
        <value>Elenco di nomi di directory separati con punti e virgola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando la copia shadow è attivata, il valore predefinito è la copia shadow di tutti gli assembly trovati durante il rilevamento; ovvero, nelle directory specificate dal <xref:System.AppDomainSetup.PrivateBinPath%2A> e <xref:System.AppDomainSetup.ApplicationBase%2A> proprietà. Il <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> proprietà limita la copia shadow agli assembly nella directory specificata da <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>.  
  
 Se non si assegna una stringa alla proprietà <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>  o se si imposta questa proprietà su `null`, tutti gli assembly nelle directory specificate dalle proprietà <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> vengono replicati come copie shadow.  
  
> [!IMPORTANT]
>  I percorsi delle directory non devono contenere punti e virgola, perché il punto e virgola è il carattere delimitatore. Non esiste alcun carattere di escape per i punti e virgola.  
  
 Quando la copia shadow è attivo, i file di assembly vengono copiati in un altro percorso prima gli assembly vengono caricati. Il file di assembly originale non è bloccato, pertanto può essere aggiornata. Per ulteriori informazioni sulla creazione di copie shadow, vedere [copie Shadow di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni sul percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta una stringa in cui viene indicato se la replica è attivata o disattivata.</summary>
        <value>Valore di stringa "true" per indicare che la copia shadow è attivata oppure "false" per indicare che quest'ultima è disattivata.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla creazione di copie shadow, vedere [copie Shadow di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta una stringa che specifica la versione di destinazione e il profilo di .NET Framework per il dominio applicazione, in un formato che può essere analizzato dal costruttore <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" />.</summary>
        <value>Versione e profilo di .NET Framework di destinazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare questa proprietà per indicare alla versione di .NET Framework attualmente in esecuzione che il dominio applicazione verrà utilizzato per caricare ed eseguire gli assembly compilati per la versione e il profilo di destinazione. Se la versione di .NET Framework attualmente in esecuzione presenta comportamenti facoltativi che influiscono sulla compatibilità del codice compilato con la versione di destinazione, è possibile abilitare o disabilitare tali comportamenti, in base alle esigenze, per migliorare la compatibilità. Ciò può essere utile quando un'applicazione supporta componenti aggiuntivi compilati con più versioni di .NET Framework eseguendoli in domini applicazione separati.  
  
 Per le applicazioni client, il valore della proprietà <xref:System.AppDomainSetup.TargetFrameworkName%2A> viene dedotto dall'attributo <xref:System.Runtime.Versioning.TargetFrameworkAttribute>. In [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] e versioni successive, questo attributo viene aggiunto all'assembly automaticamente in base all'impostazione del progetto **Framework di destinazione** proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>